// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../.config/yarn/global/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../.config/yarn/global/node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../.config/yarn/global/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../.config/yarn/global/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../.config/yarn/global/node_modules/base64-js/index.js","ieee754":"../../.config/yarn/global/node_modules/ieee754/index.js","isarray":"../../.config/yarn/global/node_modules/isarray/index.js","buffer":"../../.config/yarn/global/node_modules/buffer/index.js"}],"node_modules/lodash/lodash.js":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
var define;
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

},{"buffer":"../../.config/yarn/global/node_modules/buffer/index.js"}],"canvas_single/rive.js":[function(require,module,exports) {
var define;
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && (typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') exports["rive"] = factory();else root["rive"] = factory();
})(this, function () {
  return /******/function () {
    // webpackBootstrap
    /******/
    "use strict";

    /******/
    var __webpack_modules__ = [
      /* 0 */
    , (/* 1 */
    /***/function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"default": function _default() {
          return __WEBPACK_DEFAULT_EXPORT__;
        }
        /* harmony export */
      });
      var Rive = function () {
        var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
        return function () {
          var moduleArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var m = moduleArg,
            aa,
            ba;
          m.ready = new Promise(function (a, b) {
            aa = a;
            ba = b;
          });
          function fa() {
            function a(g) {
              var n = d;
              c = b = 0;
              d = new Map();
              n.forEach(function (p) {
                try {
                  p(g);
                } catch (l) {
                  console.error(l);
                }
              });
              this.ob();
              e && e.Tb();
            }
            var b = 0,
              c = 0,
              d = new Map(),
              e = null,
              f = null;
            this.requestAnimationFrame = function (g) {
              b || (b = requestAnimationFrame(a.bind(this)));
              var n = ++c;
              d.set(n, g);
              return n;
            };
            this.cancelAnimationFrame = function (g) {
              d.delete(g);
              b && 0 == d.size && (cancelAnimationFrame(b), b = 0);
            };
            this.Rb = function (g) {
              f && (document.body.remove(f), f = null);
              g || (f = document.createElement("div"), f.style.backgroundColor = "black", f.style.position = "fixed", f.style.right = 0, f.style.top = 0, f.style.color = "white", f.style.padding = "4px", f.innerHTML = "RIVE FPS", g = function g(n) {
                f.innerHTML = "RIVE FPS " + n.toFixed(1);
              }, document.body.appendChild(f));
              e = new function () {
                var n = 0,
                  p = 0;
                this.Tb = function () {
                  var l = performance.now();
                  p ? (++n, l -= p, 1000 < l && (g(1000 * n / l), n = p = 0)) : (p = l, n = 0);
                };
              }();
            };
            this.Ob = function () {
              f && (document.body.remove(f), f = null);
              e = null;
            };
            this.ob = function () {};
          }
          function ha(a) {
            console.assert(!0);
            var b = new Map();
            var c = -Infinity;
            this.push = function (d) {
              d = d + ((1 << a) - 1) >> a;
              b.has(d) && clearTimeout(b.get(d));
              b.set(d, setTimeout(function () {
                b.delete(d);
                0 == b.length ? c = -Infinity : d == c && (c = Math.max.apply(Math, _toConsumableArray(b.keys())), console.assert(c < d));
              }, 1000));
              c = Math.max(d, c);
              return c << a;
            };
          }
          var ia = m.onRuntimeInitialized;
          m.onRuntimeInitialized = function () {
            ia && ia();
            var a = m.decodeAudio;
            m.decodeAudio = function (e, f) {
              e = a(e);
              f(e);
            };
            var b = m.decodeFont;
            m.decodeFont = function (e, f) {
              e = b(e);
              f(e);
            };
            var c = m.FileAssetLoader;
            m.ptrToAsset = function (e) {
              var f = m.ptrToFileAsset(e);
              return f.isImage ? m.ptrToImageAsset(e) : f.isFont ? m.ptrToFontAsset(e) : f.isAudio ? m.ptrToAudioAsset(e) : f;
            };
            m.CustomFileAssetLoader = c.extend("CustomFileAssetLoader", {
              __construct: function __construct(_ref) {
                var e = _ref.loadContents;
                this.__parent.__construct.call(this);
                this.Gb = e;
              },
              loadContents: function loadContents(e, f) {
                e = m.ptrToAsset(e);
                return this.Gb(e, f);
              }
            });
            m.CDNFileAssetLoader = c.extend("CDNFileAssetLoader", {
              __construct: function __construct() {
                this.__parent.__construct.call(this);
              },
              loadContents: function loadContents(e) {
                var f = m.ptrToAsset(e);
                e = f.cdnUuid;
                if ("" === e) {
                  return !1;
                }
                (function (g, n) {
                  var p = new XMLHttpRequest();
                  p.responseType = "arraybuffer";
                  p.onreadystatechange = function () {
                    4 == p.readyState && 200 == p.status && n(p);
                  };
                  p.open("GET", g, !0);
                  p.send(null);
                })(f.cdnBaseUrl + "/" + e, function (g) {
                  f.decode(new Uint8Array(g.response));
                });
                return !0;
              }
            });
            m.FallbackFileAssetLoader = c.extend("FallbackFileAssetLoader", {
              __construct: function __construct() {
                this.__parent.__construct.call(this);
                this.kb = [];
              },
              addLoader: function addLoader(e) {
                this.kb.push(e);
              },
              loadContents: function loadContents(e, f) {
                var _iterator = _createForOfIteratorHelper(this.kb),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var g = _step.value;
                    if (g.loadContents(e, f)) {
                      return !0;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                return !1;
              }
            });
            var d = m.computeAlignment;
            m.computeAlignment = function (e, f, g, n) {
              var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1.0;
              return d.call(this, e, f, g, n, p);
            };
          };
          var ja = "createConicGradient createImageData createLinearGradient createPattern createRadialGradient getContextAttributes getImageData getLineDash getTransform isContextLost isPointInPath isPointInStroke measureText".split(" "),
            ka = new function () {
              function a() {
                if (!b) {
                  var k = document.createElement("canvas"),
                    t = {
                      alpha: 1,
                      depth: 0,
                      stencil: 0,
                      antialias: 0,
                      premultipliedAlpha: 1,
                      preserveDrawingBuffer: 0,
                      powerPreference: "high-performance",
                      failIfMajorPerformanceCaveat: 0,
                      enableExtensionsByDefault: 1,
                      explicitSwapControl: 1,
                      renderViaOffscreenBackBuffer: 1
                    };
                  var r;
                  if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                    if (r = k.getContext("webgl", t), c = 1, !r) {
                      return console.log("No WebGL support. Image mesh will not be drawn."), !1;
                    }
                  } else {
                    if (r = k.getContext("webgl2", t)) {
                      c = 2;
                    } else {
                      if (r = k.getContext("webgl", t)) {
                        c = 1;
                      } else {
                        return console.log("No WebGL support. Image mesh will not be drawn."), !1;
                      }
                    }
                  }
                  r = new Proxy(r, {
                    get: function get(D, w) {
                      if (D.isContextLost()) {
                        if (p || (console.error("Cannot render the mesh because the GL Context was lost. Tried to invoke ", w), p = !0), "function" === typeof D[w]) {
                          return function () {};
                        }
                      } else {
                        return "function" === typeof D[w] ? function () {
                          for (var _len = arguments.length, M = new Array(_len), _key = 0; _key < _len; _key++) {
                            M[_key] = arguments[_key];
                          }
                          return D[w].apply(D, M);
                        } : D[w];
                      }
                    },
                    set: function set(D, w, M) {
                      if (D.isContextLost()) {
                        p || (console.error("Cannot render the mesh because the GL Context was lost. Tried to set property " + w), p = !0);
                      } else {
                        return D[w] = M, !0;
                      }
                    }
                  });
                  d = Math.min(r.getParameter(r.MAX_RENDERBUFFER_SIZE), r.getParameter(r.MAX_TEXTURE_SIZE));
                  function B(D, w, M) {
                    w = r.createShader(w);
                    r.shaderSource(w, M);
                    r.compileShader(w);
                    M = r.getShaderInfoLog(w);
                    if (0 < (M || "").length) {
                      throw M;
                    }
                    r.attachShader(D, w);
                  }
                  k = r.createProgram();
                  B(k, r.VERTEX_SHADER, "attribute vec2 vertex;\n                attribute vec2 uv;\n                uniform vec4 mat;\n                uniform vec2 translate;\n                varying vec2 st;\n                void main() {\n                    st = uv;\n                    gl_Position = vec4(mat2(mat) * vertex + translate, 0, 1);\n                }");
                  B(k, r.FRAGMENT_SHADER, "precision highp float;\n                uniform sampler2D image;\n                varying vec2 st;\n                void main() {\n                    gl_FragColor = texture2D(image, st);\n                }");
                  r.bindAttribLocation(k, 0, "vertex");
                  r.bindAttribLocation(k, 1, "uv");
                  r.linkProgram(k);
                  t = r.getProgramInfoLog(k);
                  if (0 < (t || "").trim().length) {
                    throw t;
                  }
                  e = r.getUniformLocation(k, "mat");
                  f = r.getUniformLocation(k, "translate");
                  r.useProgram(k);
                  r.bindBuffer(r.ARRAY_BUFFER, r.createBuffer());
                  r.enableVertexAttribArray(0);
                  r.enableVertexAttribArray(1);
                  r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, r.createBuffer());
                  r.uniform1i(r.getUniformLocation(k, "image"), 0);
                  r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
                  b = r;
                }
                return !0;
              }
              var b = null,
                c = 0,
                d = 0,
                e = null,
                f = null,
                g = 0,
                n = 0,
                p = !1;
              a();
              this.hc = function () {
                a();
                return d;
              };
              this.Mb = function (k) {
                b.deleteTexture && b.deleteTexture(k);
              };
              this.Lb = function (k) {
                if (!a()) {
                  return null;
                }
                var t = b.createTexture();
                if (!t) {
                  return null;
                }
                b.bindTexture(b.TEXTURE_2D, t);
                b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, k);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
                2 == c ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR_MIPMAP_LINEAR), b.generateMipmap(b.TEXTURE_2D)) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
                return t;
              };
              var l = new ha(8),
                u = new ha(8),
                v = new ha(10),
                x = new ha(10);
              this.Qb = function (k, t, r, B, D) {
                if (a()) {
                  var w = l.push(k),
                    M = u.push(t);
                  if (b.canvas) {
                    if (b.canvas.width != w || b.canvas.height != M) {
                      b.canvas.width = w, b.canvas.height = M;
                    }
                    b.viewport(0, M - t, k, t);
                    b.disable(b.SCISSOR_TEST);
                    b.clearColor(0, 0, 0, 0);
                    b.clear(b.COLOR_BUFFER_BIT);
                    b.enable(b.SCISSOR_TEST);
                    r.sort(function (H, ca) {
                      return ca.wb - H.wb;
                    });
                    w = v.push(B);
                    g != w && (b.bufferData(b.ARRAY_BUFFER, 8 * w, b.DYNAMIC_DRAW), g = w);
                    w = 0;
                    var _iterator2 = _createForOfIteratorHelper(r),
                      _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var T = _step2.value;
                        b.bufferSubData(b.ARRAY_BUFFER, w, T.Ta), w += 4 * T.Ta.length;
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    console.assert(w == 4 * B);
                    var _iterator3 = _createForOfIteratorHelper(r),
                      _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        var da = _step3.value;
                        b.bufferSubData(b.ARRAY_BUFFER, w, da.Db), w += 4 * da.Db.length;
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    console.assert(w == 8 * B);
                    w = x.push(D);
                    n != w && (b.bufferData(b.ELEMENT_ARRAY_BUFFER, 2 * w, b.DYNAMIC_DRAW), n = w);
                    T = 0;
                    var _iterator4 = _createForOfIteratorHelper(r),
                      _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                        var ra = _step4.value;
                        b.bufferSubData(b.ELEMENT_ARRAY_BUFFER, T, ra.indices), T += 2 * ra.indices.length;
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    console.assert(T == 2 * D);
                    ra = 0;
                    da = !0;
                    w = T = 0;
                    var _iterator5 = _createForOfIteratorHelper(r),
                      _step5;
                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        var H = _step5.value;
                        H.image.Ka != ra && (b.bindTexture(b.TEXTURE_2D, H.image.Ja || null), ra = H.image.Ka);
                        H.mc ? (b.scissor(H.Ya, M - H.Za - H.jb, H.Ac, H.jb), da = !0) : da && (b.scissor(0, M - t, k, t), da = !1);
                        r = 2 / k;
                        var ca = -2 / t;
                        b.uniform4f(e, H.ha[0] * r * H.Ba, H.ha[1] * ca * H.Ca, H.ha[2] * r * H.Ba, H.ha[3] * ca * H.Ca);
                        b.uniform2f(f, H.ha[4] * r * H.Ba + r * (H.Ya - H.ic * H.Ba) - 1, H.ha[5] * ca * H.Ca + ca * (H.Za - H.jc * H.Ca) + 1);
                        b.vertexAttribPointer(0, 2, b.FLOAT, !1, 0, w);
                        b.vertexAttribPointer(1, 2, b.FLOAT, !1, 0, w + 4 * B);
                        b.drawElements(b.TRIANGLES, H.indices.length, b.UNSIGNED_SHORT, T);
                        w += 4 * H.Ta.length;
                        T += 2 * H.indices.length;
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                    console.assert(w == 4 * B);
                    console.assert(T == 2 * D);
                  }
                }
              };
              this.canvas = function () {
                return a() && b.canvas;
              };
            }(),
            la = m.onRuntimeInitialized;
          m.onRuntimeInitialized = function () {
            function a(q) {
              switch (q) {
                case l.srcOver:
                  return "source-over";
                case l.screen:
                  return "screen";
                case l.overlay:
                  return "overlay";
                case l.darken:
                  return "darken";
                case l.lighten:
                  return "lighten";
                case l.colorDodge:
                  return "color-dodge";
                case l.colorBurn:
                  return "color-burn";
                case l.hardLight:
                  return "hard-light";
                case l.softLight:
                  return "soft-light";
                case l.difference:
                  return "difference";
                case l.exclusion:
                  return "exclusion";
                case l.multiply:
                  return "multiply";
                case l.hue:
                  return "hue";
                case l.saturation:
                  return "saturation";
                case l.color:
                  return "color";
                case l.luminosity:
                  return "luminosity";
              }
            }
            function b(q) {
              return "rgba(" + ((16711680 & q) >>> 16) + "," + ((65280 & q) >>> 8) + "," + ((255 & q) >>> 0) + "," + ((4278190080 & q) >>> 24) / 255 + ")";
            }
            function c() {
              0 < M.length && (ka.Qb(w.drawWidth(), w.drawHeight(), M, T, da), M = [], da = T = 0, w.reset(512, 512));
              var _iterator6 = _createForOfIteratorHelper(D),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var q = _step6.value;
                  var _iterator7 = _createForOfIteratorHelper(q.H),
                    _step7;
                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                      var y = _step7.value;
                      y();
                    }
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                  q.H = [];
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
              D.clear();
            }
            la && la();
            var d = m.RenderPaintStyle;
            var e = m.RenderPath,
              f = m.RenderPaint,
              g = m.Renderer,
              n = m.StrokeCap,
              p = m.StrokeJoin,
              l = m.BlendMode,
              u = d.fill,
              v = d.stroke,
              x = m.FillRule.evenOdd;
            var k = 1;
            var t = m.RenderImage.extend("CanvasRenderImage", {
                __construct: function __construct() {
                  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    q = _ref2.la,
                    y = _ref2.xa;
                  this.__parent.__construct.call(this);
                  this.Ka = k;
                  k = k + 1 & 2147483647 || 1;
                  this.la = q;
                  this.xa = y;
                },
                __destruct: function __destruct() {
                  this.Ja && (ka.Mb(this.Ja), URL.revokeObjectURL(this.Wa));
                  this.__parent.__destruct.call(this);
                },
                decode: function decode(q) {
                  var y = this;
                  y.xa && y.xa(y);
                  var F = new Image();
                  y.Wa = URL.createObjectURL(new Blob([q], {
                    type: "image/png"
                  }));
                  F.onload = function () {
                    y.Fb = F;
                    y.Ja = ka.Lb(F);
                    y.size(F.width, F.height);
                    y.la && y.la(y);
                  };
                  F.src = y.Wa;
                }
              }),
              r = e.extend("CanvasRenderPath", {
                __construct: function __construct() {
                  this.__parent.__construct.call(this);
                  this.T = new Path2D();
                },
                rewind: function rewind() {
                  this.T = new Path2D();
                },
                addPath: function addPath(q, y, F, G, A, I, J) {
                  var K = this.T,
                    X = K.addPath;
                  q = q.T;
                  var Q = new DOMMatrix();
                  Q.a = y;
                  Q.b = F;
                  Q.c = G;
                  Q.d = A;
                  Q.e = I;
                  Q.f = J;
                  X.call(K, q, Q);
                },
                fillRule: function fillRule(q) {
                  this.Va = q;
                },
                moveTo: function moveTo(q, y) {
                  this.T.moveTo(q, y);
                },
                lineTo: function lineTo(q, y) {
                  this.T.lineTo(q, y);
                },
                cubicTo: function cubicTo(q, y, F, G, A, I) {
                  this.T.bezierCurveTo(q, y, F, G, A, I);
                },
                close: function close() {
                  this.T.closePath();
                }
              }),
              B = f.extend("CanvasRenderPaint", {
                color: function color(q) {
                  this.Xa = b(q);
                },
                thickness: function thickness(q) {
                  this.Ib = q;
                },
                join: function join(q) {
                  switch (q) {
                    case p.miter:
                      this.Ia = "miter";
                      break;
                    case p.round:
                      this.Ia = "round";
                      break;
                    case p.bevel:
                      this.Ia = "bevel";
                  }
                },
                cap: function cap(q) {
                  switch (q) {
                    case n.butt:
                      this.Ha = "butt";
                      break;
                    case n.round:
                      this.Ha = "round";
                      break;
                    case n.square:
                      this.Ha = "square";
                  }
                },
                style: function style(q) {
                  this.Hb = q;
                },
                blendMode: function blendMode(q) {
                  this.Eb = a(q);
                },
                clearGradient: function clearGradient() {
                  this.ja = null;
                },
                linearGradient: function linearGradient(q, y, F, G) {
                  this.ja = {
                    yb: q,
                    zb: y,
                    bb: F,
                    cb: G,
                    Ra: []
                  };
                },
                radialGradient: function radialGradient(q, y, F, G) {
                  this.ja = {
                    yb: q,
                    zb: y,
                    bb: F,
                    cb: G,
                    Ra: [],
                    ec: !0
                  };
                },
                addStop: function addStop(q, y) {
                  this.ja.Ra.push({
                    color: q,
                    stop: y
                  });
                },
                completeGradient: function completeGradient() {},
                draw: function draw(q, y, F) {
                  var G = this.Hb;
                  var A = this.Xa,
                    I = this.ja;
                  q.globalCompositeOperation = this.Eb;
                  if (null != I) {
                    A = I.yb;
                    var J = I.zb;
                    var X = I.bb;
                    var K = I.cb;
                    var Q = I.Ra;
                    I.ec ? (I = X - A, K -= J, A = q.createRadialGradient(A, J, 0, A, J, Math.sqrt(I * I + K * K))) : A = q.createLinearGradient(A, J, X, K);
                    for (var ea = 0, R = Q.length; ea < R; ea++) {
                      J = Q[ea], A.addColorStop(J.stop, b(J.color));
                    }
                    this.Xa = A;
                    this.ja = null;
                  }
                  switch (G) {
                    case v:
                      q.strokeStyle = A;
                      q.lineWidth = this.Ib;
                      q.lineCap = this.Ha;
                      q.lineJoin = this.Ia;
                      q.stroke(y);
                      break;
                    case u:
                      q.fillStyle = A, q.fill(y, F);
                  }
                }
              });
            var D = new Set();
            var w = null,
              M = [],
              T = 0,
              da = 0;
            var ra = m.CanvasRenderer = g.extend("Renderer", {
              __construct: function __construct(q) {
                this.__parent.__construct.call(this);
                this.S = [1, 0, 0, 1, 0, 0];
                this.C = q.getContext("2d");
                this.Ua = q;
                this.H = [];
              },
              save: function save() {
                var _this$S;
                (_this$S = this.S).push.apply(_this$S, _toConsumableArray(this.S.slice(this.S.length - 6)));
                this.H.push(this.C.save.bind(this.C));
              },
              restore: function restore() {
                var q = this.S.length - 6;
                if (6 > q) {
                  throw "restore() called without matching save().";
                }
                this.S.splice(q);
                this.H.push(this.C.restore.bind(this.C));
              },
              transform: function transform(q, y, F, G, A, I) {
                var J = this.S,
                  K = J.length - 6;
                J.splice(K, 6, J[K] * q + J[K + 2] * y, J[K + 1] * q + J[K + 3] * y, J[K] * F + J[K + 2] * G, J[K + 1] * F + J[K + 3] * G, J[K] * A + J[K + 2] * I + J[K + 4], J[K + 1] * A + J[K + 3] * I + J[K + 5]);
                this.H.push(this.C.transform.bind(this.C, q, y, F, G, A, I));
              },
              rotate: function rotate(q) {
                var y = Math.sin(q);
                q = Math.cos(q);
                this.transform(q, y, -y, q, 0, 0);
              },
              _drawPath: function _drawPath(q, y) {
                this.H.push(y.draw.bind(y, this.C, q.T, q.Va === x ? "evenodd" : "nonzero"));
              },
              _drawRiveImage: function _drawRiveImage(q, y, F) {
                var G = q.Fb;
                if (G) {
                  var A = this.C,
                    I = a(y);
                  this.H.push(function () {
                    A.globalCompositeOperation = I;
                    A.globalAlpha = F;
                    A.drawImage(G, 0, 0);
                    A.globalAlpha = 1;
                  });
                }
              },
              _getMatrix: function _getMatrix(q) {
                var y = this.S,
                  F = y.length - 6;
                for (var G = 0; 6 > G; ++G) {
                  q[G] = y[F + G];
                }
              },
              _drawImageMesh: function _drawImageMesh(q, y, F, G, A, I, J, K, X, Q) {
                var ea = this.C.canvas.width,
                  R = this.C.canvas.height;
                var Xb = X - J,
                  Yb = Q - K;
                J = Math.max(J, 0);
                K = Math.max(K, 0);
                X = Math.min(X, ea);
                Q = Math.min(Q, R);
                var Fa = X - J,
                  Ga = Q - K;
                console.assert(Fa <= Math.min(Xb, ea));
                console.assert(Ga <= Math.min(Yb, R));
                if (!(0 >= Fa || 0 >= Ga)) {
                  X = Fa < Xb || Ga < Yb;
                  ea = Q = 1;
                  var sa = Math.ceil(Fa * Q),
                    ta = Math.ceil(Ga * ea);
                  R = ka.hc();
                  sa > R && (Q *= R / sa, sa = R);
                  ta > R && (ea *= R / ta, ta = R);
                  w || (w = new m.DynamicRectanizer(R), w.reset(512, 512));
                  R = w.addRect(sa, ta);
                  0 > R && (c(), D.add(this), R = w.addRect(sa, ta), console.assert(0 <= R));
                  var Zb = R & 65535,
                    $b = R >> 16;
                  M.push({
                    ha: this.S.slice(this.S.length - 6),
                    image: q,
                    Ya: Zb,
                    Za: $b,
                    ic: J,
                    jc: K,
                    Ac: sa,
                    jb: ta,
                    Ba: Q,
                    Ca: ea,
                    Ta: new Float32Array(G),
                    Db: new Float32Array(A),
                    indices: new Uint16Array(I),
                    mc: X,
                    wb: q.Ka << 1 | (X ? 1 : 0)
                  });
                  T += G.length;
                  da += I.length;
                  var ya = this.C,
                    md = a(y);
                  this.H.push(function () {
                    ya.save();
                    ya.resetTransform();
                    ya.globalCompositeOperation = md;
                    ya.globalAlpha = F;
                    var ac = ka.canvas();
                    ac && ya.drawImage(ac, Zb, $b, sa, ta, J, K, Fa, Ga);
                    ya.restore();
                  });
                }
              },
              _clipPath: function _clipPath(q) {
                this.H.push(this.C.clip.bind(this.C, q.T, q.Va === x ? "evenodd" : "nonzero"));
              },
              clear: function clear() {
                D.add(this);
                this.H.push(this.C.clearRect.bind(this.C, 0, 0, this.Ua.width, this.Ua.height));
              },
              flush: function flush() {},
              translate: function translate(q, y) {
                this.transform(1, 0, 0, 1, q, y);
              }
            });
            m.makeRenderer = function (q) {
              var y = new ra(q),
                F = y.C;
              return new Proxy(y, {
                get: function get(G, A) {
                  if ("function" === typeof G[A]) {
                    return function () {
                      for (var _len2 = arguments.length, I = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        I[_key2] = arguments[_key2];
                      }
                      return G[A].apply(G, I);
                    };
                  }
                  if ("function" === typeof F[A]) {
                    if (-1 < ja.indexOf(A)) {
                      throw Error("RiveException: Method call to '" + A + "()' is not allowed, as the renderer cannot immediately pass through the return                 values of any canvas 2d context methods.");
                    }
                    return function () {
                      var _F$A;
                      for (var _len3 = arguments.length, I = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                        I[_key3] = arguments[_key3];
                      }
                      y.H.push((_F$A = F[A]).bind.apply(_F$A, [F].concat(I)));
                    };
                  }
                  return G[A];
                },
                set: function set(G, A, I) {
                  if (A in F) {
                    return y.H.push(function () {
                      F[A] = I;
                    }), !0;
                  }
                }
              });
            };
            m.decodeImage = function (q, y) {
              new t({
                la: y
              }).decode(q);
            };
            m.renderFactory = {
              makeRenderPaint: function makeRenderPaint() {
                return new B();
              },
              makeRenderPath: function makeRenderPath() {
                return new r();
              },
              makeRenderImage: function makeRenderImage() {
                var q = ca;
                return new t({
                  xa: function xa() {
                    q.total++;
                  },
                  la: function la() {
                    q.loaded++;
                    if (q.loaded === q.total) {
                      var y = q.ready;
                      y && (y(), q.ready = null);
                    }
                  }
                });
              }
            };
            var H = m.load,
              ca = null;
            m.load = function (q, y) {
              var F = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
              var G = new m.FallbackFileAssetLoader();
              void 0 !== y && G.addLoader(y);
              F && (y = new m.CDNFileAssetLoader(), G.addLoader(y));
              return new Promise(function (A) {
                var I = null;
                ca = {
                  total: 0,
                  loaded: 0,
                  ready: function ready() {
                    A(I);
                  }
                };
                I = H(q, G);
                0 == ca.total && A(I);
              });
            };
            var nd = m.RendererWrapper.prototype.align;
            m.RendererWrapper.prototype.align = function (q, y, F, G) {
              var A = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1.0;
              nd.call(this, q, y, F, G, A);
            };
            d = new fa();
            m.requestAnimationFrame = d.requestAnimationFrame.bind(d);
            m.cancelAnimationFrame = d.cancelAnimationFrame.bind(d);
            m.enableFPSCounter = d.Rb.bind(d);
            m.disableFPSCounter = d.Ob;
            d.ob = c;
            m.resolveAnimationFrame = c;
            m.cleanup = function () {
              w && w.delete();
            };
          };
          var ma = Object.assign({}, m),
            na = "./this.program",
            oa = "function" == typeof importScripts,
            pa = "",
            qa;
          if ("object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) || oa) {
            oa ? pa = self.location.href : "undefined" != typeof document && document.currentScript && (pa = document.currentScript.src), _scriptDir && (pa = _scriptDir), 0 !== pa.indexOf("blob:") ? pa = pa.substr(0, pa.replace(/[?#].*/, "").lastIndexOf("/") + 1) : pa = "", oa && (qa = function qa(a) {
              var b = new XMLHttpRequest();
              b.open("GET", a, !1);
              b.responseType = "arraybuffer";
              b.send(null);
              return new Uint8Array(b.response);
            });
          }
          var ua = m.print || console.log.bind(console),
            va = m.printErr || console.error.bind(console);
          Object.assign(m, ma);
          ma = null;
          m.thisProgram && (na = m.thisProgram);
          var wa;
          m.wasmBinary && (wa = m.wasmBinary);
          var noExitRuntime = m.noExitRuntime || !0;
          "object" != (typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) && xa("no native wasm support detected");
          var za,
            z,
            Aa = !1,
            C,
            E,
            Ba,
            Ca,
            L,
            N,
            Da,
            Ea;
          function Ha() {
            var a = za.buffer;
            m.HEAP8 = C = new Int8Array(a);
            m.HEAP16 = Ba = new Int16Array(a);
            m.HEAP32 = L = new Int32Array(a);
            m.HEAPU8 = E = new Uint8Array(a);
            m.HEAPU16 = Ca = new Uint16Array(a);
            m.HEAPU32 = N = new Uint32Array(a);
            m.HEAPF32 = Da = new Float32Array(a);
            m.HEAPF64 = Ea = new Float64Array(a);
          }
          var Ia,
            Ja = [],
            Ka = [],
            La = [];
          function Ma() {
            var a = m.preRun.shift();
            Ja.unshift(a);
          }
          var Na = 0,
            Oa = null,
            Pa = null;
          function xa(a) {
            if (m.onAbort) {
              m.onAbort(a);
            }
            a = "Aborted(" + a + ")";
            va(a);
            Aa = !0;
            a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
            ba(a);
            throw a;
          }
          function Qa(a) {
            return a.startsWith("data:application/octet-stream;base64,");
          }
          var Ra;
          Ra = "data:application/octet-stream;base64,AGFzbQEAAAAB7wu5AWABfwBgAX8Bf2ACf38Bf2ACf38AYAN/f38Bf2ADf39/AGAEf39/fwF/YAR/f39/AGAFf39/f38Bf2AAAGAGf39/f39/AX9gBX9/f39/AGABfwF9YAJ/fQBgA39/fQBgAAF/YAZ/f39/f38AYAJ/fwF9YAh/f39/f39/fwF/YAN/fX0AYAZ/f31/fX8AYAJ/fgF/YAR/f35/AX9gB39/f39/f38Bf2ADf35/AX9gAn99AX1gCH9/f39/f39/AGAHf39/f39/fwBgAX0BfWAEf39/fQBgA39/fQF/YAN/fX8Bf2ADf399AX1gA39+fwF+YAN/fX8AYAJ/fQF/YAZ/f399fX8AYAF8AXxgAX0Bf2AHf319fX19fQBgBX9+fn5+AGACfX0BfWAGf39/fX99AGAKf39/f39/f39/fwBgA398fABgBX9/f39+AX9gBn9/f39/fQBgBH9/fX0AYAR/f39+AX9gBX9/fn9/AGACf38BfmAIf39/fX19fX8AYAp/f399fX19fX1/AGAFf39/f30AYAN/f38BfmABfwF8YAJ/fAF/YAV/f399fQBgA39/fwF9YAR/fX19AX1gC39/f39/f39/f39/AX9gB39/f39/fn4Bf2ADf39/AXxgAAF8YAR/fn5/AGACfHwBfGADf319AX9gCX9/f39/f39/fQBgA39/fgBgBX9/fX19AX1gCX9/f39/f39/fwF/YAN9fX0BfWACf34AYAV/f39/fwF9YAJ/fwF8YAZ/f39/fn4Bf2ACfH8BfGAEfn5+fgF/YAF8AX9gA3x+fgF8YAF8AGABfgF/YAN8fH8BfGABfAF+YAN/f3wBf2AJf399fX19f39/AGAIf399fX1/f38AYAR/f31/AX9gBn9/fn9/fQBgBH9/f34AYAJ/fgF+YAZ/f39/f34Bf2AAAX5gBH99f38AYAV/f39+fgBgBX99fX19AX9gBX9/f319AX1gBX99fXx8AGAKf398fHx8f39/fwBgAnx/AX1gBn98f39/fwF/YAJ+fwF/YAF+AX5gBH9/f38BfmAMf39/f39/f39/f39/AX9gBX9/f398AX9gBH9/f3wBf2AFf39/fn4Bf2APf39/f39/f39/f39/f39/AGABfAF9YA1/f39/f39/f39/f39/AGAJf39/f39/f39/AGAFf39/f38BfGACfn4Bf2ACfn8BfGACfn4BfGACf3wAYAJ+fgF9YAZ/f39/f30Bf2AHf399fX9/fQBgBH9/f30Bf2AEf398fABgB39/f39/f30AYAh/f319fX19fQBgB39/f39+f38AYAR/f359AGAEf35/fwBgB39/f39+f38Bf2ADf39+AX5gA39+fQBgCX9/f39/f35/fwBgBH9+fn4Bf2AFf35+fn8Bf2ACfX8BfWABfwF+YAZ/f319fX0Bf2AHf39/fX1/fwBgBX99fX9/AGADfX99AX1gBn9+f39/fwBgBX99fX1/AGAFfX9/f38AYAR/f31/AGAOf319f39/fX1/f39/f38Bf2AFf399fX0AYAR/fHx8AGAGf399fX1/AGAGf39/fX19AX1gA35+fQF9YAR/f319AX9gBX9/fX9/AGADfX1/AX9gCX9/f319fX19fQBgB39/f319fX0AYAl/f319fX19fX8AYAl/fX18fHx8fHwAYAd/fHx8fHx8AGAGf39/f39/AX1gBH9/f38BfWALf39/f39/f39/f38AYAR8fH9/AX1gDX99f31/fX99fX19fX8Bf2AEf31/fQF/YAV/fX99fQF/YA5/fX1/f399fX9/f39/fwBgB39/fX99f38AYAZ/f319f38AYAR/f319AX1gBH99fX8BfWADf319AX1gBH9/f34BfmACfX8Bf2ADfn9/AX9gAn19AX9gAn5/AX5gA39+fgBgAn98AXxgAnx/AX9gBH9/fn8BfmAFf39/fn8Bf2ADf39+AX9gBn9/f35/fwBgCH9/f39/f35+AX9gCn9/f39/f39/f38Bf2AEf35/fwF/AsgMNQNlbnYFYWJvcnQACQNlbnYRX2VtdmFsX25ld19vYmplY3QADwNlbnYNX2VtdmFsX2RlY3JlZgAAA2VudhBfZW12YWxfbmV3X2FycmF5AA8DZW52GV9lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24AGwNlbnYWX2VtYmluZF9yZWdpc3Rlcl9jbGFzcwBuA2VudiJfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yABADZW52H19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24AbwNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQArA2Vudg1fZW12YWxfaW5jcmVmAAADZW52E19lbXZhbF9zZXRfcHJvcGVydHkABQNlbnYSX2VtdmFsX25ld19jc3RyaW5nAAEDZW52EV9lbXZhbF90YWtlX3ZhbHVlAAIDZW52JV9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY2xhc3NfcHJvcGVydHkAGgNlbnYVX2VtYmluZF9yZWdpc3Rlcl9lbnVtAAcDZW52G19lbWJpbmRfcmVnaXN0ZXJfZW51bV92YWx1ZQAFA2Vudh1fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdAAQA2VudiNfZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZAArA2Vudh1fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdAAAA2VudiVfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uABoDZW52F19lbXZhbF9jYWxsX3ZvaWRfbWV0aG9kAAcDZW52GF9lbXZhbF9nZXRfbWV0aG9kX2NhbGxlcgACA2VudhJfZW12YWxfY2FsbF9tZXRob2QAcANlbnYWX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwAAA2VudiVfZW1iaW5kX2NyZWF0ZV9pbmhlcml0aW5nX2NvbnN0cnVjdG9yAAQDZW52E19lbXZhbF9nZXRfcHJvcGVydHkAAgNlbnYJX2VtdmFsX2FzAD4DZW52Gl9lbXZhbF9nZXRfbW9kdWxlX3Byb3BlcnR5AAEDZW52GGVtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludAAEA2VudhVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQAAwNlbnYVX2VtYmluZF9yZWdpc3Rlcl9ib29sAAsDZW52G19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwADA2VudhxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAUDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZW12YWwAAwNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAsDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABQNlbnYcX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwAFA2VudhBfX3N5c2NhbGxfb3BlbmF0AAYDZW52EV9fc3lzY2FsbF9mY250bDY0AAQDZW52D19fc3lzY2FsbF9pb2N0bAAEFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAGFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAEDZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAFFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQAAhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAIDZW52EmVtc2NyaXB0ZW5fZ2V0X25vdwA/A2VudhZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAEDZW52E2Vtc2NyaXB0ZW5fZGF0ZV9ub3cAPwNlbnYgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMADwNlbnYKc3RyZnRpbWVfbAAIA2VudhdfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludAAbFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc2VlawAIA6A36TYJBA8BAAQEAQQGAgIBAUwPAQEAAgIDAk1NcUBAKCgoKAAPDwABDw8oKCUMDDc3JU5PP1AcQU5RUSVyUk9QBCkmHCYpJikmQVNzDQN0A3UFAwEACgEAAQAJCQMGBgEAAAwGAQAMBAkJAgECAQIBAgECAQIBBAIBD3YuBAUCAQEAQgIMAwwBAAEPEQwCDg0CDA0MDQwNDA0MDQIEBQcBAAECAgQCBAEFAQIEAgQCBAEAAAMBAAADAQABAQEAAgECOFQDBQIEAgQCBAIEAgQCBAIEAQMCBAIEAQECBAEFBAQGBAYAAwMFAwIRDAIODQIMDQEDAgUBAgwNEQ4BABEMAg4NAgwNDA0BAgMFAQEBABECDg0CDQEAAgEDAgUBAQEADA0RDgEBAQARDg0CDQEAAgECAQEBAAICAQIBAQEBAgEMES85AQAEAgwNEQ4BAiMeDQ4BAQEAAQAEBAQBAAEAAQIBAgICAwIBAQEBAwIDBQEBAQADBQEBAQADBQEBAQADBQEABAIjHjhUBQQsAywsAQUEAQUEAwUBAAECAQIBAQIBAgECAQEBAAEDAgUBAQEADA0RDgEBAQAAAw8AAwEAAgEFBwQGAQUBAQAIAQEBAAADAgEEBQEAAgECAQIBAgQCBAMDAwEDAQEAAQICBAIEAgQCBAIEAgQCBAMCAAMCBAEAAQIAAwEBAQAMDREOAQEBAAEDAgUBAQEAAQMCBQcLCxADBQEBAQADAwIFAQEBAAADAQEBAAMDAgUDAgMBAwQFAwABAwABBAYDAQEDAQUBAQEDAQMCAAIEAAl3LwIBEQIFAQQCAgECAQEAASMDBAIDAgIEAQcDAQMDeB8BAwEBAwECAgEKAwEDAQMEHwJ5IxEBDgIDAgMBAwECAQMBAwECAgECAgIDAgQCAgICAwILAwEFBQUDBQIBAQMBAAYAAQEBBQMDAQECAQQEBAQBAgkJAQALVQZWBwUBAwMFAwMBAQEAAwMAAQEAAwEAAQABAAUFBwUuegEBAQAAAwIBBQEABQcFBXsBAQEAAAMCAQUBAAEABQUOBQUFBQEBAQAAAwIBBQEABQcAAwEBAQAAAwIBBQMDLwEBAAABAAMDDQMDAwMAAAEAAAMFEwcTJwABBQABAAAAAwUDHUMEAAEBAAEBAgQEAgICAwAAAwMDAgIMHQEAAAEMAAwMAwAAAwQCAQEBAQADAQMAAwEABAEAAAAAAAIHAQEBAQABAAEAAgAABAwEAQQEBAQEAwMJAwMAAgEBAQEBAAEAAwAAAwEAAAADAwEBAwUBAwIDAgQGAQMFAQEBAwQCAwABAwQGAwEBAQEAAQIBAgICAgMEBgMBAwMDAAMBAgNXAwECBgQEBQMDAgIDBQMBBQABAAEAAQACAQMDAwMDAwEJAAAABQcFAwICAQgBBAUFBAcCfDAIGFgHRBh9MQd+fwMCAgQEAgMEAgcGgAEEBgcEAwQCAQMCAQgEAQQRBgMEAgYEBQMKCAYEMjIWGBYCCgYCAgMlAgMDAwICBwgEAQEBBgYEAQ8EAAAEBAIBDwUFABYKgQFYBANZIlkDAgOCAUUWCgMWFQIWFQoCAgMEBAAIAgQDAQICCBgYAwEWIQUFIRUBISEKAgIhBAQEAAQEBAQEAgMEBAYECAgDBAICBAQBBAIYAgQEBBoCBAFGFgFaFRUKAgIBFQSDAYQBFQQEBAQDBAQICAUEAQILFQAIAQYEBBUhIQECBAEBAgIChQEDBwUQAAUmAgQDAxYVCgICBAQEBAYIBgYGCgIGGAICAgIGAAYYAhIICAoFEggICgUSCAgKBRYWFRUKCgICAgYEBgMDCwQCAgsWWy0CBAILAAsEWgsDBwQDCRYVCgICBAYDAQEBAQEBAQABAwEBAwMBAwMBAQABAQMCAgMEBgEBAwIAAAMDAgMAAAADAAECBAMCCQIBAQABAoYBAQECAgICAgICAgAHOgcDBAQDBAQHBAABAAcOAwAEEQIABwUEAAcFBAMDAwAHBQQCAAcFBAIBAwAHBwMCBwEBBAYBAgMBAQEDAAcEAgIDAgEBAAECBAAAAAADAAAFBQEBAQMDAwQGAwEDAgIDAAQBAAECBAABAQQBAQABAgQAAAIEBAEFAAOHAQQEAAECBAEAAAAAAAAAAQEBBAQFAgEDAgIAAAECBAABAgIBAAECDAwBFAEBAQADBAEBBQgAAAIBAQAECAEABQAIAQEBBRMZRwIAAQEAAAECBAI7GQAAAABCHEcBAQABAgQCOxkcAAAAAB6IAQMDIgUiBwICDokBIAMDAwEDBgMBAwQBBwQDAQABAQAAAR4DAQABAgQBAIoBBAAAAAABAQABAgQBAAEBAAAAAAECBAIAAQEBAQAABQWLAQABAQMDAQEDABwAAAAAAAABAgQEAQMBAQABAgQEAwMBAQECAQEDAQABAQIEBAQDAAEBAQEBAQEBAAEBAQEBAAEBAQEBAQMBAQEBAQMAAQIBAQEBAwEBAAEBAQEBAQMBAQABAQABAAEAAQEAAQIAAQIEAAABAQMDAwAAAAECBAQBAQMHDgcOBwIDBwABAgEBAwAAAQEOGQdHKQcCjAEDAwAAAQIEBAEBAAAAAgEAAAEBAwIDAAECAQECAAECAQEJAQABAQEAIg4BAAIAAQIEBAAJAAICAQICAgIAAQIEBAAAAAABAwUAAAMJAAMBAwMGAQAAAQEAAAMBAAEiIgQODgEAAQwMAQAGAgIDAQIMAAEBAgIAAQIEBAABAQIZAAECBAAAAAABOxkAAQIBAQEAIiIOAQAGAgMBAgABAgEBAgABAgEBAwICAAEBAgQEAAAAAAAAAAABAgIAAQIEAAEBAAAAAAAAAQIEAQEAAAAAAAECBAEBAgIAAwEAAQIEAAAAAQECAgAAAQIEHh4BAQMEBAABAgQEAAEBBAQAAQIBAQQEAAECAQEBAAECAQMEBAEFAAEAAQIEAQIAAQEEHAABAgQBAAEBBAABAgEBAQQEAwMFAQABAgQAAQEEDQEBAAECAQEBAwMCAgAMDAMBAQABAgQBAQADAgQDAwMBAQEBAQABAgQAAQAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEAAQIEAAAAAAABAgAEAAAAAQIAAQIEAAABAgICAAECBAQAAAAAAAABAgABAgQAAAECBAAAAQIEAAABAgQAAAECAQAAAQIEAAABAgQAAQABAgQAAAABAgQAAQIEAAECAQIAAQIAAAABAgQAAAECAAECBAEAAAEAAQIEBAAAAAECAQIAAQIAAQIAAQIEAAABAgQAAAECBAIAAAABAgABAgABAgABAgABAgQCAAAAAAECBAAAAQIEAAAAAQIEAAEAAQMAAAMBAgQAAAECBAQAAQAAAAAAAAAAAAAAAQIBAQIAAQIEAAAAAAAAAAECBABcAQIAAAECBAABAAECBAAAAQIAAQIAAQIAAQIEAAEAAQIEAAEAAQIEAAABAgQBAAABAgABAgABAgQAAQIAAQIEAAABAgMCAQMBAQICBQQBAwEDAwACAwMBAAECBAABAQABAwECAg4LAQEAAQIEAAEDAQAAAykDAwMDBAYDAQcBAgABAAECBAABAwQDAQABAgEAAgICAg8kAyQDMwM0AwcDAQMBAwETEycAAwMAAQEBBQcRAREBAwUCBAIHAQcABQcLDwIFBgYEAAAAAwEDAwADAwMBAQcDARsPAgIAEgQACAAAAgICAQECAgYDAQQAAwEGAggLCgAAAwQBAQAAAQIBAQEAAQIAAAAAAQIEAQAAAgANBxwAAwMBAAECBAABAxMDEwCNAQMLAgMTBAIBAQMAAwAAAAEBDAwUFAcHAQABAgQAAAABAAEAAQIEAAMAAAECAgADDBQUBwcAAAAAAAAAAQIEAAAAAAAAAQEBAAEBAgQCAgIBAAEBAAABAQIEAgICAAFXAQABAgIdKgABAgQEAAAAAQEjJh4eHY4BKgABAgQAAR0vKgABAgQAAR0qAAECBAABAh0qAQABAgQAAQAdKgABAgQAAQEAAgIDAgABAQAABAMBDl0AAF0DAw0ADQAAAgIBAQMBAQ8BAgILCQEDHw8BAAECAgIAAwMAAAAAAAADAAMAHwIOAgADFBQDAQAfAQAEBgMBAQQBAQMUAQIPDw8PDwUAHiAZjwEBkAGRAQEAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIEAAAAAAABAAECBAICAgAAAAAAAAAADJIBAQAAAwEBDCMOAUgBAA4BIwEBAgIAAwIHCAoGBwQODhsAAAAAAAAAAQEBAAECBAEAAQMCAQQHAAECBAAAAQICBwABAgQEAAAAAQcAAQIEAAECAgIHAAECBAABAgIHAAECAQIHAQABAgENBxMCAgMEBgMBAgADAQMAAAEBAwACAQMDAAMFNTUBAQAAAQIEAAEAAQAAAgABAgEDAAAAAAMDAQ4OOQIBAgEAAQIDAAADkwEAAQMAAAMDBQMHBwcLCwUDBRQUBwcBAQEAAAECBAAAAQEBAQABAQABAQABAQABAgIAAwUHAwMHAQMAAAABAAEDBAMDAwQDAgABAgQAAAEAAQECBAEBAgIDAwQDAwAAFAcfARQHHxgDAQEDAgAAAAAAAAABAgQBAQMAAQIEAAAAAAMBAAECBAABAwICAAEAAQIEBAADAAEBAgANDAABAgQAAQADHwABAgQBAwMfAAECBAAAAQABAQIfAwMBAwAAAQIBAAAAAQIBAQAUFAcHAwMAAAAAAAIABAYDAQEClAEcAAMBAgICAAIAAAABAwMAAAEAAQIEAQABAAEAAQECBAMCAwAAAQABAxsAAQIBAAEAAwYDAQUAAQIEAAAAAAABEAIDAgMDAAIAAAABAgQMDAEDAgABAgEBAwMAAQIBAQMdAwICAgIBAgICAgwRDBEDAwMRDBEMLgACDQ0CAAECBAAAAQMDAwMAAQMBAAEDAwMDAwMfHwMAAQECAAECBAAAAAMDAwABAwIAAAEAAwMDAAIAAQADBRMTJwABAQEAAQICAgIAAwMEARQCAR4UAQEAAh4BAAAAAwUTEycAAQEBAgAAAQABAgQCAAMDAAAAAAAAAQEAAzUEBgECAAAODgABAQEAAQIEAQABAwIAAgABAgQBAAECBAMBAAABAQABAQICAgIBAQEDAQECAAECBAAAAQABAQICAgAAAQAAAAAEAgICAhAECAIDAwYBAwEBAAEDAAACAQABAAYFAgIG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EGR5bkNhbGxfaWlpaWlpamoAmzcJpDoBAEEBC48dli2XLZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBuAG5AboBuwG8Ab0BvgHAAcEBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AYACgQKCAoMChAKFAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKfAqACogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKzArQCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLEAsUCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt8C4ALhAuIC4wLlAuYC5wLoAukC6gLrAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8CgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5gDmQOaA5wDnQOeA58DoAOhA6IDowOkA6UDpgOnA6gDqQOqA6sDrAOtA64DrwOwA7EDsgOzA7QDtQO2A7cDuAO5A7oDuwO9A74DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA/AD8QPyA/MD9AP1A/YD9wP4A/oD+wP8A/0D/gP/A4AEgQSCBIMEhASFBIYEhwSIBIkEigSLBI0EjgSPBJAEkQSSBJMElASWBJcEmQSaBJsEnASdBJ4EnwSgBKEEogSjBKQEpQSmBKcEqASpBKoEqwSsBK0ErgSvBLAEsQSyBLMEtAS1BLYEtwS4BLkEugS7BLwEvQS+BL8EwATBBMIEwwTEBMUExgTHBMgEyQTKBMsEzATNBM4EzwTQBNEE0gTTBNQE1QTWBNcE2ATZBNoE2wTcBN0E3gTfBOAE4QTiBOME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E4wTjhOZE5cTmBOWE7YXtxe4F7kXuheuF6UXohekF7sXvBe9F6gXpheyF7QXqxezF7UXvhe/F6oXpxetF9kX2hfbF9wX5RfKF8sXzBfNF9MX1BfVF9YX3RfeF9cX2BffF+AX4RfiF88X0RfjF9AX0hfkF+cX5hfoF+kX6hfxF+sX7BftF+8X8hf0F/MX9Rf2F/cX/hf4F/kX+hf7F/8XgBiFGIYYhxiIGI0YghiBGJkUihiLGIMYhBiMGJUUlhSXFJgUjhiWGJcYmBiZGJsYkxiVGJoYnxigGKEYohikGJwYnhijGKcYqBipGKoYrBilGKYYqxiwGLcYshizGLQYthi1GLEYrhivGLoYuxi8GL0Yvxi4GLkYvhjGGMcY5gfsGO0Y7hjUB6YZ8hieB/MYyxj7GMgIghmHGYgZihmLGYwNjw2GDYcNgh2QDZENkg2TDYQN8hnzGfQZ9Rn7GawZwBnBGcIZwxnEGcUZxhnHGcgZyRnKGcsZzBnNGc4ZzxnQGdEZ0hnTGdQZ1Rm7GbwZvRm+GfYZvxmvGbAZrhn3GfgZ+RmtGbEZshmpGbUZthm3GbgZuRm6GbMZtBnWGdcZ3hnfGeAZ4RniGeMZ5BnlGeYZ5xnoGekZ6hnrGewZ7RnYGdkZ3BndGdoZ2xn6Ge4Z7xnwGfEZ2A/8Gf0Z/hn/GY0agBqBGoIawxSDGoQahRqGGocaiBqJGooajhqdGo8a+R2QGpEakhqTGpQa+h37Hfwd/R3+Hf8dgB6BHoIegx6VGpgamRqaGpsawxrEGsUaxhrJGr8awhrHGsgazRrOGs8a0BrVGt0azBrSGtMayhrLGtQa1xrYGtka2hrcGtYa2xrhGuIa4xrkGuYa4BreGt8a5RrqGusa7BrRGu0a6RrnGuga8RryGvMawRr0Gu4a7xqTG5YblxuYG5kbhhv4GvkajhuPG/oagxuaG5EbhBuMG5sbnBuFG50bnhuNG5IboRuiG6MbpBvKFLwbvRu+G78bwBvBG7MbtBu1G7cbuBu5G7ob0RvVG9Yb1xvYG+YbqhvZG9obqBupG6Yb2xvCG8UbyBvKG80bzxvcG84b0BvdG6cb3hvfG+Ab4RviG8cbxBvjG+Qb5RvJG8wbyxTMFM0UzhTPFNAU5xvoG+kb6hv6G+sb7BvtG/Yb9xv4G/kb0hvUG4MchByFHIYciRyCHIcciByLHIocjByNHI4cjxyRHJIckxyUHJUclhyXHJgcmRyaHJscnByeHJ8coBytHK4crxywHKMcphylHKccqBypHKocqxysHLQctRy2HLccsRyzHLgcuRy6HL4cvxzAHMEcwxyjFKQUuxy9HLwcwhzRHMkcyhzLHMwcxRzGHM4czxzQHNcc2BzZHNoc3BzUHNYc1RzbHOAc4RziHOMc5BzfHN4c3RzoHOkc6hzrHO4c5xzsHO0c8BzvHPEc8hzNHPYc8xz0HMcc0hzTHPkc+hz7HKIU/Bz4HPccnxSgFKEUpRTaE4Qd3BPdE94Tgx3jDt8T4BPbE+QO5Q7mDuEOqh2rHawdrR2uHbMdpB2mHaUdpx2vHbAdqB2xHbIdqR21HbQdth23HbgdwB25HbwdvR2+Hb8dthrDHcQdxR26GsgdnxqhGqIarxqwGrEashqzGqoarRq0GsIdrhq1GsYdxx2rGrcauBq5Gr0arBq7GrwakhnPHdAd0R3SHdgd/BjTHdQd1R3WHdcdgRLjHeQd5R3mHekd4B3nHegd/RHhHeIdgxKEEoUShhL3EfsR/hH/Eewd7R3uHdgU8B3qHe8d3hTfFOAU4RTiFOMU5BTlFPMd9B31He8U9x3yHfYd8BTxFPIU8xT0FPUUlR6WHpcemB6bHpQekR6QHooe+hSIHpkemh6jHqAeoR6eHp0eoh6kHqUenx6mHqcesx60HrUeth6wHrIerx6oHq4etx64HrkeqR6sHq0eqh72FPcU+BT5FMsLvR6+Hrseuh68HsEe/BT9FJoPmw+cD9Ue1h7XHtge9x7ZHtoe2x7cHt0e3h7fHuAe4R7iHuQe5R7mHuce6B7pHuoe6x7sHuMe7R7uHu8e8B7xHvIe8x70HvUewx7CHpQIlQjEHsUexh77Hvwe/R7+Hv8eih+AH4Efgh+DH4QfhR+GH4cfiB+JH4sfjB+NH44flBuVG5ofmx+cH50fnh+hH5Iflx+VH5MfmB+UH5kfnx+gH5YfjQ2mH6cfqB+pH6ofpR+jH6Qfqx+sH60frh+zH68fsB+xH7Ifth+1H7cfuB/CFMAfuR+6H7sf0Q6/FMAUwRTODtAOghSDFIQUhRSGFMEfzR/OH88fiBSJFMMfxB/FH8YfyR/CH8cfyB/KH8sfzB/RH9If0x/UH9Uf1h+YIJcgmSCaIJsgnCCdIJ4g2R/YH9of2x+fIKAgoSCiIKMgpCCmIKcgqCCpIKogqyCsIK0griDvH/of8R/yH/Mf+x/2H/cf+B/5H/Qf9R/tH/Af5h/nH+gf6R/qH+sf7B+KIJIgkyCUIJUgkCCLIIwgjSCOII8ghSCGIIcgiCCJILkguiC7ILwghxTAIL0gviC/IMAYwSDCIMMgxCDFIMYgxyDIIMEYxBXFFcogySDLIMwgzSDSIM4gzyDQINEg0yDUILoUuxS8FL0U1SC+FKkUqhSrFNYg0B+NFI4UjxSLFIwUihTXINgg2SDiEN8g3SDeIOAg4SDwIPEg8iDzIPUg6yDpIOgg7CDqIO0g7iDvIPQg+h78E/0T/hPfFbQf9iD3IPgg+SD/IIAhgSGCIYoh/SD+IIMhhCGFIYYhhyGIIYkh+SH7Ifwh/SH+IYIi7yH0IeMh9SHpIeoh6yHsIe4h9yH4Ie0h9iH/IYAigSLCIdAhzyHTIYUNkyKVIpYilyKYIpkihCKJIooiiyKMIo0ijiKPIpAikSKmIqciqCKpIqoirCKaIpsinCKdIp4inyKgIqEioiKjIqQipSKrIq0iriKvIrAisSKyIrQitSK2IrciuCK5IroiuyK8Ir0iviK/IsAiwSLCIsMixCLFIvUW9hbGIsciyCLNIs4izyLQItEiyiLLIswi0yLUItUi1iLZItIi1yLYIsseyh7MHs0ezh7PHtAe0R7SHtMe5CLsIuYi5yLoIusi7SLuIuMi5SLcItsi3SLaIt8i4SLgIuIi6SLqIvEi8iLzIvQi9iKDIu8i9SLwIoIjgyOEI4UjhiOBI/8igCP+IrIUsxS0FLUUhyOYI5kjmiPdI7YUtxS4FLkUiiOLI4wjjSORI5sjiSOII48jkCOeI58joCOhI6MjnSOcI6IjpiOnI6gjqSOrI5IjpCOqI+8OxhPHE8gTyRPsDsoT7g6zI7QjtSOXI7YjrCOtI7kjuiO7I44jvCO4I7cjviO/I8AjwSPDI70jwiPFI8YjxyPII8ojxCPJI5oUmxScFJ0UyyOWI54UzSPOI88j0CPSI8wj0SPUI9sj1iPXI9gj2iPZI9Uj0yPFFMYUxxTIFNwjyRTeI98j4CPhI+Ij5CPlI+Yj6CPjI+cj7BTtFO4U1RTWFNcU5hTnFOgU2RT8IOoU6xSWD80LzgvPC9AL6SPqI+sj7CPuI+0jrw6PHbkOug62Dv8cgB2B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BCAAIAFqIAE2AgAgAEEAKAKo0htHDQBBACABNgKc0hsPCwJAIAFB/wFLDQAgAUF4cUG80htqIQMCQAJAQQAoApTSGyIEQQEgAUEDdnQiAXENAEEAIAQgAXI2ApTSGyADIQEMAQsgAygCCCEBCyADIAA2AgggASAANgIMIAAgAzYCDCAAIAE2AggPC0EfIQMCQCABQf///wdLDQAgAUEmIAFBCHZnIgNrdkEBcSADQQF0a0E+aiEDCyAAIAM2AhwgAEIANwIQIANBAnRBxNQbaiEEAkACQAJAQQAoApjSGyIGQQEgA3QiAnENAEEAIAYgAnI2ApjSGyAEIAA2AgAgACAENgIYDAELIAFBAEEZIANBAXZrIANBH0YbdCEDIAQoAgAhBgNAIAYiBCgCBEF4cSABRg0CIANBHXYhBiADQQF0IQMgBCAGQQRxakEQaiICKAIAIgYNAAsgAiAANgIAIAAgBDYCGAsgACAANgIMIAAgADYCCA8LIAQoAggiASAANgIMIAQgADYCCCAAQQA2AhggACAENgIMIAAgATYCCAsLYwIBfwF+AkACQCAADQBBACECDAELIACtIAGtfiIDpyECIAEgAHJBgIAESQ0AQX8gAiADQiCIp0EARxshAgsCQCACEEYiAEUNACAAQXxqLQAAQQNxRQ0AIABBACACEDoaCyAAC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC0sCAX4CfyABQv///////z+DIQICQAJAIAFCMIinQf//AXEiA0H//wFGDQBBBCEEIAMNAUECQQMgAiAAhFAbDwsgAiAAhFAhBAsgBAtTAQF+AkACQCADQcAAcUUNACABIANBQGqthiECQgAhAQwBCyADRQ0AIAFBwAAgA2utiCACIAOtIgSGhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtTAQF+AkACQCADQcAAcUUNACACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAuUCwIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQogBCAChUKAgICAgICAgIB/gyELIAJC////////P4MiDEIgiCENIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIOQoCAgICAgMD//wBUIA5CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCELDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCELIAMhAQwCCwJAIAEgDkKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhC0IAIQEMAwsgC0KAgICAgIDA//8AhCELQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA6EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACELDAMLIAtCgICAgICAwP//AIQhCwwCCwJAIAEgDoRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhCAJAIA5C////////P1YNACAFQdAAaiABIAwgASAMIAxQIggbeSAIQQZ0rXynIghBcWoQT0EQIAhrIQggBUHYAGopAwAiDEIgiCENIAUpA1AhAQsgAkL///////8/Vg0AIAVBwABqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahBPIAggCWtBEGohCCAFQcgAaikDACEKIAUpA0AhAwsgA0IPhiIOQoCA/v8PgyICIAFCIIgiBH4iDyAOQiCIIg4gAUL/////D4MiAX58IhBCIIYiESACIAF+fCISIBFUrSACIAxC/////w+DIgx+IhMgDiAEfnwiESADQjGIIApCD4YiFIRC/////w+DIgMgAX58IgogEEIgiCAQIA9UrUIghoR8Ig8gAiANQoCABIQiEH4iFSAOIAx+fCINIBRCIIhCgICAgAiEIgIgAX58IhQgAyAEfnwiFkIghnwiF3whASAHIAZqIAhqQYGAf2ohBgJAAkAgAiAEfiIYIA4gEH58IgQgGFStIAQgAyAMfnwiDiAEVK18IAIgEH58IA4gESATVK0gCiARVK18fCIEIA5UrXwgAyAQfiIDIAIgDH58IgIgA1StQiCGIAJCIIiEfCAEIAJCIIZ8IgIgBFStfCACIBZCIIggDSAVVK0gFCANVK18IBYgFFStfEIghoR8IgQgAlStfCAEIA8gClStIBcgD1StfHwiAiAEVK18IgRCgICAgICAwACDUA0AIAZBAWohBgwBCyASQj+IIQMgBEIBhiACQj+IhCEEIAJCAYYgAUI/iIQhAiASQgGGIRIgAyABQgGGhCEBCwJAIAZB//8BSA0AIAtCgICAgICAwP//AIQhC0IAIQEMAQsCQAJAIAZBAEoNAAJAQQEgBmsiB0H/AEsNACAFQTBqIBIgASAGQf8AaiIGEE8gBUEgaiACIAQgBhBPIAVBEGogEiABIAcQUCAFIAIgBCAHEFAgBSkDICAFKQMQhCAFKQMwIAVBMGpBCGopAwCEQgBSrYQhEiAFQSBqQQhqKQMAIAVBEGpBCGopAwCEIQEgBUEIaikDACEEIAUpAwAhAgwCC0IAIQEMAgsgBq1CMIYgBEL///////8/g4QhBAsgBCALhCELAkAgElAgAUJ/VSABQoCAgICAgICAgH9RGw0AIAsgAkIBfCIBUK18IQsMAQsCQCASIAFCgICAgICAgICAf4WEQgBRDQAgAiEBDAELIAsgAiACQgGDfCIBIAJUrXwhCwsgACABNwMAIAAgCzcDCCAFQeAAaiQAC3UBAX4gACAEIAF+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgA0L/////D4MgAiABfnwiAUIgiHw3AwggACABQiCGIAVC/////w+DhDcDAAvSEAIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQogAkL///////8/gyELIAQgAoVCgICAgICAgICAf4MhDCAEQjCIp0H//wFxIQYCQAJAAkAgAkIwiKdB//8BcSIHQYGAfmpBgoB+SQ0AQQAhCCAGQYGAfmpBgYB+Sw0BCwJAIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhDAwCCwJAIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhDCADIQEMAgsCQCABIA1CgICAgICAwP//AIWEQgBSDQACQCADIAJCgICAgICAwP//AIWEUEUNAEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsCQCADIAJCgICAgICAwP//AIWEQgBSDQBCACEBDAILAkAgASANhEIAUg0AQoCAgICAgOD//wAgDCADIAKEUBshDEIAIQEMAgsCQCADIAKEQgBSDQAgDEKAgICAgIDA//8AhCEMQgAhAQwCC0EAIQgCQCANQv///////z9WDQAgBUHAAmogASALIAEgCyALUCIIG3kgCEEGdK18pyIIQXFqEE9BECAIayEIIAVByAJqKQMAIQsgBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahBPIAkgCGpBcGohCCAFQbgCaikDACEKIAUpA7ACIQMLIAVBoAJqIANCMYggCkKAgICAgIDAAIQiDkIPhoQiAkIAQoCAgICw5ryC9QAgAn0iBEIAEFIgBUGQAmpCACAFQaACakEIaikDAH1CACAEQgAQUiAFQYACaiAFKQOQAkI/iCAFQZACakEIaikDAEIBhoQiBEIAIAJCABBSIAVB8AFqIARCAEIAIAVBgAJqQQhqKQMAfUIAEFIgBUHgAWogBSkD8AFCP4ggBUHwAWpBCGopAwBCAYaEIgRCACACQgAQUiAFQdABaiAEQgBCACAFQeABakEIaikDAH1CABBSIAVBwAFqIAUpA9ABQj+IIAVB0AFqQQhqKQMAQgGGhCIEQgAgAkIAEFIgBUGwAWogBEIAQgAgBUHAAWpBCGopAwB9QgAQUiAFQaABaiACQgAgBSkDsAFCP4ggBUGwAWpBCGopAwBCAYaEQn98IgRCABBSIAVBkAFqIANCD4ZCACAEQgAQUiAFQfAAaiAEQgBCACAFQaABakEIaikDACAFKQOgASIKIAVBkAFqQQhqKQMAfCICIApUrXwgAkIBVq18fUIAEFIgBUGAAWpCASACfUIAIARCABBSIAggByAGa2ohBgJAAkAgBSkDcCIPQgGGIhAgBSkDgAFCP4ggBUGAAWpBCGopAwAiEUIBhoR8Ig1CmZN/fCISQiCIIgIgC0KAgICAgIDAAIQiE0IBhiIUQiCIIgR+IhUgAUIBhiIWQiCIIgogBUHwAGpBCGopAwBCAYYgD0I/iIQgEUI/iHwgDSAQVK18IBIgDVStfEJ/fCIPQiCIIg1+fCIQIBVUrSAQIA9C/////w+DIg8gAUI/iCIXIAtCAYaEQv////8PgyILfnwiESAQVK18IA0gBH58IA8gBH4iFSALIA1+fCIQIBVUrUIghiAQQiCIhHwgESAQQiCGfCIQIBFUrXwgECASQv////8PgyISIAt+IhUgAiAKfnwiESAVVK0gESAPIBZC/v///w+DIhV+fCIYIBFUrXx8IhEgEFStfCARIBIgBH4iECAVIA1+fCIEIAIgC358Ig0gDyAKfnwiD0IgiCAEIBBUrSANIARUrXwgDyANVK18QiCGhHwiBCARVK18IAQgGCACIBV+IgIgEiAKfnwiCkIgiCAKIAJUrUIghoR8IgIgGFStIAIgD0IghnwgAlStfHwiAiAEVK18IgRC/////////wBWDQAgFCAXhCETIAVB0ABqIAIgBCADIA4QUiABQjGGIAVB0ABqQQhqKQMAfSAFKQNQIgFCAFKtfSENIAZB/v8AaiEGQgAgAX0hCgwBCyAFQeAAaiACQgGIIARCP4aEIgIgBEIBiCIEIAMgDhBSIAFCMIYgBUHgAGpBCGopAwB9IAUpA2AiCkIAUq19IQ0gBkH//wBqIQZCACAKfSEKIAEhFgsCQCAGQf//AUgNACAMQoCAgICAgMD//wCEIQxCACEBDAELAkACQCAGQQFIDQAgDUIBhiAKQj+IhCENIAatQjCGIARC////////P4OEIQ8gCkIBhiEEDAELAkAgBkGPf0oNAEIAIQEMAgsgBUHAAGogAiAEQQEgBmsQUCAFQTBqIBYgEyAGQfAAahBPIAVBIGogAyAOIAUpA0AiAiAFQcAAakEIaikDACIPEFIgBUEwakEIaikDACAFQSBqQQhqKQMAQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIgFUrX0hDSAEIAF9IQQLIAVBEGogAyAOQgNCABBSIAUgAyAOQgVCABBSIA8gAiACQgGDIgEgBHwiBCADViANIAQgAVStfCIBIA5WIAEgDlEbrXwiAyACVK18IgIgAyACQoCAgICAgMD//wBUIAQgBSkDEFYgASAFQRBqQQhqKQMAIgJWIAEgAlEbca18IgIgA1StfCIDIAIgA0KAgICAgIDA//8AVCAEIAUpAwBWIAEgBUEIaikDACIEViABIARRG3GtfCIBIAJUrXwgDIQhDAsgACABNwMAIAAgDDcDCCAFQdACaiQAC8kGAgR/A34jAEGAAWsiBSQAAkACQAJAIAMgBEIAQgAQTEUNACADIAQQTiEGIAJCMIinIgdB//8BcSIIQf//AUYNACAGDQELIAVBEGogASACIAMgBBBRIAUgBSkDECIEIAVBEGpBCGopAwAiAyAEIAMQUyAFQQhqKQMAIQIgBSkDACEEDAELAkAgASACQv///////////wCDIgkgAyAEQv///////////wCDIgoQTEEASg0AAkAgASAJIAMgChBMRQ0AIAEhBAwCCyAFQfAAaiABIAJCAEIAEFEgBUH4AGopAwAhAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGAkACQCAIRQ0AIAEhBAwBCyAFQeAAaiABIAlCAEKAgICAgIDAu8AAEFEgBUHoAGopAwAiCUIwiKdBiH9qIQggBSkDYCEECwJAIAYNACAFQdAAaiADIApCAEKAgICAgIDAu8AAEFEgBUHYAGopAwAiCkIwiKdBiH9qIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCELIAlC////////P4NCgICAgICAwACEIQkCQCAIIAZMDQADQAJAAkAgCSALfSAEIANUrX0iCkIAUw0AAkAgCiAEIAN9IgSEQgBSDQAgBUEgaiABIAJCAEIAEFEgBUEoaikDACECIAUpAyAhBAwFCyAKQgGGIARCP4iEIQkMAQsgCUIBhiAEQj+IhCEJCyAEQgGGIQQgCEF/aiIIIAZKDQALIAYhCAsCQAJAIAkgC30gBCADVK19IgpCAFkNACAJIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEFEgBUE4aikDACECIAUpAzAhBAwBCwJAIApC////////P1YNAANAIARCP4ghAyAIQX9qIQggBEIBhiEEIAMgCkIBhoQiCkKAgICAgIDAAFQNAAsLIAdBgIACcSEGAkAgCEEASg0AIAVBwABqIAQgCkL///////8/gyAIQfgAaiAGcq1CMIaEQgBCgICAgICAwMM/EFEgBUHIAGopAwAhAiAFKQNAIQQMAQsgCkL///////8/gyAIIAZyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQACwYAIAAkAQsEACMBCwQAIwALBgAgACQACxIBAn8jACAAa0FwcSIBJAAgAQsEAEEACwQAQQAL3woCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEJAkACQAJAIAFQIgYgAkL///////////8AgyIKQoCAgICAgMCAgH98QoCAgICAgMCAgH9UIApQGw0AIANCAFIgCUKAgICAgIDAgIB/fCILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELAkAgBiAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEEIAEhAwwCCwJAIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQQMAgsCQCABIApCgICAgICAwP//AIWEQgBSDQBCgICAgICA4P//ACACIAMgAYUgBCAChUKAgICAgICAgIB/hYRQIgYbIQRCACABIAYbIQMMAgsgAyAJQoCAgICAgMD//wCFhFANAQJAIAEgCoRCAFINACADIAmEQgBSDQIgAyABgyEDIAQgAoMhBAwCCyADIAmEUEUNACABIQMgAiEEDAELIAMgASADIAFWIAkgClYgCSAKURsiBxshCSAEIAIgBxsiC0L///////8/gyEKIAIgBCAHGyICQjCIp0H//wFxIQgCQCALQjCIp0H//wFxIgYNACAFQeAAaiAJIAogCSAKIApQIgYbeSAGQQZ0rXynIgZB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vSIFQjSIp0H/D3EiBkH/D0YNACAEQv///////////wCDQoGAgICAgID4/wBUDQELIAAgAaIiASABow8LAkAgBUIBhiIEIANWDQAgAEQAAAAAAAAAAKIgACAEIANRGw8LIAJCNIinQf8PcSEHAkACQCAGDQBBACEGAkAgBUIMhiIDQgBTDQADQCAGQX9qIQYgA0IBhiIDQn9VDQALCyAFQQEgBmuthiEDDAELIAVC/////////weDQoCAgICAgIAIhCEDCwJAAkAgBw0AQQAhBwJAIAJCDIYiBEIAUw0AA0AgB0F/aiEHIARCAYYiBEJ/VQ0ACwsgAkEBIAdrrYYhAgwBCyACQv////////8Hg0KAgICAgICACIQhAgsCQCAGIAdMDQADQAJAIAMgAn0iBEIAUw0AIAQhAyAEQgBSDQAgAEQAAAAAAAAAAKIPCyADQgGGIQMgBkF/aiIGIAdKDQALIAchBgsCQCADIAJ9IgRCAFMNACAEIQMgBEIAUg0AIABEAAAAAAAAAACiDwsCQAJAIANC/////////wdYDQAgAyEEDAELA0AgBkF/aiEGIANCgICAgICAgARUIQcgA0IBhiIEIQMgBw0ACwsgBUKAgICAgICAgIB/gyEDAkACQCAGQQFIDQAgBEKAgICAgICAeHwgBq1CNIaEIQQMAQsgBEEBIAZrrYghBAsgBCADhL8LBQAgAL0L4gMCAn8CfiMAQSBrIgIkAAJAAkAgAUL///////////8AgyIEQoCAgICAgMD/Q3wgBEKAgICAgIDAgLx/fFoNACAAQjyIIAFCBIaEIQQCQCAAQv//////////D4MiAEKBgICAgICAgAhUDQAgBEKBgICAgICAgMAAfCEFDAILIARCgICAgICAgIDAAHwhBSAAQoCAgICAgICACFINASAFIARCAYN8IQUMAQsCQCAAUCAEQoCAgICAgMD//wBUIARCgICAgICAwP//AFEbDQAgAEI8iCABQgSGhEL/////////A4NCgICAgICAgPz/AIQhBQwBC0KAgICAgICA+P8AIQUgBEL///////+//8MAVg0AQgAhBSAEQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQTyACIAAgBEGB+AAgA2sQUCACKQMAIgRCPIggAkEIaikDAEIEhoQhBQJAIARC//////////8PgyACKQMQIAJBEGpBCGopAwCEQgBSrYQiBEKBgICAgICAgAhUDQAgBUIBfCEFDAELIARCgICAgICAgIAIUg0AIAVCAYMgBXwhBQsgAkEgaiQAIAUgAUKAgICAgICAgIB/g4S/C+ABAgN/An4jAEEQayICJAACQAJAIAG8IgNB/////wdxIgRBgICAfGpB////9wdLDQAgBK1CGYZCgICAgICAgMA/fCEFQgAhBgwBCwJAIARBgICA/AdJDQAgA61CGYZCgICAgICAwP//AIQhBUIAIQYMAQsCQCAEDQBCACEGQgAhBQwBCyACIAStQgAgBGciBEHRAGoQTyACQQhqKQMAQoCAgICAgMAAhUGJ/wAgBGutQjCGhCEFIAIpAwAhBgsgACAGNwMAIAAgBSADQYCAgIB4ca1CIIaENwMIIAJBEGokAAuMAQICfwJ+IwBBEGsiAiQAAkACQCABDQBCACEEQgAhBQwBCyACIAEgAUEfdSIDcyADayIDrUIAIANnIgNB0QBqEE8gAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALjQICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqEE8gAkEIaikDAEKAgICAgIDAAIVBjPgAIANrrUIwhoQhBSACKQMAIQYLIAAgBjcDACAAIAUgBEKAgICAgICAgIB/g4Q3AwggAkEQaiQAC3ECAX8CfiMAQRBrIgIkAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABrUIAIAFnIgFB0QBqEE8gAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQAC8IDAgN/AX4jAEEgayICJAACQAJAIAFC////////////AIMiBUKAgICAgIDAv0B8IAVCgICAgICAwMC/f3xaDQAgAUIZiKchAwJAIABQIAFC////D4MiBUKAgIAIVCAFQoCAgAhRGw0AIANBgYCAgARqIQQMAgsgA0GAgICABGohBCAAIAVCgICACIWEQgBSDQEgBCADQQFxaiEEDAELAkAgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRGw0AIAFCGYinQf///wFxQYCAgP4HciEEDAELQYCAgPwHIQQgBUL///////+/v8AAVg0AQQAhBCAFQjCIpyIDQZH+AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBSADQf+Bf2oQTyACIAAgBUGB/wAgA2sQUCACQQhqKQMAIgVCGYinIQQCQCACKQMAIAIpAxAgAkEQakEIaikDAIRCAFKthCIAUCAFQv///w+DIgVCgICACFQgBUKAgIAIURsNACAEQQFqIQQMAQsgACAFQoCAgAiFhEIAUg0AIARBAXEgBGohBAsgAkEgaiQAIAQgAUIgiKdBgICAgHhxcr4LUAEBfyAAIAAoAgAiA0EBQSAgAkF/amdrdCICIAMgAkgbNgIMIAAgA0EBQSAgAUF/amdrdCICIAMgAkgbNgIIIABBGGpBABCEASAAQgA3AhALRQEBfyAAKAIAIQIgACABNgIAAkAgAkUNACACKAIEIQAgAkEANgIEAkAgAEUNACAAIAAoAgAoAgQRAAALIAIQhQEQhgELCwsAIABBABCEASAACwYAIAAQRwvPAQECfyMAQRBrIgYkACAFIANrIQUgBCACayEHAkACQCAADQBBHBCIASIEIAU2AgggBCAHNgIEIARCADcCDCAEQeDxEDYCACAEQRRqQQA2AgAgBBCJAQwBC0GUARCIASIEIAU2AgggBCAHNgIEIARBxPEQNgIAIARBDGpBAEGIARA6GgtBEBCIASEFIAZBADYCCCAGQQA2AgwgBSADNgIMIAUgAjYCCCAFIAQ2AgQgBSABNgIAIAZBDGoQhQEaIAZBCGoQhQEaIAZBEGokACAFCzUBAX8gAEEBIABBAUsbIQECQANAIAEQRiIADQECQBDANiIARQ0AIAARCQAMAQsLEAAACyAAC2cBA39BACEBIABBADYCGCAAQQxqIQICQAJAIAAoAgwiAw0AIABBFGooAgAhAQwBCyADEEcgAEEUakEANgIAIABCADcCDAsgAhCLASAAKAIMIAFBDGxqIgFCADcCACABIAAoAgQ2AggLCwAgACgCABBHIAALfQEDfwJAAkACQCAAKAIIIgFBAWoiAkF/TA0AAkAgACgCBCACTg0AIAFBBWoiAUECdiABaiIBQX9MDQIgACABNgIEIAAoAgAgAUEMbCIDEEghAQJAIANFDQAgAUUNBAsgACABNgIACyAAIAI2AggPCxCMAQALEI0BAAsQAAALLwEBfyMAQRBrIgAkACAAQaHnEDYCCCAAQZcDNgIEIABBlMwQNgIAIAAgABCOAQALLwEBfyMAQRBrIgAkACAAQb7nEDYCCCAAQawDNgIEIABBlMwQNgIAIAAgABCOAQALKQEBfyMAQRBrIgIkACACIAE2AgxBwJ4bQYXxECABEJkBGiACQRBqJAALegEDfwJAIAAoAgQiBCAEKAIEIgUgAUEBaiIGIAUgBkgbIAEgBSABShsgBCgCCCIBIAJBAWoiBSABIAVIGyACIAEgAkobIAMgBCgCACgCDBEGACICRQ0AIAMgAy8BACAALwEIajsBACADIAMvAQIgAC8BDGo7AQILIAILhQIBB39BACEEAkAgACgCBCIFIAFJDQAgACgCCCIGIAJJDQBBACEEIABBIEEBQQAgAkF/amdrdCIHQQIgB0ECShsiCEF/amdrQQN0aiIJQQxqIQcCQAJAIAlBEGoiCSgCAA0AIAAoAowBIgUgCGoiCiAGSg0CIAcgBTsBAiAHQQA7AQAgCSAINgIAIAAgCjYCjAEMAQsgBy4BACABaiAFTA0AQQAhBCAAKAKMASIFIAhqIgogBkoNASAHIAU7AQIgB0EAOwEAIAkgCDYCACAAIAo2AowBCyADIAcoAgA2AQAgByAHLwEAIAFqOwEAIAAgACgCkAEgAiABbGo2ApABQQEhBAsgBAsEACAACwcAIAAQhgELDwAgAEEMakEAQYgBEDoaCxcAIAAoApABsiAAKAIEsiAAKAIIspSVC54FARJ/QQAhBAJAAkAgACgCBCIFIAFJDQAgACgCCCIGIAJJDQBBACEHIABBFGooAgAiCEEAIAhBAEobIQkgAEEMaiEKIAZBAWohCyAFQQFqIQwgACgCDCENQX8hDkEAIQ8DQAJAIA8gCUcNAAJAIA5Bf0YNACAKEIsBIAooAgAgDkEMbCINaiIEQQxqIAQgCCAOa0EMbBByGiAEIAE2AgggBCALIAJqNgIEIAQgBzYCACAOQQFqIRADQCAQIAAoAhQiEU4NBSAKKAIAIhIgEEEMbGoiBCgCACITIBIgDWoiEigCCCASKAIAaiISTg0FIAQgEjYCACAEIAQoAgggEyASa2oiEjYCCCASQQBKDQUgACARQX9qIhI2AhQgBCAEQQxqIBIgEGtBDGwQchoMAAsAC0EAIQQgA0EANgEADAILAkAgDSAPQQxsaiIUKAIAIhUgAWogBUoNACAUKAIEIQQgASEQIA8hEgJAA0AgEEEBSA0BIAQgDSASQQxsaiITKAIEIhEgBCARShsiBCACaiAGSg0CIBJBAWohEiAQIBMoAghrIRAMAAsACwJAAkAgBCALTg0AIBQoAgghEAwBCyAEIAtHDQEgFCgCCCIQIAxODQELIBAhDCAVIQcgBCELIA8hDgsgD0EBaiEPDAALAAsgBA8LQQAhEANAIBAgEUF/aiINIBAgDUobIREgCigCACETAkADQCAQIgQgEUYNASAEQQFqIRAgEyAEQQxsaiISKAIEIBJBEGooAgBHDQALIBIgEigCCCATIBBBDGxqIhEoAghqNgIIIAAgDTYCFCARIBFBDGogDSAQa0EMbBByGiAAKAIUIREgBCEQDAELCyADIAs7AQIgAyAHOwEAIAAgACgCGCACIAFsajYCGEEBCw0AIABBDGoQigEaIAALEAAgAEEMahCKARogABCGAQsWACAAKAIYsiAAKAIEsiAAKAIIspSVCw8AIAAgASACQQFBAhCMLQswAEEAQQM2AoTWG0EAQQA2AojWGxCbAUEAQQAoAvDfGzYCiNYbQQBBhNYbNgLw3xsLrkQBAn9B7rwQQQJB/PEQQdj+EEEEQQVBABAEQd68EEECQYTyEEHY/hBBBkEHQQAQBEH9vBBBAkGM8hBB2P4QQQhBCUEAEARBz7wQQQJBlPIQQdj+EEEKQQtBABAEQYbFEEECQZzyEEHY/hBBDEENQQAQBEG/uRBBAkGk8hBB2P4QQQ5BD0EAEARBo9YQQQNBrPIQQciAEUEQQRFBABAEQam0EEEBQbjyEEHA/RBBEkETQQAQBEGwuhBBBkHA8hBB2PIQQRRBFUEAEARBkNcQQQNB4PIQQciAEUEWQRdBABAEQfC9EEECQezyEEHY/hBBGEEZQQAQBEGV1htBl9YbQZjWG0EAQcD9EEEaQcP9EEEAQcP9EEEAQZPcEEHF/RBBGxAFQZXWG0EDQfTyEEGA8xBBHEEdEAZBkbcQQR4QtwFBzLUQQR8QtwFBqdcbQZnWG0Ga1htBAEHA/RBBIEHD/RBBAEHD/RBBAEGN3BBBxf0QQSEQBUGp1xtBAUGU8xBBwP0QQSJBIxAGQanXG0HRtRBBieAbQZDzEEEkQSVBABC/AUGJ4BtBxIMRQSZBJ0EAEMIBEAhBqdcbQYO0EEGJ4BtBkPMQQSRBKEEAEL8BQYngG0HEgxFBJkEpQQAQwgEQCEGp1xtBzrUQQYngG0GQ8xBBJEEqQQAQvwFBieAbQcSDEUEmQStBABDCARAIQanXG0GAtBBBieAbQZDzEEEkQSxBABC/AUGJ4BtBxIMRQSZBLUEAEMIBEAhBqdcbQdm1EEGJ4BtBkPMQQSRBLkEAEL8BQYngG0HEgxFBJkEvQQAQwgEQCEGp1xtBoLQQQYngG0GQ8xBBJEEwQQAQvwFBieAbQcSDEUEmQTFBABDCARAIQQQQiAEiAEEyNgIAQanXG0HytxBBA0GY8xBByIARQTMgAEEAQQAQB0EEEIgBIgBBNDYCAEGp1xtB8bQQQQRBsPMQQYD+EEE1IABBAEEAEAdBm9YbQZLWG0Gc1htBAEHA/RBBNkHD/RBBAEHD/RBBAEGB0RBBxf0QQTcQBUEEEIgBIgBBODYCAEGb1htB8tMQQQJBwPMQQdj+EEE5IABBAEEAEAdBBBCIASIAQTo2AgBBm9YbQcnQEEEDQcjzEEHIgBFBOyAAQQBBABAHQQQQiAEiAEE8NgIAQZvWG0HmthBBA0HU8xBByIARQT0gAEEAQQAQB0GQuRBBPkEAENoBQeG4EEE/QQAQ2gFBBBCIASIAQcAANgIAQZvWG0GZthBBA0Ho8xBByIARQcEAIABBAEEAEAdBBBCIASIAQcIANgIAQZvWG0GX0BBBA0H08xBByIARQcMAIABBAEEAEAdBBBCIASIAQcQANgIAQZvWG0GkyRBBA0GA9BBByIARQcUAIABBAEEAEAdBoNYbQZHWG0Gh1htBAEHA/RBBxgBBw/0QQQBBw/0QQQBBnMAQQcX9EEHHABAFQQgQiAEiAEEANgIEIABByAA2AgBBoNYbQfzNEEECQYz0EEHQ/RBByQAgAEEAQQAQB0Gi1htBkNYbQaPWG0EAQcD9EEHKAEHD/RBBAEHD/RBBAEHiwBBBxf0QQcsAEAVBCBCIASIAQQA2AgQgAEHMADYCAEGi1htB/M0QQQJBlPQQQdD9EEHNACAAQQBBABAHQaTWG0Gf1htBpdYbQQBBwP0QQc4AQcP9EEEAQcP9EEEAQYHPEEHF/RBBzwAQBUGm1htBndYbQafWG0Gk1htBwP0QQdAAQcD9EEHRAEHA/RBB0gBB+dMQQcX9EEHTABAFQabWG0GC0BBBi+AbQdj+EEHUAEHVAEEAEPIBQQBBAEEAQQAQCEEEEIgBIgBB1gA2AgBBptYbQbnSEEEDQZz0EEGo9BBB1wAgAEEAQQAQB0EEEIgBIgBB2AA2AgBBptYbQZe3EEEDQbD0EEHg/RBB2QAgAEEAQQAQB0EEEIgBIgBB2gA2AgBBptYbQYq6EEEDQbz0EEHIgBFB2wAgAEEAQQAQB0EEEIgBIgBB3AA2AgBBptYbQfrREEEDQcj0EEHIgBFB3QAgAEEAQQAQB0EEEIgBIgBB3gA2AgBBptYbQfrFEEEDQdT0EEHIgBFB3wAgAEEAQQAQB0EEEIgBIgBB4AA2AgBBptYbQcjPEEEDQeD0EEHIgBFB4QAgAEEAQQAQB0EEEIgBIgBB4gA2AgBBptYbQc3PEEEDQez0EEHIgBFB4wAgAEEAQQAQB0EEEIgBIgBB5AA2AgBBptYbQYi2EEEDQfj0EEHIgBFB5QAgAEEAQQAQB0EEEIgBIgBB5gA2AgBBptYbQYfQEEEDQYT1EEHIgBFB5wAgAEEAQQAQB0HSuBBB6AAQhgJBBBCIASIAQekANgIAQabWG0GqthBBA0GY9RBByIARQeoAIABBAEEAEAdBBBCIASIAQesANgIAQabWG0Gn0BBBA0Gk9RBByIARQewAIABBAEEAEAdB8LgQQe0AEIYCQcC4EEHuABCGAkEEEIgBIgBB7wA2AgBBptYbQfS1EEEDQbD1EEHIgBFB8AAgAEEAQQAQB0GiuBBB8QAQhgJBBBCIASIAQfIANgIAQabWG0HntRBBA0G89RBByIARQfMAIABBAEEAEAdBBBCIASIAQfQANgIAQabWG0GyyxBBBEHQ9RBB4PUQQfUAIABBAEEAEAdBBBCIASIAQfYANgIAQabWG0GnyxBBBEHw9RBB4PUQQfcAIABBAEEAEAdBBBCIASIAQfgANgIAQabWG0GUzhBBAkGA9hBB0P0QQfkAIABBAEEAEAdBBBCIASIAQfoANgIAQabWG0Hy0hBBA0GI9hBB4P0QQfsAIABBAEEAEAdBBBCIASIAQfwANgIAQabWG0GnvxBBrtcbQdj+EEH9ACAAQQBBAEEAQQAQCEGm1htBjssQQYngG0GQ8xBB/gBB/wBBABCeAkGJ4BtBxIMRQYABQYEBQQAQoQIQCEGm1htB4LsQQYngG0GQ8xBB/gBBggFBABCeAkGJ4BtBxIMRQYABQYMBQQAQoQIQCEEIEIgBIgBBADYCBCAAQYQBNgIAQQgQiAEiAUEANgIEIAFBhQE2AgBBptYbQZ/HEEH93xtB2P4QQYYBIABB/d8bQeD9EEGHASABEAhBBBCIASIAQYgBNgIAQabWG0HyxBBB/d8bQdj+EEGJASAAQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQYoBNgIAQQgQiAEiAUEANgIEIAFBiwE2AgBBptYbQezPEEGJ4BtBkPMQQYwBIABBieAbQcSDEUGNASABEAhBsdYbQajWG0Gy1htBAEHA/RBBjgFBw/0QQQBBw/0QQQBBnboQQcX9EEGPARAFQbHWG0G11xBBieAbQZDzEEGQAUGRAUEAELICQYngG0HEgxFBkgFBkwFBABC1AhAIQbHWG0GJ1xBBieAbQZDzEEGQAUGUAUEAELICQYngG0HEgxFBkgFBlQFBABC1AhAIQbHWG0HAxhBBieAbQZDzEEGQAUGWAUEAELICQYngG0HEgxFBkgFBlwFBABC1AhAIQQQQiAEiAEGYATYCAEGx1htBssgQQQJBlPYQQdj+EEGZASAAQQBBABAHQQQQiAEiAEGaATYCAEGx1htBwcgQQQNBnPYQQeD9EEGbASAAQQBBABAHQbPWG0Gp1htBtNYbQbHWG0HA/RBBnAFBwP0QQZ0BQcD9EEGeAUGG0hBBxf0QQZ8BEAVBs9YbQZG3EEGJ4BtBkPMQQaABQegAQQEQwwJBieAbQcSDEUGhAUGiAUEAEMYCEAhBs9YbQcy1EEGJ4BtBkPMQQaABQewAQQEQwwJBieAbQcSDEUGhAUGjAUEAEMYCEAhBtdYbQarWG0G21htBAEHA/RBBpAFBw/0QQQBBw/0QQQBBgsYQQcX9EEGlARAFQbXWG0GC0BBBi+AbQdj+EEGmAUHVAEEAEPIBQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQacBNgIAQQgQiAEiAUEANgIEIAFBqAE2AgBBtdYbQbK3EEGL4BtB2P4QQakBIABBi+AbQeD9EEGqASABEAhBt9YbQavWG0G41htBsdYbQcD9EEGrAUHA/RBBrAFBwP0QQa0BQdrPEEHF/RBBrgEQBUEIEIgBIgBBADYCBCAAQa8BNgIAQQgQiAEiAUEANgIEIAFBsAE2AgBBt9YbQfzKEEGJ4BtBkPMQQbEBIABBieAbQcSDEUGyASABEAhBudYbQazWG0G61htBt9YbQcD9EEGzAUHA/RBBtAFBwP0QQbUBQdbPEEHF/RBBtgEQBUG51htBkbcQQYngG0GQ8xBBtwFB6ABBARDDAkGJ4BtBxIMRQbgBQbkBQQAQ3gIQCEG51htBzLUQQYngG0GQ8xBBtwFB7ABBARDDAkGJ4BtBxIMRQbgBQboBQQAQ3gIQCEG71htBvNYbQb3WG0EAQcD9EEG7AUHD/RBBAEHD/RBBAEHjxhBBxf0QQbwBEAVBu9YbQYLQEEGL4BtB2P4QQb0BQb4BQQAQ5AJBAEEAQQBBABAIQb7WG0Gt1htBv9YbQbvWG0HA/RBBvwFBwP0QQcABQcD9EEHBAUHdxhBBxf0QQcIBEAVBvtYbQYLQEEGL4BtB2P4QQcMBQb4BQQAQ5AJBAEEAQQBBABAIQb7WG0HUxhBBhOAbQdj+EEHEAUHFAUEAEOwCQQBBAEEAQQAQCEG+1htB/b0QQYTgG0HY/hBBxAFBxgFBABDsAkEAQQBBAEEAEAhBvtYbQfm3EEGE4BtB2P4QQcQBQccBQQAQ7AJBAEEAQQBBABAIQb7WG0Gi1BBBhOAbQdj+EEHEAUHIAUEAEOwCQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQckBNgIAQb7WG0Hn1hBB/d8bQdj+EEHKASAAQQBBAEEAQQAQCEG+1htBws4QQYTgG0HY/hBBxAFBywFBABDsAkEAQQBBAEEAEAhBCBCIASIAQQA2AgQgAEHMATYCAEG+1htBkdYQQYngG0GQ8xBBzQEgAEEAQQBBAEEAEAhBCBCIASIAQQA2AgQgAEHOATYCAEG+1htB27QQQQVBsPYQQcT2EEHPASAAQQBBABAHQcDWG0HB1htBwtYbQQBBwP0QQdABQcP9EEEAQcP9EEEAQdrSEEHF/RBB0QEQBUHA1htBA0HM9hBByIARQdIBQdMBEAZBCBCIASIAQQA2AgQgAEHUATYCAEEIEIgBIgFBADYCBCABQdUBNgIAQcDWG0HzzxBBieAbQZDzEEHWASAAQYngG0HEgxFB1wEgARAIQQgQiAEiAEEANgIEIABB2AE2AgBBwNYbQabDEEH93xtB2P4QQdkBIABBAEEAQQBBABAIQQgQiAEiAEEANgIEIABB2gE2AgBBwNYbQbnSEEEDQdj2EEHk9hBB2wEgAEEAQQAQB0EIEIgBIgBBADYCBCAAQdwBNgIAQcDWG0HbtBBBA0Hs9hBBxIMRQd0BIABBAEEAEAdBw9YbQa7WG0HE1htBu9YbQcD9EEHeAUHA/RBB3wFBwP0QQeABQd/PEEHF/RBB4QEQBUHF1htBlNYbQcbWG0EAQcD9EEHiAUHD/RBBAEHD/RBBAEG5tBBBxf0QQeMBEAVBCBCIASIAQqiAgIAQNwMAQcXWG0GGxRBBA0H49hBByIARQeQBIABBAEEAEAdBCBCIASIAQqCAgIAQNwMAQcXWG0Hu0RBBA0GE9xBByIARQeUBIABBAEEAEAdBCBCIASIAQqSAgIAQNwMAQcXWG0G/uRBBA0GQ9xBByIARQeYBIABBAEEAEAdByNYbQcvWG0HM1htBAEHA/RBB5wFBw/0QQQBBw/0QQQBBz8cQQcX9EEHoARAFQc3WG0GM1htBztYbQQBBwP0QQekBQcP9EEEAQcP9EEEAQfO8EEHF/RBB6gEQBUEIEIgBIgBBADYCBCAAQesBNgIAQc3WG0GC0BBBi+AbQdj+EEHsASAAQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQe0BNgIAQc3WG0HlyBBBi+AbQdj+EEHuASAAQQBBAEEAQQAQCEHN1htB98YQQYvgG0HY/hBB7wFBxABBARCXA0EAQQBBAEEAEAhBzdYbQfjPEEGL4BtB2P4QQe8BQfABQQAQlwNBAEEAQQBBABAIQc3WG0HqxBBB/d8bQdj+EEHxAUHyARCbA0EAQQBBAEEAEAhBzdYbQbjREEH93xtB2P4QQfEBQfMBEJsDQQBBAEEAQQAQCEHN1htBuLkQQf3fG0HY/hBB8QFB9AEQmwNBAEEAQQBBABAIQQQQiAEiAEH1ATYCAEHN1htBz9QQQYvgG0HY/hBB9gEgAEEAQQBBAEEAEAhBBBCIASIAQfcBNgIAQc3WG0H/0RBBA0Hc9xBB4P0QQfgBIABBAEEAEAdBz9YbQY7WG0HQ1htBzdYbQcD9EEH5AUHA/RBB+gFBwP0QQfsBQYK9EEHF/RBB/AEQBUEEEIgBIgBB/QE2AgBBz9YbQcDREEEDQej3EEHg/RBB/gEgAEEAQQAQB0HR1htBjdYbQdLWG0HN1htBwP0QQf8BQcD9EEGAAkHA/RBBgQJB47wQQcX9EEGCAhAFQQQQiAEiAEGDAjYCAEHR1htBn9IQQQNB9PcQQeD9EEGEAiAAQQBBABAHQdPWG0GP1htB1NYbQc3WG0HA/RBBhQJBwP0QQYYCQcD9EEGHAkHUvBBBxf0QQYgCEAVBBBCIASIAQYkCNgIAQdPWG0GwuRBBA0GA+BBB4P0QQYoCIABBAEEAEAdB1dYbQZbWG0HW1htBAEHA/RBBiwJBw/0QQQBBw/0QQQBBrtMQQcX9EEGMAhAFQdXWG0EDQYz4EEHIgBFBjQJBjgIQBkEEEIgBIgBBjwI2AgBB1dYbQbnSEEEDQZj4EEHk9hBBkAIgAEEAQQAQB0EEEIgBIgBBkQI2AgBB1dYbQeG0EEEDQaT4EEGo9BBBkgIgAEEAQQAQB0GXuBBBNEEBELwDQQgQiAEiAEK4gICAEDcDAEHV1htBvLcQQQNBuPgQQciAEUGTAiAAQQBBABAHQeDFEEGUAhC/A0GmzhBBlQIQvwNBwMMQQZYCEL8DQa24EEGXAkEAELwDQQQQiAEiAEGYAjYCAEHV1htByb0QQQNB6PgQQciAEUGZAiAAQQBBABAHQZ65EEGaAkEAELwDQQQQiAEiAEGbAjYCAEHV1htBvrYQQQNB9PgQQciAEUGcAiAAQQBBABAHQQQQiAEiAEGdAjYCAEHV1htB8tIQQQNBgPkQQeD9EEGeAiAAQQBBABAHQdfWG0Gv1htB2NYbQQBBwP0QQZ8CQcP9EEEAQcP9EEEAQcK3EEHF/RBBoAIQBUEIEIgBIgBBADYCBCAAQaECNgIAQdfWG0GwzxBBguAbQdj+EEGiAiAAQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQaMCNgIAQdfWG0GC0BBBi+AbQdj+EEGkAiAAQQBBAEEAQQAQCEHX1htB8MgQQYLgG0H08RBBwP0QQaUCQQBBABANQdfWG0G5whBBguAbQfbxEEHA/RBBpQJBAEEAEA1B19YbQZTBEEGC4BtB+PEQQcD9EEGlAkEAQQAQDUEEEIgBIgBBpgI2AgBB19YbQfXIEEECQYz5EEHY/hBBpwIgAEEAQQAQB0EEEIgBIgBBqAI2AgBB19YbQcDCEEECQZT5EEHY/hBBqQIgAEEAQQAQB0EEEIgBIgBBqgI2AgBB19YbQZzBEEECQZz5EEHY/hBBqwIgAEEAQQAQB0Hc1htB2dYbQd3WG0HX1htBwP0QQawCQcD9EEGtAkHA/RBBrgJB/MgQQcX9EEGvAhAFQQgQiAEiAEEANgIEIABBsAI2AgBBCBCIASIBQQA2AgQgAUGxAjYCAEHc1htBvM4QQf3fG0HY/hBBsgIgAEH93xtB4P0QQbMCIAEQCEHe1htB2tYbQd/WG0HX1htBwP0QQbQCQcD9EEG1AkHA/RBBtgJB4cIQQcX9EEG3AhAFQQgQiAEiAEEANgIEIABBuAI2AgBBCBCIASIBQQA2AgQgAUG5AjYCAEHe1htBvM4QQYngG0GQ8xBBugIgAEGJ4BtBxIMRQbsCIAEQCEHg1htB29YbQeHWG0HX1htBwP0QQbwCQcD9EEG9AkHA/RBBvgJBv8EQQcX9EEG/AhAFQQgQiAEiAEEANgIEIABBwAI2AgBB4NYbQaTPEEECQaT5EEHQ/RBBwQIgAEEAQQAQB0Gs1xtB3LsQQQFBABAOQazXG0GJyRBBABAPQazXG0GrxxBBARAPQazXG0HhvxBBAhAPQazXG0GeyxBBAxAPQazXG0HyuxBBBBAPQazXG0HDzxBBBRAPQazXG0HsxRBBBhAPQazXG0HLtxBBBxAPQa3XG0G3uhBBAUEAEA5BrdcbQby8EEEAEA9BrdcbQfa/EEEBEA9BrdcbQYi8EEECEA9BrdcbQbG8EEEDEA9BrdcbQe+/EEEEEA9BrdcbQfy7EEEFEA9BrdcbQcS8EEEGEA9BrdcbQYDAEEEHEA9BrdcbQZG8EEEIEA9BrtcbQZ7cEEGs+RBBwgJBxf0QQcMCEBBBsNcQQQAQ7wNBhNcQQQQQ7wNBq9cQQQgQ7wNB/9YQQQwQ7wNBrtcbEBJB4tYbQePWG0Hk1htBAEHA/RBBxAJBw/0QQQBBw/0QQQBBz78QQcX9EEHFAhAFQeLWG0ECQbD5EEHY/hBBxgJBxwIQBkEIEIgBIgBBADYCBCAAQcgCNgIAQeLWG0GNvRBBBEHA+RBBgP4QQckCIABBAEEAEAdBCBCIASIAQQA2AgQgAEHKAjYCAEHi1htBpb0QQQRB0PkQQeD1EEHLAiAAQQBBABAHQZTLEEHMAkEAEPkDQee7EEHNAkEAEPkDQeXWG0GT1htB5tYbQQBBwP0QQc4CQcP9EEEAQcP9EEEAQY3CEEHF/RBBzwIQBUEIEIgBIgBBATYCBCAAQQg2AgBB59YbQdm9EEEFQfD5EEGE+hBB0AIgAEEBQQAQB0Hn1htB6NYbQenWG0Hl1htBwP0QQdECQcD9EEHSAkHA/RBB0wJBy8AQQcX9EEHUAhAFQQQQiAEiAEHVAjYCAEHn1htBrMYQQQJBjPoQQdD9EEHWAiAAQQBBABAHQeXWG0HBuhBBAkGU+hBB2P4QQdcCQdgCQQAQE0Hl1htBm9QQQQNBvIARQciAEUHZAkHaAkEAEBNB9NYbQZ7WG0H11htBAEHA/RBB2wJBw/0QQQBBw/0QQQBBs8kQQcX9EEHcAhAFQfTWG0GJuBBBhuAbQdj+EEHdAkHeAkEAEIwEQQBBAEEAQQAQCEEIEIgBIgBBADYCBCAAQd8CNgIAQfTWG0GC0BBBi+AbQdj+EEHgAiAAQQBBAEEAQQAQCEH01htBgrkQQYbgG0HY/hBB3QJB4QJBABCMBEEAQQBBAEEAEAhBBBCIASIAQeICNgIAQfTWG0HWthBBA0HQ+hBByIARQeMCIABBAEEAEAdBBBCIASIAQeQCNgIAQfTWG0G60BBBA0Hc+hBByIARQeUCIABBAEEAEAdBjL8QQeYCEJUEQfC+EEHnAhCVBEHK0hBB6AIQmARBwdIQQekCEJgEQYDXG0Gw1htBgdcbQQBBwP0QQeoCQcP9EEEAQcP9EEEAQY3TEEHF/RBB6wIQBUEIEIgBIgBBADYCBCAAQewCNgIAQYDXG0GJuBBBhuAbQdj+EEHtAiAAQQBBAEEAQQAQCEEEEIgBIgBB7gI2AgBBgNcbQbnCEEEDQYD7EEHIgBFB7wIgAEEAQQAQB0EEEIgBIgBB8AI2AgBBgNcbQZrNEEEDQYz7EEHIgBFB8QIgAEEAQQAQB0EEEIgBIgBB8gI2AgBBgNcbQd7HEEEDQZj7EEHIgBFB8wIgAEEAQQAQB0EEEIgBIgBB9AI2AgBBgNcbQbK/EEEDQaT7EEHIgBFB9QIgAEEAQQAQB0EEEIgBIgBB9gI2AgBBgNcbQY3IEEEDQbD7EEHIgBFB9wIgAEEAQQAQB0EEEIgBIgBB+AI2AgBBgNcbQZTBEEEDQbz7EEHIgBFB+QIgAEEAQQAQB0EEEIgBIgBB+gI2AgBBgNcbQZrJEEEDQcj7EEHIgBFB+wIgAEEAQQAQB0EEEIgBIgBB/AI2AgBBgNcbQYy/EEECQdT7EEHY/hBB/QIgAEEAQQAQB0EEEIgBIgBB/gI2AgBBgNcbQZ/TEEECQdz7EEHQ/RBB/wIgAEEAQQAQB0EEEIgBIgBBgAM2AgBBgNcbQYa0EEEDQeT7EEHIgBFBgQMgAEEAQQAQB0GJ1xtBiNcbQYrXG0EAQcD9EEGCA0HD/RBBAEHD/RBBAEHMzhBBxf0QQYMDEAVBCBCIASIAQQA2AgQgAEGEAzYCAEGJ1xtBhtYQQf3fG0HY/hBBhQMgAEEAQQBBAEEAEAhBBBCIASIAQYYDNgIAQYnXG0GavxBBAkHw+xBB0P0QQYcDIABBAEEAEAdBi9cbQYLXG0GM1xtBidcbQcD9EEGIA0HA/RBBiQNBwP0QQYoDQcnCEEHF/RBBiwMQBUEIEIgBIgBBADYCBCAAQYwDNgIAQQgQiAEiAUEANgIEIAFBjQM2AgBBi9cbQbzOEEGJ4BtBkPMQQY4DIABBieAbQcSDEUGPAyABEAhBjdcbQYTXG0GO1xtBidcbQcD9EEGQA0HA/RBBkQNBwP0QQZIDQebHEEHF/RBBkwMQBUEIEIgBIgBBADYCBCAAQZQDNgIAQQgQiAEiAUEANgIEIAFBlQM2AgBBjdcbQbzOEEH93xtB2P4QQZYDIABB/d8bQeD9EEGXAyABEAhBj9cbQYXXG0GQ1xtBidcbQcD9EEGYA0HA/RBBmQNBwP0QQZoDQbi/EEHF/RBBmwMQBUEIEIgBIgBBADYCBCAAQZwDNgIAQQgQiAEiAUEANgIEIAFBnQM2AgBBj9cbQbzOEEGD4BtB2P4QQZ4DIABBg+AbQeD9EEGfAyABEAhBBBCIASIAQaADNgIAQY/XG0G/1hBBBUGA/BBBlPwQQaEDIABBAEEAEAdBBBCIASIAQaIDNgIAQY/XG0G+1hBBBkGg/BBBuPwQQaMDIABBAEEAEAdBBBCIASIAQaQDNgIAQY/XG0Hh1hBBA0HA/BBB4P0QQaUDIABBAEEAEAdBkdcbQYPXG0GS1xtBidcbQcD9EEGmA0HA/RBBpwNBwP0QQagDQaHNEEHF/RBBqQMQBUEIEIgBIgBBADYCBCAAQaoDNgIAQQgQiAEiAUEANgIEIAFBqwM2AgBBkdcbQbzOEEGL4BtB2P4QQawDIABBi+AbQeD9EEGtAyABEAhBk9cbQYfXG0GU1xtBidcbQcD9EEGuA0HA/RBBrwNBwP0QQbADQabBEEHF/RBBsQMQBUEEEIgBIgBBsgM2AgBBk9cbQZTBEEECQcz8EEHQ/RBBswMgAEEAQQAQB0GV1xtBhtcbQZbXG0GJ1xtBwP0QQbQDQcD9EEG1A0HA/RBBtgNBksgQQcX9EEG3AxAFQQgQiAEiAEEANgIEIABBuAM2AgBBCBCIASIBQQA2AgQgAUG5AzYCAEGV1xtBvM4QQYvgG0HY/hBBugMgAEGL4BtB4P0QQbsDIAEQCEEEEIgBIgBBvAM2AgBBldcbQem+EEGQ4BtB2P4QQb0DIABBAEEAQQBBABAICwkAIAEgABEBAAsEACAACwkAIAEgABEBAAsEACAACwkAIAEgABEBAAsEACAACwkAIAEgABEBAAsEACAACzABAX8jAEEQayICJAAgAiABNgIMIAJBDGogABEBACEBIAIoAgwQAiACQRBqJAAgAQviAQEDfyMAQTBrIgEkACABQQA2AiwgAUIANwIkIAFBIGogACgCABDuBCABKAIgIgIQ7wQhAyACEAIgAUEkaiADEPAEIAFBIGogAyABKAIkIgIQ8QQiAygCAEGPvRAgABDyBEEEEIgBIQAgASACNgIUIAEgASgCKCACazYCGEEAKAKg1xsoAighAiABIAEpAhQ3AwggAUEcakGg1xsgAUEIaiACEQUAIABBADYCACABKAIcIQIgAUEANgIcIAAgAhDzBCABKAIcEPQEIAMoAgAQAiABQSRqEPUEGiABQTBqJAAgAAswAQF/IwBBEGsiAiQAIAIgATYCDCACQQxqIAARAQAhASACKAIMEAIgAkEQaiQAIAEL4gEBA38jAEEwayIBJAAgAUEANgIsIAFCADcCJCABQSBqIAAoAgAQ7gQgASgCICICEO8EIQMgAhACIAFBJGogAxDwBCABQSBqIAMgASgCJCICEPEEIgMoAgBBj70QIAAQ8gRBBBCIASEAIAEgAjYCFCABIAEoAiggAms2AhhBACgCoNcbKAIkIQIgASABKQIUNwMIIAFBHGpBoNcbIAFBCGogAhEFACAAQQA2AgAgASgCHCECIAFBADYCHCAAIAIQ9gQgASgCHBD3BCADKAIAEAIgAUEkahD1BBogAUEwaiQAIAALMgEBfyMAQRBrIgMkACADIAE2AgwgA0EMaiACIAARAgAhASADKAIMEAIgA0EQaiQAIAELuCcDE38CfQF+IwBBsAFrIgIkACACQQA2AkggAkIANwJAIAJBgAFqIAAoAgAQ7gQgAigCgAEiAxDvBCEEIAMQAiACQcAAaiAEEPAEIAJBPGogBCACKAJAIgMQ8QQiBSgCAEGPvRAgABDyBCACKAJEIQYgAkEAOwF4IAIgAzYCdCACIAYgA2s2AnAgAiADNgJsIAJB4ABqQgA3AgAgAkHoAGpBgICA/AM2AgAgAkIANwJYIAJB2ABqIQdBACEAAkACQAJAA0AgAEEERg0BAkACQCAGIANrQQBKDQAgAiAGNgJ0IAJBAToAeEEAIQQgBiEDDAELIAIgA0EBaiIINgJ0IAMtAAAhBCAIIQMLIABB4tsQaiEIIABBAWohACAILAAAIARB/wFxRg0ADAILAAsgAiACQewAahD4BDYCTCACLQB4DQAgAiACQewAahD4BDYCUCACLQB4DQAgAiACQewAahD4BDYCVCACLQB4DQAgAkEANgKsASACQgA3AqQBIAJBrAFqIQggAkHsAGoQ+AQhAAJAAkADQCAARQ0BAkACQCACKAKoASIDIAIoAqwBRg0AIAMgADYCACACIANBBGo2AqgBDAELIAJBgAFqIAIoAqQBIgQgAyADIARrQQJ1QQFqEPkEIAIoAqgBIAIoAqQBa0ECdSAIEPoEIQMgAigCiAEiBCAANgIAIAIgBEEEajYCiAEgAkGkAWogAxD7BCADEPwEGgsgAi0AeA0CIAJB7ABqEPgEIQAMAAsACyACQeAAaiEJIAIoAqgBIQogAigCpAEhC0EAIQxBCCENAkACQANAAkACQAJAAkACQAJAIAsgCkYiDg0AIAsoAgAhBgJAIA1BCEcNAAJAAkAgAigCbCACKAJwaiIAIAIoAnQiA2tBA0sNACACQQE6AHhBACEMDAELIANBBGohACADKAAAIQwLIAIgADYCdEEAIQ0LAkAgAigCXCIERQ0AAkACQCAEaUEBSyIPDQAgBEF/aiAGcSEIDAELIAYhCCAGIARJDQAgBiAEcCEICyACKAJYIAhBAnRqKAIAIgNFDQAgBEF/aiEQA0AgAygCACIDRQ0BAkAgAygCBCIAIAZGDQACQAJAIA8NACAAIBBxIQAMAQsgACAESQ0AIAAgBHAhAAsgACAIRw0CCyADKAIIIAZHDQAMBwsAC0EQEIgBIgMgBjYCCCADIAY2AgQgA0EANgIAIANBDGpBADYCACACKgJoIRUgAigCZEEBarMhFgJAIARFDQAgFSAEs5QgFl1FDQULIARBAXQgBEEDSSAEIARBf2pxQQBHcnIhAAJAAkAgFiAVlY0iFUMAAIBPXSAVQwAAAABgcUUNACAVqSEPDAELQQAhDwtBAiEIAkAgACAPIAAgD0sbIgBBAUYNAAJAIAAgAEF/anENACAAIQgMAQsgABD9BCEIIAIoAlwhBAsCQCAIIARLDQAgCCAETw0EIARBA0khDwJAAkAgAigCZLMgAioCaJWNIhVDAACAT10gFUMAAAAAYHFFDQAgFakhAAwBC0EAIQALAkACQCAPDQAgBGlBAUsNACAAQQFBICAAQX9qZ2t0IABBAkkbIQAMAQsgABD9BCEACwJAIAggACAIIABLGyIIIARJDQAgAigCXCEEDAULIAhFDQILIAhBgICAgARPDQggByAIQQJ0EIgBEP4EIAIgCDYCXEEAIQACQANAAkAgACAIRw0AIAIoAmAiEA0CDAULIAIoAlggAEECdGpBADYCACAAQQFqIQAMAAsACyAQKAIEIRECQAJAIAhpQQFLIhINACARIAhBf2pxIREMAQsgESAISQ0AIBEgCHAhEQsgAigCWCARQQJ0aiAJNgIAIAhBf2ohEwNAIBAoAgAiBEUNAyAEKAIEIQACQAJAIBINACAAIBNxIQAMAQsgACAISQ0AIAAgCHAhAAsCQCAAIBFGDQACQCACKAJYIABBAnQiD2oiFCgCAA0AIBQgEDYCACAAIREMAQsgECAEKAIANgIAIAQgAigCWCAPaigCACgCADYCACACKAJYIA9qKAIAIAQ2AgAMAQsgBCEQDAALAAsgAkGkAWoQ/wQaDAYLQQAhBCAHQQAQ/gQgAkEANgJcDAELIAghBAsCQCAEIARBf2oiAHENACAAIAZxIQgMAQsCQCAGIARPDQAgBiEIDAELIAYgBHAhCAsCQAJAAkAgAigCWCAIQQJ0aiIIKAIAIgANACADIAIoAmA2AgAgAiADNgJgIAggCTYCACADKAIAIgBFDQIgACgCBCEAAkACQCAEIARBf2oiCHENACAAIAhxIQAMAQsgACAESQ0AIAAgBHAhAAsgAigCWCAAQQJ0aiEADAELIAMgACgCADYCAAsgACADNgIACyACIAIoAmRBAWo2AmQLIANBDGogDCANdUEDcTYCAAJAIAItAHgNACALQQRqIQsgDUECaiENDAELCyACQaQBahD/BBogDkUNAwsCQCACKAJMIgBBB0YNACACIAA2AiAgAiACKAJQNgIkIAJCBzcDKCAAQdTtECACQSBqEIAFIAJBADYCfAwEC0E8EIgBIhJBBGpBAEEwEDohDSASIAE2AjggEkGg1xs2AjQgAiASNgJ8IAJBgAFqQQhqQgA3AwAgAkGAAWpBGGpCADcDACACQgA3A4ABIAJCgICA/AM3A5ABA0AgAi0AeSEDIAItAHghAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAnQgAigCbCACKAJwakYNACAAQf8BcQ0AIANB/wFxDQAgAkHsAGoQ+AQQgQUhEQJAA0AgAkHsAGoQggUiBEUNASACLQB4IAItAHlyDRkCQCARRQ0AIBEgBCACQewAaiARKAIAKAIQEQQADQELAkACQCAEQXxqIgBB2gVLDQAgAEECdEGUrRJqKAIAIgBBf0cNAQsCQCACKAJcIg9FDQACQAJAIA9pQQFLIgYNACAPQX9qIARxIQgMAQsgBCEIIA8gBEsNACAEIA9wIQgLIAIoAlggCEECdGooAgAiAEUNACAPQX9qIRADQCAAKAIAIgBFDQECQCAAKAIEIgMgBEYNAAJAAkAgBg0AIAMgEHEhAwwBCyADIA9JDQAgAyAPcCEDCyADIAhGDQEMAgsgACgCCCAERw0ACyAAQQxqKAIAIgBBf0cNAQsgAiAENgIQIABBgPAQIAJBEGoQgAUMGgsCQAJAAkACQCAADgQAAQIDBAsgAkHsAGoQgwUaDAMLIAJBpAFqIAJB7ABqEIQFIAJBpAFqEIUFGgwCCwJAAkAgAigCbCACKAJwaiIAIAIoAnQiA2tBA0sNACACQQE6AHgMAQsgA0EEaiEACyACIAA2AnQMAQsCQAJAIAIoAmwgAigCcGoiACACKAJ0IgNrQQNLDQAgAkEBOgB4DAELIANBBGohAAsgAiAANgJ0DAALAAsgEUUNGCARIQQCQCARQb4DIBEoAgAoAgwRAgBFDQACQCAUDQBBACEEDAELIBEgFDYCHCAUIQQLIBEgAkGAAWogESgCACgCJBECACEDIBEgESgCACgCCBEBACEAAkACQAJAIAMNAAJAAkACQAJAIABBzXxqDgUBBgYCAwALAkAgAEEBRg0AIABB/gNGDQIgAEHpAEYNBSAAQY0BRg0FIABBlgNGDQUgAEEXRw0GIBIgETYCAAwGCyARIBIoAjQ2AoALAkAgEigCFCIAIBIoAhhGDQAgACARNgIAIBIgAEEEajYCFAwGCyAAIBIoAhAiCGsiA0ECdSIQQQFqIgZBgICAgARPDQcCQAJAIANBAXUiDyAGIA8gBksbQf////8DIANB/P///wdJGyIGDQBBACEPDAELIAZBgICAgARPDSEgBkECdBCIASEPCyAPIBBBAnRqIhAgETYCACAQIQMCQANAIAAgCEYNASADQXxqIgMgAEF8aiIAKAIANgIADAALAAsgEiAQQQRqNgIUIBIoAhAhACASIAM2AhAgEiAPIAZBAnRqNgIYIABFDQUgABCGAQwFCwJAIBIoAiAiACASKAIkRg0AIAAgETYCACASIABBBGo2AiAMBQsgACASKAIcIghrIgNBAnUiEEEBaiIGQYCAgIAETw0GAkACQCADQQF1Ig8gBiAPIAZLG0H/////AyADQfz///8HSRsiBg0AQQAhDwwBCyAGQYCAgIAETw0gIAZBAnQQiAEhDwsgDyAQQQJ0aiIQIBE2AgAgECEDAkADQCAAIAhGDQEgA0F8aiIDIABBfGoiACgCADYCAAwACwALIBIgEEEEajYCICASKAIcIQAgEiADNgIcIBIgDyAGQQJ0ajYCJCAARQ0EIAAQhgEMBAsCQCASKAIsIgAgEigCMEYNACAAIBE2AgAgEiAAQQRqNgIsDAQLIAAgEigCKCIIayIDQQJ1Ig9BAWoiBkGAgICABE8NBQJAAkAgA0EBdSIQIAYgECAGSxtB/////wMgA0H8////B0kbIgYNAEEAIRAMAQsgBkGAgICABE8NHyAGQQJ0EIgBIRALIBAgD0ECdGoiDyARNgIAIA8hAwJAA0AgACAIRg0BIANBfGoiAyAAQXxqIgAoAgA2AgAMAAsACyASIA9BBGo2AiwgEigCKCEAIBIgAzYCKCASIBAgBkECdGo2AjAgAEUNAyAAEIYBDAMLIBEoAhgiACASKAIsIBIoAigiA2tBAnVPDQIgESADIABBAnRqKAIANgIUDAILIAIgADYCACAAQYXsECACEIAFIBEgESgCACgCBBEAACAEIRQMGwsgDSAREIYFCyARIBEoAgAoAggRAQAiAEFHaiIDQRVLDQNBASADdCIIQfCBJHENBAJAIAhBgIKAAXENACADDQQgAigCgAEgAigChAEQhwUiAEUNFiAAKAIEIQBBDBCIASIDIAA2AgggAyARNgIEIANBkJcTNgIAQTkhAAwVC0EIEIgBIgMgETYCBCADQZSbEzYCAEHBACEADBQLIAAgA3JB/wFxDRQgAigCmAEhAAJAA0ACQCAAIAIoApQBRw0AQQAhBAwCCyAAQXxqIgAoAgAiAyADKAIAKAIIEQEAIgRFDQALCyACKAKMAUUNASACKAKIARCIBSACQQA2AogBIAIoAoQBIQNBACEAA0ACQCAAIANHDQAgAkEANgKMAQwDCyACKAKAASAAQQJ0akEANgIAIABBAWohAAwACwALEAAACyACIAIoApQBIgA2ApgBIARBAEdBAXQhAwwTC0EAIQMCQCAAQal8ag4MDw8PDw8REREREREOAAsCQCAAQWlqDgkCEQYHEREREQUACwJAIABBzXxqDgcLEQwEERENAAsCQCAAQY98ag4HDhEQERERDwALIABBAUYNAiAAQTVGDQcgAEHpAEYNCSAAQfIARg0IIABBjQFGDQkgAEGWA0YNCSAAQZAERw0QC0EIEIgBIgMgETYCBCADQeDWEjYCAEE8IQAMDwtBgAEQiAEiA0IANwIIIAMgETYCBCADQfz9ETYCACADQRBqQgA3AgAgA0EYakGAgID8AzYCACADQRxqQQBB5AAQOhpBFyEADA4LQQgQiAEiAyARNgIEIANBlP4RNgIAQQEhAAwNC0EIEIgBIgMgETYCBCADQYCGEjYCAEG2AyEADAwLQQgQiAEiAyARNgIEIANB9N4SNgIAQR8hAAwLC0EIEIgBIgMgETYCBCADQdDREjYCAEEZIQAMCgsgAigCgAEgAigChAEQiQUiAEUNCiAAKAIEIQBBDBCIASIDIBE2AgggAyAANgIEIANBnNISNgIAQRohAAwJC0EIEIgBIgMgETYCBCADQaiSEzYCAEE1IQAMCAtBCBCIASIDIBE2AgQgA0GgmBM2AgBB8gAhAAwHC0EUEIgBIQMgEikCNCEXIAMgETYCBCADQQA2AhAgA0HExBI2AgAgAyAXQiCJNwIIQecAIQAMBgtBCBCIASIDIBE2AgQgA0HQwhM2AgBBswMhAAwFC0EIEIgBIgMgETYCBCADQfjEEzYCAEG1AyEADAQLQQgQiAEiAyARNgIEIANBzMUTNgIAQbkDIQAMAwtBCBCIASIDIBE2AgQgA0G4sRM2AgBB4gMhAAwCC0EIEIgBIgMgETYCBCADQZiGEjYCAEEJIQAMAQtBCBCIASIDIBE2AgQgA0GwhhI2AgBB8wMhAAsgAkGAAWogACADEIoFDQAgBCEUIBFBwgAgESgCACgCDBECAEUNBEEIEIgBIgAgETYCBCAAQfiWEzYCACAEIRQgAkGAAWpBwgAgABCKBUUNBAtBAiEDIAIoApQBIQALAkAgAEUNACACIAA2ApgBIAAQhgELIAIoAogBEIgFIAIoAoABIQAgAkEANgKAAQJAIABFDQAgABCGAQsgA0UNBiACQfwAahCLBQwGCyARRQ0AIBEgESgCACgCBBEAAAsgAigCmAEhAANAIAAgAigClAFGDQEgAEF8aiIAKAIAIgMgAygCACgCDBEBAA0BDAALAAsACxCMBQALIAJBpAFqEP8EGgtB8OoQQQtBAUHAnhsQPhogAkEANgJ8CyACQeAAaigCACEAAkADQCAARQ0BIAAoAgAhAyAAEIYBIAMhAAwACwALIAIoAlghACACQQA2AlgCQCAARQ0AIAAQhgELIAJBADYCgAEgAigCfCEAIAJBgAFqEIsFIAUoAgAQAiACQcAAahD1BBogAkGwAWokACAACwcAIAARDwALBgBBoNcbC6EBAQF/IwBBwABrIgYkACAGQRhqQQhqIANBCGopAgA3AwAgBiADKQIANwMYIAZBCGpBCGogBEEIaikCADcDACAGIAQpAgA3AwggBkEoaiABIAIgBkEYaiAGQQhqIAUgABEuAEEYEIgBIgNBEGogBkEoakEQaikCADcCACADQQhqIAZBKGpBCGopAgA3AgAgAyAGKQIoNwIAIAZBwABqJAAgAws6AQF/QZDXEiEGAkAgAkEISw0AIAJBAnRB1PwQaigCACEGCyAAIAEgBioCACAGKgIEIAMgBCAFEI0FC3sCAX8BfiMAQTBrIgMkACADIAIpAgAiBDcDICADQQhqQQhqIAFBCGopAgA3AwAgA0EIakEQaiABQRBqKQIANwMAIAMgASkCADcDCCADIAQ3AwAgA0EoaiADQQhqIAMgABEFAEEIEIgBIgEgAykDKDcDACADQTBqJAAgAQsTACAAIAEgAioCACACKgIEEI4FCwkAIAEgABEBAAvFAQEGfyMAQRBrIgEkAEEBIQICQCAAQdAAaigCACAAKAJMRw0AIAFBBGogACgCCEGkCmoQjwUiAygCBCEEIAMoAgAhBQJAA0AgBSAERg0BIAUoAgAiAEHYAWooAgAhBiAAKALUASEAAkADQCAAIAZGDQECQCAAKAIAIgJB3wAgAigCACgCDBECAEUNACACKAJIELEBDQQLIABBBGohAAwACwALIAVBBGohBQwACwALIAUgBEchAiADEJAFGgsgAUEQaiQAIAILBgBBldYbCwcAIAAQhgELNQEBfyMAQRBrIgMkACADIAE4AgwgAyACOAIIIANBDGogA0EIaiAAEQIAIQAgA0EQaiQAIAALJwIBfwF9QQgQiAEhAiAAKgIAIQMgAiABKgIAOAIEIAIgAzgCACACCwcAIAAqAgALKwEBf0EEEIgBIgIgATYCAEGV1hsgAEECQYjzEEGQ8xBBvgMgAkEAQQAQBwsHACAAKgIECwYAQanXGwsHACAAEIYBCwcAIAARDwALNQEBf0EYEIgBIgBBEGpBACkC2LETNwIAIABBCGpBACkC0LETNwIAIABBACkCyLETNwIAIAALOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQwACwcAIAAqAgALGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsJACAAIAE4AgALGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgsHACAAKgIECwkAIAAgATgCBAsHACAAKgIICwkAIAAgATgCCAsHACAAKgIMCwkAIAAgATgCDAsHACAAKgIQCwkAIAAgATgCEAsHACAAKgIUCwkAIAAgATgCFAsJACAAIAEQkgULDgAgASACIAAoAgARAgALUAEBfyMAQSBrIgMkACADQQhqIAAgAhCTBSABQRBqIANBCGpBEGopAgA3AgAgAUEIaiADQQhqQQhqKQIANwIAIAEgAykCCDcCACADQSBqJAALEAAgASACIAMgACgCABEFAAsGAEGb1hsLEgACQCAARQ0AIAAQlAUQhgELCxEAIAAoAhAgACgCFEEAEJUFCwwAIAEgACgCABEBAAuNAQEFfyMAQSBrIgIkACACQRRqIAJBCGogARCWBSIDEJYFIQQgAEEUaigCACEFIAAoAhAhAAJAA0BBACEBAkAgACAFRw0AQQAhBgwCCyAAKAIAIgZBCGogBBCXBQ0BIABBBGohAAwACwALIAQQhQUaAkAgBkUNACAGEJgFIQELIAMQhQUaIAJBIGokACABCz4BAX8jAEEQayIDJAAgACgCACEAIANBBGogAhCrBSABIANBBGogABECACEAIANBBGoQhQUaIANBEGokACAACxEAIAAoAhAgACgCFCABEJUFCw4AIAEgAiAAKAIAEQIACxMAIABBFGooAgAgACgCEGtBAnULMgEBf0EIEIgBIgMgAjYCBCADIAE2AgBBm9YbIABBAkHg8xBB2P4QQb8DIANBAEEAEAcLEwAgAEEgaigCACAAKAIca0ECdQtHAQJ/QQAhAgJAIABBIGooAgAgACgCHCIDa0ECdSABTQ0AQQgQiAEhAiADIAFBAnRqKAIAIQEgAiAANgIEIAIgATYCAAsgAgsOACABIAIgACgCABECAAuBAQEEfyMAQRBrIgIkACACQQRqIAEQlgUhAyAAQSBqKAIAIQQgACgCHCEBA38CQAJAAkAgASAERw0AQQAhAQwBCyABKAIAIgVBCGogAxCXBUUNAUEIEIgBIgEgADYCBCABIAU2AgALIAMQhQUaIAJBEGokACABDwsgAUEEaiEBDAALCz4BAX8jAEEQayIDJAAgACgCACEAIANBBGogAhCrBSABIANBBGogABECACEAIANBBGoQhQUaIANBEGokACAAC0sBAn9BACECAkAgASgC1AkiASAAQSBqKAIAIAAoAhwiA2tBAnVPDQAgAyABQQJ0aigCACEBQQgQiAEiAiAANgIEIAIgATYCAAsgAgsOACABIAIgACgCABECAAsGAEGg1hsLEgACQCAARQ0AIAAQmgUQhgELCy8BAX8gACgCACIAIAAoAgQiAUF/ajYCBAJAIAFBAUcNACAAIAAoAgAoAgQRAAALCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAsGAEGi1hsLEgACQCAARQ0AIAAQmwUQhgELCwoAIAAoAgAQnAULOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQAACwYAQaTWGwsXAAJAIABFDQAgACAAKAIAKAIEEQAACwsGAEGm1hsLBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzwBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBABCdBQsHACAAQQhqCxkBAX9BCBCIASICIAE2AgQgAiAANgIAIAILCgAgACABthCeBQsOACABIAIgACgCABE4AAsJACAAIAEQnwULDgAgASACIAAoAgARAwALZAECfyAAQeAJaigCACECIAAoAtwJIQACQANAAkAgACACRw0AQQAhAwwCCwJAIAAoAgAiA0UNACADQSYgAygCACgCDBECAEUNACADQQhqIAEQlwUNAgsgAEEEaiEADAALAAsgAws+AQF/IwBBEGsiAyQAIAAoAgAhACADQQRqIAIQqwUgASADQQRqIAARAgAhACADQQRqEIUFGiADQRBqJAAgAAtkAQJ/IABB4AlqKAIAIQIgACgC3AkhAAJAA0ACQCAAIAJHDQBBACEDDAILAkAgACgCACIDRQ0AIANBAiADKAIAKAIMEQIARQ0AIANBCGogARCXBQ0CCyAAQQRqIQAMAAsACyADCz4BAX8jAEEQayIDJAAgACgCACEAIANBBGogAhCrBSABIANBBGogABECACEAIANBBGoQhQUaIANBEGokACAACxMAIAAoAtwJIAAoAuAJIAEQoAULPgEBfyMAQRBrIgMkACAAKAIAIQAgA0EEaiACEKsFIAEgA0EEaiAAEQIAIQAgA0EEahCFBRogA0EQaiQAIAALZAECfyAAQeAJaigCACECIAAoAtwJIQACQANAAkAgACACRw0AQQAhAwwCCwJAIAAoAgAiA0UNACADQSggAygCACgCDBECAEUNACADQQhqIAEQlwUNAgsgAEEEaiEADAALAAsgAws+AQF/IwBBEGsiAyQAIAAoAgAhACADQQRqIAIQqwUgASADQQRqIAARAgAhACADQQRqEIUFGiADQRBqJAAgAAtkAQJ/IABB4AlqKAIAIQIgACgC3AkhAAJAA0ACQCAAIAJHDQBBACEDDAILAkAgACgCACIDRQ0AIANBKSADKAIAKAIMEQIARQ0AIANBCGogARCXBQ0CCyAAQQRqIQAMAAsACyADCz4BAX8jAEEQayIDJAAgACgCACEAIANBBGogAhCrBSABIANBBGogABECACEAIANBBGoQhQUaIANBEGokACAACzQBAX9BACECAkAgAEHsCWooAgAgACgC6AkiAGtBAnUgAU0NACAAIAFBAnRqKAIAIQILIAILDgAgASACIAAoAgARAgALRAECfyAAQewJaigCACECIAAoAugJIQADQAJAIAAgAkcNAEEADwsgACgCACEDIABBBGohACADQQhqIAEQlwVFDQALIAMLPgEBfyMAQRBrIgMkACAAKAIAIQAgA0EEaiACEKsFIAEgA0EEaiAAEQIAIQAgA0EEahCFBRogA0EQaiQAIAALFQAgAEHsCWooAgAgACgC6AlrQQJ1CysBAX9BBBCIASICIAE2AgBBptYbIABBAkGQ9RBB2P4QQcADIAJBAEEAEAcLNAEBf0EAIQICQCAAQfgJaigCACAAKAL0CSIAa0ECdSABTQ0AIAAgAUECdGooAgAhAgsgAgsOACABIAIgACgCABECAAtEAQJ/IABB+AlqKAIAIQIgACgC9AkhAANAAkAgACACRw0AQQAPCyAAKAIAIQMgAEEEaiEAIANBCGogARCXBUUNAAsgAws+AQF/IwBBEGsiAyQAIAAoAgAhACADQQRqIAIQqwUgASADQQRqIAARAgAhACADQQRqEIUFGiADQRBqJAAgAAsVACAAQfgJaigCACAAKAL0CWtBAnULVgEDfyAAQeAJaigCACEBIAAoAtwJIQBBACECAkADQCAAIAFGDQECQCAAKAIAIgNFDQAgAiADQYcBIAMoAgAoAgwRAgBqIQILIABBBGohAAwACwALIAILawEDfyAAQeAJaigCACECIAAoAtwJIQBBACEDAkADQAJAIAAgAkcNAEEAIQQMAgsCQCAAKAIAIgRFDQAgBEGHASAEKAIAKAIMEQIARQ0AIAMgAUYNAiADQQFqIQMLIABBBGohAAwACwALIAQLDgAgASACIAAoAgARAgALVgEDfyAAQeAJaigCACEBIAAoAtwJIQBBACECAkADQCAAIAFGDQECQCAAKAIAIgNFDQAgAiADQYABIAMoAgAoAgwRAgBqIQILIABBBGohAAwACwALIAILcAEDfyABQeAJaigCACEDIAEoAtwJIQFBACEEAkADQAJAIAEgA0cNAEEAIQUMAgsCQCABKAIAIgVFDQAgBUGAASAFKAIAKAIMEQIARQ0AIAQgAkYNAiAEQQFqIQQLIAFBBGohAQwACwALIAAgBRCiBQs3AQF/IwBBEGsiAyQAIANBDGogASACIAAoAgARBQAgAygCDBAJIAMoAgwiABACIANBEGokACAAC80DAQZ/IwBBwABrIgMkAEEAIQQCQCACKAIEIAItAAsiBSAFQRh0QRh1QQBIG0UNACAAIAIQowUiAkUNACADQRxqIANBBGogARCWBSIGEJYFIQcCQAJAAkAgA0EQakGx1hoQpAUiCCgCBCAILQALIgQgBEEYdEEYdUEASBtFDQAgA0E0aiAIEJYFIQEgAkHYAWooAgAhACACKALUASECA0BBACEFAkAgAiAARw0AQQAhBAwDCwJAIAIoAgAiBEHfACAEKAIAKAIMEQIARQ0AIARBCGogARCXBQ0DCyACQQRqIQIMAAsACyACQdgBaigCACEBIAIoAtQBIQIDQAJAIAIgAUcNAEEAIQUMAwsCQCACKAIAIgRB3wAgBCgCACgCDBECAEUNACADQTRqIAcQlgUhACAEQcwAaigCACAEQdAAaigCACAAEKUFIQUgABCFBRogBQ0DCyACQQRqIQIMAAsACyABEIUFGiAERQ0AIANBKGogBxCWBSECIARBzABqKAIAIARB0ABqKAIAIAIQpQUhBSACEIUFGgsgCBCFBRogBxCFBRogBhCFBRpBACEEIAVFDQAgBRCmBUUNACAFEKYFIQQLIANBwABqJAAgBAtWAQF/IwBBIGsiBCQAIAAoAgAhACAEQRRqIAIQqwUgBEEIaiADEKsFIAEgBEEUaiAEQQhqIAARBAAhACAEQQhqEIUFGiAEQRRqEIUFGiAEQSBqJAAgAAtYAQJ/QQAhAwJAIAIoAgQgAi0ACyIEIARBGHRBGHVBAEgbRQ0AIAAgAhCjBSICRQ0AIAIoAtABIgJFDQAgAkHcCWooAgAgAkHgCWooAgAgARCgBSEDCyADC1YBAX8jAEEgayIEJAAgACgCACEAIARBFGogAhCrBSAEQQhqIAMQqwUgASAEQRRqIARBCGogABEEACEAIARBCGoQhQUaIARBFGoQhQUaIARBIGokACAAC1gBAX0CQCAAKgLIASAAKgKgCyIBWw0AIAAgATgCyAEgACAAKAIAKAKcAREAAAsCQCAAKgLMASAAKgKkCyIBWw0AIAAgATgCzAEgACAAKAIAKAKgAREAAAsLDAAgASAAKAIAEQAACxAAIAAgASgCAEEAQQEQpwULDgAgASACIAAoAgARAwALCQAgACABEKgFC0EBAX8jAEEQayICJAAgAiABIAAoAgARAwBBEBCIASIAQQhqIAJBCGopAgA3AgAgACACKQIANwIAIAJBEGokACAACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAsIACAAKgLIAQsZAQF/QQgQiAEiAiABNgIEIAIgADYCACACCzsBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAAkAgA0EBcUUNACABKAIAIABqKAIAIQALIAEgAiAAEQ0ACyYAAkAgACoCyAEgAVsNACAAIAE4AsgBIAAgACgCACgCnAERAAALCxkBAX9BCBCIASICIAE2AgQgAiAANgIAIAILCAAgACoCzAELJgACQCAAKgLMASABWw0AIAAgATgCzAEgACAAKAIAKAKgAREAAAsLCAAgAC0AiQsLIgACQCAALQCJCyABRg0AIAAgAToAiQsgAEEQQQAQvQcaCws5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALBwAgABCpBQsMACABIAAoAgARAQALCAAgACoCtAsLTgECfyAAIAE4ArQLIABBqApqKAIAIQIgACgCpAohAAJAA0AgACACRg0BAkAgACgCACgC0AEiA0UNACADIAEQqwILIABBBGohAAwACwALCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsGAEGx1hsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQwACwcAIAAqAmQLGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsjAAJAIAAqAmQgAVsNACAAIAE4AmQgACAAKAIAKAJUEQAACwsZAQF/QQgQiAEiAiABNgIEIAIgADYCACACCwcAIAAqAmgLIwACQCAAKgJoIAFbDQAgACABOAJoIAAgACgCACgCWBEAAAsLBwAgACoCYAsjAAJAIAAqAmAgAVsNACAAIAE4AmAgACAAKAIAKAJQEQAACwsIACAAQcgAags/ACABIAAoAgARAQAhAEEYEIgBIgFBEGogAEEQaikCADcCACABQQhqIABBCGopAgA3AgAgASAAKQIANwIAIAELVgECfiAAKAIYIgBByABqQbCXGyAAQdsAIAAoAgAoAgwRAgAbIgApAgAhAiAAQQhqKQIAIQMgAUEQaiAAQRBqKQIANwIAIAFBCGogAzcCACABIAI3AgALDgAgASACIAAoAgARAwALBgBBs9YbCwQAIAALBAAgAAsXAAJAIABFDQAgACAAKAIAKAIEEQAACws5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARDAALGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAslAAJAIAAqApwBIAFbDQAgACABOAKcASAAIAAoAgAoAnQRAAALCxkBAX9BCBCIASICIAE2AgQgAiAANgIAIAILJQACQCAAKgKgASABWw0AIAAgATgCoAEgACAAKAIAKAJ4EQAACwsGAEG11hsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLPAEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQEAEJ0FCwcAIABBPGoLKQEBfwJAIABBPGoiAiABEJcFDQAgAiABEKoFIAAgACgCACgCSBEAAAsLPAEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQEAEJ0FC2EBAn8jAEEQayIDJAAgASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIANBBGogAhCrBSABIANBBGogABEDACADQQRqEIUFGiADQRBqJAALBgBBt9YbCwQAIAALBAAgAAsXAAJAIABFDQAgACAAKAIAKAIEEQAACwsIACAAKgKcAQslAAJAIAAqApwBIAFbDQAgACABOAKcASAAIAAoAgAoAnQRAAALCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsGAEG51hsLBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAslAAJAIAAqArgBIAFbDQAgACABOAK4ASAAIAAoAgAoAngRAAALCxkBAX9BCBCIASICIAE2AgQgAiAANgIAIAILJQACQCAAKgK8ASABWw0AIAAgATgCvAEgACAAKAIAKAJ8EQAACwsGAEG71hsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLPAEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQEAEJ0FCwcAIABBCGoLGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgsGAEG+1hsLBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzwBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBABCdBQs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAQALBwAgACgCGAsZAQF/QQgQiAEiAiABNgIEIAIgADYCACACCwcAIAAoAhQLBwAgACgCJAsHACAAKAIoCwcAIAAtACwLOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQEACwcAIAAoAiALBwAgACoCHAs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARDAALwgMCAX0LfwJAIAAtAC1FDQAgACgCFLMiBCAClI4gBJUhAgsgAEE0aigCACEFIAAoAjAhBgJAA0AgBiAFRg0BAkAgASAGKAIAIgAoAgggASgCACgC5AERAgAiB0UNACAHQfgBaiEIIABBEGooAgAhCSAAKAIMIQADQCAAIAlGDQECQCAAKAIAIgooAggiC0GLA0YNACALQZEDRg0AIAMhBAJAIAcgBygCACgCCBEBAEGZA0cNAEMAAIA/IAMgCCAKKAIIIAgoAgAoAggRAgAbIQQLIAooAgghDAJAIApBDGooAgAiCyAKQRBqKAIAIg0gAkEAEP0XIgoNACALKAIAIgogByAMIAQgCigCACgCNBEdAAwBCyAKQQJ0IAtqIg5BfGooAgAhDwJAIAogDSALa0ECdU4NAAJAIA4oAgAiCioCDCACXA0AIAogByAMIAQgCigCACgCNBEdAAwCCyAPKAIAIQsCQCAPKAIQDQAgDyAHIAwgBCALKAI0ER0ADAILIA8gByAMIAIgCiAEIAsoAjgRKgAMAQsgDyAHIAwgBCAPKAIAKAI0ER0ACyAAQQRqIQAMAAsACyAGQQRqIQYMAAsACws/AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhAAJAIAVBAXFFDQAgASgCACAAaigCACEACyABIAIgAyAEIAARLwALBgBBwNYbCxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzUBAX8jAEEQayIDJAAgAyABNgIMIAMgAjYCCCADQQxqIANBCGogABECACEBIANBEGokACABCxoAQcAAEIgBIAAoAgAgASgCAEMAAIA/EKwFCwcAIAAqAiALcgIBfQJ/AkAgACoCICABWw0AIAAgATgCICAAKgIoIAAqAiyTIQICQAJAIAAoAhwiAy0ALA0AQQAhBAwBCyADKAIkIQQLIAMoAhQhAyAAQYCAgPwDNgI0IAAgASADIARsspMiATgCKCAAIAEgApM4AiwLCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsHACAALQA4CzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBAAsLACAAIAFBABCtBQs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABEjAAsWACAAKAIcIAAoAgggACoCICABEPUCCzsBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAAkAgA0EBcUUNACABKAIAIABqKAIAIQALIAEgAiAAEQ0ACwYAQcPWGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLBgBBxdYbCxcAAkAgAEUNACAAIAAoAgAoAgQRAAALC4sBAgJ/AX4jAEEgayIDJAAgASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAMgAikCACIFNwIUIAMgBTcDCCADQRxqIAEgA0EIaiAAEQUAQQQQiAEhACADKAIcIQEgA0EANgIcIAAgATYCAEEAEPQEIANBIGokACAAC48BAgJ/AX4jAEEgayIDJAAgASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAMgAikCACIFNwIUIAMgBTcDCCADQRxqIAEgA0EIaiAAEQUAQQQQiAEhACADKAIcIQEgA0EANgIcIAAgATYCACADQRxqELsFGiADQSBqJAAgAAuLAQICfwF+IwBBIGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhAAJAIARBAXFFDQAgASgCACAAaigCACEACyADIAIpAgAiBTcCFCADIAU3AwggA0EcaiABIANBCGogABEFAEEEEIgBIQAgAygCHCEBIANBADYCHCAAIAE2AgBBABD3BCADQSBqJAAgAAsGAEHI1hsLBwAgABCGAQsGAEHN1hsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLBwAgAEEIags8AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAQAQnQULBwAgAEEYags8AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAQAQnQULYwECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgAkEEaiABIAARAwAgAkEEahCdBSEAIAJBBGoQhQUaIAJBEGokACAACxkBAX9BCBCIASICIAE2AgQgAiAANgIAIAILpQMBB38jAEHAAGsiAiQAAkAgAkEwaiABQQhqEJYFIgMQyRUiBEF/Rg0AIAMgAkEgaiADQQAgBBCsCCIEENsHIAQQhQUaCwJAIAMoAgQgAy0ACyIEIARBGHRBGHUiBUEASBsiBkEBaiIEQfD///8HTw0AAkACQCAEQQpLDQAgAkEoakEANgIAIAJCADcDICACIAQ6ACtBACACQSBqIARBGHRBGHVBAEgbIQcMAQsgBEEPckEBaiIIEIgBIQcgAiAENgIkIAIgBzYCICACIAhBgICAgHhyNgIoCyAHIAMoAgAgAyAFQQBIGyAGEHIgBmpBLTsAACACQRRqIAEoAhQQyhUgAkEIaiACQSBqIAJBFGoQxxUgAkEUahCFBRogAkEgahCFBRogAxCFBRogAkEwakEIaiACQQhqEMsVIgNBCGoiBCgCADYCACACIAMpAgA3AzAgA0IANwIAIARBADYCACACQSBqIAEgASgCACgCRBEDACAAIAJBMGogAkEgahDHFSACQSBqEIUFGiACQTBqEIUFGiADEIUFGiACQcAAaiQADwsQAAALDAAgASAAKAIAEQEACxIAIABBlgMgACgCACgCDBECAAsSAQF/QQQQiAEiASAANgIAIAELEgAgAEHpACAAKAIAKAIMEQIACxIAIABBjQEgACgCACgCDBECAAvZBAEKfyMAQbABayICJAACQAJAIAFBKGooAgAgASgCJGtBEEYNACAAQbHWGhCkBRoMAQtBACEDIAJBADYCoAEgAkIANwKYASACQRAQrgUiBDYCmAEgAiAEQcAAaiIFNgKgASAEQZz3EEHAABA7IQYgAiAFNgKcASACQcC3GjYCSCACQay3GjYCCCACQYS3GjYCECACQQA2AgwgAkEIakHAAGogAkEUaiIEEK8FIAJBmLcaNgJIIAJB8LYaNgIIIAJCgICAgHA3ApABIAJBhLcaNgIQIAQQsAUiB0GIsxo2AgAgAkE8akIANwIAIAJBNGpCADcCACACQcQAakEYNgIAIAJBCGpBCGoiCCACKAIQQXRqIgQoAgBqIgUgBSgCBEG1f3FBCHI2AgQCQCAIIAQoAgBqIgQoAkxBf0cNACAEQRxqKAIAELEFGgsgBEEwNgJMIAJBpwFqQQFqIQkgAkEcaiEKA0ACQCADQRBHDQAgACAHELIFIAJBCGoQswUaIAJBmAFqEP8EGgwCCyAGIANBAnRqKAIAIQQgCiACKAIQQXRqKAIAakECNgIAIAggBCABKAIkai0AABC0BSEFAkAgBEEISw0AQQEgBHRB0QJxRQ0AIAJBLToApwECQCACQagBaiAFELUFIgstAABFDQAgBSAFKAIAQXRqKAIAaiIEKAIYIAJBpwFqIAkgAkGnAWogBCgCBEGwAXFBIEYbIAkgBCAEELYFELcFDQAgBSAFKAIAQXRqKAIAakEFELgFCyALELkFGgsgA0EBaiEDDAALAAsgAkGwAWokAAs4AQF/IwBBEGsiAiQAIAJBBGogASAAKAIAEQMAIAJBBGoQnQUhACACQQRqEIUFGiACQRBqJAAgAAuEAQEDfyMAQRBrIgIkACACQQhqIAEoAgAQ7gQgAigCCCIDEO8EIQQgAxACIAQQRiEDIAIgBDYCDCACIAM2AgggAkEEaiAEIAMQ8QQiBCgCAEGPvRAgARDyBCAAIAJBCGpBoNcbIAAoAgAoAkARBAAaIAQoAgAQAiACKAIIEEcgAkEQaiQACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEDACADKAIMEAIgA0EQaiQACwYAQc/WGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLQwEBfyMAQRBrIgIkAAJAIAFFDQAgASABKAIEQQFqNgIECyACIAE2AgwgACACQQxqELoFIAJBDGoQuwUaIAJBEGokAAsOACABIAIgACgCABEDAAsGAEHR1hsLBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzsAAkACQCABKAIAIgENACAAQcAAakEAEPMEDAELIAEgASgCAEECajYCACAAQcAAaiABEPMECyABEPQECw4AIAEgAiAAKAIAEQMACwYAQdPWGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLRwEBfyMAQRBrIgIkAAJAIAEoAgAiAUUNACABIAEoAgRBAWo2AgQLIAIgATYCDCAAIAJBDGoQvAUgAigCDBD3BCACQRBqJAALDgAgASACIAAoAgARAwALBgBB1dYbCxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzUBAX8jAEEQayIDJAAgAyABNgIMIAMgAjYCCCADQQxqIANBCGogABECACEBIANBEGokACABCxUAQaQBEIgBIAAoAgAgASgCABC9BQsLACAAIAFBARC+BQsOACABIAIgACgCABEjAAsSACAAIAG2IAAoAgAoAhwRIwALDgAgASACIAAoAgAROAALMgEBf0EIEIgBIgMgAjYCBCADIAE2AgBB1dYbIABBAkGw+BBB2P4QQcEDIANBAEEAEAcLOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAgALQgECfyMAQRBrIgMkACADIAK2OAIMIAMgAbY4AgggACgCACgCJCEEIAMgAykCCDcDACAAIAMgBBECABogA0EQaiQACysBAX9BBBCIASICIAE2AgBB1dYbIABBBEHQ+BBB4PgQQcIDIAJBAEEAEAcLQgECfyMAQRBrIgMkACADIAK2OAIMIAMgAbY4AgggACgCACgCKCEEIAMgAykCCDcDACAAIAMgBBECABogA0EQaiQAC0IBAn8jAEEQayIDJAAgAyACtjgCDCADIAG2OAIIIAAoAgAoAiwhBCADIAMpAgg3AwAgACADIAQRAgAaIANBEGokAAsTACAAQShqKAIAIAAoAiRrQQN1C4gBAgF/AX0jAEEQayIDJAACQAJAAkAgAUEoaigCACABKAIkIgFrQQN1IAJNDQAgASACQQN0aiIBKAIAIgINAQsgAEEBNgIADAELIAEqAgQhBCAAIAIQogUgACgCAEGCtRAQCyIBIANBDGogBBDBBSICKAIAEAogAigCABACIAEQAgsgA0EQaiQACzcBAX8jAEEQayIDJAAgA0EMaiABIAIgACgCABEFACADKAIMEAkgAygCDCIAEAIgA0EQaiQAIAALQwEDfyAAKAJIIQEgACgCRCECQQAhA0EAIQADfwJAIAAgAkcNACADDwsgAyABIABBOGxqLQAsaiEDIABBAWohAAwACwvJAQEDfyABKAJIIQMgASgCRCEEQQAhBUEAIQECQAJAAkACQANAIAEgBEYNBAJAAkAgAyABQThsai0ALEUNAAJAIAUgAkcNACADIAFBOGxqKAIQIgFFDQcgASgCBCIBRQ0HIAEgASgCACgCCBEBAEFDag4EAgYEBQcLIAVBAWohBQsgAUEBaiEBDAELCyAAIAEoAixBCGoQlgUaDwsgAEGjtBAQpAUaDwsgAEHXuxAQpAUaDwsgAEHStBAQpAUaDwsgAEHQxRAQpAUaCzoBAX8jAEEQayIDJAAgA0EEaiABIAIgACgCABEFACADQQRqEJ0FIQAgA0EEahCFBRogA0EQaiQAIAALFAAgACABKAIAIAAoAgAoAiARAwALDgAgASACIAAoAgARAwALBgBB19YbCxcAAkAgAEUNACAAIAAoAgAoAggRAAALCxQAIAAoAggiACAAKAIAKAIIEQEACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBAAsKACAAKAIIQQhqCzwBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBABCdBQsHACAALwEACx4BAX8gAEEAIAAoAggiASABKAIAKAIIEQEAQTtGGwsMACABIAAoAgARAQALHgEBfyAAQQAgACgCCCIBIAEoAgAoAggRAQBBOEYbCwwAIAEgACgCABEBAAseAQF/IABBACAAKAIIIgEgASgCACgCCBEBAEE6RhsLDAAgASAAKAIAEQEACwYAQdzWGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCCBEAAAsLBwAgAC0ADAsgAAJAIAAtAAwgAUYNACAAIAE6AAwgACgCBEEBOgA0Cws5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALBgBB3tYbCwQAIAALBAAgAAsXAAJAIABFDQAgACAAKAIAKAIIEQAACwsHACAAKgIMCyAAAkAgACoCDCABWw0AIAAgATgCDCAAKAIEQQE6ADQLCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEMAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABENAAsGAEHg1hsLBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAggRAAALCx0AAkAgAC0ADA0AIABBAToADCAAKAIEQQE6ADQLCzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAscAQF/QRAQiAEiAEIANwIAIABBCGpCADcCACAACwcAIAAQhgELKgBBrtcbIABBieAbQZDzEEHDAyABEMMFQYngG0HEgxFBxAMgARDDBRARCwYAQeLWGwsYAAJAIABFDQAgAEEYahCFARogABCGAQsLKQEBfyMAQRBrIgIkACACIAE2AgwgAkEMaiAAEQEAIQEgAkEQaiQAIAELMgEBf0EcEIgBIQEgACgCACEAIAFBADYCGCABQQA2AgQgASAANgIAIAFBAUEBEIMBIAELCwAgACABIAIQgwELPQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQACQCAEQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgABEFAAviBAEGfyMAQRBrIgMkAAJAAkAgAiABIAIgAUobIAAoAgAiBEwNAEEAIQAMAQsCQAJAIAEgAiABIAJIG0EASg0AIANBADYBCAwBCyAAQRhqIQUCQCAAKAIYDQACQCAAKAIIIgYgAU4NACAAIARBAUEgIAFBf2pna3QiBiAEIAZIGyIGNgIICwJAIAAoAgwiByACTg0AIAAgBEEBQSAgAkF/amdrdCIHIAQgB0gbIgc2AgwLIAAoAgRBAEEAQQAgBiAHEIcBIQQgA0EANgIMIAUgBBCEASADQQxqEIUBGgsgBSEEA0ACQCAEKAIAIgQNAAJAA0AgACgCDCEEAkAgACgCCCIHIAAoAgAiBkgNACAEIAZODQILAkACQCAEIAdKDQAgACAGIARBAXQiCCAGIAhIGyIGNgIMIAAoAhghCCAAQQA2AhggACgCBCAIQQAgBCAHIAYQhwEhBCADQQA2AgwgBSAEEIQBIANBDGoQhQEaDAELIAAgBiAHQQF0IgggBiAISBsiBjYCCCAAKAIYIQggAEEANgIYIAAoAgQgCCAHQQAgBiAEEIcBIQQgA0EANgIMIAUgBBCEASADQQxqEIUBGgsgBSgCACABIAIgA0EIahCPAUUNAAwECwALQQAhACADLwEIIQQgAy8BCiEBDAMLIAQgASACIANBCGoQjwFFDQALCyAAIAAoAhAiBiADLgEIIgQgAWoiASAGIAFKGzYCECAAQRRqIgAgACgCACIAIAMuAQoiASACaiICIAAgAkobNgIAQQEhAAsgA0EQaiQAIAFBEHQgBEEQdEEQdXJBfyAAGws9AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhAAJAIARBAXFFDQAgASgCACAAaigCACEACyABIAIgAyAAEQQACwcAIAAoAhALMgEBf0EIEIgBIgMgAjYCBCADIAE2AgBB4tYbIABBAkHg+RBB2P4QQcUDIANBAEEAEAcLCgAgAEEUaigCAAsGAEHl1hsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLaAICfwF+IwBBEGsiBSQAIAEgACgCBCIGQQF1aiEBIAAoAgAhAAJAIAZBAXFFDQAgASgCACAAaigCACEACyAFIAMpAgAiBzcCCCAFIAc3AwAgASACIAUgBCAAEQYAIQAgBUEQaiQAIAALBgBB59YbCwQAIAALBAAgAAsXAAJAIABFDQAgACAAKAIAKAIEEQAACwsJACAAQQE6AAQLDAAgASAAKAIAEQAACzABAX8jAEEQayICJAAgAiABNgIMIAJBDGogABEBACEBIAIoAgwQAiACQRBqJAAgAQssAQF/QQwQiAEiAUEAOgAEIAEgACgCADYCCCAAQQA2AgAgAUGk+hA2AgAgAQtbAQF/IwBBIGsiAyQAIANBEGogARCrBSADIAI2AgwgA0EcaiADQRBqIANBDGogABEFACADKAIcEAkgAygCHCIBEAIgAygCDBACIANBEGoQhQUaIANBIGokACABCyIAIAAgASgCACABIAEsAAtBAEgbQefWGyACKAIAEBg2AgALBgBB9NYbCwcAIAAQhgELOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQEAC0ABA38jAEEQayIBJAAgAUEEaiAAKAIAQRhqEMcFIgAoAgAhAiAAKAIEIQMgABDJBRogAUEQaiQAIAMgAmtBAnULGQEBf0EIEIgBIgIgATYCBCACIAA2AgAgAgsKACAAKAIAQQhqCzwBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEBABCdBQsYACAAKAIAIgBBKGooAgAgACgCJGtBAnULnQEBAn9BACECAkAgACgCACIDQShqKAIAIAMoAiQiA2tBAnUgAU0NACADIAFBAnRqKAIAIgFFDQAgASABKAIAKAIUEQEAIQEgACgCBCABEMYFQSwQiAEiAkIANwIEIAIgATYCACACQgA3AhggAkEMakIANwIAIAJBFGpBgICA/AM2AgAgAkEgakIANwIAIAJBKGpBgICA/AM2AgALIAILDgAgASACIAAoAgARAgALsAEBBH8gACgCACICQShqKAIAIQMgAigCJCECAkADQEEAIQQgAiADRg0BIAIoAgAhBSACQQRqIQIgBUEIaiABEJcFRQ0ACyAFRQ0AIAUgBSgCACgCFBEBACECIAAoAgQgAhDGBUEsEIgBIgRCADcCBCAEIAI2AgAgBEIANwIYIARBDGpCADcCACAEQRRqQYCAgPwDNgIAIARBIGpCADcCACAEQShqQYCAgPwDNgIACyAECz4BAX8jAEEQayIDJAAgACgCACEAIANBBGogAhCrBSABIANBBGogABECACEAIANBBGoQhQUa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BCADp2ogBi0AADoAACADQgF8IQMgBkEBaiEGDAALAAsgAlANASABIAg2AgggAUEBOgAMIABBCGpBADYCACAAQgA3AgAMAgsQAAALIAEgBzYCCCAAIAQgBRDlBQsCQCAERQ0AIAQQhgELCxoAAkAgAC0ACxDELkUNACAAKAIAEOouCyAAC4ICAQZ/AkAgACgCBCICIAAoAghGDQAgAiABNgIAIAAgAkEEajYCBA8LAkACQCACIAAoAgAiA2siBEECdSIFQQFqIgZBgICAgARPDQACQAJAIARBAXUiByAGIAcgBksbQf////8DIARB/P///wdJGyIEDQBBACEGDAELIARBgICAgARPDQIgBEECdBCIASEGCyAGIAVBAnRqIgUgATYCACAFIQECQANAIAIgA0YNASABQXxqIgEgAkF8aiICKAIANgIADAALAAsgACAFQQRqNgIEIAAoAgAhAiAAIAE2AgAgACAGIARBAnRqNgIIAkAgAkUNACACEIYBCw8LEAAACxCMBQALHQACQCAAIAFBARDSByIBDQBBAA8LIAFBDGooAgALKwEBfwJAA0AgAEUNASAAKAIAIQEgAEEMahDzEhogABCGASABIQAMAAsACwsdAAJAIAAgAUEfENIHIgENAEEADwsgAUEMaigCAAuSDQILfwJ9IwBBEGsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAIAAoAgQgARDSByIERQ0AIABBGGooAgAhBSAEQQxqKAIAIQYgACgCFCEEAkADQCAEIAVGDQECQCAEKAIAIAZGDQAgBEEEaiEEDAELCyAEIARBBGoiByAFIAdrEHIaIAAgBUF8ajYCGAsgBiAGKAIAKAIIEQEAIgQNAQsCQCACDQAgACABEPASQQAhBAwKCwJAAkAgAEEYaigCACIEIABBHGooAgAiBk8NACAEIAI2AgAgACAEQQRqNgIYDAELIAQgACgCFCIFa0ECdSIIQQFqIgdBgICAgARPDQICQAJAIAYgBWsiBkEBdSIJIAcgCSAHSxtB/////wMgBkH8////B0kbIgcNAEEAIQkMAQsgB0GAgICABE8NBSAHQQJ0EIgBIQkLIAkgCEECdGoiCCACNgIAIAghBgJAA0AgBCAFRg0BIAZBfGoiBiAEQXxqIgQoAgA2AgAMAAsACyAAIAhBBGo2AhggACgC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NgIMIABBgtAQIAQQ5gUgAkHDzxAQpAUhBwJAIAYoAgBBf2oiBkEHSw0AIAcgBkECdEH4/BBqKAIAEOcFCyAAQbDPECAHEOYFIANB7csQIAJBDGoQ6AUgBxCFBRogABACIAQQhQUaIAFBEGohAQwACwALIAJBIGokAAtJAQJ/AkAgACgCACIBRQ0AIAAoAgQhAgJAA0AgAiABRg0BIAJBdGoQhQUaIAJBcGohAgwACwALIAAgATYCBCAAKAIAEIYBCyAACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAwAgAigCDBAJIAIoAgwiABACIAJBEGokACAACxwAAkAgAEGAgICABEkNABCMBQALIABBAnQQiAELxwIBBn8CQCAAKAIEIgIgACgCCEYNACAAIAIgARCWBUEMajYCBA8LAkACQCACIAAoAgBrQQxtIgJBAWoiA0HWqtWqAU8NAEEAIQQCQCACQQF0IgUgAyAFIANLG0HVqtWqASACQarVqtUASRsiBkUNACAGQdaq1aoBTw0CIAZBDGwQiAEhBAsgBCACQQxsaiABEJYFIQcgACgCACEFIAAoAgQhAiAHIQECQANAIAIgBUYNASABQXRqIgEgAkF0aiICKQIANwIAIAFBCGogAkEIaiIDKAIANgIAIAJCADcCACADQQA2AgAMAAsACyAAKAIAIQMgACABNgIAIAAoAgQhAiAAIAdBDGo2AgQgACAEIAZBDGxqNgIIAkADQCACIANGDQEgAkF0ahCFBSECDAALAAsCQCADRQ0AIAMQhgELDwsQAAALEIwFAAsfAQF/AkAgACgCACIBRQ0AIAAgATYCBCABEIYBCyAAC2cBAn8jAEEQayICJAACQAJAQQAtAPzWG0EBcUUNAEEAKAL41hshAwwBC0ECQfD6EBAVIQNBAEEBOgD81htBACADNgL41hsLIAIgARCdBTYCCCADIABB7csQIAJBCGoQFCACQRBqJAALQwECfwJAIAAoAgAiAUUNACAAKAIEIQICQANAIAIgAUYNASACQXRqEIUFIQIMAAsACyAAIAE2AgQgACgCABCGAQsgAAsMACABIAAoAgARAQALzwYBB38jAEEQayICJAACQAJAIAENAEEAIQMMAQsgAEEgaigCACEEIAAoAhwhBUEAIQYCQANAIAUgBEYNASAFKAIAIAFGDQEgBUEE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aiEBDAALAAsgACACNgIECw8LEAAACx8BAX8CQCAAKAIAIgFFDQAgACABNgIEIAEQhgELIAALfAECfyMAQRBrIgMkAAJAAkACQCACEM0uRQ0AIAAgAhDOLgwBCyACQfD///8HTw0BIANBCGogAhDPLkEBahDQLiAAIAMoAggiBBDRLiAAIAMoAgwQ0i4gACACENMuIAQhAAsgACABIAJBAWoQ5i0aIANBEGokAA8LENUuAAuAAQECfyMAQRBrIgMkAAJAIAJB8P///wdPDQACQAJAIAIQzS5FDQAgACACEM4uDAELIANBCGogAhDPLkEBahDQLiAAIAMoAggiBBDRLiAAIAMoAgwQ0i4gACACENMuIAQhAAsgACABIAIQ5i0gAmpBABDULiADQRBqJAAPCxDVLgALOAEBfyMAQRBrIgMkACAAIAEQCyIBIANBDGogAhDpBSICKAIAEAogAigCABACIAEQAiADQRBqJAALDgAgACABIAEQjC8QwjYLCwAgACABIAIQ8gQLMAEBfyMAQRBrIgIkACACIAEQnQU2AgggAEGL4BsgAkEIahAMNgIAIAJBEGokACAACw4AIAAoAgAQCSAAKAIACy0AIABBuPoQNgIAAkAgAC0ABEUNACAAKAIIQZq9EBDsBQsgAEEIahDtBRogAAtIAQF/AkACQEEALQC01xtBAXFFDQBBACgCsNcbIQIMAQtBAUG0/xAQFSECQQBBAToAtNcbQQAgAjYCsNcbCyACIAAgAUEAEBQLCwAgACgCABACIAALCgAgABDrBRCGAQuzAQICfwF8IwBBIGsiBCQAIARBCGogAigCBCACKAIAEPEEIQIgACgCCCEFAkACQEEALQDw1htBAXFFDQBBACgC7NYbIQAMAQtBA0HE+hAQFSEAQQBBAToA8NYbQQAgADYC7NYbCyAEIAE2AhAgAigCABAJIAQgAigCADYCGCAAIAVB2b0QIARBDGogBEEQahAWIQYgBCgCDBAXIAIoAgAQAiAEQSBqJAAgBkQAAAAAAAAAAGILAwAACwsAIAAoAgAQRyAACxkAIABBiLMaNgIAIABBIGoQhQUaIAAQ+gULBwAgABDbLQuAAQECfyMAQRBrIgMkAAJAIAFB8P///wdPDQACQAJAIAEQzS5FDQAgACABEM4uDAELIANBCGogARDPLkEBahDQLiAAIAMo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IAVCgYCAgPCX25FFNwIEIAVBpIYRNgIAIAUgBBBGNgIcIAAgBTYCAAs8AEE0EIgBIAYgByAIEIcGIgggBTgCMCAIIAQ4AiwgCCADOAIoIAggAjgCJCAIQaD9EDYCACAAIAg2AgALpgEBAX8gAEIANwIMIABBvIYRNgIAIABCgYCAgJDT8fLBADcCBCAAQRRqQQA2AgACQCADDQAgAEIANwIYIABBIGpBADYCACAADwsgAEEMaiADEI8GIAAoAhAgAiADQQJ0IgQQciECIABBIGpBADYCACAAQgA3AhggACACIARqNgIQIABBGGogAxCQBiAAQRxqIQMgAyADKAIAIAEgBBByIARqNgIAIAALNQBBMBCIASAFIAYgBxCHBiIHIAQ4AiwgByADOAIoIAcgAjgCJCAHQbT9EDYCACAAIAc2AgALvQICBH8BfiMAQRBrIgQkACAEQQxqQbO0EBAbIgVByMsQEIoGIAUQAiAEKAIMIgYQiwYiBSADIAUoAgAoAgwRAwAgAkEQaigCACEHIAIoAgwhAyACKAIAIQICQANAIAMgB0YNAQJAAkACQAJAAkAgAy0AAA4GAAEEBAIDBAsgBSACKQIAIginviAIQiCIp74gBSgCACgCFBETACACQQhqIQIMAwsgBSACKQIAIginviAIQiCIp74gBSgCACgCGBETACACQQhqIQIMAgsgBSACKQIAIginviAIQiCIp74gAikCCCIIp74gCEIgiKe+IAIpAhAiCKe+IAhCIIinviAFKAIAKAIcEScAIAJBGGohAgwBCyAFIAUoAgAoAiARAAALIANBAWohAwwACwALIAAgBTYCACAGEAIgBEEQaiQAC54BAgJ/AXwjAEEQayIDJAACQAJAQQAtANzYG0EBcUUNAEEAKALY2BshBAwBC0EBQciGERAVIQRBAEEBOgDc2BtBACAENgLY2BsLAkACQCAEIAEgAiADQQxqQQAQFiIFRAAAAAAAAPBBYyAFRAAAAAAAAAAAZnFFDQAgBashAgwBC0EAIQILIAMoAgwhBCAAIAI2AgAgBBAXIANBEGokAAtbAgF/AXwjAEEQayIBJAAgAEGq1xsgAUEMahAaIQIgASgCDBAXAkACQCACRAAAAAAAAPBBYyACRAAAAAAAAAAAZnFFDQAgAqshAAwBC0EAIQALIAFBEGokACAACz8BAn8j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AgQRAAALCwkAIABBAToABAsMACABIAAoAgARAAALMAEBfyMAQRBrIgIkACACIAE2AgwgAkEMaiAAEQEAIQEgAigCDBACIAJBEGokACABCywBAX9BDBCIASIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeT+EDYCACABCyIAIAAgASgCACABIAEsAAtBAEgbQafXGyACKAIAEBg2AgALBgBB7NcbCxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCzIBAX9BCBCIASIDIAI2AgQgAyABNgIAQe7XGyAAQQJB0IARQdD9EEGLBCADQQFBABAHCz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAARBQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALMgEBf0EIEIgBIgMgAjYCBCADIAE2AgBB7tcbIABBBEGAgRFBkIERQYwEIANBAUEAEAcLRQEBfyABIAAoAgQiCEEBdWohASAAKAIAIQACQCAIQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgBCAFIAYgByAAEScACwYAQe7XGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLCQAgAEEBOgAMCwwAIAEgACgCABEAAAswAQF/IwBBEGsiAiQAIAIgATYCDCACQQxqIAARAQAhASACKAIMEAIgAkEQaiQAIAELPAEBf0EUEIgBIgFBADoADCABQoGAgIDA6ZfV5gA3AgQgASAAKAIANgIQIABBADYCACABQeSBETYCACABCyIAIAAgASgCACABIAEsAAtBAEgbQe7XGyACKAIAEBg2AgALBgBBl9gbCxIAAkAgAEUNACAAEOcGEIYBCwsGAEGa2BsLFwACQCAARQ0AIAAgACgCACgCBBEAAAsLOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARDQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAwALeAEDfyMAQRBrIgMkACABIAAoAgQiBEEBdWohBSAAKAIAIQECQCAEQQFxRQ0AIAUoAgAgAWooAgAhAQsCQCACKAIAIgBFDQAgACAAKAIEQQFqNgIECyADIAA2AgwgBSADQQxqIAERAwAgA0EMahDnBhogA0EQaiQACwYAQZzYGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLCQAgAEEBOgAMCwwAIAEgACgCABEAAAswAQF/IwBBEGsiAiQAIAIgATYCDCACQQxqIAARAQAhASACKAIMEAIgAkEQaiQAIAELPAEBf0EUEIgBIgFBADoADCABQoGAgICw7cHRwAA3AgQgASAAKAIANgIQIABBADYCACABQZSEETYCACABCyIAIAAgASgCACABIAEsAAtBAEgbQZzYGyACKAIAEBg2AgALBgBB0NgbCxcAAkAgAEUNACAAIAAoAgAoAgQRAAALCxAAIAAgAjYCECAAIAE2AgwLPQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQACQCAEQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgABEFAAsqAQF/IAAgACgCBCIBQX9qNgIEAkAgAUEBRw0AIAAgACgCACgCBBEAAAsLOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQAACwYAQdLYGwsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEAAAsLCQAgAEEBOgAwCwwAIAEgACgCABEAAAswAQF/IwBBEGsiAiQAIAIgATYCDCACQQxqIAARAQAhASACKAIMEAIgAkEQaiQAIAELcwEBf0E4EIgBIgFCADcCDCABQoGAgICQqaKbODcCBCABQQA6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NgIAIABB3AlqQQBB/AAQOhogAEH8CmpBADoAACAAQQE6ANgKIABCADcC3AogAEHkCmpCADcCACAAQewKakIANwIAIABB9ApqQQA2AgAgAEIANwKACyAAQgA3AowLIABBiAtqQYACOwEAIABBlAtqQgA3AgAgAEGAgID8AzYCtAsgAEEAOgCwCyAAQQA2AqwLIABBAToAqAsgAEEANgKkCyAAQZwLakKAgID8AzcCACAAQQE6AMQBIAAL/AIBAX8gABD8EiIAQQA2AvABIABCADcC6AEgAEEAOgDkASAAQYCAgPwDNgLYASAAQv////+PgIDAPzcC0AEgAEIANwLIASAAQQA6AMQBIABBADYC/AEgAEHg2RI2AvgBIABB1NkSNgL0ASAAQcDZEjYC4AEgAEGw2RI2AtwBIABBnNkSNgJsIABBwNcSNgIAQZgGEIgBQQBBmAYQOhDfGCIBQcwEahDgGBogAEEANgL4AiAAQQA6APQCIAAgATYCgAIgAEGEAmpBAEHpABA6GiAAQfwCahDZEhogAEIANwLMByAAQdQHahD8EkH02RI2AgAgAEKAgID+h4CA4P8ANwLACSAAQQA6AL4JIABBATsBvAkgAEF/NgK4CSAAQv////+PgIDg/wA3ArAJIABBqAlqQoCAgICAgIDg/wA3AgAgAEIANwKgCSAAQQA6AJwJIABBmAlqIABB3AFqNgIAIABBwAhqQZTbEjYCACAAKAKAAigCuARBADYCFCAACwoAIAAQkQcQhgELvgcBBX8jAEEgayIBJAAgAEHkiRE2AtgJIABB0IkRNgL4ASAAQcSJETYC9AEgAEGwiRE2AuABIABBoIkRNgLcASAAQYyJETYCbCAAQZyHETYCACABQQhqQQAQ3AcCQCABKAIIIgJFDQAgAUEBOgAcIAEgAkEQajYCGBDdBwJAIAIoAjQiA0UNACADIAMoAgBBAWo2AgALIAEgAzYCFCACQShqIQQCQANAIANFDQECQCADKALICiIFRQ0AIAUgBSgCAEEBajYCACABKAIUIQMLIAEgBTYCEAJAIAMoAtQKIABHDQACQCADLQDECg0AIANB/ARqQQE2AgAgASgCFCEDCyAEIAMQ3gcCQCABKAIUIgMNACABQQA2AgwgAiABQQxqEN8HDAELIAMgAygCAEEBajYCACABIAM2AgwgAiABQQxqEN8HIAMQ4AcLIAFBFGogAUEQahDhByEDIAEoAhAQ4AcgAygCACEDDAALAAsgAUEYahDiBxoLIABB4AlqKAIAIQIgACgC3AkhAwN/AkAgAyACRw0AIABBvApqIQQgAEHACmooAgAhAiAAKAK8CiEDA0ACQCADIAJHDQACQCAALQCICw0AIABB7AlqKAIAIQIgACgC6AkhAwNAAkAgAyACRw0AIABB+AlqKAIAIQIgACgC9AkhAwNAIAMgAkYNAwJAIAMoAgAiBUUNACAFIAUoAgAoAgQRAAALIANBBGohAwwACwALAkAgAygCACIFRQ0AIAUgBSgCACgCBBEAAAsgA0EEaiEDDAALAAsgAUEIahDjBxogAEGUC2ooAgAQ0AcgACgCjAshAyAAQQA2AowLAkAgA0UNACADEIYBCyAAQeAKahC3BxogAEHICmoQ5AcaIAQQ5AcaAkAgACgCsAoiA0UNACAAQbQKaiADNgIAIAMQhgELIABBpApqEJAFGgJAIAAoApgKIgNFDQAgAEGcCmogAzYCACADEIYBCwJAIAAoAowKIgNFDQAgAEGQCmogAzYCACADEIYBCyAAQYAKahDlBxoCQCAAKAL0CSIDRQ0AIABB+AlqIAM2AgAgAxCGAQsCQCAAKALoCSIDRQ0AIABB7AlqIAM2AgAgAxCGAQsCQCAAKALcCSIDRQ0AIAAgAzYC4AkgAxCGAQsgABDmByEDIAFBIGokACADDwsCQCADKAIAIgVFDQAgBSAFKAIAKAIEEQAACyADQQRqIQMMAAsACwJAIAMoAgAiBSAARg0AIAVFDQAgBSAFKAIAKAIEEQAACyADQQRqIQMMAAsLBABBAQtDAQF/AkACQCABQXZqIgJBHEsNAEEBIAJ0QYuAgIABcQ0BCyABQX9qQQJJDQAgAUHbAEYNACABQZkDRg0AQQAPC0EBCz0AIAAgASACEJUHIQICQAJAAkAgAUF5ag4CAAECCyAAIAAqAsgBOAKgCyACDwsgACAAKgLMATgCpAsLIAILbAACQAJAAkACQAJAIAFBdWoOAgECAAsgAUHsAUYNAiABQccERw0DIAAgAhCDBTYC1AlBAQ8LIAAgAhDTBzgCyAlBAQ8LIAAgAhDTBzgCzAlBAQ8LIAAgAhCDBTYC0AlBAQ8LIAAgASACENQHC70JAg1/An0CQCABKAIAIAEoAgQQlwciAg0AQQEPCwJAAkACQCAAIAEQmAcNACACIAIoAnwiA0EBajYCfCACQQhqIQQCQCACQQxqKAIAIgUNAAwCCwJAAkAgBWkiAUEBSw0AIAVBf2ogA3EhBgwBCyADIQYgAyAFSQ0AIAMgBXAhBgsgBCgCACAGQQJ0aigCACIHRQ0BIAVBf2ohCCABQQFLIQkDQCAHKAIAIgdFDQICQCAHKAIEIgEgA0YNAAJAAkAgCQ0AIAEgCHEhAQwBCyABIAVJDQAgASAFcCEBCyABIAZHDQMLIAcoAgggA0cNAAwDCwALIAIgAigCfEEBajYCfEEBDwtBEBCIASIHIAM2AgggByADNgIEIAdBADYCACAHQQxqQQA2AgAgAkEQaiEKIAJBGGoqAgAhDyACQRRqKAIAQQFqsyEQAkACQCAFRQ0AIA8gBbOUIBBdRQ0BCyAFQQF0IAVBA0kgBSAFQX9qcUEAR3JyIQECQAJAIBAgD5WNIg9DAACAT10gD0MAAAAAYHFFDQAgD6khBQwBC0EAIQULQQIhBgJAIAEgBSABIAVLGyIBQQFGDQACQCABIAFBf2pxDQAgASEGDAELIAEQ/QQhBgsCQAJAAkACQCAGIAIoAgwiBUsNACAGIAVPDQMgBUEDSSEJAkACQCACKAIUsyACKgIYlY0iD0MAAIBPXSAPQwAAAABgcUUNACAPqSEBDAELQQAhAQsCQAJAIAkNACAFaUEBSw0AIAFBAUEgIAFBf2pna3QgAUECSRshAQwBCyABEP0EIQELAkAgBiABIAYgAUsbIgYgBUkNACACKAIMIQUMBAsgBkUNAQsCQCAGQYCAgIAETw0AIAQgBkECdBCIARCZByACIAY2AgxBACEBAkADQAJAIAEgBkcNACAKKAIAIggNAgwFCyAEKAIAIAFBAnRqQQA2AgAgAUEBaiEBDAALAAsgCCgCBCELAkACQCAGaSIBQQFLDQAgCyAGQX9qcSELDAELIAsgBkkNACALIAZwIQsLIAQoAgAgC0ECdGogCjYCACAGQX9qIQwgAUEBSyENA0AgCCgCACIFRQ0DIAUoAgQhAQJAAkAgDQ0AIAEgDHEhAQwBCyABIAZJDQAgASAGcCEBCwJAIAEgC0YNAAJAIAQoAgAgAUECdCIJaiIOKAIADQAgDiAINgIAIAEhCwwBCyAIIAUoAgA2AgAgBSAEKAIAIAlqKAIAKAIANgIAIAQoAgAgCWooAgAgBTYCAAwBCyAFIQgMAAsACxCMBQALQQAhBSAEQQAQmQcgAkEANgIMDAELIAYhBQsCQCAFIAVBf2oiAXENACABIANxIQYMAQsCQCADIAVPDQAgAyEGDAELIAMgBXAhBgsCQAJAAkAgBCgCACAGQQJ0IgZqKAIAIgENACAHIAooAgA2AgAgCiAHNgIAIAQoAgAgBmogCjYCACAHKAIAIgFFDQIgASgCBCEBAkACQCAFIAVBf2oiBnENACABIAZxIQEMAQsgASAFSQ0AIAEgBXAhAQsgBCgCACABQQJ0aiEBDAELIAcgASgCADYCAAsgASAHNgIACyACIAIoAhRBAWo2AhQLIAdBDGogADYCAEEACx0AAkAgACABQRcQ0gciAQ0AQQAPCyABQQxqKAIAC1EBAX9BASECAkACQAJAIABBASAAKAIAKAIMEQIARQ0AIAAgABCbCAwBCyABKAIAIAEoAgQQhwUiAUUNASABQQRqKAIAIAAQuQsLQQAhAgsgAgsfAQF/IAAoAgAhAiAAIAE2AgACQCACRQ0AIAIQhgELCwIACwIACw8AIAAgAC8BJEEEcjsBJAvlBAEJfyAAIAEQngcCQCABQQhxRQ0AIAAgAC0AsAtBAWo6ALALIABBnApqKAIAIQIgACgCmAoiAyEEA0ACQCAEIAJHDQAgAEEANgKECyAAQZAKaigCACEFIAAoAowKIQZBACEHQQAhCANAAkAgBiAFRw0AAkADQCADIAJGDQECQCADKAIAIgQoAkQiCUUNACAEKAJAIQYCQAJAAkAgBC0APA4CAAEDCwJAIAYoArwBIgVFDQAgBSAJNgLAASAJIAU2ArwBCwJAIAYgB0cNACAAIAk2AoQLIAkhBwsgBiAEKAJIIgQ2ArwBIARBwAFqIQQMAQsCQCAGKALAASIFRQ0AIAUgBCgCSCIKNgK8ASAKIAU2AsABCwJAIAYgCEcNACAEKAJIIQgLIAYgCTYCwAEgCUG8AWohBAsgBCAGNgIACyADQQRqIQMMAAsACyAAIAg2AoQLDAQLAkACQCAGKAIAIgQoArgBIglFDQAgCSgCSCIJRQ0AAkAgCSgCRA0AIAkgBDYCRCAJIAQ2AkggBEIANwK8AQwCCyAJKAJIIgogBDYCwAEgBCAKNgK8ASAJIAQ2AkggBEEANgLAAQwBCyAEQQA2AsABIAQgCDYCvAECQAJAIAgNACAAIAQ2AoQLIAQhBwwBCyAIIAQ2AsABCyAEIQgLIAZBBGohBgwACwALIAQoAgBCADcCRCAEQQRqIQQMAAsACwJAIAFBgBBxRQ0AIAAgACgC/AEiBCAALQD0AhCfByAEIAAoAvACEKAHIAAQoQcQogcgABCjB0UNACAALQCoC0H/AXFFDQAgABCkByAAEKUHCwvlAwICfwJ9IwBBMGsiAiQAIAAgARDMGAJAAkACQCABQf7/A0cNACAAEM0YRQ0BIAAgAEHIAkGkAiAALQDsAhtqIgMpAhQ3AoQCIABBjAJqIANBHGopAgA3AgAgACAAKAIAKALMAREAAAwBCyABQYACcUUNAQsgACAAKAIAKAJMEQwAIQQgACgC6AEgACgC7AEgBBDOGAsCQCABQYABcUUNACAAKAIYIgNFDQACQAJAIANB2wAgAygCACgCDBECAEUNACACQShqIAAoAhgiA0HYAGopAgA3AwAgAkEgaiADQdAAaikCADcDACACIAMpAkg3AxgMAQsgAkEoakEAKQLYsRM3AwAgAkEgakEAKQLQsRM3AwAgAkEAKQLIsRM3AxggACgCGCEDCyAAQYgCaioCACEEIAAqAoQCIQUCQCADQQEgAygCACgCDBECAEUNACAEIAAoAhgiA0GQAmoqAgAgAyoCzAmUkyEEIAUgA0GMAmoqAgAgAyoCyAmUkyEFCyACIAQ4AhQgAiAFOAIQIAJCgICAgICAgMA/NwIIIAJCgICA/AM3AgAgAEHIAGogAkEYaiACEJMFIAAgACgCACgCXBEAAAsCQCABQZARcUUNACAAIAAoAgAoArwBEQAACyACQTBqJAALOAEBf0EAIQICQCAARQ0AAkACQCAALQC0AUF/ag4CAAECCyABIQIMAQsgACgCuAEhAgsgAkH/AXELNgEBf0EAIQICQCAARQ0AAkACQCAALQC0AUF/ag4CAAECCyABIQIgAQ0BCyAAKALkAiECCyACC00CAX0Bf0MAAAAAIQECQCAAKAL8ASICRQ0AAkACQAJAIAItALQBQX9qDgIAAQMLIABB+AJqIQAMAQsgAkHAAWohAAsgACoCACEBCyABC7ABAQJ/AkACQCAAKAL8ASIERQ0AIAQtALQBQQFGDQELQwAAAAAhA0EAIQFBACECCyAAIAM4AvgCIAAgAjYC8AIgACABOgD0AiAAQTxqKAIAIQQgACgCOCECAkADQCACIARGDQECQCACKAIAIgFBmQMgASgCACgCDBECAEUNACABIAAoAvwBIgUgAC0A9AIQnwcgBSAAKALwAhCgByAAEKEHEKIHCyACQQRqIQIMAAsACwvHAQEDfwJAIABBmAtqKAIAIgFFDQAgAEGUC2ohAgNAAkAgAigCACICDQAgACgCmAtFDQIgACgClAsQ0AcgAEEANgKUCyAAQZALaigCACECQQAhAwNAAkAgAyACRw0AIABBADYCmAsMBAsgACgCjAsgA0ECdGpBADYCACADQQFqIQMMAAsACwJAIAIoAggiAyADKAIAKAIIEQEAQQFHDQACQCADIABHDQAgABDRBwwCCyADEKMHGgwBCyADENEHDAALAAsgAUEARwuTBAMDfwV9AX4jAEHQAGsiASQAIAAqAswBIQQgACoCyAEhBSAAKAKAAiEAIAFBADYCDCABIAFBDGo2AhQgAEEDIAFBFGoQnRkgAUEUakEAQTgQOhpBAEEAKALs3xtBAWo2AuzfGyAAEJ4ZQQIhAgJAAkAgAEECIAUQnxlFDQAgACkCvAQiCae+IQZDAADAfyEHAkACQAJAIAlCIIinQX9qDgIAAQILIAYhBwwBCyAFIAaUQwrXIzyUIQcLIAcgAEECIAUQoBmSIQdBASECDAELIABB2AFqKAIAIAUQoRkiByAHWw0AIAUgBVshAiAFIQcLAkACQCAAQQAgBBCfGUUNACAAQcQEaikCACIJp74hCEMAAMB/IQYCQAJAAkAgCUIgiKdBf2oOAgABAgsgCCEGDAELIAQgCJRDCtcjPJQhBgsgBiAAQQAgBRCgGZIhBkEBIQMMAQtBAiEDIABB3AFqKAIAIAQQoRkiBiAGWw0AIAQgBFshAyAEIQYLAkAgACAHIAZBACACIAMgBSAEQQFBACAAKAK4BCABQRRqQQBBACgC7N8bEKIZRQ0AIAAgAEGsAmotAAAQoxkgBSAEIAUQpBkgACAAKAK4BCoCFLtEAAAAAAAAAABEAAAAAAAAAAAQpRkLIAFBADYCDCABIAFBFGo2AhAgASABQQxqNgJMIABBBCABQcwAahCdGSABQdAAaiQAC7cFAwZ/A34CfSMAQRBrIgEkAAJAIAAoAoACIgItAAQiA0EBcUUNACACIANB/gFxOgAEIABBPGooAgAhBCAAKAI4IQMCQANAIAMgBEYNAQJAAkAgAygCACIFQZkDIAUoAgAoAgwRAgBFDQAgBRClBwwBCyAFQcQDIAUoAgAoAgwRAgBFDQAgBSgC0AEiBUUNACAFEKUHCyADQQRqIQMMAAsACyACQZwCaikCACEHIAJBpAJqKQIAIQggAkH0AWoqAgAhCiACKQLkASEJIAEgAkH4AWoqAgAiCzgCDCABIAo4AgggASAJNwIAIABBnAJqIAg3AgAgACAHNwKUAgJAAkACQCAAEM0YRQ0AIAEgAEHIAmoiBSAAQaQCaiIDIAAtAOwCIgIbIgRBFGoQgRlFDQIgAyAFIAQqAgAiCkMAAAAAWyIGGyEDIApDAAAAAFwhBAJAIAYNACACRQ0AIAAgACoCyAI4AqQCIABBsAJqIABB1AJqKQIANwIAIABBqAJqIABBzAJqKQIANwIAIABBuAJqIABB3AJqKQIANwIAIABBwAJqIABB5AJqKQIANwIAQQEhBCAFIQMLIAAgBDoA7AIgAyAAKQKEAjcCBCADQQxqIABBjAJqKQIANwIAIANBHGogAUEIaikCADcCACABKQIAIQcgA0EANgIAIAMgBzcCFAwBCyABIABBhAJqIgMQgRlFDQECQAJAIABBjAJqKgIAIApcDQAgAEGQAmoqAgAgC1sNAQsgAEEQQQAQvQcaCyADIAEpAgA3AgAgA0EIaiABQQhqIgMpAgA3AgAgAEHAAmogAykCADcCACAAQbgCaiABKQIANwIACyAAIAAoAgAoAswBEQAAIAAQrBcLIAAtAJwJRQ0AIAAgACAAKAIAKAJAEQEAEN4YIABBADoAnAkLIAFBEGokAAsKACAALwEkQQFxCwgAIAAqAogBCwIACwgAIAAqAoQCCwsAIABBiAJqKgIACzsBAn0gAUGMAmoqAgAhAiABQZACaioCACEDIABCADcCACAAIANDAAAAAJI4AgwgACACQwAAAACSOAIICwIACwIACwkAIAAgARCfBQuiAgIBfwR9IwBBMGsiAyQAIANBGGpBEGogAkEQaikCADcDACADQRhqQQhqIAJBCGopAgA3AwAgAyACKQIANwMYAkAgAC0AiQtFDQAgAEGMAmoqAgAhBCAAQZACaioCACEFIAAqAsgJIQYgACoCzAkhByADQoCAgICAgIDAPzcCCCADQoCAgPwDNwIAIAMgBSAHlDgCFCADIAQgBpQ4AhAgA0EYaiADELAHGgsCQAJAIAAoAoQLIgINAEEAIQAMAQsDQCACIgAoArwBIgINAAsLAkADQAJAIAANAEEAIQIMAgsCQCAAIAAoAgAoAowBEQEADQAgACABIANBGGogACgCACgCiAERBAAiAg0CCyAAKALAASEADAALAAsgA0EwaiQAIAILUgEBfyMAQSBrIgIkACACQQhqIAAgARCTBSAAQRBqIAJBCGpBEGopAgA3AgAgAEEIaiACQQhqQQhqKQIANwIAIAAgAikCCDcCACACQSBqJAAgAAsEAEEACwQAIAALBwAgACgCIAsQACAAIAAoAgAoAowBEQEAC4EDAgN/BH0jAEHQAGsiASQAIABBjAJqKgIAIQQgACoCyAkhBSABIAAqAswJIABBkAJqKgIAIgaMlCIHOAIkIAEgBiAHkjgCLCABIAUgBIyUIgU4AiAgASAEIAWSOAIoAkACQCAALQCJC0UNACABIAY4AhwgASAEOAIYIAFCADcCEAwBCyABQRBqQQhqIAFBIGpBCGopAgA3AwAgASABKQIgNwMQCyAAKAKACyECIAFBOGpCADcDACABQcAAakIANwMAIAFCADcDMCABQQA6AEwgAUEwaiABQRBqELYHIAFBDGogAiABQTBqQQAgAigCACgCFBEHACABQTBqELcHGiABKAIMIQIgAUEANgIMIABB0AdqIAIQuAcgASgCDBC5ByAAQfwKakEAOgAAIABB5ApqIAAoAuAKNgIAIABB8ApqIABB7ApqKAIANgIAIABB4ApqIgIgAUEgahC2ByAAKALMByIDIAMoAgAoAggRAAAgAiAAKALMBxC6ByABQdAAaiQAC88BAQR/IwBBIGsiAiQAIABBBRDcDQJAIABBFGoiAygCACAAKAIMIgRrQQVLDQAgAEEQaigCACEFIAJBDGpBEGogAzYCACACQQYQiAEiAzYCDCACIAMgBSAEa2oiBDYCFCACIANBBmo2AhggAiAENgIQIABBDGogAkEMahDMHSACQQxqEM0dGgsgACABKgIAIAEqAgQQoBYgACABKgIIIAEqAgQQoRYgACABKgIIIAEqAgwQoRYgACABKgIAIAEqAgwQoRYgABCjFiACQSBqJAALJQEBfwJAIAAoAgwiAUUNACAAQRBqIAE2AgAgARCGAQsgABDoBwsXAQF/IAAoAgAhAiAAIAE2AgAgAhC5BwsvAQF/AkAgAEUNACAAIAAoAgQiAUF/ajYCBCABQQFHDQAgACAAKAIAKAIEEQAACwuqAwMFfwJ+A30jAEEQayICJAAgACgCACEDIAAoAgwhBCACQQhqIAAQ2A0gAigCCCEFAkADQCAEIgAgBUYNASADIAAtAAAiBkEYdEEYdUECdEGE/RJqKAIAQQN0aiEEAkACQAJAAkACQAJAIAYOBgABBAUCAwULIAEgBCkCACIHp74gB0IgiKe+IAEoAgAoAhQREwAMBAsgASAEKQIIIgenviAHQiCIp74gASgCACgCGBETAAwDCyABIAQpAggiB6e+IAdCIIinviAEKQIQIgenviAHQiCIp74gBCkCGCIHp74gB0IgiKe+IAEoAgAoAhwRJwAMAgsgASABKAIAKAIgEQAADAELIAEgBCkCCCIHp74iCSAEKQIAIginviIKk0Orqio/lCAKkiAHQiCIp74iCyAIQiCIp74iCpNDq6oqP5QgCpIgCSAEKQIQIgenviIKk0Orqio/lCAKkiALIAdCIIinviIJk0Orqio/lCAJkiAKIAkgASgCACgCHBEnAAsgAEEBaiEEIAMgACwAAEECdEGkghJqKAIAQQN0aiEDDAALAAsgAkEQaiQACwQAQQELJAAgAEEQQQAQvQcaAkAgACgCrAsQvgdFDQAgACgCrAsQvwcLC38BAn8CQCAALwEkIgMgAXEiBCABRg0AIAAgAyABciIDOwEkIAAgAyAAKAIAKAI4EQMAIABBNGooAgAgACgCHBDBCyACRQ0AIABBLGooAgAhAiAAKAIoIQADQCAAIAJGDQEgACgCACABQQEQvQcaIABBBGohAAwACwALIAQgAUcLHAACQCAADQBBAA8LIABBxAMgACgCACgCDBECAAsXAAJAIABBwABBABC9B0UNACAAEKwXCwsCAAsCAAsCAAsCAAs0AQF/QQAhAgJAIABB4AlqKAIAIAAoAtwJIgBrQQJ1IAFNDQAgACABQQJ0aigCACECCyACCwIACwQAQQELFgAgAEGkfmoiACAAKAIAKAKMAREBAAsLACAAQcB+aigCAAsLACAAQaB+ahCRBwsLACAAQaB+ahCQBwsLACAAQYh+ahCRBwsLACAAQYh+ahCQBwsLACAAQah2ahCRBwsLACAAQah2ahCQBwsvAQF/QQAhAgJAIAAoAgggACgCBCIAa0ECdSABTQ0AIAAgAUECdGooAgAhAgsgAgsiAQF/AkADQCAARQ0BIAAoAgAhASAAEIYBIAEhAAwACwALC+EWAgp/BH0jAEGQAWsiASQAAkAgACgC/AEiAkUNACAAKAKAAiEDAkACQAJAIAItAOwBRQ0AIABBPGooAgAhBCAAKAI4IQIDQCACIARGDQIgAigCACIFQZkDIAUoAgAoAgwRAgANASACQQRqIQIgBUHEAyAFKAIAKAIMEQIARQ0ACwsgA0EAEJQZDAELIAMgADYCACADQY0EEJQZCyAAKgLMASELIAAqAsgBIQwgACgC/AEiAigCrAEhBCACKAL0ASEGIAIoAqgBIQcgAigC8AEhAgJAAkAgABCWGQ0AQQEhBQwBCyAAEJYZQfwBaigCABCTGSEFCwJAIAAgACgCACgCwAERAQBFDQAgACoCtAkiDSANXCEFIAAqAqwJIg4gDlwhCCAALQC8CSEJAkACQAJAAkAgACgCsAkiCkEBag4FAwIBAQACC0ECQQEgAC0AvQkbIQdBAyECDAILQQAhBwsgCiECCyALIA0gBRshCyAMIA4gCBshDCAJQQBHIQUCQAJAAkAgACgCuAkiCEEBag4FAwIBAQACC0ECQQEgAC0AvgkbIQRBAyEGDAILQQAhBAsgCCEGCwJAAkAgACoCwAkiDSANXA0AIAFBjAFqIA1DAAAAACANQwAAAABeG0EBEOkYIQIMAQsgAUGIAWogDEMAAAAAIAxDAAAAAF4bIAIQ6RghAgsgA0H8BWogAigCADYCAAJAAkAgACoCxAkiDSANXA0AIAFBhAFqIA1DAAAAACANQwAAAABeG0EBEOkYIQYMAQsgAUGAAWogC0MAAAAAIAtDAAAAAF4bIAYQ6RghBgsgA0HMBGohAiADQYAGaiAGKAIANgIAAkACQAJAAkAgB0H/AXEOAwABAgMLAkAgBUUNACADQdQEakIANwIAIANB3ARqIAFB/ABqIAAoAvwBKgKcAUEDEOkYKAIANgIADAMLIAFBDTYCeCABIAI2AnQgAUH0AGpBABDkGBoMAgsCQCAFRQ0AIANB1ARqIAAqAtQBOAIAIANB2ARqIAAqAtQBOAIAIANB3ARqIAFB8ABqIAAoAvwBIgcqApwBIAcoAqABEOkYKAIANgIADAILIAFBDTYCeCABIAI2AnQgAUH0AGpBBBDkGBoMAQsCQCAFRQ0AIANB1ARqQgA3AgAgA0HcBGogAUHsAGogACgC/AEqApwBQQMQ6RgoAgA2AgAMAQsgAUENNgJ4IAEgAjYCdCABQfQAakEAEOQYGgsCQAJAAkACQCAEQf8BcQ4DAAECAwsCQCAFDQAgA0HUBGpCADcCACADQdwEaiABQegAaiAAKAL8ASoCnAFBAxDpGCgCADYCAAwDCyABQQ02AnggASACNgJ0IAFB9ABqQQAQ5BgaDAILAkAgBQ0AIANB1ARqIAAqAtgBOAIAIANB2ARqIAAqAtgBOAIAIANB3ARqIAFB5ABqIAAoAvwBIgUqApwBIAUoAqABEOkYKAIANgIADAILIAFBDTYCeCABIAI2AnQgAUH0AGpBBBDkGBoMAQsCQCAFDQAgA0HUBGpCADcCACADQdwEaiABQeAAaiAAKAL8ASoCnAFBAxDpGCgCADYCAAwBCyABQQ02AnggASACNgJ0IAFB9ABqQQAQ5BgaCyAAKAL8ASIEEJMZIQUCQCAELQCwASIEQQtLDQACQAJAAkBBASAEdCIEQYcEcQ0AIARBuAhxRQ0CIAVFDQEgAUEKNgJ4IAEgAjYCdCABQfQAakECEOQYGiABQQc2AnggASACNgJ0IAFB9ABqQQIQ5BgaDAMLAkAgBUUNACABQQo2AnggASACNgJ0IAFB9ABqQQEQ5BgaIAFBBzYCeCABIAI2AnQgAUH0AGpBARDkGBoMAwsgAUEENgJ4IAEgAjYCdCABQfQAakEAEJcZGgwCCyABQQQ2AnggASACNgJ0IAFB9ABqQQEQlxkaDAELAkAgBUUNACABQQo2AnggASACNgJ0IAFB9ABqQQMQ5BgaIAFBBzYCeCABIAI2AnQgAUH0AGpBAxDkGBoMAQsgAUEENgJ4IAEgAjYCdCABQfQAakECEJcZGgsCQAJAAkACQAJAIAAoAvwBLQCwAQ4MAAECAAECAAECAwMDBAsCQCAFRQ0AIAFBBDYCeCABIAI2AnQgAUH0AGpBABCXGRoMBAsgAUEKNgJ4IAEgAjYCdCABQfQAakEBEOQYGiABQQc2AnggASACNgJ0IAFB9ABqQQEQ5BgaDAMLAkAgBUUNACABQQQ2AnggASACNgJ0IAFB9ABqQQEQlxkaDAMLIAFBCjYCeCABIAI2AnQgAUH0AGpBAhDkGBogAUEHNgJ4IAEgAjYCdCABQfQAakECEOQYGgwCCwJAIAVFDQAgAUEENgJ4IAEgAjYCdCABQfQAakECEJcZGgwCCyABQQo2AnggASACNgJ0IAFB9ABqQQMQ5BgaIAFBBzYCeCABIAI2AnQgAUH0AGpBAxDkGBoMAQsgAUEENgJ4IAEgAjYCdCABQfQAakEDEJcZGgsgA0GEBmogAUHcAGogACgC/AEiBSoCSCAFKALAAhDpGCgCADYCACADQYgGaiABQdgAaiAAKAL8ASIFKgJMIAUoAsQCEOkYKAIANgIAIANBjAZqIAFB1ABqIAAoAvwBIgUqAkAgBSgCyAIQ6RgoAgA2AgAgA0GQBmogAUHQAGogACgC/AEiBSoCRCAFKALMAhDpGCgCADYCACADQfAFaiABQcwAaiAAKAL8ASIFKgI4IAUoArgCEOkYKAIANgIAIANB9AVqIAFByABqIAAoAvwBIgUqAjwgBSgCvAIQ6RgoAgA2AgAgA0HMBWogAUHEAGogACgC/AEiBSoCUCAFKAL4ARDpGCgCADYCACADQdQFaiABQcAAaiAAKAL8ASIFKgJUIAUoAvwBEOkYKAIANgIAIANB0AVqIAFBPGogACgC/AEiBSoCWCAFKAKAAhDpGCgCADYCACADQdgFaiABQThqIAAoAvwBIgUqAlwgBSgChAIQ6RgoAgA2AgAgA0HgBGogAUE0aiAAKAL8ASIFKgJgIAUoAogCEOkYKAIANgIAIANB6ARqIAFBMGogACgC/AEiBSoCZCAFKAKMAhDpGCgCADYCACADQeQEaiABQSxqIAAoAvwBIgUqAmggBSgCkAIQ6RgoAgA2AgAgA0HsBGogAUEoaiAAKAL8ASIFKgJsIAUoApQCEOkYKAIANgIAIANBqAVqIAFBJGogACgC/AEiBSoCcCAFKAKYAhDpGCgCADYCACADQbAFaiABQSBqIAAoAvwBIgUqAnQgBSgCnAIQ6RgoAgA2AgAgA0GsBWogAUEcaiAAKAL8ASIFKgJ4IAUoAqACEOkYKAIANgIAIANBtAVqIAFBGGogACgC/AEiBSoCfCAFKAKkAhDpGCgCADYCACADQYQFaiABQRRqIAAoAvwBIgUqAoABIAUoAqgCEOkYKAIANgIAIANBjAVqIAFBEGogACgC/AEiBSoChAEgBSgCrAIQ6RgoAgA2AgAgA0GIBWogAUEMaiAAKAL8ASIFKgKIASAFKAKwAhDpGCgCADYCACADQZAFaiABQQhqIAAoAvwBIgUqAowBIAUoArQCEOkYKAIANgIAIAMgACgC/AEiBSgCxAFBfxCYGXRBf3MiBHFBFnQgAygCzAQgBEEWdEF/c3FyIgQ2AswEIAMgBSgCyAFBfxCZGXRBf3MiB3FBEHQgBCAHQRB0QX9zcXI2AswEIANB0ARqIAUqApABOAIAIAAoAvwBKALMASEFIAFBAjYCeCABIAI2AnQgAUH0AGogBRDjGBogAyAAKAL8ASgC5AFBfxCaGXRBf3MiAHFBEnQgAygCzAQgAEESdEF/c3FyNgLMBCADQRhqIAJBzAEQOxoLIAFBkAFqJAALvwEBBX8CQCABRQ0AIAJB//8DcSEDAkACQCABaSIEQQFLDQAgAUF/aiADcSEFDAELIAMhBSADIAFJDQAgAyABcCEFCyAAIAVBAnRqKAIAIgBFDQAgAUF/aiEGIAJB//8DcSEHIARBAUshBANAIAAoAgAiAEUNAQJAIAAoAgQiAiADRg0AAkACQCAEDQAgAiAGcSECDAELIAIgAUkNACACIAFwIQILIAIgBUcNAgwBCyAALwEIIAdHDQALIAAPC0EAC00CAn8BfQJAAkAgACgCACAAKAIEaiIBIAAoAggiAmtBA0sNACAAQQE6AAxDAAAAACEDDAELIAJBBGohASACKgAAIQMLIAAgATYCCCADC5wBAAJAAkACQAJAAkACQAJAIAFBeWoOAgECAAsCQCABQb56ag4CBAUACyABQe4DRg0CIAFBxAFHDQUgACACENUHOgDEAUEBDwsgACACENMHOALIAUEBDwsgACACENMHOALMAUEBDwsgACACEIMFNgLQAUEBDwsgACACENMHOALUAUEBDwsgACACENMHOALYAUEBDwsgACABIAIQ1gcLCgAgABDbC0EBRgs8AAJAAkAgAUGBAUYNACABQRdHDQEgACACEIMFNgKkAUEBDwsgACACEIMFNgKoAUEBDwsgACABIAIQ1wcLOgACQAJAAkAgAUFzag4CAAECCyAAIAIQ0wc4ApwBQQEPCyAAIAIQ0wc4AqABQQEPCyAAIAEgAhDYBwtJAAJAAkACQAJAIAFBcWoOAwABAgMLIAAgAhDTBzgCYEEBDwsgACACENMHOAJkQQEPCyAAIAIQ0wc4AmhBAQ8LIAAgASACENkHCyIAAkAgAUESRw0AIAAgAhDTBzgCREEBDwsgACABIAIQ2gcLYAECfyMAQRBrIgMkAEEAIQQCQAJAAkACQCABQXxqDgIAAQMLIANBBGogAhCEBSAAQQhqIANBBGoQ2wcgA0EEahCFBRoMAQsgACACEIMFNgIUC0EBIQQLIANBEGokACAECz8AAkAgACwAC0F/Sg0AIAAoAgAQhgELIAAgASkCADcCACAAQQhqIAFBCGooAgA2AgAgAUEAOgALIAFBADoAAAuQDgIKfwF+IwBBwANrIgIkAEEAIQNBACgCgNkbIQQCQAJAAkAgAUUNACAEDQEgAkHoAmpCADcDACACQeACakIANwMAIAJCADcD2AJB4AcQiAFBAEHgBxA6IQQgAkGA9wI2AvgCIAJCgYCAgCA3A/ACIAJB/AJqQQBBOBA6GiACKQKsAyEMIAQgAigCqAM2AtAHIAIoAowDIQMgBCAMNwLUByAEIAM2AswHIARBqAdqIgUgAkHYAmpBOGoQ7ggaIAQgAigC3AIiAzYCiAQCQAJAAkACQCADDQAgAigCpAMNAAJAAkAgBEGsB2ooAgAiA0UNACAEQcAYIAQoAqgHIAMRAgAiAzYCiAQgA0UNAyACQQE2AoQBIAJBlAFqQQBBOBA6GiACQQQ2AswBIAJB3AFqQQBB/AAQOhogAkHUAWpBBTYCACACQdgBaiACKAL0AjYCACACIAQ2AqwBIAJBgQI7AZwBIAIgAigC4AI2AtABIAIgAigC+AI2AogBIAIgAigC6AI2AqQBIAIgAikC/AI3AowBIAIgAigC5AIiAUGOBCABGzYCoAECQAJAIAIoAtgCIgENACACQQRqQQRqQQBB/AAQOhogAkEcaiAFQQhqKQIANwIAIAIgBSkCADcCFCACIAIoAuwCNgIEIAJBBGogAkGEAWogAxCyCSEDDAELIAEgAkGEAWogAxCxCSEDCyADRQ0BIAQoAogEIAUQ7QcLIARBADYCiAQMAgsgBEEBOgC5ByAEKAKIBCEDCwJAAkAgAw0AIAIoAvgCIQYgAigC9AIhAQwBCyACIANBvAdqKAIAIgE2AvQCIAIgAygCCCIGNgL4AgsgAUUNACAGRQ0AIAQgBjYCkAQCQCACKALsAiIGDQAgA0UNAAJAIAMoAgAiAw0AQQAhBgwBCyADKAI4IQYLIAQgBjYCjAQgAiABrUKAgICAgDyENwO4AyACIAIoAvwCIgNB//8DIANB//8DSRsiATsBvAMgBEEAQYgEEDoiAyABQeADIAEbOwGABCACQgA3ApQBIAJB/wE2ApABIAJCgICAgPAfNwKIASACQeiUGzYChAEgAiACQbgDajYCmAECQCADIAJBhAFqIAUgAxCACyIGDQAgAkH/ATYCECACQoCAgIDwHzcCCCACQfiUGzYCBCACIAJBuANqNgIYIAIgAkG4A2o2AhQCQCADIAJBBGogBSADQYACaiIHEIALIgZFDQAgAyAFEPMHDAELAkACQCACKALwAiIBDQBBASEBIAJBATYC8AIMAQtBfiEGIAFBBEsNAQtBACEIA0ACQAJAAkAgCCABTw0AQX4hBiADKAK0AkUNASADKAK8Ai0ABSIJRQ0BAkAgCUEHakH4A3EiCg0AQQAhCwwDCyAKIAUQ0ggiCw0CQXwhBgwBCyADIAIoAoQDIgE2AsgHAkAgAQ0AIAMgAigCiAMiAUEIIAEbIAMoApAEbEHoB242AsgHCyADQgA3ArwHIAIoAqADDQUgAygCiAQiAUUNBQJAIAEoAgwNAEF9IQYMAQsgASgCDEECRg0FIAFBAzYCDAJAAkAgASgCACIGEO4HRQ0AAkAgBigCGCIGDQBBfSEGDAILIAEgBhEBACIGDQEgAUECNgIMIAEQuAkMBwsgAUEBNgI4IAFBhAFqEO8HIAEoAqACIgZFDQYLIAFBATYCDAtBACEBAkADQCABIAMoApQETw0BIAMgAUHkAGxqQZgEaiAFEPIHIAFBAWohAQwACwALIAcgBRDzBwwCCyADIAhB5ABsaiIGQZgEakEAQeQAEDohASAGQfgEaiALNgIAAkAgC0UNACAKRQ0AIAtBACAKEDoaCyABQgA3AiQgAUKAgICAgICAwD83AhwgAUKAgICA4Mzp1cMANwIUIAFC2p+khqT7w+TAADcCDCABQgA3AgQgASAJNgIAIAFBLGpCADcCACABQTRqQgA3AgAgAUE8akEANgIAIAZB3ARqQgA3AgAgBkHYBGpBgICA/Hs2AgAgBkHkBGpCADcCACAGQewEakKAgICAEDcCACABIAs2AgQCQAJAIAlBAkcNACALQYsYOwAADAELQQAgCyAJIAkQ9wgLIAZB9ARqQQE2AgAgAyADKAKUBEEBajYClAQgCEEBaiEIIAIoAvACIQEMAAsACwJAIAMtALkHRQ0AIAMoAogEEOwHIAMoAogEIAUQ7QcLIAZFDQELQZfrEEEqQQFBwJ4bED4aIAQQhgFBACEEDAELQTgQiAEiBEEBNgIAIAMoAogEIQEgBCADNgIIIAQgATYCBCAEQQxqQQBBLBA6GgtBACEDQQAoAoDZGyEBQQAgBDYCgNkbIAFFDQAgARDnB0EAKAKA2RshBAsgBEUNAQsgBCAEKAIAQQFqNgIAIAQhAwsgACADNgIAIAJBwANqJAALDwACQBC9NkUNABDFLQALC/ACAQZ/AkAgACgCBCICIAAoAghGDQACQCABRQ0AIAEgASgCAEEBajYCAAsgAiABNgIAIAAgAkEEajYCBA8LAkACQCACIAAoAgAiA2siBEECdSIFQQFqIgZBgICAgARPDQACQAJAIARBAXUiByAGIAcgBksbQf////8DIARB/P///wdJGyIEDQBBACEHDAELIARBgICAgARPDQIgBEECdBCIASEHCyAEQQJ0IQQgByAFQQJ0aiEGAkAgAUUNACABIAEoAgBBAWo2AgAgACgCACEDIAAoAgQhAgsgByAEaiEHIAYgATYCACAGIQECQANAIAIgA0YNASACQXxqIgIoAgAhBCACQQA2AgAgAUF8aiIBIAQ2AgAMAAsACyAAIAc2AgggACgCACEEIAAgATYCACAAKAIEIQIgACAGQQRqNgIEAkADQCACIARGDQEgAkF8ahD0ByECDAALAAsCQCAERQ0AIAQQhgELDwsQAAALEIwFAAvwAQEDfyMAQRBrIgIkAAJAIAEoAgAiAygCyAoiBEUNACAEIAQoAgBBAWo2AgAgASgCACEDCyACIAQ2AgwCQCADKALMCiIDRQ0AIAMgAygCAEEBajYCACACKAIMIQQLIAIgAzYCCAJAIARFDQAgBEHMCmogAkEIahDhBxogAigCCCEDCwJAIANFDQAgA0HICmogAkEMahDhBxoLAkAgACgCNCABKAIAIgRHDQAgAEE0aiACQQxqEOEHGiABKAIAIQQLIARByApqQQAQ6gcgASgCAEHMCmpBABDqByACKAIIEOAHIAIoAgwQ4AcgAkEQaiQAC0oBAX8CQCAARQ0AIAAgACgCACIBQX9qNgIAIAFBAUcNACAAEOkHIABBzApqEPQHGiAAQcgKahD0BxogAEHACmoQmwUaIAAQhgELCzgAAkAgACABRg0AAkAgASgCACIBDQAgAEEAEOoHIAAPCyABIAEoAgBBAWo2AgAgACABEOoHCyAACxIAAkAgAC0ABEUNABCaCwsgAAsYAQF/AkAgACgCACIBRQ0AIAEQ5wcLIAALHwEBfwJAIAAoAgAiAUUNACAAIAE2AgQgARCGAQsgAAsfAQF/AkAgACgCACIBRQ0AIAAgATYCBCABEIYBCyAAC7QBAQJ/IABB4NkSNgL4ASAAQdTZEjYC9AEgAEHA2RI2AuABIABBsNkSNgLcASAAQZzZEjYCbCAAQcDXEjYCAAJAIAAoAoACIgFFDQAgAUGsBGoQkBkaIAEQhgELIABB4AFqIQICQCAAKAKgCSIBRQ0AIABBpAlqIAE2AgAgARCGAQsgAEHUB2oQjA0aIABB0AdqEPENGiAAQcwHahDxDRogAEH8AmoQkhkaIAIQ9RYaIAAQjA0LvwUBB38jAEEQayIBJAAgACAAKAIAIgJBf2o2AgACQCACQQFHDQACQCAAKAI0IgJFDQAgAiACKAIAQQFqNgIACyAAQTRqIQMgASACNgIMAkADQCACRQ0BIAIQ6QcCQCABKAIMIgQoAsgKIgJFDQAgAiACKAIAQQFqNgIAIAEoAgwhBAsgASACNgIIIARByApqQQAQ6gcgASgCDEHMCmpBABDqByABQQxqIAFBCGoQ4QchAiABKAIIEOAHIAIoAgAhAgwACwALIABBKGohBSAAQSxqKAIAIQYgACgCKCEEA0ACQCAEIAZHDQAgBRDrBwJAAkAgACgCCCICDQBBACECDAELIAIoAogEIQQCQAJAIAItALkHRQ0AIAQQ7AcgAigCiAQgAkGoB2oQ7QcMAQsgBEUNACAEKAIMRQ0AIAQoAgxBAUYNACAEQQQ2AgwCQAJAIAQoAgAiBhDuB0UNAAJAIAYoAhwiBkUNACAEIAYRAQAaCyAEQQE2AgwMAQsCQCAGKAIsIgZFDQAgBCAGEQEAGgsgBEHQAWoQ7wcLIARB6A1qQgA3AwAgBEHYDWpBADYCACAEQfANakIANwMACyACQbwHahDwByACQagHaiEGAkADQCACKALAByIERQ0BIAIgBCgC2AU2AsAHIAQQ8QcgAigCtAciB0UNACAEIAYoAgAgBxEDAAwACwALQQAhBCACQQA2ArwHAkADQCAEIAIoApQETw0BIAIgBEHkAGxqQZgEaiAGEPIHIARBAWohBAwACwALIAJBgAJqIAYQ8wcgACgCCCECCyACEIYBIAEoAgwQ4AcgAxD0BxoCQCAFKAIARQ0AIAUQ6wcgBSgCABCGAQsgABCGAQwCCwJAIAQoAgAiAkUNACACIAIoAgBBAWo2AgALIAIQ6QcgAhDgByAEQQRqIQQMAAsACyABQRBqJAALHwEBfwJAIAAoAgAiAUUNACAAIAE2AgQgARCGAQsgAAtUAQF/AkAgAC0AxAoNACAAQQE6AMQKIABB6ARqEPEHIABBwABqEOQKIABB4ARqKAIARQ0AIABByARqKAIAIgEgAEHkBGpGDQAgASAAQdAEahDtBwsLFwEBfyAAKAIAIQIgACABNgIAIAIQ4AcLMwECfyAAKAIEIQEgACgCACECAkADQCABIAJGDQEgAUF8ahD0ByEBDAALAAsgACACNgIEC7IDAQN/AkAgAEUNACAAKAIMRQ0AIABBADYCDAJAIAAoAgAiARDuBw0AIABBATYCOAsCQCABKAIUIgJFDQAgACACEQEAGiAAKAIAIQELAkAgARDuB0UNACAAKAIEQQNHDQAgAEGAA2otAABFDQAgAEHoAmooAgBBfGooAgAgAEGEA2oQ7QcLAkAgACgCBCIBQX5qQQJLDQAgAEGoFmogACgCAEGUAWoQ+QggACgCBCEBCwJAAkAgAUF/ag4DAAEAAQsgAEHgC2ogACgCAEGUAWoQ+QgLAkAgAEHcDWooAgAiAUUNACAAKAIAIgJBoAFqKAIAIgNFDQAgASACKAKUASADEQMACwJAIABBmBhqKAIAIgFFDQAgACgCACICQaABaigCACIDRQ0AIAEgAigClAEgAxEDAAsCQCAAQdANaigCACIBRQ0AIAAoAgAiAkGgAWooAgAiA0UNACABIAIoApQBIAMRAwALAkAgAC0ApAJFDQAgACgCACIBQaABaigCACECIAEoApQBIQMgARCwCSAAKAIAIgFFDQAgAkUNACABIAMgAhEDAAsgAEEAQcAYEDoaCwsvAQF/AkAgAEUNAAJAIAFFDQAgASgCDCICRQ0BIAAgASgCACACEQMADwsgABBHCwsjAQF/QQAhAQJAIAAoAiANACAAKAIkDQAgACgCKEUhAQsgAQsRAAJAIABFDQAgAEEANgIACwszAQF/AkAgAEUNAANAIAAoAgAhASAAQQE2AgAgAUUNAQNAIAAoAgBBAUYNAAwBCwALAAsLGQACQCAARQ0AIAAgACgCgAJBqAdqEJYLCwscAAJAIABFDQAgACgCXEUNACAAKAJgIAEQ7QcLC5MBAQN/AkAgAEUNAEEAIQICQANAIAIgACgCNE8NASAAIAIQgwsgAkEBaiECDAALAAtBACEDAkADQCADIAAoAjBPDQEgACgCOCADQTRsakEcaiEEAkADQCAEKAIAIgJFDQEgAigCACACLQAEEIMLDAALAAsgA0EBaiEDDAALAAsgACgC/AFFDQAgACgC+AEgARDtBwsLDAAgACgCABDgByAACxgBAX8CQCAAKAIAIgFFDQAgARCGAQsgAAs7AQF/AkAgAUF/Sg0AEAAACyABQX9qQQV2QQFqIgFBAnQQiAEhAiAAIAE2AgggAEEANgIEIAAgAjYCAAuwAwEDfyAAIAAoAgQiAyABaiIENgIEAkACQAJAIAMNACAEQX9qIQUMAQsgBEF/aiIFIANBf2pzQSBJDQELIAAoAgBBACAFQQV2IARBIUkbQQJ0akEANgIACwJAIAFFDQAgA0EfcSEFIAAoAgAgA0EDdkH8////AXFqIQQCQCACRQ0AAkAgBUUNACAEIAQoAgBBf0EgIAVrIgAgACABIAAgAUkbIgBrdkF/IAV0cXI2AgAgASAAayEBIARBBGohBAsgAUEFdiIFIQAgBCEDAkADQCAARQ0BIANBfzYCACAAQX9qIQAgA0EEaiEDDAALAAsgAUEfcSIARQ0BIAQgBUECdGoiAyADKAIAQX9BICAAa3ZyNgIADwsCQCAFRQ0AIAQgBCgCAEF/QSAgBWsiACAAIAEgACABSRsiAGt2QX8gBXRxQX9zcTYCACABIABrIQEgBEEEaiEECyABQQV2IgUhACAEIQMCQANAIABFDQEgA0EANgIAIABBf2ohACADQQRqIQMMAAsACyABQR9xIgBFDQAgBCAFQQJ0aiIDIAMoAgBBf0EgIABrdkF/c3E2AgALC8QfAg9/AX4jAEGgAWsiASQAIAFBOGogACgCgAsiAiACKAIAKAIYEQMAIAEoAjghAiABQQA2AjggAEHMB2ogAhC4ByABKAI4ELkHIAFBOGogACgCgAsiAiACKAIAKAIYEQMAIAEoAjghAiABQQA2AjggAEHQB2ogAhC4ByABKAI4ELkHIABCADcChAIgAEGMAmogACkCyAE3AgAgACAAEPkHIABB2AlqIQMgAEHgCWooAgAhBCAAKALcCSECAkACQANAIAIgBEYNAQJAIAIoAgAiBUUNAEECIQYgBSADIAUoAgAoAhwRAgBBAkYNAwsgAkEEaiECDAALAAsCQCAALQCICw0AIABB7AlqKAIAIQQgACgC6AkhAgJAA0AgAiAERg0BIAIoAgAhBUECIQYgAkEEaiECIAUgAyAFKAIAKAIcEQIAQQJHDQAMAwsACyAAQfgJaigCACEEIAAoAvQJIQIDQCACIARGDQEgAigCACEFQQIhBiACQQRqIQIgBSADIAUoAgAoAhwRAgBBAkcNAAwCCwALIAFBkAFqQgA3AwAgAUIANwOIASABQYCAgPwDNgKYASAAQaQKaiEHIAAoAuAJIQggACgC3AkhBQJAAkACQAJAA0AgBSAIRg0BAkAgBSgCACICRQ0AQQIhBiACIAMgAigCACgCIBECAEECRg0FAkACQCACIAIoAgAoAggRAQAiBkG9fGpBAkkNACAGQZQBRg0BIAZB3ABGDQAgBkExRw0CIAEgACACKAIUIAAoAgAoAuQBEQIAIgY2AjgCQCAGRQ0AIAFBiAFqIAFBOGoQ+gcgAjYCAAwDCyABIAIoAhQ2AgAgAkGp7BAgARCABQwCCyABIAI2AjggByABQThqEPsHDAELAkAgAigCpAFFDQAgAEEAOgDYCgsCQCAAKAK0CiIGIAAoArgKRg0AIAYgAjYCACAAIAZBBGo2ArQKDAELIAYgACgCsAoiBGsiCUECdSIKQQFqIgtBgICAgARPDQQCQAJAIAlBAXUiDCALIAwgC0sbQf////8DIAlB/P///wdJGyIJDQBBACEMDAELIAlBgICAgARPDQQgCUECdBCIASEMCyAMIApBAnRqIgsgAjYCACALIQICQANAIAYgBEYNASACQXxqIgIgBkF8aiIGKAIANgIADAALAAsgACALQQRqNgK0CiAAKAKwCiEGIAAgAjYCsAogACAMIAlBAnRqNgK4CiAGRQ0AIAYQhgELIAVBBGohBQwACwALAkAgAC0AiAsNACAAQewJaigCACEEIAAoAugJIQICQANAIAIgBEYNASACKAIAIQVBAiEGIAJBBGohAiAFIAMgBSgCACgCIBECAEECRw0ADAULAAsgAEH4CWooAgAhBCAAKAL0CSECA0AgAiAERg0BIAIoAgAhBUECIQYgAkEEaiECIAUgAyAFKAIAKAIgEQIAQQJHDQAMBAsACyAAQZQKaiENIABBjApqIQogACgC4AkhCyAAKALcCSEHA0ACQCAHIAtHDQBBACEOQQAhBEEAIQxBACEIA0ACQAJAAkACQCAIIAAoApAKIAAoAowKIgJrQQJ1SQ0ADAELIAIgCEECdGooAgAhCyAMIARGDQEgCyAEQXxqKAIAIgUQ/AchBiAFRQ0BIAQhAiAGDQIDQCAFQdQHaiEHIAAoAowKIgIgCEECdGohAwJAAkAgACgCkAoiBiAAKAKUCiIFTw0AAkAgAyAGRw0AIAMgBzYCACAAIANBBGo2ApAKDAILIAZBfGohAiAGIANrQXxqIglBAnUhDyAGIQUCQANAIAIgBk8NASAFIAIoAgA2AgAgBUEEaiEFIAJBBGohAgwACwALIAAgBTYCkAogBiAPQQJ0ayADIAkQchogAyAHNgIADAELIAFBEGogAiAFIAYgAmtBAnVBAWoQ/QcgAyAKKAIAa0ECdSANEP4HIQkCQCABKAIYIgIgASgCHEcNAAJAIAEoAhQiBSAJKAIAIgZNDQAgASAFIAUgBmtBAnVBAWpBfm1BAnQiBmogBSACIAVrIgIQciACaiICNgIYIAEgASgCFCAGajYCFAwBCyABQThqQQEgAiAGa0EBdSACIAZGGyICIAJBAnYgASgCIBD+ByEPIAEoAkAiAiABKAIYIAEoAhQiBWtqIQYCQANAIAIgBkYNASACIAUoAgA2AgAgBUEEaiEFIAJBBGohAgwACwALIAkoAgAhAiAJIA8oAgA2AgAgDyACNgIAIAEoAhQhAiABIAEoAjw2AhQgASACNgI8IAEpAhghECABIAY2AhggASABKAJENgIcIAEgEDcCQCAPEP8HGiABKAIYIQILIAIgBzYCACABIAEoAhhBBGo2AhggCigCACEGIAEoAhQhBSADIQICQANAIAIgBkYNASAFQXxqIgUgAkF8aiICKAIANgIADAALAAsgASAFNgIUIAEoAhggAyAAKAKQCiADayIFEHIhBiAAKAKMCiECIAAgASgCFDYCjAogASACNgIUIAAoApAKIQMgACAGIAVqNgKQCiABIAM2AhggACgClAohBSAAIAEoAhw2ApQKIAEgBTYCHCAJIAI2AgAgCRD/BxoLIAhBAWohCAJAIAwgBEF8aiICRw0AIAwhAgwECyAEQXhqIQUgAiEEIAsgBSgCACIFEPwHRQ0ADAMLAAsCQANAIAwgBEYNASAEQXxqIgQoAgBB1AdqIQUCQCAAKAKQCiICIAAoApQKIgZJDQAgAUE4aiAAKAKMCiIDIAYgAiADa0ECdUEBahD9ByAAKAKQCiAAKAKMCmtBAnUgDRD+ByECIAEoAkAgBTYCACABIAEoAkBBBGo2AkAgCiACEIAIIAIQ/wcaDAELIAIgBTYCACAAIAJBBGo2ApAKDAALAAsgAUHAAGpCADcDACABQdQAakIANwIAIAFB3ABqQYCAgPwDNgIAIAFCADcDOCABQgA3AkwgAUGAgID8AzYCSCABQThqIAAgAEGACmoQgQggAEGECmooAgAhBiAAKAKACiECQQAhBQJAA0AgAiAGRg0BIAIoAgAgBTYCHCACQQRqIQIgBUEBaiEFDAALAAsgACAALwEkQQRyOwEkIAFBOGoQgggaIAAoAuAJIQYgACgC3AkhBUEAIQNBACELQQAhCgNAAkAgBSAGRw0AIAFBOGoQgwghCSAKIQ0DQAJAIA0gC0cNACABQRhqQgA3AwAgAUEsakIANwIAIAFBNGpBgICA/AM2AgAgAUIANwMQIAFCADcCJCABQYCAgPwDNgIgIAFBADYCDCABQgA3AgQgAUEQaiAJIAFBBGoQgQggASgCBCEDAkADQCADQQRqIgMgASgCCEYNASADKAIAIQUCQCAAKAKcCiICIAAoAqAKIgRPDQAgAiAFNgIAIAAgAkEEajYCnAoMAQsgAiAAKAKYCiIGa0ECdSIHQQFqIghBgICAgARPDQwCQAJAIAQgBmsiBEEBdSILIAggCyAISxtB/////wMgBEH8////B0kbIgQNAEEAIQgMAQsgBEGAgICABE8NDCAEQQJ0EIgBIQgLIAggB0ECdGoiByAFNgIAIAchBQJAA0AgAiAGRg0BIAVBfGoiBSACQXxqIgIoAgA2AgAMAAsACyAAIAdBBGo2ApwKIAAoApgKIQIgACAFNgKYCiAAIAggBEECdGo2AqAKIAJFDQAgAhCGAQwACwALIAFBBGoQ5QcaIAFBEGoQgggaIAkQhAgaAkAgCkUNACAKEIYBC0EAIQYgDEUNCyAMEIYBDAsLIA0oAgAiAkE8aigCACEHIAIoAjghCANAAkAgCCAHRw0AIA1BBGohDQwCCyAJIAgoAgAiBBCFCAJAIAQoAkAoArgBIgNFDQAgACgC4AkhBiAAKALcCSECA0AgAiAGRg0BAkAgAigCACIFRQ0AIAVBMCAFKAIAKAIMEQIARQ0AIAUoAhggA0cNACAFIAQQhQgLIAJBBGohAgwACwALIAhBBGohCAwACwALAAsgASAFKAIAIgI2AjgCQCACRQ0AIAEoAogBIAEoAowBIAIQhghFDQAgAUGIAWogAUE4ahD6ByECAkAgCyADTw0AIAsgAigCADYCACALQQRqIQsMAQsgCyAKa0ECdSIHQQFqIgRBgICAgARPDQgCQAJAIAMgCmsiA0EBdSIIIAQgCCAESxtB/////wMgA0H8////B0kbIgMNAEEAIQgMAQsgA0GAgICABE8NCCADQQJ0EIgBIQgLIAggB0ECdGoiBCACKAIANgIAIAQhAgJAA0AgCyAKRg0BIAJBfGoiAiALQXxqIgsoAgA2AgAMAAsACyAEQQRqIQsgCCADQQJ0aiEDAkAgCkUNACAKEIYBCyACIQoLIAVBBGohBQwACwALIAQhAgsCQAJAIAtBmQMgCygCACgCDBECAA0AIAIhBAwBCwJAAkAgAiAOTw0AIAIgCzYCAAwBCyACIAxrQQJ1IgRBAWoiBUGAgICABE8NBgJAAkAgDiAMayIGQQF1IgMgBSADIAVLG0H/////AyAGQfz///8HSRsiBg0AQQAhAwwBCyAGQYCAgIAETw0GIAZBAnQQiAEhAwsgAyAEQQJ0aiIEIAs2AgAgBCEFAkADQCACIAxGDQEgBUF8aiIFIAJBfGoiAigCADYCAAwACwALIAMgBkECdGohDgJAIAxFDQAgDBCGAQsgBCECIAUhDAsgAkEEaiEECyAIQQFqIQgMAAsACwJAIAcoAgAiBkUNAAJAIAZBCiAGKAIAKAIMEQIARQ0AIAYgBigCACgCNBEAAAsgBkENIAYoAgAoAgwRAgAhAiAGIABGDQAgAkUNACABIAY2AhACQAJAIAAoApAKIgIgACgClApGDQAgAiAGNgIAIAAgAkEEajYCkAoMAQsgAUE4aiAAKAKMCiIFIAIgAiAFa0ECdUEBahD9ByAAKAKQCiAAKAKMCmtBAnUgDRD+ByECIAEoAkAgBjYCACABIAEoAkBBBGo2AkAgCiACEIAIIAIQ/wcaCwJAIAZBgQQgBigCACgCDBECAEUNACAAKAKQCiAAKAKMCmtBAnVBf2ohAiAGKAIYIQkDQCACRQ0BIAooAgAiAyACQX9qIgRBAnRqIggoAgAhBSAIIAMgAkECdGoiAigCADYCACACIAU2AgAgBCECIAUgCUcNAAsLIAFBEGohBSABKAKMASEDIAEoAogBIQQDQCAFKAIAIgJFDQEgAkEYaiEFIAQgAyACEIYIIgJFDQALIAYgAkEMaigCADYCuAELIAdBBGohBwwACwALEIwFAAsQAAALIAEoApABIQICQANAIAJFDQEgAigCACEFIAIQhgEgBSECDAALAAsgASgCiAEhAiABQQA2AogBIAJFDQAgAhCGAQsgAUGgAWokACAGC7AJAg1/An0jAEEQayICJAAgAiABNgIMIABBjAtqIQMgAkEMakEEEIcIIQQCQAJAAkAgAEGQC2ooAgAiBQ0ADAELAkACQCAFaSIGQQFLDQAgBUF/aiAEcSEHDAELIAQhByAEIAVJDQAgBCAFcCEHCyADKAIAIAdBAnRqKAIAIghFDQAgBUF/aiEJIAZBAUshCgNAIAgoAgAiCEUNAQJAIAgoAgQiBiAERg0AAkACQCAKDQAgBiAJcSEGDAELIAYgBUkNACAGIAVwIQYLIAYgB0cNAgsgCCgCCCABRw0ADAILAAtBDBCIASILIAQ2AgQgCyABNgIIIAtBADYCACAAQZQLaiEMIABBnAtqKgIAIQ8gACgCmAtBAWqzIRACQAJAIAVFDQAgDyAFs5QgEF1FDQELIAVBAXQgBUEDSSAFIAVBf2pxQQBHcnIhCAJAAkAgECAPlY0iEEMAAIBPXSAQQwAAAABgcUUNACAQqSEGDAELQQAhBgtBAiEBAkAgCCAGIAggBksbIghBAUYNAAJAIAggCEF/anENACAIIQEMAQsgCBD9BCEBIAAoApALIQULAkACQAJAAkAgASAFSw0AIAEgBU8NAyAFQQNJIQYCQAJAIAAoApgLsyAAKgKcC5WNIhBDAACAT10gEEMAAAAAYHFFDQAgEKkhCAwBC0EAIQgLAkACQCAGDQAgBWlBAUsNACAIQQFBICAIQX9qZ2t0IAhBAkkbIQgMAQsgCBD9BCEICwJAIAEgCCABIAhLGyIBIAVJDQAgACgCkAshBQwECyABRQ0BCwJAIAFBgICAgARPDQAgAyABQQJ0EIgBEIgIIAAgATYCkAtBACEIAkADQAJAIAggAUcNACAMKAIAIgcNAgwFCyADKAIAIAhBAnRqQQA2AgAgCEEBaiEIDAALAAsgBygCBCEKAkACQCABaSIIQQFLDQAgCiABQX9qcSEKDAELIAogAUkNACAKIAFwIQoLIAMoAgAgCkECdGogDDYCACABQX9qIQ0gCEEBSyEJA0AgBygCACIGRQ0DIAYoAgQhCAJAAkAgCQ0AIAggDXEhCAwBCyAIIAFJDQAgCCABcCEICwJAIAggCkYNAAJAIAMoAgAgCEECdCIFaiIOKAIADQAgDiAHNgIAIAghCgwBCyAHIAYoAgA2AgAgBiADKAIAIAVqKAIAKAIANgIAIAMoAgAgBWooAgAgBjYCAAwBCyAGIQcMAAsACxCMBQALQQAhBSADQQAQiAggAEEANgKQCwwBCyABIQULAkAgBSAFQX9qIghxDQAgCCAEcSEHDAELAkAgBCAFTw0AIAQhBwwBCyAEIAVwIQcLAkACQAJAIAMoAgAgB0ECdGoiBigCACIIDQAgCyAMKAIANgIAIAwgCzYCACAGIAw2AgAgCygCACIIRQ0CIAgoAgQhCAJAAkAgBSAFQX9qIgZxDQAgCCAGcSEIDAELIAggBUkNACAIIAVwIQgLIAMoAgAgCEECdGohCAwBCyALIAgoAgA2AgALIAggCzYCAAsgACAAKAKYC0EBajYCmAsLAkAgACgCrAsQvgdFDQAgACgCrAsQiQgLIABBBEEAEL0HGiACQRBqJAAL7AgCC38CfSABKAIAIgIQigghAwJAAkACQCAAKAIEIgQNAAwBCwJAAkAgBGkiAUEBSw0AIARBf2ogA3EhBQwBCyADIQUgAyAESQ0AIAMgBHAhBQsgACgCACAFQQJ0aigCACIGRQ0AIARBf2ohByABQQFLIQgDQCAGKAIAIgZFDQECQCAGKAIEIgEgA0YNAAJAAkAgCA0AIAEgB3EhAQwBCyABIARJDQAgASAEcCEBCyABIAVHDQILIAYoAgggAkcNAAwCCwALQRAQiAEiBiACNgIIIAYgAzYCBCAGQQA2AgAgBkEMakEANgIAIABBCGohCSAAKgIQIQ0gACgCDEEBarMhDgJAAkAgBEUNACANIASzlCAOXUUNAQsgBEEBdCAEQQNJIAQgBEF/anFBAEdyciEBAkACQCAOIA2VjSIOQwAAgE9dIA5DAAAAAGBxRQ0AIA6pIQUMAQtBACEFC0ECIQICQCABIAUgASAFSxsiAUEBRg0AAkAgASABQX9qcQ0AIAEhAgwBCyABEP0EIQIgACgCBCEECwJAAkACQAJAIAIgBEsNACACIARPDQMgBEEDSSEFAkACQCAAKAIMsyAAKgIQlY0iDkMAAIBPXSAOQwAAAABgcUUNACAOqSEBDAELQQAhAQsCQAJAIAUNACAEaUEBSw0AIAFBAUEgIAFBf2pna3QgAUECSRshAQwBCyABEP0EIQELAkAgAiABIAIgAUsbIgIgBEkNACAAKAIEIQQMBAsgAkUNAQsCQCACQYCAgIAETw0AIAAgAkECdBCIARCLCCAAIAI2AgRBACEBAkADQAJAIAEgAkcNACAJKAIAIggNAgwFCyAAKAIAIAFBAnRqQQA2AgAgAUEBaiEBDAALAAsgCCgCBCEHAkACQCACaSIBQQFLDQAgByACQX9qcSEHDAELIAcgAkkNACAHIAJwIQcLIAAoAgAgB0ECdGogCTYCACACQX9qIQogAUEBSyELA0AgCCgCACIERQ0DIAQoAgQhAQJAAkAgCw0AIAEgCnEhAQwBCyABIAJJDQAgASACcCEBCwJAIAEgB0YNAAJAIAAoAgAgAUECdCIFaiIMKAIADQAgDCAINgIAIAEhBwwBCyAIIAQoAgA2AgAgBCAAKAIAIAVqKAIAKAIANgIAIAAoAgAgBWooAgAgBDYCAAwBCyAEIQgMAAsACxCMBQALQQAhBCAAQQAQiwggAEEANgIEDAELIAIhBAsCQCAEIARBf2oiAXENACABIANxIQUMAQsCQCADIARPDQAgAyEFDAELIAMgBHAhBQsCQAJAAkAgACgCACAFQQJ0aiICKAIAIgENACAGIAkoAgA2AgAgCSAGNgIAIAIgCTYCACAGKAIAIgFFDQIgASgCBCEBAkACQCAEIARBf2oiAnENACABIAJxIQEMAQsgASAESQ0AIAEgBHAhAQsgACgCACABQQJ0aiEBDAELIAYgASgCADYCAAsgASAGNgIACyAAIAAoAgxBAWo2AgwLIAZBDGoLmgEBBH8jAEEgayICJAACQAJAIAAoAgQiAyAAKAIIIgRPDQAgAyABKAIANgIAIAAgA0EEajYCBAwBCyACQQxqIAAoAgAiBSAEIAMgBWtBAnVBAWoQjAggACgCBCAAKAIAa0ECdSAAQQhqEI0IIgMoAgggASgCADYCACADIAMoAghBBGo2AgggACADEI4IIAMQjwgaCyACQSBqJAALPgEBfwJAA0AgAEUNASAAQZkDIAAoAgAoAgwRAgAhAgJAIAAgAUcNACACDQILIAAoAhghAAwACwALIABBAEcLNwACQCACQYCAgIAESQ0AEAAACyABIABrIgFBAXUiACACIAAgAksbQf////8DIAFB/P///wdJGwtqAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkACQCABRQ0AIAFBgICAgARPDQEgAUECdBCIASEECyAAIAQ2AgAgACAEIAJBAnRqIgM2AgggACAEIAFBAnRqNgIMIAAgAzYCBCAADwsQjAUAC0IBAn8gACgCCCEBIAAoAgQhAgJAA0AgASACRg0BIAAgAUF8aiIBNgIIDAALAAsCQCAAKAIAIgFFDQAgARCGAQsgAAuTAQEDfyABKAIEIQIgACgCACEDIAAoAgQhBAJAA0AgBCADRg0BIAJBfGoiAiAEQXxqIgQoAgA2AgAMAAsACyABIAI2AgQgACgCACEEIAAgAjYCACABIAQ2AgQgACgCBCEEIAAgASgCCDYCBCABIAQ2AgggACgCCCEEIAAgASgCDDYCCCABIAQ2AgwgASABKAIENgIACxYAIAIgAigCADYCBCAAIAEgAhDzDBoLEAAgAEEUahCRCBogABCRCAsrACAAEJAIIgBBADYCSCAAQgA3AkAgAEHQiRI2AgAgAEL/////DzcCOCAACxkAIABBhNETNgIAIABBKGoQ5QcaIAAQkggLYQEDfyMAQRBrIgIkACACIAE2AgwgAEEoaiEDIABBLGooAgAhBCAAKAIoIQACQAJAA0AgACAERg0BIAAoAgAgAUYNAiAAQQRqIQAMAAsACyADIAJBDGoQvAsLIAJBEGokAAu0AQEFfyACEIoIIQMCQCABRQ0AAkACQCABaSIEQQFLDQAgAUF/aiADcSEFDAELIAMhBSADIAFJDQAgAyABcCEFCyAAIAVBAnRqKAIAIgBFDQAgAUF/aiEGIARBAUshBwNAIAAoAgAiAEUNAQJAIAAoAgQiBCADRg0AAkACQCAHDQAgBCAGcSEEDAELIAQgAUkNACAEIAFwIQQLIAQgBUcNAgwBCyAAKAIIIAJHDQALIAAPC0EAC6YBAQJ/IAEhAgJAA0AgAkEESQ0BIAAoAABBldPH3gVsIgNBGHYgA3NBldPH3gVsIAFBldPH3gVscyEBIAJBfGohAiAAQQRqIQAMAAsACwJAAkACQAJAIAJBf2oOAwIBAAMLIAAtAAJBEHQgAXMhAQsgAC0AAUEIdCABcyEBCyABIAAtAABzQZXTx94FbCEBCyABQQ12IAFzQZXTx94FbCICQQ92IAJzCx8BAX8gACgCACECIAAgATYCAAJAIAJFDQAgAhCGAQsLHAEBfwJAIAAoAiAiAUUNACABIAAoAtABEPkHCwspAQF/IwBBEGsiASQAIAEgADYCDCABQQxqQQQQhwghACABQRBqJAAgAAsfAQF/IAAoAgAhAiAAIAE2AgACQCACRQ0AIAIQhgELCzcAAkAgAkGAgICABEkNABAAAAsgASAAayIBQQF1IgAgAiAAIAJLG0H/////AyABQfz///8HSRsLVAEBf0EAIQQgAEEANgIMIABBEGogAzYCAAJAIAFFDQAgARD/BSEECyAAIAQ2AgAgACAEIAJBAnRqIgM2AgggACAEIAFBAnRqNgIMIAAgAzYCBCAAC5MBAQN/IAEoAgQhAiAAKAIAIQMgACgCBCEEAkADQCAEIANGDQEgAkF8aiICIARBfGoiBCgCADYCAAwACwALIAEgAjYCBCAAKAIAIQQgACACNgIAIAEgBDYCBCAAKAIEIQQgACABKAIINgIEIAEgBDYCCCAAKAIIIQQgACABKAIMNgIIIAEgBDYCDCABIAEoAgQ2AgALQgECfyAAKAIIIQEgACgCBCECAkADQCABIAJGDQEgACABQXxqIgE2AggMAAsACwJAIAAoAgAiAUUNACABEIYBCyAAC1IAIABB0NETNgIAIABBfzYCBCAAQQhqQbHWGhCkBRogAEEwakEANgIAIABCADcCKCAAQf7/AzsBJCAAQQA2AiAgAEGE0RM2AgAgAEIANwIUIAALRgECfyAAKAIIIQECQANAIAFFDQEgASgCACECIAEQhgEgAiEBDAALAAsgACgCACEBIABBADYCAAJAIAFFDQAgARCGAQsgAAsWACAAQdDREzYCACAAQQhqEIUFGiAACwoAIAAQkggQhgELBABBCgsHACABQQpGCwQAQQALBABBAQsEAEEACwQAQQALBABBAAuhAQEEfyMAQSBrIgIkAAJAAkAgAEHgCWooAgAiAyAAQeQJaiIEKAIARg0AIAMgATYCACAAIANBBGo2AuAJDAELIAJBDGogACgC3AkiBSADIAMgBWtBAnVBAWoQnAggACgC4AkgACgC3AlrQQJ1IAQQnQgiAygCCCABNgIAIAMgAygCCEEEajYCCCAAQdwJaiADEJ4IIAMQnwgaCyACQSBqJAALNwACQCACQYCAgIAESQ0AEAAACyABIABrIgFBAXUiACACIAAgAksbQf////8DIAFB/P///wdJGwtqAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkACQCABRQ0AIAFBgICAgARPDQEgAUECdBCIASEECyAAIAQ2AgAgACAEIAJBAnRqIgM2AgggACAEIAFBAnRqNgIMIAAgAzYCBCAADwsQjAUAC5MBAQN/IAEoAgQhAiAAKAIAIQMgACgCBCEEAkADQCAEIANGDQEgAkF8aiICIARBfGoiBCgCADYCAAwACwALIAEgAjYCBCAAKAIAIQQgACACNgIAIAEgBDYCBCAAKAIEIQQgACABKAIINgIEIAEgBDYCCCAAKAIIIQQgACABKAIMNgIIIAEgBDYCDCABIAEoAgQ2AgALQgECfyAAKAIIIQEgACgCBCECAkADQCABIAJGDQEgACABQXxqIgE2AggMAAsACwJAIAAoAgAiAUUNACABEIYBCyAAC4ICAQZ/AkAgACgCBCICIAAoAghGDQAgAiABNgIAIAAgAkEEajYCBA8LAkACQCACIAAoAgAiA2siBEECdSIFQQFqIgZBgICAgARPDQACQAJAIARBAXUiByAGIAcgBksbQf////8DIARB/P///wdJGyIEDQBBACEGDAELIARBgICAgARPDQIgBEECdBCIASEGCyAGIAVBAnRqIgUgATYCACAFIQECQANAIAIgA0YNASABQXxqIgEgAkF8aiICKAIANgIADAALAAsgACAFQQRqNgIEIAAoAgAhAiAAIAE2AgAgACAGIARBAnRqNgIIAkAgAkUNACACEIYBCw8LEAAACxCMBQALggIBBn8C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IAFBBGohAQwACwALIAVBBGohBQwACwALlAEBBH8jAEEQayICJAAgAEHACmooAgAhAyAAKAK8CiEEAkADQAJAIAQgA0cNACAAQagKaigCACEFIAAoAqQKIQQDQCAEIAVGDQMCQCAEKAIAKALQASIDRQ0AIAMgARCwCAsgBEEEaiEEDAALAAsgAiAEKAIANgIMIAEgAkEMahC2CCAEQQRqIQQMAAsACyACQRBqJAALhgEBA38jAEEQayICJAACQCABRQ0AIAEgAkEEaiAAQSxqELIIIgMQxQwhBCADEJIGGgJAIARFDQACQCAALQAMQQRxDQAgBCAAQRRqEMYMCyAAIAQ2AiAgACAAKAIAKAI8EQAACyAAKAIoIgRFDQAgBCABIAAgBCgCACgCOBEFAAsgAkEQaiQAC0QBAn8gAEEANgIIIABCADcCAAJAIAEoAgQiAiABKAIAIgNGDQAgACACIANrQQJ1EJAGIAAgASgCACABKAIEELUICyAAC74BAQR/IwBBEGsiAiQAQQAhAwJAIAEoAgQgASgCACIERg0AAkAgACgCBCIFRQ0AIAUoAjggBCgCAEcNAANAAkAgBEEEaiIEIAEoAgRHDQAgBSEDDAMLIAVBPGooAgAgBUHAAGooAgAgBCgCABDRDCIFRQ0BIAVBvAMgBSgCACgCDBECAEUNASAFKAIkIgUNAAsLIAAoAgAiBEUNACAEIAJBBGogARCyCCIFELMIIQMgBRCSBhoLIAJBEGokACADCxEAAkAgAEUNACAAIAEQ9RwLCzoBAX8gACgCBCEDAkADQCABIAJGDQEgAyABKAIANgIAIANBBGohAyABQQRqIQEMAAsACyAAIAM2AgQLgQIBBn8CQCAAKAIEIgIgACgCCEYNACACIAEoAgA2AgAgACACQQRqNgIEDwsCQCACIAAoAgAiA2siBEECdSIFQQFqIgZBgICAgARPDQACQAJAIARBAXUiByAGIAcgBksbQf////8DIARB/P///wdJGyIHDQBBACEEDAELIAcQtwghBCAAKAIAIQMgACgCBCECCyAEIAVBAnRqIgYgASgCADYCACAGIQECQANAIAIgA0YNASABQXxqIgEgAkF8aiICKAIANgIADAALAAsgACAGQQRqNgIEIAAoAgAhAiAAIAE2AgAgACAEIAdBAnRqNgIIAkAgAkUNACACEIYB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ACACQQAgARDOCAsJACAAIAEQ7QcLCQAgACABENIICywBAX8CQCABRQ0AAkAgASgCBCICDQBBAA8LIAAgASgCACACEQIADwsgABBGCysAAkAgAA0AQQAPCyAAQThqENUIIAAoAmRBAnRB0I0RaigCACAAKAJobG4LpBcCB38JfiMAQaDgAGsiBSQAAkACQCAADQBBfiEGDAELQX0hBgJAAkACQAJAAkACQAJAAkAgACgCHA4GAAECAwUECAtCACEMQgAhDQJAIAJFDQAgAikDACENCwJAIARFDQAgBCkDACEMCyANIAwgDSAMVBshDgJAIANFDQAgDiAAKAIEQQJ0QdCNEWooAgAgACgCDGytfiEMAkAgAQ0AA0AgDFANAiAMQv////8PIAxC/////w9UGyINpyEAAkAgA0UNACADQQAgABA6GgsgAyAAaiEDIAwgDX0hDAwACwALA0AgDFANASADIAEgDEL/////DyAMQv////8PVBsiDaciABA7IQMgDCANfSEMIAEgAGohASADIABqIQMMAAsACwJAIAJFDQAgAiAONwMAC0EAIQYgBEUNByAEIA43AwAMBwtCACEMQgAhDQJAIAJFDQAgAikDACENCwJAIARFDQAgBCkDACEMCyANIAwgDSAMVBshDiADRQ0FIAAoAgQhBgJAIAFFDQAgAyAGIAEgACgCACAOIAAoAgggACgCGBDcCAwGCyAOIAZBAnRB0I0RaigCACAAKAIMbK1+IQwDQCAMUA0GIAxC/////w8gDEL/////D1QbIg2nIQACQCADRQ0AIANBACAAEDoaCyADIABqIQMgDCANfSEMDAALAAtCACEMQgAhDQJAIAJFDQAgAikDACENCwJAIARFDQAgBCkDACEMCyANIAwgDSAMVBshDgJAIAAtAOABDQAgAC0A4QENACAAQSBqIAMgASAOEN0IIgYNBgwECyAAQSBqIQdCACEMA0AgDiAMWA0EQYAgIAAoAiAiCEECdEHQjRFqKAIAIgkgACgCKGxuIQpBACEGQQAhCwJAIAFFDQAgASAAKAIIIAynbCAAKAIAQQJ0QdCNEWooAgBsaiELCwJAIANFDQAgAyAAKAIMIAynbCAAKAIEQQJ0QdCNEWooAgBsaiEGCwJAAkAgAC0A4AFFDQAgDiAMfSINQYAgIAAoAiQgCWxurSIPIA0gD1Qb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4QggCCAHaiEHDAALAAsgACABIAIgAxDhCAsgAUUNAAJAIAINACAKQwAAgD9bDQAgASABIAOtIABBuAdqKAIAIABBvAdqKAIAIAoQ4AgLIAAtAKYCDQAgAEG4B2ooAgBBBUcNACABIAEgAEG8B2ooAgAgA2ytEOIICyAEQYAgaiQAC34BA39BfiECAkAgAEUNACAAQcgAaigCACIDQf////8HcSAAKAJoIAFsIAAoAmRBAnRB0I0RaigCAGxqIgEgAEE8aigCACIESw0AIAAgA0GAgICAeHEiAkGAgICAeHMgASACciABIARGGzYCSEEAQW8gAEE4ahDVCBshAgsgAgvDIQQDfgZ/Cn0BfCAFrSAEfiEEAkACQCABIANHDQAgBCABQQJ0QdCNEWo1AgB+IQQDQCAEUA0CIAAgAiAEQv////8PIARC/////w9UGyIHpyIBEDshACAEIAd9IQQgAiABaiECIAAgAWohAAwACwALAkACQAJAAkACQCADQX9qDgUAAQIDBAULQgAhBwJAAkACQAJAIAFBfmoOBAABAgMICwNAIAcgBFENCCAAIAenIgFBAXRqIAIgAWotAABBCHRBgIACczsBACAHQgF8IQcMAAsACwNAIAcgBFENByACIAenIgFqLQAAIQMgACABQQNsaiIBQQA7AAAgAUECaiADQYABczoAACAHQgF8IQcMAAsACwNAIAcgBFENBiAAIAenIgFBAnRqIAIgAWotAABBGHRBgICAgHhzNgIAIAdCAXwhBwwACwALA0AgByAEUQ0FIAAgB6ciAUECdGogAiABai0AALNDgYAAPJRDAACAv5I4AgAgB0IBfCEHDAALAAtCACEHAkACQAJAAkAgAUF/ag4FAAcBAgMHCwJAIAYNAEIAIQcDQCAHIARRDQggACAHpyIBaiACIAFBAXRqLQABQYABczoAACAHQgF8IQcMAAsAC0EAKAKklRshA0IAIQcgBkF/aiEKA0AgByAEUQ0HIAIgB6ciBUEBdGouAQAhBkEAIQECQAJAAkAgCg4CAAECC0EAIANBj/kCbEH/////B28iAzYCpJUbIANBGHZBgH9qIQEMAQtBACADQY/5AmxB/////wdvIgFBj/kCbEH/////B28iAzYCpJUbIAFB8Y/wD24gA0EZdmpBgH9qIQELIAAgBWogASAGaiIBQf//ASABQf//AUgbQQh2QYABczoAACAHQgF8IQcMAAsACwNAIAcgBFENBiAAIAenIgNBA2xqIgFBADoAACABQQFqIAIgA0EBdGoiAy0AADoAACABQQJqIAMtAAE6AAAgB0IBfCEHDAALAAsDQCAHIARRDQUgACAHpyIBQQJ0aiACIAFBAXRqLwEAQRB0NgIAIAdCAXwhBwwACwALA0AgByAEUQ0EIAAgB6ciAUECdGogAiABQQF0ai4BALJDAAAAOJQ4AgAgB0IBfCEHDAALAAtCACEHAkACQAJAAkAgAUF/ag4FAAEGAgMGCwJAIAYNAEIAIQcDQCAHIARRDQcgACAHpyIBaiABQQNsIAJqQQJqLQAAQYABczoAACAHQgF8IQcMAAsAC0EAKAKklRshBUIAIQcgBkF/aiEKA0AgByAEUQ0GIAIgB6ciBkEDbGoiAUEBai0AAEEQdCABLQAAQQh0ciABQQJqLQAAQRh0ciEDQQAhAQJAAkACQCAKDgIAAQILQQAgBUGP+QJsQf////8HbyIFNgKklRsgBUEIdkGAgIB8aiEBDAELQQAgBUGP+QJsQf////8HbyIBQY/5AmxB/////wdvIgU2AqSVGyAFQQl2IAFBCXZqQYCAgHxqIQELIAAgBmogASADakEYdkGAAXNBfyABrCADrHxCgICAgAhTGzoAACAHQgF8IQcMAAsACwJAIAYNAEIAIQcDQCAHIARRDQYgACAHpyIBQQF0aiABQQNsIAJqQQFqLwAAOwEAIAdCAXwhBwwACwALQQAoAqSVGyEFQgAhByAGQX9qIQoDQCAHIARRDQUgAiAHpyIGQQNsaiIBQQFqLQAAQRB0IAEtAABBCHRyIAFBAmotAABBGHRyIQNBACEBAkACQAJAIAoOAgABAgtBACAFQY/5AmxB/////wdvIgU2AqSVGyAFQRB2QYCAfmohAQwBC0EAIAVBj/kCbEH/////B28iAUGP+QJsQf////8HbyIFNgKklRsgAUH9/wduIAVBEXZqQYCAfmohAQsgACAGQQF0aiABIANqQRB2Qf//ASABrCADrHxCgICAgAhTGzsBACAHQgF8IQcMAAsACwNAIAcgBFENBCAAIAenIgFBAnRqIAIgAUEDbGoiAUEBai0AAEEQdCABLQAAQQh0ciABQQJqLQAAQRh0cjYCACAHQgF8IQcMAAsACwNAIAcgBFENAyAAIAenIgFBAnRqIAIgAUEDbGoiAUEBai0AAEEQdCABLQAAQQh0ciABQQJqLQAAQRh0ckEIdbJDAAAANJQ4AgAgB0IBfCEHDAALAAtCACEHAkACQAJAAkAgAUF/ag4FAAECBQMFCwJAIAYNAEIAIQcDQCAHIARRDQYgACAHpyIBaiACIAFBAnRqLQADQYABczoAACAHQgF8IQcMAAsAC0EAKAKklRshBUIAIQcgBkF/aiEKA0AgByAEUQ0FIAIgB6ciBkECdGooAgAhA0EAIQECQAJAAkAgCg4CAAECC0EAIAVBj/kCbEH/////B28iBTYCpJUbIAVBCHZBgICAfGohAQwBC0EAIAVBj/kCbEH/////B28iAUGP+QJsQf////8HbyIFNgKklRsgBUEJdiABQQl2akGAgIB8aiEBCyAAIAZqIAEgA2pBGHZBgAFzQX8gAawgA6x8QoCAgIAIUxs6AAAgB0IBfCEHDAALAAsCQCAGDQBCACEHA0AgByAEUQ0FIAAgB6ciAUEBdGogAiABQQJ0ai8BAjsBACAHQgF8IQcMAAsAC0EAKAKklRshBUIAIQcgBkF/aiEKA0AgByAEUQ0EIAIgB6ciBkECdGooAgAhA0EAIQECQAJAAkAgCg4CAAECC0EAIAVBj/kCbEH/////B28iBTYCpJUbIAVBEHZBgIB+aiEBDAELQQAgBUGP+QJsQf////8HbyIBQY/5AmxB/////wdvIgU2AqSVGyABQf3/B24gBUERdmpBgIB+aiEBCyAAIAZBAXRqIAEgA2pBEHZB//8BIAGsIAOsfEKAgICACFMbOwEAIAdCAXwhBwwACwALA0AgByAEUQ0DIAAgB6ciA0EDbGoiAUEBaiACIANBAnRqKAIAIgNBEHY6AAAgASADQQh2OgAAIAFBAmogA0EYdjoAACAHQgF8IQcMAAsACwNAIAcgBFENAiAAIAenQQJ0IgFqIAIgAWooAgC3RAAAAAAAAAA+orY4AgAgB0IBfCEHDAALAAtBACEDQgAhBwJAAkACQAJAIAFBf2oOBAABAwIEC0MCgYA8QwAAAAAgBhshEEMEAgE8QwAAAAAgBhshEUMAAAAAQwAAALxDAAAAACAGGyISkyETQQAoAqSVGyEBQgAhByAGQX9qIQYDQCAHIARRDQQgAiAHpyIDQQJ0aioCACEUQwAAAAAhFQJAAkACQCAGDgIAAQILQQAgAUGP+QJsQf////8HbyIBNgKklRsgAbdEAADA////30GjtiAQlCASkiEVDAELQQAgAUGP+QJsQf////8HbyIFQY/5AmxB/////wdvIgE2AqSVGyAFt0QAAMD////fQaO2IBOUIBKSIAG3RAAAwP///99Bo7YgEZRDAAAAAJKSIRULAkACQEMAAAAAQwAAf0MgFCAVkiIVQwAAgD+SQwAA/0KUIBVDAACAP14bIBVDAACAv10bIhVDAACAT10gFUMAAAAAYHFFDQAgFakhBQwBC0EAIQULIAAgA2ogBToAACAHQgF8IQcMAAsAC0OAAIA4QwAAAAAgBhshFkMAAQA4QwAAAAAgBhshF0MAAAAAQwAAALhDAAAAACAGGyIVkyEYIARCAoghCEEAKAKklRshA0IAIQkgBkF/aiELQgAhBwNAAkAgCSAIUg0AIAZBf2ohBgNAIAcgBFoNBSACIAenIgFBAnRqKgIAIRJDAAAAACEUAkACQAJAIAYOAgABAgtBACADQY/5AmxB/////wdvIgM2AqSVGyADt0QAAMD////fQaO2IBaUIBWSIRQMAQtBACADQY/5AmxB/////wdvIgVBj/kCbEH/////B28iAzYCpJUbIAW3RAAAwP///99Bo7YgGJQgFZIgA7dEAADA////30GjtiAXlEMAAAAAkpIhFAsCQAJAQwD+/8ZDAP7/RiASIBSSIhRDAP7/RpQgFEMAAIA/XhsgFEMAAIC/XRsiFItDAAAAT11FDQAgFKghBQwBC0GAgICAeCEFCyAAIAFBAXRqIAU7AQAgB0IBfCEHDAALAAtDAAAAACESQwAAAAAhFEMAAAAAIRBDAAAAACERAkACQAJAIAsOAgABAgtBACADQY/5AmxB/////wdvIgFBj/kCbEH/////B28iBUGP+QJsQf////8HbyIKQY/5AmxB/////wdvIgM2AqSVGyABt0QAAMD////fQaO2IBaUIBWSIRQgBbdEAADA////30GjtiAWlCAVkiEQIAq3RAAAwP///99Bo7YgFpQgFZIhEiADt0QAAMD////fQaO2IBaUIBWSIREMAQtBACADQY/5AmxB/////wdvIgFBj/kCbEH/////B28iBUGP+QJsQf////8HbyIKQY/5AmxB/////wdvIgxBj/kC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AJIhECAFQQFqIQUMAAsACyABIAhBAnRqIBAgCbOVOAIAIA5CAXwhDgwACwALQX0hBAJAAkACQAJAAkAgACgCAEF/ag4FAAECAwQHC0IAIQ4DQCAOIANRDQggAiAOpyIGaiEIQQAhBQJAA0AgBSAAKAIIIglPDQEgASAJIAZsIAVqaiAILQAAOgAAIAVBAWohBQwACwALIA5CAXwhDgwACwALQgAhDgJAIAAoAggiBUECRw0AA0AgDiADUQ0IIAEgDqciAEECdGoiBSACIABBAXRqIgAvAQA7AQAgBUECaiAALwEAOwEAIA5CAXwhDgwACwALA0AgDiADUQ0HIAUgDqciAGwhCSACIABBAXRqIQZBACEAAkADQCAAIAVGDQEgASAAIAlqQQF0aiAGLwEAOwEAIABBAWohAAwACwALIA5CAXwhDgwACwALQgAhDgNAIA4gA1ENBiACIA6nIghBA2xqIgZBAmohByAGQQFqIQpBACEFAkADQCAFIAAoAggiCU8NASABIAkgCGwgBWpBA2xqIgkgBi0AADoAACAJQQFqIAotAAA6AAAgCUECaiAHLQAAOgAAIAVBAWohBQwACwALIA5CAXwhDgwACwALQgAhDgNAIA4gA1ENBSACIA6nIgZBAnRqIQhBACEFAkADQCAFIAAoAggiCU8NASABIAkgBmwgBWpBAnRqIAgoAgA2AgAgBUEBaiEFDAALAAsgDkIBfCEODAALAAtCACEOAkAgACgCCCIFQQJHDQADQCAOIANRDQUgASAOpyIAQQN0aiIFIAIgAEECdGoiACoCADgCACAFQQRqIAAqAgA4AgAgDkIBfCEODAALAAsDQCAOIANRDQQgBSAOpyIAbCEJIAIgAEECdGohBkEAIQACQANAIAAgBUYNASABIAAgCWpBAnRqIAYqAgA4AgAgAEEBaiEADAALAAsgDkIBfCEODAALAAsgACgCAEECdEHQjRFqKAIAIAAoAghsrSADfiEOIAEhBQJAA0AgDlANASAOQv////8PIA5C/////w9UGyIPpyEJAkAgBUUNACAFQQAgCRA6GgsgBSAJaiEFIA4gD30hDgwACwALQX0hBAJAAkACQAJAAkAgACgCAEF/ag4FAAECAwQGC0EAIQRBACEIA0BBACEJIAitIANaDQYCQANAQQAhBSAJIAAoAgRPDQECQANAIAUg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ByACKAIYIABBLGxqQQAQngkgAEEBaiEADAALAAsgAigCFCADQRhsakEAEJsJIANBAWohAwwACwALIAZBAWohBgwACwALIAIgCDYCECACIAk2AgwgAiAAKAIANgIAIAIgACgCBDYCBCACIAAoAgg2AghBACEFDAELQX0hBQsgBEHQAGokACAFC9oBAQV/AkAgAUUNACABQgA3AAAgAUEIakEANgAAC0F+IQICQCAARQ0AIAAoAgQiA0UNACAAKAIYIgRBCEsNAEEAIQAgAUEANgIEIARBAXEhBSADQQJ0QQdqQXhxQRhqIQZBACECAkADQCACIAVGDQEgASAGIABqIgA2AgAgAkEBaiECDAALAAsgASAANgIIIARBAXYhBSADQQN0QSxqIQZBACECAkADQCACIAVGDQEgASAGIABqIgA2AgAgAkEBaiECDAALAAsgASAAQQdqQXhxNgIAQQAhAgsgAgvnAQIEfwF8QX4hAgJAIABFDQAgAUUNAEF+IQICQCAAKAIAIgNBfmoOBAABAQABC0F9IQICQCABKAIAIgRFDQAgBCADRw0BCyAAKAIEIQUCQAJAIAEoAgQiBA0AIAUhBAwBCyAEIAVHDQELIAEgBDYCBCABIAM2AgAgACsDEEQYLURU+yEZwKIgACgCCLijEGMhBgJAAkAgA0EFRw0AIAEgBrY4AggMAQsCQAJAIAZEAAAAAAAA0ECiIgaZRAAAAAAAAOBBY0UNACAGqiECDAELQYCAgIB4IQILIAEgAjYCCAtBACECCyACCxwAAkAgAEUNACAAKAIURQ0AIAAoAhAgARDtBwsLzwEBAn8jAEEQayIBJAACQAJAIAC9QiCIp0H/////B3EiAkH7w6T/A0sNACACQYCAwPIDSQ0BIABEAAAAAAAAAABBABCBNyEADAELAkAgAkGAgMD/B0kNACAAIAChIQAMAQsCQAJAAkACQCAAIAEQgjdBA3EOAwABAgMLIAErAwAgASsDCEEBEIE3IQAMAwsgASsDACABKwMIEIM3IQAMAgsgASsDACABKwMIQQEQgTeaIQAMAQsgASsDACABKwMIEIM3miEACyABQRBqJAAgAAutBAIEfwF8QX4hAgJAIABFDQAgACsDICIGRAAAAAAAAAAAYQ0AQX4hAgJAIAAoAgAiA0F+ag4EAAEBAAELQX0hAgJAIAEoAgAi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EGokACAGC18BAn9BASEDAkADQCABUA0BAkACQCABQoCAgIAIVA0AIAJB/////wdBASAAEQQARQ0BIAFCgYCAgHh8IQEMAgsgAachBEIAIQEgAiAEQQEgABEEAA0BCwtBACEDCyADC24BAn9BACEDAkACQCABQoCAgIAIVA0AQQAhBCACQf////8HQQAgABEEAEUNAUEBIQMDQCABQoGAgIB4fCIBQoCAgIAIVA0BIAJB/////wdBASAAEQQADQAMAgsACyACIAGnIAMgABEEACEECyAECycBAX8CQCAARQ0AIAFFDQAgASgCDCICRQ0AIAAgASgCACACEQMACwteAQJ/AkACQCAALwFSIgFBB3ENACAAQSZqLwEAIAFsQQN2IQEMAQsgAEEwai8BACEBCwJAAkAgAC8BVEH+/wNxQQZHDQBBACECIAEgAEEmai8BAEcNAQsgASECCyACC4MbAw5/BH4BfCMAQYAgayIEJAACQCADRQ0AIANCADcDAAtBfiEFAkAgAEUNACACUA0AQX0hBQJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAJIDgYMAQMBAgABCyAAQdAAaiEGAkAgAQ0AIAYgAkEAEOMJIRIMCQsCQCAAQaABai8BACIFrUL//wODIAJ+QoCAgID8////P4NQDQBB/////wMgBUH//wNxbq0hAgtCACESAkAgAEGkAWovAQAiB0F/ag4HAAgGCgoFBAcLIARBAEGAIBA6IQhCACESIAYQ4QkiCUUNCCAJIAVB//8DcSIFbiEKIAkgBUkNCCAJIAogBWxHDQhBwAAgCkEDdGshCyAKrSETQgAhEiAKQX9qIQwgCkEJSSENA0AgAlANCSAGIAJBgCAgCW6tIhQgAiAUVBsgCBDjCSIVUA0JIBUgADMBoAF+IhQgE35CgCBWDQkgFKchDgJAAkACQAJAAkACQCAMDgQABAECAwtBACEFIAEhByABRQ0EA0AgBSAORg0FIAcgCCAFai0AALNDgYAAPJRDAACAv5I4AgAgBUEBaiEFIAdBBGohBwwACwALQQAhBSABIQcgAUUNAwNAIAUgDkYNBCAHIAggBUEDbGoiD0EBai0AAEEQdCAPLQAAQQh0ciAPQQJqLQAAQRh0ckEIdbdEAAAAAAAAgD6itjgCACAFQQFqIQUgB0EEaiEHDAALAAtBACEF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IA1BAXIgACgCvAJrIApsakECdGogBzYCACAIQQFqIQgMAAsACyALQQFqIQsMAAsACwsgASARfCERCyADQRBqJAAgEQurAQACQCABRQ0AIAFBADYCAAsCQCACRQ0AIAJBADYCAAsCQCADRQ0AIANBADYCAAsCQCAERQ0AIAVFDQAgBEEAIAUQOhoLAkAgAA0AQX0PCwJAIAFFDQAgASAAKAJINgIACwJAIAJFDQAgAiAAQaABai8BADYCAAsCQCADRQ0AIAMgAEGcAWooAgA2AgALAkAgBA0AQQAPC0EAIAQgBSAAQaABai8BABD3CEEACzABAX9BfiECAkAgAUUNACABQgA3AwAgAEUNACABIABByAFqKQMANwMAQQAhAgsgAgswAQF/QX4hAgJAIAFFDQAgAUIANwMAIABFDQAgASAAQagBaikDADcDAEEAIQILIAIL9gICBn8CfiMAQYAgayIDJABCACEJAkAgAEUNACABUA0AIAAvAVQiBEECRg0AIARBEUYNACAAEOEJIgVFDQACQAJAIAApA1ggACkDeH0iCiABIAogAVQbIAWtfiIBQoCAgIAQVA0AQX8gBXBBf3OtIQEMAQsgAVANAQtBACEEAkAgACkDcCIJIAEgCSABQv////8Pg1QbpyIGRQ0AIAAQ4QkiB0UNAAJAAkAgAg0AQQAhAgJAA0AgBiACIgRNDQEgBiAEayICQf////8HIAJB/////wdJGyIIIARqIQIgACgCDCAIQQEgACgCCBEEAA0ACwsDQCAGIARNDQIgACgCDCADIAYgBGsiAkGAICACQYAgSRsiAiAAKAIAEQQAIgggBGohBCAIIAJPDQAMAgsACyAAKAIMIAIgBiAAKAIAEQQAIQQLIAAgACkDcCAErX03A3AgACAAKQN4IAQgB26tfDcDeAsgBCAFbq0hCQsgA0GAIGokACAJCzAAAkACQCAAQaAEQaEEIAEgAhDWCUUNAEEBIQIgABDaCQ0BCyABEPIJQQAhAgsgAgsLACABIAIgABDzCQsPACAAIAEgAkEBRhD0CUULogEBAn8CQAJAIAAoAkxBAEgNACAAEDghASAAENssGiAAIAAoAgwRAQAaIAFFDQEgABA5DAELIAAQ2ywaIAAgACgCDBEBABoLAkAgAC0AAEEBcQ0AAkAgACgCNCIBRQ0AIAEgACgCODYCOAsC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NAIQfnwgE0FoajQCACAGNAIUfnwgE0FkajQCACAGNAIYfnwgE0FgajQCACAGNAIcfnwhFQsgFSAUh6chAgwBC0EAIQICQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0F/ag4gHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAgCyATQYB/aigCACAGKAJ8bCECCyATQYR/aigCACAGKAJ4bCACaiECCyATQYh/aigCACAGKAJ0bCACaiECCyATQYx/aigCACAGKAJwbCACaiECCyATQZB/aigCACAGKAJsbCACaiECCyATQZR/aigCACAGKAJobCACaiECCyATQZh/aigCACAGKAJkbCACaiECCyATQZx/aigCACAGKAJgbCACaiECCyATQaB/aigCACAGKAJcbCACaiECCyATQaR/aigCACAGKAJYbCACaiECCyATQah/aigCACAGKAJUbCACaiECCyATQax/aigCACAGKAJQbCACaiECCyATQbB/aigCACAGKAJMbCACaiECCyATQbR/aigCACAGKAJIbCACaiECCyATQbh/aigCACAGKAJEbCACaiECCyATQbx/aigCACAGKAJAbCACaiECCyATQUBqKAIAIAYoAjxsIAJqIQILIBNBRGooAgAgBigCOGwgAmohAgsgE0FIaigCACAGKAI0bCACaiECCyATQUxqKAIAIAYoAjBsIAJqIQILIBNBUGooAgAgBigCLGwgAmohAgsgE0FUaigCACAGKAIobCACaiECCyATQVhqKAIAIAYoAiRsIAJqIQILIBNBXGooAgAgBigCIGwgAmohAgsgE0FgaigCACAGKAIcbCACaiECCyATQWRqKAIAIAYoAhhsIAJqIQILIBNBaGooAgAgBigCFGwgAmohAgsgE0FsaigCACAGKAIQbCACaiECCyATQXBqKAIAIAYoAgxsIAJqIQILIBNBdGooAgAgBigCCGwgAmohAgsgE0F4aigCACAGKAIEbCACaiECCyATQXxqKAIAIAYoAgBsIAJqIQILIAIgBHUhAgsgEyATKAIAIAJqNgIAIBFBAWohEQwACwALIBBBAUYNASAQQX9qIRAgDCAPQQJ0aiEMIAsgDyAKGyEPDAALAAsg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KAIAKAIsEQQAIQALQQAhAyAAQQQgACgCACgCABECAA0BDAILAkAgA0UNACADIAAgAiADKAIAKAIwEQQAIQALQQAhAyAAQQQgACgCACgCABECAEUNAQsgACgCBCEDCyADC4gBAQF/IAIoAighAwJAAkACQCABRQ0AAkAgA0UNACADIAAgAiADKAIAKAIsEQQAIQALQQAhAyAAQQMgACgCACgCABECAA0BDAILAkAgA0UNACADIAAgAiADKAIAKAIwEQQAIQALQQAhAyAAQQMgACgCACgCABECAEUNAQsgAC0ABEEARyEDCyADCyMAAkAgAC0AICABRg0AIAAgAToAICAAIAAoAgAoAjQRAAALC4UBAQF/IAIoAighAwJAAkACQCABRQ0AAkAgA0UNACADIAAgAiADKAIAKAIsEQQAIQALQQAhAyAAQQYgACgCACgCABECAA0BDAILAkAgA0UNACADIAAgAiADKAIAKAIwEQQAIQALQQAhAyAAQQYgACgCACgCABECAEUNAQsgACgCBCEDCyADC4UBAQF/IAIoAighAwJAAkACQCABRQ0AAkAgA0UNACADIAAgAiADKAIAKAIsEQQAIQALQQAhAyAAQQcgACgCACgCABECAA0BDAILAkAgA0UNACADIAAgAiADKAIAKAIwEQQAIQALQQAhAyAAQQcgACgCACgCABECAEUNAQsgACgCBCEDCyADCwIACwQAQQAL2QEBA38jAEEQayIBJAACQCAAKAIEKAIgIgJFDQACQAJAAkACQAJAAkAgAiACKAIAKAIIEQEAIgNB0HxqDgIEAQALIANBqgNGDQEgA0H1A0YNBCADQcEDRg0CIANBugNHDQUgACgCCCACKgIgOAIEDAULIAAoAghBBGogAUEEaiACQSBqEJYFIgIQqgUgAhCFBRoMBAsgACgCCCACKAIgNgIEDAMLIAAoAgggAi0AIDoABAwCCyAAKAIIIAIoAiA2AgQMAQsgACgCCCACKAIgNgIECyABQRBqJAALBAAgAAsHACAAEIYBCx0AIAAQ8QsgASACIAAoAgggAyAAKAIEEOcLEPULC+A5AAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBeWoOygF6exMUfn8TFBAREg+6AWhpugG6AWBhZLoBugG6AboBbLoBVldYugG6AboBXLoBugFVugG6AboBWVu6AboBugG6AboBugG6AboBugG6AUy6AboBugG6AUFCQ0S6AboBugFLugG6AboBugG6AboBugG6AWVmZ3Bxdnd4eboBkAGRAZIBugG6AboBugGZAZoBmwGcAZ0BngG6AboBkwGUAZUBlgGXAZgBugG6AboBugFdXl+6AboBugG6AboBugFqa7oBcnO6AboBugG6AboBugG6AboBugG6AboBugFAugG6AboBugG6AboBugG6AboBugG6AboBugG6AboBugFFugG6AboBbW5vugG6AVK6AboBugG6AboBAboBugG6AboBAroBugG6AboBAwQFBgcIugG6AboBugG6AboBugG6AboBugG6AT08ugFRugG6AboBugG3AbgBAAsCQCABQeN9ag5hsgGzAboBsQG6AboBugE+ugG6AboBugE/ugGAAYEBugG6AYIBgwGGAYcBhAGFAboBugG6AboBugG6AboBugGiAaMBpAG6AaUBqQGqAagBugG6AZ8BpgGnAawBrQGrAboBoQG6AaABRkdISboBugG6AboBugG6AboBugG6AboBugG6AboBugG6AboBugG6AboBugG6AboBCboBugG0AbUBugG6Aa8BtgENDroBugG6AboBugG6AXR1AAsCQCABQY58ag4hGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyugG6AboBugG6AbkBAAsCQCABQc56ag4eVLoBWroBugG6AboBODk6O7oBugG6AboBugF8fboBugG6AboBU7oBugG6AYkBigGLAYwBAAsCQCABQYR7ag4RjQG6AboBugE0NTY3jgGPAboBugG6AboBugG6AU0ACwJAIAFBqHpqDgMKCwwACwJAIAFBqX5qDgJiYwALAkACQCABQZF+ag4FUbsBuwG7AQEACwJAIAFB6nxqDgJPUAALAkAgAUHpemoOAhYXAAsgAUHlAUYNSiABQZICRg2uASABQYYDRg2wASABQakFRg2IASABQdAERg0zIAFBowVGDRcgAUG/BEcNugEgACoCICACWw26ASAAIAI4AiAgACAAKAIAKAI0EQAADwsgACoCOCACWw25ASAAIAI4AjggACAAKAIAKAJEEQAADwsgACoCOCACWw24ASAAIAI4AjggACAAKAIAKAJEEQAADwsgACoCRCACWw23ASAAIAI4AkQgACAAKAIAKAJYEQAADwsgACoCUCACWw22ASAAIAI4AlAgACAAKAIAKAJkEQAADwsgACoCVCACWw21ASAAIAI4AlQgACAAKAIAKAJoEQAADwsgACoCWCACWw20ASAAIAI4AlggACAAKAIAKAJsEQAADwsgACoCYCACWw2zASAAIAI4AmAgACAAKAIAKAKAAREAAA8LIAAqAmQgAlsNsgEgACACOAJkIAAgACgCACgChAERAAAPCyAAKgJoIAJbDbEBIAAgAjgCaCAAIAAoAgAoAogBEQAADwsgACoCTCACWw2wASAAIAI4AkwgACAAKAIAKAJgEQAADwsgACoCXCACWw2vASAAIAI4AlwgACAAKAIAKAJsEQAADwsgACoCYCACWw2uASAAIAI4AmAgACAAKAIAKAJwEQAADwsgACoCZCACWw2tASAAIAI4AmQgACAAKAIAKAJ0EQAADwsgACoCTCACWw2sASAAIAI4AkwgACAAKAIAKAJgEQAADwsgACoCUCACWw2rASAAIAI4AlAgACAAKAIAKAJkEQAADwsgACoCRCACWw2qASAAIAI4AkQgACAAKAIAKAJIEQAADwsgACoCYCACWw2pASAAIAI4AmAgACAAKAIAKAJQEQAADwsgACoCZCACWw2oASAAIAI4AmQgACAAKAIAKAJUEQAADwsgACoCaCACWw2nASAAIAI4AmggACAAKAIAKAJYEQAADwsgACoCnAEgAlsN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AAAPCyAAKgJkIAJbDVQgACACOAJkIAAgACgCACgCYBEAAA8LIAAqAmggAlsNUyAAIAI4AmggACAAKAIAKAJkEQAADwsgACoCbCACWw1SIAAgAjgCbCAAIAAoAgAoAmgRAAAPCyAAKgLcASACWw1RIAAgAjgC3AEgACAAKAIAKAKMAREAAA8LIAAqAuABIAJbDVAgACACOALgASAAIAAoAgAoApABEQAADwsgACoC5AEgAlsNTyAAIAI4AuQBIAAgACgCACgClAERAAAPCyAAKgLoASACWw1OIAAgAjgC6AEgACAAKAIAKAKYAREAAA8LIAAqAvABIAJbDU0gACACOALwASAAIAAoAgAoAqgBEQAADwsgACoC9AEgAlsNTCAAIAI4AvQBIAAgACgCACgCrAERAAAPCyAAKgL4ASACWw1LIAAgAjgC+AEgACAAKAIAKAKwAREAAA8LIAAqAvwBIAJbDUogACACOAL8ASAAIAAoAgAoArQBEQAADwsgACoCZCACWw1JIAAgAjgCZCAAIAAoAgAoAmARAAAPCyAAKgJoIAJbDUggACACOAJoIAAgACgCACgCZBEAAA8LIAAqAvABIAJbDUcgACACOALwASAAIAAoAgAoAqgBEQAADwsgACoCgAIgAlsNRiAAIAI4AoACIAAgACgCACgCtAERAAAPCyAAKgLIASACWw1FIAAgAjgCyAEgACAAKAIAKAKcAREAAA8LIAAqAswBIAJbDUQgACACOALMASAAIAAoAgAoAqABEQAADwsgACoCZCACWw1DIAAgAjgCZCAAIAAoAgAoAmARAAAPCyAAKgJoIAJbDUIgACACOAJoIAAgACgCACgCZBEAAA8LIAAqAmwgAlsNQSAAIAI4AmwgACAAKAIAKAJoEQAADwsgACoCcCACWw1AIAAgAjgCcCAAIAAoAgAoAmwRAAAPCyAAKgLIASACWw0/IAAgAjgCyAEgACAAKAIAKAKcAREAAA8LIAAqAswBIAJbDT4gACACOALMASAAIAAoAgAoAqABEQAADwsgACoC1AEgAlsNPSAAIAI4AtQBIAAgACgCACgCqAERAAAPCyAAKgLYASACWw08IAAgAjgC2AEgACAAKAIAKAKsAREAAA8LIAAqAsgJIAJbDTsgACACOALICSAAIAAoAgAoAtQBEQAADwsgACoCzAkgAlsNOiAA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QCAALQDsASABRg0AIAAgAToA7AEgACAAKAIAKAKkAREAAAsLBwAgABCGAQsdACAAEPELIAEgAiAAKAIIIAMgACgCBBDqCxCIDAv6AQACQAJAAkACQAJAIAFBW2oOAgECAAsCQAJAIAFB2ABGDQAgAUGLBUYNASABQf4ERg0EIAFBqwRHDQUgACgCICACRg0FIAAgAjYCICAAIAAoAgAoAjQRAAAPCyAAKAIcIAJGDQQgACACNgIcIAAgACgCACgCPBEAAA8LIAAoAgggAkYNAyAAIAI2AgggACAAKAIAKAIsEQAADwsgACgCOCACRg0CIAAgAjYCOCAAIAAoAgAoAkQRAAAPCyAAKAI4IAJGDQEgACACNgI4IAAgACgCACgCRBEAAA8LIAAoAgggAkYNACAAIAI2AgggACAAKAIAKAIoEQAACwsiACABIAIQigwhAUEIEIgBIgIgATYCBCACQfj/ETYCACACC4cBAQF/AkACQAJAAkACQAJAIAFBW2oOAgECAAsCQAJAIAFB2ABGDQAgAUGLBUYNASABQf4ERg0EQQAhAiABQasERw0GIABBIGohAQwFCyAAQRxqIQEMBAsgAEEIaiEBDAMLIABBOGohAQwCCyAAQThqIQEMAQsgAEEIaiEBCyABKAIAIQILIAILBwAgABCGAQsdACAAEPELIAEgAiAAKAIIIAMgACgCBBDtCxCNDAvKOAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFB6HtqDsQBUXOaAbUBtQG1AbUBtQG1AbUBtQG1AbUBAQIDtQG1AQS1AbUBtQG1AbUBBrUBtQG1AQgKDLUBtQG1AbUBtQG1AbUBBbUBtQEOtQG1AbUBtQG1AYkBtQG1AZABkQG1ASssLbUBtQG1AbUBLi8wMTIzNDU2N7UBODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PViq1AbUBtQG1AZkBtQG1AbUBtQG1AbUBtQG1AbUBtQFpamu1AbUBfLUBKCm1AbUBtQGSAbUBtQG1AbUBISIjJJgBtQG1ASUmtQG1AbUBZLUBlwG1AbUBkwGwAbUBsQGPAQ21AVK1AbUBtQG1AbUBtQG1AbUBtQG1AbUBtQG1AbUBtQEntQG1AQcJtQG1AbUBlAGVAZYBtQG1AbUBtQG1AbUBGLUBtQEbGhm1AbUBtQEXAAsCQCABQaR/ag4mgwGEAbUBnQG1AbUBtQG1AbUBtQGbAZwBtQG1AbUBtQG1AbUBngGfAaABoQG1AbUBtQGAAbUBDxCHAWW1AbUBhQG1AbUBggEdAAsCQCABQet+ag4gWbUBbW61AbUBX2i1AW+1AXC1AbUBtQG1AVy1AWxdtQG1AX21ARG1ARa1AbUBEhMUAAsCQCABQVhqDh6BAbUBtQG1AbUBtQG1AbUBfn+1AVu1AWC1AbUBdne1AXh5erUBtQG1AbUBtQFTVFUACwJAIAFBoH5qDhFhYrUBV2a1AbUBtQG1AbUBtQG1AYgBWrUBtQFnAAsCQCABQch9ag4PjAGNAbUBtQGiAbUBtQG1AagBtQG1AbUBtQGjAaQBAAsCQCABQb1+ag4MFbUBHh+1AbUBtQG1AbUBswG1AYYBAAsCQCABQel9ag4LqgG1AawBtQG1Aa0BtQG1Aa4BtQGrAQALAkAgAUH7fGoODFC1AbUBdHW1AbUBtQG1AbUBY1gACwJAIAFB2H1qDgcgtQFetQG1AYoBiwEACwJAIAFBo31qDglxcrUBtQG1AbUBtQGmAacBAAsCQCABQYd9ag4CrwGlAQALAkAgAUHrfGoOBHu1AbUBtAEACyABQQVGDQogAUEXRg0bIAFB+QFGDY0BIAFBkAJGDbEBIAFBzwJGDagBIAFB7gNHDbQBIAAoAtABIAJGDbQBIAAgAjYC0AEgACAAKAIAKAKkAREAAA8LIAAoAgwgAkYNswEgACACNgIMIAAgACgCACgCLBEAAA8LIAAoAhAgAkYNsgEgACACNgIQIAAgACgCACgCMBEAAA8LIAAoAhQgAkYNsQEgACACNgIUIAAgACgCACgCNBEAAA8LIAAoAgggAkYNsAEgACACNgIIIAAgACgCACgCKBEAAA8LIAAoAhggAkYNrwEgACACNgIYIAAgACgCACgCMBEAAA8LIAAoAiAgAkYNrgEgACACNgIgIAAgACgCACgCNBEAAA8LIAAoAhggAkYNrQEgACACNgIYIAAgACgCACgCMBEAAA8LIAAoAhQgAkYNrAEgACACNgIUIAAgACgCACgCLBEAAA8LIAAoAhQgAkYNqwEgACACNgIUIAAgACgCACgCKBEAAA8LIAAoAhQgAkYNqgEgACACNgIUIAAgACgCACgCLBEAAA8LIAAoAhQgAkYNqQEgACACNgIUIAAgACgCACgCLBEAAA8LIAAoAjggAkYNqAEgACACNgI4IAAgACgCACgCRBEAAA8LIAAoAiAgAkYNpwEgACACNgIgIAAgACgCACgCNBEAAA8LIAAoAiAgAkYNpgEgACACNgIgIAAgACgCACgCNBEAAA8LIAAoAjggAkYNpQEgACACNgI4IAAgACgCACgCRBEAAA8LIAAoAjwgAkYNpAEgACACNgI8IAAgACgCACgCSBEAAA8LIAAoAjwgAkYNowEgACACNgI8IAAgACgCACgCUBEAAA8LIAAoAkggAkYNogEgACACNgJIIAAgACgCACgCXBEAAA8LIAAoAkQgAkYNoQEgACACNgJEIAAgACgCACgCWBEAAA8LIAAoAkggAkYNoAEgACACNgJIIAAgACgCACgCXBEAAA8LIAAoAkwgAkYNnwEgACACNgJMIAAgACgCACgCYBEAAA8LIAAoAkggAkYNngEgACACNgJIIAAgACgCACgCXBEAAA8LIAAoAjggAkYNnQEgACACNgI4IAAgACgCACgCRBEAAA8LIAAoAjwgAkYNnAEgACACNgI8IAAgACgCACgCUBEAAA8LIAAoAkQgAkYNmwEgACACNgJEIAAgACgCACgCXBEAAA8LIAAoAkggAkYNmgEgACACNgJIIAAgACgCACgCYBEAAA8LIAAoAkAgAkYNmQEgACACNgJAIAAgACgCACgCWBEAAA8LIAAoAqQBIAJGDZgBIAAgAjYCpAEgACAAKAIAKAJ8EQAADwsgACgCqAEgAkYNlwEgACACNgKoASAAIAAoAgAoAoABEQAADwsgACgCxAEgAkYNlgEgACACNgLEASAAIAAoAgAoAqABEQAADwsgACgCRCACRg2VASAAIAI2AkQgACAAKAIAKAJIEQAADwsgACgCpAEgAkYNlAEgACACNgKkASAAIAAoAgAoAnwRAAAPCyAAKAL0ASACRg2TASAAIAI2AvQBIAAgACgCACgCvAERAAAPCyAAKAL4ASACRg2SASAAIAI2AvgBIAAgACgCACgCwAERAAAPCyAAKAL8ASACRg2RASAAIAI2AvwBIAAgACgCACgCxAERAAAPCyAAKAKAAiACRg2QASAAIAI2AoACIAAgACgCACgCyAERAAAPCyAAKAI4IAJGDY8BIAAgAjYCOCAAIAAoAgAoAkQRAAAPCyAAKAI8IAJGDY4BIAAgAjYCPCAAIAAoAgAoAkgRAAAPCyAAKAKgASACRg2NASAAIAI2AqABIAAgACgCACgCrAERAAAPCyAAKAKoASACRg2MASAAIAI2AqgBIAAgACgCACgCtAERAAAPCyAAKAKsASACRg2LASAAIAI2AqwBIAAgACgCACgCuAERAAAPCyAAKAKwASACRg2KASAAIAI2ArABIAAgACgCACgCvAERAAAPCyAAKAK0ASACRg2JASAAIAI2ArQBIAAgACgCACgCwAERAAAPCyAAKAK4ASACRg2IASAAIAI2ArgBIAAgACgCACgCxAERAAAPCyAAKAK8ASACRg2HASAAIAI2ArwBIAAgACgCACgCyAERAAAPCyAAKALEASACRg2GASAAIAI2AsQBIAAgACgCACgC0AERAAAPCyAAKALIASACRg2FASAAIAI2AsgBIAAgACgCACgC1AERAAAPCyAAKALMASACRg2EASAAIAI2AswBIAAgACgCACgC2AERAAAPCyAAKALQASACRg2DASAAIAI2AtABIAAgACgCACgC3AERAAAPCyAAKALUASACRg2CASAAIAI2AtQBIAAgACgCACgC4AERAAAPCyAAKALYASACRg2BASAAIAI2AtgBIAAgACgCACgC5AERAAAPCyAAKALcASACRg2AASAAIAI2AtwBIAAgACgCACgC6AERAAAPCyAAKALgASACRg1/IAAgAjYC4AEgACAAKAIAKALsAREAAA8LIAAoAuQBIAJGDX4gACACNgLkASAAIAAoAgAoAvABEQAADwsgACgC6AEgAkYNfSAAIAI2AugBIAAgACgCACgC9AERAAAPCyAAKALwASACRg18IAAgAjYC8AEgACAAKAIAKAL8AREAAA8LIAAoAvQBIAJGDXsgACACNgL0ASAAIAAoAgAoAoACEQAADwsgACgC+AEgAkYNeiAAIAI2AvgBIAAgACgCACgChAIRAAAPCyAAKAL8ASACRg15IAAgAjYC/AEgACAAKAIAKAKIAhEAAA8LIAAoAoACIAJGDXggACACNgKAAiAAIAAoAgAoAowCEQAADwsgACgChAIgAkYNdyAAIAI2AoQCIAAgACgCACgCkAIRAAAPCyAAKAKIAiACRg12IAAgAjYCiAIgACAAKAIAKAKUAhEAAA8LIAAoAowCIAJGDXUgACACNgKMAiAAIAAoAgAoApgCEQAADwsgACgCkAIgAkYNdCAAIAI2ApACIAAgACgCACgCnAIRAAAPCyAAKAKUAiACRg1zIAAgAjYClAIgACAAKAIAKAKgAhEAAA8LIAAoApgCIAJGDXIgACACNgKYAiAAIAAoAgAoAqQCEQAADwsgACgCnAIgAkYNcSAAIAI2ApwCIAAgACgCACgCqAIRAAAPCyAAKAKgAiACRg1wIAAgAjYCoAIgACAAKAIAKAKsAhEAAA8LIAAoAqQCIAJGDW8gACACNgKkAiAAIAAoAgAoArACEQAADwsgACgCqAIgAkYNbiAAIAI2AqgCIAAgACgCACgCtAIRAAAPCyAAKAKsAiACRg1tIAAgAjYCrAIgACAAKAIAKAK4AhEAAA8LIAAoArACIAJGDWwgACACNgKwAiAAIAAoAgAoArwCEQAADwsgACgCtAIgAkYNayAAIAI2ArQCIAAgACgCACgCwAIRAAAPCyAAKAK4AiACRg1qIAAgAjYCuAIgACAAKAIAKALEAhEAAA8LIAAoArwCIAJGDWkgACACNgK8AiAAIAAoAgAoAsgCEQAADwsgACgCwAIgAkYNaCAAIAI2AsACIAAgACgCACgCzAIRAAAPCyAAKALEAiACRg1nIAAgAjYCxAIgACAAKAIAKALQAhEAAA8LIAAoAsgCIAJGDWYgACACNgLIAiAAIAAoAgAoAtQCEQAADwsgACgCzAIgAkYNZSAAIAI2AswCIAAgACgCACgC2AIRAAAPCyAAKAIIIAJGDWQgACACNgIIIAAgACgCACgCLBEAAA8LIAAoAhQgAkYNYyAAIAI2AhQgACAAKAIAKAIoEQAADwsgACgCCCACRg1iIAAgAjYCCCAAIAAoAgAoAiwRAAAPCyAAKAIIIAJGDWEgACACNgIIIAAgACgCACgCKBEAAA8LIAAoAhAgAkYNYCAAIAI2AhAgACAAKAIAKAIsEQAADwsgACgCFCACRg1fIAAgAjYCFCAAIAAoAgAoAjARAAAPCyAAKAIcIAJGDV4gACACNgIcIAAgACgCACgCPBEAAA8LIAAoAgggAkYNXSAAIAI2AgggACAAKAIAKAIsEQAADwsgACgCDCACRg1cIAAgAjYCDCAAIAAoAgAoAjARAAAPCyAAKAIoIAJGDVsgACACNgIoIAAgACgCACgCNBEAAA8LIAAoAjggAkYNWiAAIAI2AjggACAAKAIAKAJEEQAADwsgACgCCCACRg1ZIAAgAjYCCCAAIAAoAgAoAigRAAAPCyAAKAIIIAJGDVggACACNgIIIAAgACgCACgCKBEAAA8LIAAoAhAgAkYNVyAAIAI2AhAgACAAKAIAKAIsEQAADwsgACgCGCACRg1WIAAgAjYCGCAAIAAoAgAoAjQRAAAPCyAAKAIIIAJGDVUgACACNgIIIAAgACgCACgCMBEAAA8LIAAoAgggAkYNVCAAIAI2AgggACAAKAIAKAIoEQAADwsgACgCFCACRg1TIAAgAjYCFCAAIAAoAgAoAiwRAAAPCyAAKAIYIAJGDVIgACACNgIYIAAgACgCACgCMBEAAA8LIAAoAhwgAkYNUSAAIAI2AhwgACAAKAIAKAI0EQAADwsgACgCCCACRg1QIAAgAjYCCCAAIAAoAgAoAiwRAAAPCyAAKAIcIAJGDU8gACACNgIcIAAgACgCACgCPBEAAA8LIAAoAhAgAkYNTiAAIAI2AhAgACAAKAIAKAI8EQAADwsgACgCCCACRg1NIAAgAjYCCCAAIAAoAgAoAiwRAAAPCyAAKAIMIAJGDUwgACACNgIMIAAgACgCACgCNBEAAA8LIAAoAgggAkYNSyAAIAI2AgggACAAKAIAKAIwEQAADwsgACgCDCACRg1KIAAgAjYCDCAAIAAoAgAoAjQRAAAPCyAAKAIQIAJGDUkgACACNgIQIAAgACgC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CwJAIAFB63xqDgR7tgG2AbQBAAsgAUEFRg0KIAFBF0YNGyABQfkBRg2NASABQZACRg2xASABQc8CRg2oASABQe4DRw21ASAAQdABaiECDLQBCyAAQQxqIQIMswELIABBEGohAgyyAQsgAEEUaiECDLEBCyAAQQhqIQIMsAELIABBGGohAgyvAQsgAEEgaiECDK4BCyAAQRhqIQIMrQELIABBFGohAgysAQsgAEEUaiECDKsBCyAAQRRqIQIMqgELIABBFGohAgypAQsgAEE4aiECDKgBCyAAQSBqIQIMpwELIABBIGohAgymAQsgAEE4aiECDKUBCyAAQTxqIQIMpAELIABBPGohAgyjAQsgAEHIAGohAgyiAQsgAEHEAGohAgyhAQsgAEHIAGohAgygAQsgAEHMAGohAgyfAQsgAEHIAGohAgyeAQsgAEE4aiECDJ0BCyAAQTxqIQIMnAELIABBxABqIQIMmwELIABByABqIQIMmgELIABBwABqIQIMmQELIABBpAFqIQIMmAELIABBqAFqIQIMlwELIABBxAFqIQIMlgELIABBxABqIQIMlQELIABBpAFqIQIMlAELIABB9AFqIQIMkwELIABB+AFqIQIMkgELIABB/AFqIQIMkQELIABBgAJqIQIMkAELIABBOGohAgyPAQsgAEE8aiECDI4BCyAAQaABaiECDI0BCyAAQagBaiECDIwBCyAAQawBaiECDIsBCyAAQbABaiECDIoBCyAAQbQBaiECDIkBCyAAQbgBaiECDIgBCyAAQbwBaiECDIcBCyAAQcQBaiECDIYBCyAAQcgBaiECDIUBCyAAQcwBaiECDIQBCyAAQdABaiECDIMBCyAAQdQBaiECDIIBCyAAQdgBaiECDIEBCyAAQdwBaiECDIABCyAAQeABaiECDH8LIABB5AFqIQIMfgsgAEHoAWohAgx9CyAAQfABaiECDHwLIABB9AFqIQIMewsgAEH4AWohAgx6CyAAQfwBaiECDHkLIABBgAJqIQIMeAsgAEGEAmohAgx3CyAAQYgCaiECDHYLIABBjAJqIQIMdQsgAEGQAmohAgx0CyAAQZQCaiECDHMLIABBmAJqIQIMcgsgAEGcAmohAgxxCyAAQaACaiECDHALIABBpAJqIQIMbwsgAEGoAmohAgxuCyAAQawCaiECDG0LIABBsAJq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KAIANgIAIAMgAygCCEEEajYCCCAAIAMQngggAxCfCBoLIAJBIGokAAsHACAAEIYBCx0AIAAQ8QsgASACIAAoAgggAyAAKAIEEO4LEI0MCyIAIAEgAhCPDCEBQQgQiAEiAiABNgIEIAJB4KYSNgIAIAILBABBAAu3BAEIfyMAQRBrIgIkAAJAAkACQAJAIAEoAgAgASgCBBCXByIDDQBBASEDDAELIAIgADYCCCADQcwAaiACQQhqELYIQQAhAyAAKAIcIgRFDQAgBEHoAyAEKAIAKAIMEQIAIQUgACgCHCEEAkAgBUUNACAEIAAQqAwMAQsCQAJAIAQgBCgCACgCCBEBACIEQal8akEFSQ0AIARB9wNGDQAgBEHfA0cNAQsgASgCACABKAIEEKkMIgFFDQECQCABKAIEIgVBPGooAgAiASAFQcAAaigCACIGTw0AIAEgADYCACAFIAFBBGo2AjwMAgsgASAFKAI4IgRrQQJ1IgdBAWoiA0GAgICABE8NAkEAIQgCQCAGIARrIgZBAXUiCSADIAkgA0sbQf////8DIAZB/P///wdJGyIGRQ0AIAZBgICAgARPDQQgBkECdBCIASEIIAUoAjghBCAFKAI8IQELIAggB0ECdGoiByAANgIAIAchAAJAA0AgASAERg0BIAFBfGoiASgCACEDIAFBADYCACAAQXxqIgAgAzYCAAwACwALIAUoAjghBCAFIAA2AjggBSgCPCEBIAUgB0EEajYCPCAFIAggBkECdGo2AkACQANAIAEgBEYNASABQXxqEKoMIQEMAAsAC0EAIQMgBEUNASAEEIYBDAELIAEoAgAgASgCBBCHBSIBRQ0AIAEoAgQhASACIAA2AgwgAUG8CmogAkEMahC2CAsgAkEQaiQAIAMPCxAAAAsQjAUACygBAX8jAEEQayICJAAgAiABNgIMIABBFGogAkEMahC2CCACQRBqJAALHQACQCAAIAFBNRDSByIBDQBBAA8LIAFBDGooAgALKQEBfyAAKAIAIQEgAEEANgIAAkAgAUUNACABIAEoAgAoAgQRAAALIAALWgEBfyAAQZygEjYCFCAAQcyfEjYCAAJAIAAoAiQiAUUNACABIAEoAgAoAgQRAAALIABBADYCJAJAIAAoAigiAUUNACABIAEoAgAoAgQRAAALIABBADYCKCAACwoAIAAQqwwQhgELBQBBvgMLCAAgAUG+A0YLUgEBfwJAAkACQAJAAkAgAUG2e2oOAgABAgsgACACEIMFNgIIDAILIAAgAhCDBTYCDAwBC0EAIQMgAUGUBUcNASAAIAIQgwU2AhALQQEhAwsgAwsCAAsCAAsCAAs6AQJ/AkAgACgCDCIBQQNxRQ0AIAAoAiQiAkUNACACIAAoAhwgACgCCCABQQFxIAIoAgAoAggRBwALC5IBAQF/AkAgAUECcUUNACAAKAIoIgJFDQAgAiACKAIAKAI8EQAACwJAIAAoAiBFDQAgACgCJCICRQ0AAkAgAUEEcUUNACACIAAoAhwgAigCACgCEBEDAAsgAUGAIHFFDQAgACgCDCIBQQNxQQFGDQAgACgCJCICIAAoAhwgACgCCCABQQFxRSACKAIAKAIMEQcACwuaAwEBfwJAIAAoAiQiAUUNACABIAEoAgAoAgQRAAALIABBADYCJAJAAkACQAJAAkACQAJAAkACQCAAKAIoIgENAAJAIAAoAiAiASABKAIAKAIIEQEAIgFB0HxqDgIGAwALAkAgAUHHfGoOAgcCAAsgAUGqA0YNBCABQcEDRg0DIAFB9QNHDQgMBwsgASABKAIAKAI0EQEAQX9qDgcBAAIDBQQGBwtBDBCIASAAEN0LIgFB3P4RNgIAIAAgATYCJAwGC0EMEIgBIAAQ3QsiAUGA/xE2AgAgACABNgIkDAULQQwQiAEgABDdCyIBQaT/ETYCACAAIAE2AiQMBAtBDBCIASAAEN0LIgFB1P8RNgIAIAAgATYCJAwDC0EMEIgBIAAQ3QsiAUGEgBI2AgAgACABNgIkDAILQRgQiAEgABDdCyIBQgA3AgwgAUG0gBI2AgAgAUEUakEANgIAIAAgATYCJCABIAAoAhwQlQwMAQtBDBCIASAAEN0LIgFB2IASNgIAIAAgATYCJAsgAEGAIEEBIAAoAgAoAkQRBQALJQEBfwJAIAAoAiQiAUUNACABIAEoAgAoAhQRAAAgAEEANgIkCwtXAQF/AkAgAC8BGCIDIAFxIAFGDQAgACADIAFyOwEYIAAoAhwiAUUNACABQegDIAEoAgAoAgwRAgBFDQAgACgCHCgCICIBQYIgQQAgASgCACgCRBEFAAsLDgAgAEFsaiABQQAQtwwLMgEBf0EsEIgBQQBBLBA6ELoMIgEgACgCCDYCCCABIAAoAgw2AgwgASAAKAIQNgIQIAELRgAgAEKAgICAcDcCDCAAQv////8PNwIEIABCADcCHCAAQf7/AzsBGCAAQZygEjYCFCAAQcyfEjYCACAAQSRqQgA3AgAgAAsEACAACz0CAX4CfyABENoLIQIgASgCCCEDQQAhBAJAIAEtAAwNACABIAMgAqciBGo2AggLIAAgBDYCBCAAIAM2AgALpgEBBH8jAEEgayICJAAgASgCBCEDIAEoAgAhAUEAIQQgAkEAOwEcIAIgATYCGCACIAM2AhQgAiABNgIQIABBLGohBSABIQACQANAIAAgASADakYNASAEQf8BcQ0BIAItAB1B/wFxDQEgAiACQRBqEIMFNgIMIAUgAkEMahC+DCACLQAcIQQgAigCFCEDIAIoAhAhASACKAIYIQAMAAsACyACQSBqJAALlwEBA38jAEEgayICJAACQAJAIAAoAgQiAyAAKAIIRg0AIAMgASgCADYCACAAIANBBGo2AgQMAQsgAkEMaiAAKAIAIgQgAyADIARrQQJ1QQFqEL8MIAAoAgQgACgCAGtBAnUgAEEIahDADCIDKAIIIgQgASgCADYCACADIARBBGo2AgggACADEMEMIAMQwgwaCyACQSBqJAALNwACQCACQYCAgIAESQ0AEAAACyABIABrIgFBAXUiACACIAAgAksbQf////8DIAFB/P///wdJGwtUAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkAgAUUNACABEJgGIQQLIAAgBDYCACAAIAQgAkECdGoiAzYCCCAAIAQgAUECdGo2AgwgACADNgIEIAALkwEBA38gASgCBCECIAAoAgAhAyAAKAIEIQQCQANAIAQgA0YNASACQXxqIgIgBEF8aiIEKAIANgIADAALAAsgASACNgIEIAAoAgAhBCAAIAI2AgAgASAENgIEIAAoAgQhBCAAIAEoAgg2AgQgASAENgIIIAAoAgghBCAAIAEoAgw2AgggASAENgIMIAEgASgCBDYCAAtCAQJ/IAAoAgghASAAKAIEIQICQANAIAEgAkYNASAAIAFBfGoiATYCCAwACwALAkAgACgCACIBRQ0AIAEQhgELIAALEAAgAEEsaiABQSxqEMQMGgvFAQEGfwJAIAAgAUYNAAJAIAEoAgQiAiABKAIAIgNrQQJ1IgQgACgCCCIFIAAo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dGogBDYCACAFQQFqIQUMAAsACyAHIAVBAnRqKAIAIQQCQAJAIAogAiAFELAmIAcgCCALELEmQwAAAD+SjiAEspIiEYtDAAAAT11FDQAgEaghCQwBC0GAgICAeCEJCwJAAkACQCADKAIcIgQgAygCGEgNACADQRhqIARBAWoQriZFDQEgAygCHCEECyADIARBAWo2AhwgAygCICAEQQJ0aiAJQYCAfyAJQYCAf0obIgRBgIABIARBgIABSBs2AgAMAQtBAEEANgLg2hsLIAVBAWohBQwACwALIAAgByAGIAgQtxYMBgsgDiAJNgIAIAFBAWohASAEIA9BAnRqQQJqIQQMAAsACyAGIAVBAnQiCWoqAgAhESADQRhqIAoQrCYgAygCGCAFQRRsakGgkRkgAygCHCAFSxsgA0EsaiADQShqIANBJGoQsiZBACEEAkAgESADKgIsIhIgEiARXxsiESADKgIkIhMgESATXxsiFCADKgIoIhFbDQACQCAUIBGTIBEgEpMgEyARkyAUIBFdG5VDAACARpRDAAAAP5KOIhGLQwAAAE9dRQ0AIBGoIQQMAQtBgICAgHghBAsgByAJaiAENgIAIAVBAWohBQwACwALIAEgC0EDdGoiBSoCBCERIAUoAgAhCkEAIQUDQAJAIAUgCEcNACALQQFqIQsMAgsCQCAJIAVBFGxqQaCRGSAIIAVLGygAACIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZyciAKRw0AIAYgBUECdGogETgCAAsgBUEBaiEFDAALAAsACyADQTBqJAALtwcBAn8CQCAARQ0AIAAoAgBFDQAgACAAKAIAIgFBf2o2AgAgAUEBRw0AIABB08J8NgIAAkAgACgCCCIBRQ0AIAEQhyUgARBHIABBADYCCAsgACgCuAEhAQNAAkAgAQ0AIABBNGpBADYCACAAQTxqIgEoAgAQuCUgAUEANgIAIABBwABqIgEoAgAQuSUgAUEANgIAIABBxABqIgEoAgAQuiUgAUEANgIAIABByABqIgEoAgAQuyUgAUEANgIAIABBzABqIgEoAgAQvCUgAUEANgIAIABB0ABqIgEoAgAQvSUgAUEANgIAIABB1ABqIgEoAgAQviUgAUEANgIAAkAgAEHYAGooAgAiAUUNACABQaCRGUYNACABKAIIEJcNIAFBADYC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AmwgAEIANwKEASAAQfSXEjYCgAEgAEGUlxI2AgAgAEHUAGpCADcCACAAQdwAakIANwIAIABB9ABqQgA3AgAgAEH8AGpBADYCACAAQYwBakEANgIAIAALEQAgAEEoahDrDSAAQQA2AiALMwECfyAAKAIEIQEgACgCACECAkADQCABIAJGDQEgAUF8ahDsDSEBDAALAAsgACACNgIECxgBAX8CQCAAKAIAIgFFDQAgARDnDQsgAAu4AQECfyMAQRBrIgMkACAAQgA3AgAgAEEAOgAcIABCADcCOCAAQQhqQgA3AgAgAEEQakIANwIAIABBwABqQQA2AgAgASgCDCEEIABBJGogASgCADYCACAAIAQ2AiAgA0EIaiABENgNIAAgAykDCDcCKCABKAIAIQQgAEMAAIBBQwAAgD8gApUgAkMAAIA9XRs4AjQgACAENgIwIABBOGogAUEQaigCACABKAIMaxDZDSADQRBqJAAgAAvwAgEGfwJAIAAoAgQiAiAAKAIIRg0AAkAgAUUNACABIAEoAgBBAWo2AgALIAIgATYCACAAIAJBBGo2AgQPCwJAAkAgAiAAKAIAIgNrIgRBAnUiBUEBaiIGQYCAgIAETw0AAkACQCAEQQF1IgcgBiAHIAZLG0H/////AyAEQfz///8HSRsiBA0AQQAhBwwBCyAEQYCAgIAETw0CIARBAnQQiAEhBwsgBEECdCEEIAcgBUECdGohBgJAIAFFDQAgASABKAIAQQFqNgIAIAAoAgAhAyAAKAIEIQILIAcgBGohByAGIAE2AgAgBiEBAkADQCACIANGDQEgAkF8aiICKAIAIQQgAkEANgIAIAFBfGoiASAENgIADAALAAsgACAHNgIIIAAoAgAhBCAAIAE2AgAgACgCBCECIAAgBkEEajYCBAJAA0AgAiAERg0BIAJBfGoQ7A0hAgwACwALAkAgBEUNACAEEIYBCw8LEAAACxCMBQALEAAgAEE4ahCSBhogABC3BwsvAQF/AkAgAEUNACAAIAAoAgQiAUF/ajYCBCABQQFHDQAgACAAKAIAKAIEEQAACwsMACAAKAIAEPANIAALkQMBCX9BAiECAkAgACgCGCIDQRggAygCACgCDBECAEUNACAAKAIYIABBgAFqNgJkIABBiAFqIAAoAoQBNgIAIABBPGooAgAhBCAAKAI4IQUCQANA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ABDADhCGAQsaACAAQayFEjYCACAAQcAAahCbBRogABDIDgsFAEGWAws1AQF/QQEhAgJAAkACQCABQZ1/ag4FAgEBAQIACyABQZYDRg0BIAFBpgNGDQELQQAhAgsgAgsjAAJAIAFBkgRHDQAgACACENMHOAI8QQEPCyAAIAEgAhDEDguoAQEBfyMAQSBrIgMkAAJAAkACQAJAAkAgAUGZfWoOBAEDAwIACyABQcwBRw0CIAAgAhCDBTYCFEEBIQEMAwsgA0EYaiACELwMIAAoAgAoAiwhASADIAMpAhg3AwAgACADIAERAwBBASEBDAILIANBDGogAhCEBSAAQRhqIANBDGoQ2wcgA0EMahCFBRpBASEBDAELIAAgASACEJETIQELIANBIGokACABC2QBA39BIBCIASEDIAEoAgAhBCABKAIEIQUgAUIANwIAIANBHGogBTYCACADIAQ2AhggA0EUaiAFNgIAIAMgBDYCECADQgA3AgggA0EAOgAEIANBATYCACAAQcAAaiADEPMEQQELDAAgAEGqtxAQpAUaCwIACyIAIABBkMwSNgIAIABBMGoQqAsaIABBJGoQ9QQaIAAQjBMLKQEBf0EUEIgBIgFBmMsTNgIAIAFC/////w83AgQgAUEMakIANwIAIAELKQEBf0EUEIgBIgFC/////w83AgQgAUH8hxI2AgAgAUEMakIANwIAIAELNgEBf0EYEIgBIgFCADcCCCABQX82AgQgAUGsiBI2AgAgAUEQakEANgIAIAEgACgCFDYCFCABCyUBAX9BPBCIAUEAQTwQOhDNDiIBIAAqAjg4AjggASAAEMcIIAELGQAgABD0EiIAQaSKEjYCACAAQQA2AjggAAs4AQF/QRQQiAEiAUIANwMAIAFBEGpBADYCACABQQhqQgA3AwAgARDPDiIBQQhqIABBCGoQqgUgAQsqACAAQYSREzYCACAAQX82AgQgAEEIakGx1hoQpAUaIABB0JATNgIAIAALCgAgABDRDhCGAQsWACAAQYSREzYCACAAQQhqEIUFGiAACx4BAX9BJBCIAUEAQSQQOhDTDiIBIAAoAhQ2AhQgAQsSACAAEP8SIgBBmJESNgIAIAALbQEDfyAAQcSSEjYCACAAQShqKAIAIQEgACgCJCECA38CQCACIAFHDQACQCAAKAIkIgJFDQAgACACNgIo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OAIUIAELGgAgAiABkyAAIAMgACgCACgCLBEZAJQgAZILTwEDfSAAKgIMIgJDAABAQJQiAyAAKgIUIgRDAABAwJRDAACAP5KSIABBGGogARCoDSIBlCAEQwAAQECUIAJDAADAwJSSkiABlCADkiABlAsHACAAEIYBCwQAQRwLKAEBf0EBIQICQCABQRxGDQAgAUGLAUYNACABQa8BRg0AQQAhAgsgAgseAQF/QTAQiAFBAEEwEDoQwhAiASAAKAIUNgIUIAELEgAgABCEEyIAQdyUEjYCACAAC1YBAn8gAEHchxI2AgACQCAAKAIIIgFFDQAgAEEMaigCACECAkADQCACIAFGDQEgAkFIahDaDxogAkG4f2ohAgwACwALIAAgATYCDCAAKAIIEIYBCyAACwoAIAAQwxAQhgEL5QEBBH8gACABIAIQxhAgAEEMaigCACEDIAAoAgghACACQfwAaiEEIAJB+ABqIQUCQANAIAAgA0YNAQJAAkACQAJAAkAgACgCACIGKAIYQX9qDgIAAQILIAZBFGohBgwCCyAFKAIAIAQoAgAgBigCHBCTECIGQdkDIAYoAgAoAgwRAgBFDQIgBkEIaiEGDAELIAIgBigCECACKAIAKAI4EQIAQQxqIQYLIAAgBioCAEMAAMhClSIBQwAAAAAgAUMAAAAAXhsiAUMAAIA/IAFDAACAP10bOAJECyAAQcgAaiEADAALAAsLRwECfyAAQQxqKAIAIQMgACgCCCEAAkADQCAAIANGDQECQCAAQQRqIgQQmBBFDQAgBCABIAIQrQUaCyAAQcgAaiEADAALAAsLTgIBfwF9IABBDGooAgAhAyAAKAIIIQACQANAIAAgA0YNAQJAIAAqAkQgApQiBEMAAAAAWw0AIABBBGogBBCDAwsgAEHIAGohAAwACwALCwcAIAAtABQLCgAgABDDEBCGAQtsAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkACQCABRQ0AIAFB5PG4HE8NASABQcgAbBCIASEECyAAIAQ2AgAgACAEIAJByABsaiIDNgIIIAAgBCABQcgAbGo2AgwgACADNgIEIAAPCxCMBQALJgAgACABKAIANgIAIABBBGogAUEEahCfEBogACABKgJEOAJEIAALkgEBA38gASgCBCECIAAoAgAhAyAAKAIEIQQCQANAIAQgA0YN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IAEgA0EEaiAAQTRqELIIIgQQxQwhASAEEJIGGgJAIAFFDQAgAUG6AyABKAIAKAIMEQIARQ0AIAAgATYCMCABIAJBFGpBACACGxDGDAsgA0EQaiQACxkAIABB7KYSNgIAIABBNGoQkgYaIAAQ0gwLCgAgABDnERCGAQsFAEGFBAscACABQZh8akH//wNxIgFBHklBgYCAgAMgAXZxC1wBAX8jAEEQayIDJAACQAJAIAFBxwVHDQAgA0EIaiACELwMIAAoAgAoAkQhASADIAMpAgg3AwAgACADIAERAwBBASEBDAELIAAgASACEKoRIQELIANBEGokACABCwIACxsBAX9BNBCIAUEAQTQQOhDuESIBIAAQ4AwgAQsoACAAEPIMIgBBjKgSNgIkIABBxKcSNgIAIABBKGpBsdYaEKQFGiAAC58EAQR/IwBB0ABrIgMkAAJAAkAgAUECIAEoAgAoAgARAgBFDQAgA0HEAGogASoCBBDwEQJAIANBxABqEPERQX9GDQBBACEEIAMoAkQgA0HEAGogAywATyIBQQBIIgUbIgYgAygCSCABQf8BcSAFG2ohAQJAA0AgASAGRg0BIAFBf2oiAS0AAEEwRg0ACyABIAZrQQFqIQQLIANBxABqIANBOGogA0HEAGpBACAEEKwIIgEQ2wcgARCFBRogA0HEAGoQ8REiBiADKAJIIAMtAE8iASABQRh0QRh1QQBIG0F/akcNACADQcQAaiADQThqIANBxABqQQAgBhCsCCIBENsHIAEQhQUaCyAAQShqIANBLGogA0HEAGoQlgUiARCqBSABEIUFGiADQcQAahCFBRoMAQsCQCABQQYgASgCACgCABECAEUNAAJAAkAgASgCCCIGQQxqKAIAIAYoAggiBmtBAnUgASgCBCIBTQ0AIANBxABqIAYgAUECdGooAgBBFGoQlgUaDAELIANBxABqQbHWGhCkBRoLIABBKGogA0EgaiADQcQAahCWBSIBEKoFIAEQhQUaIANBxABqEIUFGgwBCwJAIAFBASABKAIAKAIAEQIARQ0AIABBKGogA0EUaiABQQRqEJYFIgEQqgUgARCFBRoMAQsgAEEoaiADQQhqQbHWGhCkBSIBEKoFIAEQhQUaCyADQdAAaiQAIABBJGoLMQEBfyMAQRBrIgIkACACQQRqENo2IAAgAkEEaiABENs2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NwIAIABB5AFqQgA3AgAgAAsjACAAELUSIgBBtI4TNgJsIABBrI0TNgIAIABBADYCpAEgAAtKACAAELcSIgBCADcC/AEgAEKBgICAEDcC9AEgAEKAgID8i4CAwL9/NwLsASAAQYjtEjYCyAEgAEH07BI2AmwgAEGg6xI2AgAgAAsZACAAEJAIIgBB8OgSNgIAIABCADcCOCAAC9ABACAAEJAIIgBBOGpBAEHgABA6GiAAQgA3AqQBIABBAzYCoAEgAEKAgID8AzcCmAEgAEGsAWpCADcCACAAQbQBakIANwIAIABCADcC3AEgAEKAgICAEDcC1AEgAEICNwLMASAAQoCAgIAQNwLEASAAQv////8PNwK8ASAAQeQBakIANwIAIABB7AFqQQA6AAAgAEKBgICAEDcC8AEgAEH4AWpBAEHYABA6GiAAQgA3AtQCIABBAToA0AIgAEHcAmpCADcCACAAQajbEjYCACAAC2sBAX8gABCFEyIAQcgAakEAQSgQOhogAEHI6BI2AkQgAEH05xI2AgAgAEGAgID8AzYCcEE4EIgBIgFBADYCDCABQgA3AgQgASAANgIQIAFBhIwTNgIAIAFBFGpBAEEkEDoaIAAgATYCdCAAC34AIAAQtRIiAEIANwKkASAAQawBakIANwIAIABBuAFqQQBBKBA6GiAAQYACaiAAQfABajYCACAAQdDnEjYC8AEgAEG05xI2AugBIABBmOcSNgLkASAAQYTnEjYCtAEgAEHw5hI2AmwgAEG45RI2AgAgAEGAgID8AzYC4AEgAAskACAAEP4SIgBBADoAVCAAQYCAgPwDNgJQIABBgPISNgIAIAALEgAgABCAEyIAQaD0EjYCACAACxkAIAAQgRMiAEG4mBM2AgAgAEEANgIUIAALMQAgABCDEyIAQX82AhwgAEIANwIUIABCADcCICAAQeCXEzYCACAAQShqQQA2AgAgAAstACAAEIMTIgBCADcCFCAAQZSWEzYCACAAQRxqQgA3AgAgAEEkakIANwIAIAALQAAgAEEANgIYIABCgICAgHA3AhAgAEL/////DzcCBCAAQYjVEjYCACAAQRxqQbHWGhCkBRogAEHQ1RI2AgAgAAtjACAAQQE2AiwgAEKBgICAcDcCJCAAQgA3AhwgAEL/////DzcCFCAAQv////8PNwIEIABCADcCOCAAQoCAgIAQNwIwIABBwJoTNgIAIABBDGpCADcCACAAQcAAakIANwIAIAALGQAgABCAEyIAQfzuEjYCACAAQQA6ADwgAAseACAAEM8OIgBBnJATNgIAIABBFGpBAEEwEDoaIAALEgAgABCBEyIAQfCYEzYCACAACyQAIAAQyBwiAEIANwJIIABB6PISNgIAIABB0ABqQgA3AgAgAAsZACAAEIATIgBBvPASNgIAIABBADYCPCAACyoAIABBzK8TNgIAIABBfzYCBCAAQQhqQbHWGhCkBRogAEGEsBM2AgAgAAsZACAAEP4SIgBBnPESNgIAIABBADYCUCAACxkAIAAQgRMiAEG4kRM2AgAgAEEAOgAUIAALZwAgABCFEyIAQgA3AkQgAEEANgJkIABCgICA/AM3AlwgAEGAgID8AzYCVCAAQgA3AmggAEHw/BI2AlggAEH8+xI2AgAgAEHMAGpCADcCACAAQfAAakIANwIAIABB+ABqQQA2AgAgAAsbACAAEM0SIgBB4PsSNgJYIABB7PoSNgIAIAALMgAgABCGEyIAQQE6AGAgAEEANgJcIABCgICA/AM3AlQgAEEANgJkIABBrJsTNgIAIAALNwAgABCQCCIAQQA2AkggAEKAgID8AzcCQCAAQfTo0Xs2AjggAEGQjRM2AjwgAEG0jBM2AgAgAAsdACAAEJAIIgBB7MkSNgIAIABC/////w83AjggAAtyACAAEJAIIgBCADcCOCAAQaDBEzYCSCAAQbzAEzYCACAAQgA3AkwgAEIANwJsIABBwABqQgA3AgAgAEHoAGpBADoAACAAQdQAakIANwIAIABB3ABqQgA3AgAgAEH0AGpCADcCACAAQfwAakEANgIAIAALGQAgABCGEyIAQfjEEjYCACAAQQA2AlQgAAsZACAAEIcTIgBBiOQSNgIAIABCADcCUCAAC4ECACAAEPwSIgBBADYC1AEgAEIANwLMASAAQQA6AMgBIABB0IkTNgLYASAAQbyJEzYCxAEgAEGoiRM2AmwgAEH4hxM2AgAgAEHcAWoQkAhBmIoTNgIAIABBtAJqQQA6AAAgAEGUAmogADYCACAAQZgCakIANwIAIABBoAJqQgA3AgAgAEGoAmpCADcCACAAQdQCakEAOgAAIABBuAJqQgA3AgAgAEHAAmpCADcCACAAQcgCakIANwIAIABB2AJqQgA3AgAgAEHgAmpBADoAACAAQQA2AoQDIABCADcC5AIgAEHsAmpCADcCACAAQfQCakIANwIAIABB+QJqQgA3AAAgAAsZACAAEIgTIgBB6LsTNgIAIABBADYCUCAAC1IAIAAQhRMiAEEANgJYIABCADcCUCAAQQA2AkggAEIANwJgIABBAToAXCAAQfDjEjYCTCAAQdzjEjYCRCAAQfTiEjYCACAAQegAakIANwIAIAALNQAgABC4DiIAQQA2AuQBIABBADoA3AEgAEGI+RI2AuABIABB9PgSNgJsIABB2PcSNgIAIAALgAEBBH8gABCsDiIAQgA3AvABIABBAToA7AEgAEHk/hI2AmwgAEGk/RI2AgAgAEH4AWpCADcCACAAQYACahDWEiEBIABB1AJqENYSIQIgAEGoA2oQ1hIhAyAAQfwDahDWEiEEIAAgARCtDiAAIAIQrQ4gACADEK0OIAAgBBCtDiAAC1MBA38gABCsDiIAQfy4EzYCbCAAQdC3EzYCACAAQewBahDWEiEBIABBwAJqENYSIQIgAEGUA2oQ1hIhAyAAIAEQrQ4gACACEK0OIAAgAxCtDiAACzYAIAAQrA4iAEIANwL0ASAAQdj6EjYCbCAAQZz5EjYCACAAQgU3AuwBIABB/AFqQQA2AgAgAAsnACAAENsSIgBBiJATNgJsIABByI4TNgIAIABBgICA+AM2AoACIAALWgAgABD8EiIAQYCAgPgDNgLMASAAQv////+PgICAPzcCxAEgAEKAgID+h4CA4P8ANwLcASAAQgA3AtQBIABB5M8SNgLQASAAQdDPEjYCbCAAQZDOEjYCACAAC8ABAQN+IAAQkAgiAEIANwI4IABCgICAgHA3AmAgAEJ/NwJYIABCgICgloSAgOTCADcCUCAAQoCAgPiDgICAPzcCSCAAQYjREjYCaCAAQYDQEjYCACAAQQA2AqQBIABCADcCnAEgAEHAAGpCADcCACAAQQApAsixEyIBNwJsIABB9ABqQQApAtCxEyICNwIAIABB/ABqQQApAtixEyIDNwIAIABBlAFqIAM3AgAgAEGMAWogAjcCACAAIAE3AoQBIAALMAAgABDiDiIAQcz1EjYCACAAQcQAakGx1hoQpAUaIABBqPYSNgIAIABBADYCUCAACzUAIAAQtxIiAEIANwLwASAAQQA2AuwBIABB8O4SNgLIASAAQdzuEjYCbCAAQZTtEjYCACAACx0AIAAQkAgiAEHgzxM2AgAgAEL/gYCAEDcCOCAACyMAIAAQ+BEiAEGAgBM2AmwgAEH4/hI2AgAgAEIANwK4ASAAC3EAIAAQhRMiAEIANwJUIABCgICAgICAgMA/NwJMIABCgICA/AM3AkQgAEHkihM2AgAgAEIANwJ0IABBACkCyLETNwJcIABB5ABqQQApAtCxEzcCACAAQewAakEAKQLYsRM3AgAgAEH8AGpCADcCACAAC20AIAAQkAgiAEIANwJMIABCgICAgICAgMA/NwJEIABCgICA/AM3AjwgAEF/NgI4IABBtJ0TNgIAIABBADYCbCAAQQApAsixEzcCVCAAQdwAakEAKQLQsRM3AgAgAEHkAGpBACkC2LETNwIAIAALZAAgABCFEyIAQQA2AmAgAEGAgID8AzYCTCAAQoCAgICAgIDAPzcCRCAAQgA3AlAgAEF/NgJsIABCgICA/AM3AmQgAEGwohM2AgAgAEHVAGpCADcAACAAQfAAakEAQTAQOhogAAsdACAAEJAIIgBB/KUTNgIAIABCgICAgBA3AjggAAsZACAAEJAIIgBByKgTNgIAIABCADcCOCAAC08AIAAQhRMiAEKAgID8g4CAwD83AmAgAEIANwJYIABCgICA/AM3AlAgAEIANwJIIABBADYCRCAAQbyhEzYCACAAQegAakEAQcwAEDoaIAALoAEAIAAQhRMiAEEANgJsIABBADYCZCAAQgA3AlwgAEEAOgBYIABCgICAgHA3AkwgAEKAgICKhICAwL9/NwJEIABCADcCcCAAQaykEzYCaCAAQZikEzYCVCAAQayjEzYCACAAQgA3AogBIABB+ABqQgA3AgAgAEGAAWpCgICAgICAgMA/NwIAIABBkAFqQQA6AAAgAEGUAWpBAEE8EDoaIAALGQAgABCQCCIAQailEzYCACAAQgA3AjggAAugAQAgABD8EiIAQcQBakEAQSwQOhogAEH0nxM2AmwgAEGcnhM2AgAgAEEBOgDwASAAQQApAsixEzcC9AEgAEH8AWpBACkC0LETNwIAIABBhAJqQQApAtixEzcCACAAQYwCakEAQcQAEDoaIABB0AJqQQAQihMaIABBlANqQQBB3AAQOhogAEH//wM7AfgDIABCgICA/oeAgOD/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BAwBCyADQX9MDQEgASgCACEBIAMQiAEiBCABIAMQciADaiEDCwJAIAAoAiQiAUUNACAAQShqIAE2AgAgARCGAQsgACAENgIkIABBLGogAzYCACAAQShqIAM2AgAgAkEANgIMIAJCADcCBCACQQRqEPUEGiACQRBqJAAPCxAAAAsDAAALUwECf0EBIQICQCABKAIAIAEoAgRB5wAQ0gciAUUNACABQQxqKAIAIgFFDQAgASgCECEDIAEgADYCEEEAIQIgA0UNACADIAMoAgAoAgQRAAALIAILNAEBfyABKAIAIQIgASgCBCIBEEYgAiABEDshAiAAKAIIEEcgAEEMaiABNgIAIAAgAjYCCAsCAAsWACAAQYjEEjYCACAAQQhqEPEFGiAACwoAIAAQ0hUQhgELBQBB6gALCAAgAUHqAEYLTAEBfyMAQRBrIgMkAAJAIAFB1AFHDQAgA0EIaiACELwMIAAoAgAoAighAiADIAMpAgg3AwAgACADIAIRAwALIANBEGokACABQdQBRgsCAAspAQF/QRAQiAEiAUGIxBI2AgAgAUL/////DzcCBCABQQxqQQA2AgAgAQsyAQF/IABBxMQSNgIAIAAoAhAhASAAQQA2AhACQCABRQ0AIAEgASgCACgCBBEAAAsgAAsKACAAENkVEIYBC80BAQZ/IwBBEGsiASQAAkACQAJAAkACQCAAKAIQIgJFDQAgAkEMaigCACEDIAAoAggiBEUNAiACKAIIIQIMAQtBACEDQQAhAiAAKAIIIgRFDQMLIAAoAgQhBSABIAM2AgwgASACNgIIIAAoAgwhAiAEKAIAKAIIIQYgASABKQIINwMAIAQgBSABIAIgBhEGAA0CIANFDQIgACgCECECDAELIANFDQELIAAoAgQiAyACQQhqIAAoAgwgAygCACgCQBEEABoLIAFBEGokAEEAC1gBA38gAEE0aigCACECIAAoAjAhAwJAA0AgAyACRg0BAkAgAygCACABRw0AIAMgA0EEaiIEIAIgBGsQchogACACQXxqIgI2AjQMAQsgA0EEaiEDDAALAAsLBABBAgsaACAAIAEQ3xUiAUEBIAEoAgAoAggRAwAgAQtrAQJ/IwBBEGsiAiQAIAAgATYCUCACQQxqIAEoAgwoAiAoAoALIgEgASgCACgCHBEDACACKAIMIQEgAkEANgIMIAAo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AkECdBCIARClFiAAIAI2AgRBACEBA0ACQCABIAJHDQAgACgCCCIFRQ0EIABBCGohASAFKAIEIQYCQAJAIAJpIgRBAUsNACAGIAJBf2pxIQYMAQsgBiACSQ0AIAYgAnAhBgsgACgCACAGQQJ0aiABNgIAIAJBf2ohByAEQQFLIQgDQCAFKAIAIgRFDQUgBCgCBCEBAkACQCAIDQAgASAHcSEBDAELIAEgAkkNACABIAJwIQELAkAgASAGRg0AAkAgACgCACABQQJ0IgNqIgkoAgANACAJIAU2AgAgASEGDAELIAUgBCgCADYCACAEIAAoAgAgA2ooAgAoAgA2AgAgACgCACADaigCACAENgIADAELIAQhBQwACwALIAAoAgAgAUECdGpBADYCACABQQFqIQEMAAsACxCMBQALIABBABClFiAAQQA2AgQLCyEBAX8gACgCACEBIABBADYCAAJAIAFFDQAgARCGAQsgAAuiBAIIfwF9QQIhAgJAIAFBAUYNAAJAIAEgAUF/anENACABIQIMAQsgARD9BCECCwJAAkACQCACIAAoAgQiAUsNACACIAFPDQIgAUEDSSEDAkACQCAAKAIMsyAAKgIQlY0iCkMAAIBPXSAKQwAAAABgcUUNACAKqSEEDAELQQAhBAsCQAJAIAMNACABaUEBSw0AIARBAUEgIARBf2pna3QgBEECSRshBAwBCyAEEP0EIQQLIAIgBCACIARLGyICIAFPDQIgAkUNAQsCQCACQYCAgIAETw0AIAAgAkECdBCIARCkFiAAIAI2AgRBACEBA0ACQCABIAJHDQAgACgCCCIFRQ0EIABBCGohASAFKAIEIQYCQAJAIAJpIgRBAUsNACAGIAJBf2pxIQYMAQsgBiACSQ0AIAYgAnAhBgsgACgCACAGQQJ0aiABNgIAIAJBf2ohByAEQQFLIQgDQCAFKAIAIgRFDQUgBCgCBCEBAkACQCAIDQAgASAHcSEBDAELIAEgAkkNACABIAJwIQELAkAgASAGRg0AAkAgACgCACABQQJ0IgNqIgkoAgANACAJIAU2AgAgASEGDAELIAUgBCgCADYCACAEIAAoAgAgA2ooAgAoAgA2AgAgACgCACADaigCACAENgIADAELIAQhBQwACwALIAAoAgAgAUECdGpBADYCACABQQFqIQEMAAsACxCMBQALIABB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RQ0AIABBLGooAgAgAREAAAsgAEEANgJEIABBLGpBADYCACAAQRRqQd0ENgIACwJAIAAoAgRFDQACQCAAQcgAaigCACIBRQ0AIABBMGooAgAgAREAAAsgAEEANgJIIABBMGpBADYCACAAQRhqQd4ENgIACwJAIAAoAgRFDQACQCAAQcwAaigCACIBRQ0AIABBNGooAgAgAREAAAsgAEEANgJMIABBNGpBADYCACAAQRxqQd8ENgIACwJAIAAoAgRFDQACQCAAQdAAaigCACIBRQ0AIABBOGooAgAgAREAAAsgAEEANgJQIABBOGpBADYCACAAQSBqQeAENgIACwJAIAAoAgRFDQACQCAAQdQAaigCACIBRQ0AIABBPGooAgAgAREAAAsgAEEANgJUIABBPGpBADYCACAAQSRqQeEENgIACwJAIAAoAgRFDQAgAEEANgIEC0EAQQAoAtTaGyIBIAAgARs2AtTaGyABRQ0BIABB6J0bRg0AIAAQlSUMAAsACyAAC7QDAQl/QX8hAgJAIAEoAgAiAyAAKAIIIgRPDQACQAJAAkAgACgCAA4DAAECAwsgAyAAKAIEIgUgA2otAAAiAkHAkRpqLQAAQQJ0IgBBkZEaai0AACIGaiIHIAQgByAESRshCEH/ACAGdiACcSECIABBk5Eaai0AACEJIABBkpEaai0AACEGIABBkJEaai0AACEKAkACQANAIAEgA0EBaiIDNgIAIAMgCE8NASAFIANqLQAAIgAgBkH/AXFJDQIgACAJQf8BcUsNAiACQQZ0IABBP3FyIQJBvwEhCUGAASEGDAALAAsgByAESyAKQf8BcUVyQQFHDQMLQf3/Aw8LIAAoAgQiCSADQQF0ai8BACEAIAEgA0EBaiIGNgIAIAAhAiAAQYDwA3FBgLADRw0BQf3/AyECIABB/7cDSw0BIAYgBE8NASAJIAZBAXRqLwEAIgZBgPgDcUGAuANHDQEgASADQQJqNgIAIABBCnQgBmpBgMiAZWoPCyAAKAIEIANBAnRqKAIAIQIgASADQQFqNgIAIAJB/f8DIAJBgHBxQYCwA0cbQf3/AyACQYCAxABJGyECCyACC0QBAX8gACgCACAAKAIQIgMgAmoiAmogAToAACAAKAIIIgEgAkECdGogACgCDDYCACABIANBAnRqIAI2AgAgACACNgIQC64BAQR/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KAIMEQIARQ0AAkAgACgCGCIDQewAaigCACIBIANB8ABqKAIARg0AIAEgADYCACADIAFBBGo2AmxBAA8LIAEgAygCaGsiAUECdSIEQQFqIgJBgICAgARPDQECQAJAIAFBAXUiBSACIAUgAksbQf////8DIAFB/P///wdJGyIFDQBBACEGDAELIAVBgICAgARPDQMgBUECdBCIASEGCyAGIARBAnRqIgQgADYCACADKAJoIQIgAygCbCEAIAQhAQJAA0AgACACRg0BIAFBfGoiASAAQXxqIgAoAgA2AgAMAAsACyADIARBBGo2AmwgAygCaCEAIAMgATYCaCADIAYgBUECdGo2AnBBACECIABFDQAgABCGAQsgAg8LEAAACxCMBQALCgAgACgCGBCBFwsNACAAQYAEQQAQvQcaCxAAIAAoAhhBgAxBABC9BxoLCgAgABCECBCGAQsEAEETCw0AIAFBE0YgAUEKRnILOAACQAJAAkAgAUFaag4CAAECCyAAIAIQ3As2AjhBAQ8LIAAgAhDTBzgCPEEBDwsgACABIAIQ2gcLMQEBf0HAABCIAUEAQcAAEDoQ0RIiASAAKAI4NgI4IAEgACoCPDgCPCABIAAQxwggAQsdAQF/IAAQiRcCQCAAKAJAIgFFDQAgASAAEIUICwsbAQF/AkAgACgCQCIBRQ0AIAEgACgCGBCFCAsLngkBCn8jAEEQayICJABBAiEDAkAgACgCGCIEQSggBCgCACgCDBECAEUNACAAKAIYIQMgACgCSCEEIAJBADYCDCACQgA3AgQCQANAIAJBBGogAxD6ESADKAIYIgVBKCAFKAIAKAIMEQIARQ0BIARBAEYNASAEQX9qIQQgAygCGCIDQawBaiAAEMgLDAALAAsCQAJAAkACQCACKAIIIgUgAigCBCIGayIHQQJ1IgggAEHQAGooAgAiAyAAKAJMIglrQTxtIgRNDQACQCAAQdQAaigCACIKIANrQTxtIAggBGsiC0kNACADIAtBPGxqIQQCQANAIAMgBEYNASADQgA3AgAgA0EQakEANgIAIANBCGpCADcCACADQRxqQgA3AgAgA0EUakKAgID8g4CAwD83AgAgA0EAKQLIsRM3AiQgA0EsakEAKQLQsRM3AgAgA0E0akEAKQLYsRM3AgAgA0E8aiEDDAALAAsgACAENgJQDAILIAdBkaLEiAFPDQMgCiAJa0E8bSIDQQF0IgUgCCAFIAhLG0HEiJEiIANBosSIEUkbIgZBxYiRIk8NAiAGQTxsEIgBIgcgCEE8bGohBSAHIARBPGxqIgQhAwJAA0AgAyAFRg0BIANCADcCACADQRBqQQA2AgAgA0EIakIANwIAIANBHGpCADcCACADQRRqQoCAgPyDgIDAPzcCACADQQApAsixEzcCJCADQSxqQQApAtCxEzcCACADQTRqQQApAtixEzcCACADQTxqIQMMAAsACyAAKAJMIQkgACgCUCEDAkADQCADIAlGDQEgBEFEaiIEIANBRGoiAykCADcCACAEQQhqIANBCGooAgA2AgAgBEEMaiADQQxqKgIAOAIAIARBEGogA0EQaioCADgCACAEQRRqIANBFGoqAgA4AgAgBEEYaiADQRhqKgIAOAIAIARBHGogA0EcaioCADgCACAEQSBqIANBIGoqAgA4AgAgBEEkaiADQSRqKQIANwIAIARBLGogA0EsaikCADcCACAEQTRqIANBNGopAgA3AgAMAAsACyAAIAU2AlAgACgCTCEDIAAgBDYCTCAAIAcgBkE8bGo2AlQCQCADRQ0AIAMQhgELIAIoAgQhBiACKAIIIQUMAQsgCCAETw0AIAAgCSAIQTxsajYCUAsgACgCTCELIAUhBEEAIQMDQAJAIAQgBkcNACAIQQEgCEEBShshByABQah2akEAIAEbIgMoAtwJIQsgA0HgCWooAgAhASAAKAIYIQgDQAJAIAsgAUcNACAAIAMQxwshAyACQQRqEIISGgwGCwJAIAsoAgAiBEUNACAEQSYgBCgCACgCDBECAEUNAEEBIQkDQCAJIAdGDQEgBiEDAkAgBCgCGCAGIAlBAnRqKAIARw0AAkADQCADIAVGDQEgAygCACAERg0CIANBBGohAwwACwALIAggBBCFCAsgCUEBaiEJDAALAAsgC0EEaiELDAALAAsgCyADQTxsaiIJIAM2AgAgBEF8aiIEKAIAIQcgCUEANgIIIAkgBzYCBCADQQFqIQMMAAsACxCMBQALEAAACyACQRBqJAAgAwtXAQJ/IAAQyQsgAEHQAGooAgAgACgCTGtBPG0iAUEBIAFBAUobQX9qIQJBACEBA0ACQCABIAJHDQAPCyAAKAJMIAFBPGxqKAIEEL8HIAFBAWohAQwACwAL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IAAqAsgBQQAgA2uylCAAKgLMAUEAIARrspQQoxcgASACIAAtAKQBIAAqAogBIAEoAgAoAhwRHQALIAEgASgCACgCDBEAAAsLTgEBfyMAQSBrIgMkACADIAI4AhwgAyABOAIYIANCgICAgICAgMA/NwIQIANCgICA/AM3AgggACADQQhqIAAoAgAoAhARAwAgA0EgaiQAC/kDAgN/C30jAEGQAWsiAyQAAkACQAJAIAAoAtgBRQ0AQfLLEBBBGgwBCyAAKALUASgCSCIEKAIMIQUgBCgCECEEIANBHGogAiAAQcgAahCTBSAAKgLIASEGIAAqAswBIQcgA0KAgICAgICAwD83AlggA0KAgID8AzcCUCADIAdBACAEa7KUOAJkIAMgBkEAIAVrspQ4AmAgA0HoAGogA0EcaiADQdAAahCTBSADQQA2AiQgA0IANwIcIANBHGogARCbFyADQRxqIAMqAngiBiADKgJoIghDAAAAAJQiCSADKgJwIgpDAAAAAJQiC5KSIAMqAnwiByADKgJsIgxDAAAAAJQiDSADKgJ0Ig5DAAAAAJQiD5KSEJwXIAMgByANIA4gBLIiEJQiDpKSOAJUIAMgBiAJIAogEJQiCpKSOAJQIAMgAykDUDcDECADQRxqIANBEGoQnxcgAyAHIAwgBbIiCZQiDCAOkpI4AowBIAMgBiAIIAmUIgggCpKSOAKIASADIAMpA4gBNwMIIANBHGogA0EIahCfFyADIAcgDCAPkpI4AoQBIAMgBiAIIAuSkjgCgAEgAyADKQOAATcDACADQRxqIAMQnxcgA0EcahCdFyADQRxqQQAQoRchAiADQRxqEP8EGiACDQELQQAhAAsgA0GQAWokACAACykBAX8CQCAAQdABaiABKAIAIAEoAgQQjBIiAg0AIAAgARCYByECCyACCwgAIAAoAsQBCwoAIABBdGooAgALVwACQCABQekAIAEoAgAoAgwRAgBFDQAgAEHQAWogARCOEgJAIAAoAtgBIgFFDQAgACgCIC0AiAsNACABIAAoAtQBKAJIIAEoAgAoAggRAwALIAAQqRcLC7cBAgF/BH0CQCAAKALUASIBRQ0AIAEoAkgiAUUNACAAKgLcASICIAJcDQAgACoC4AEiAyADXA0AIAMgASgCELKVIQMgACoCaCEEAkAgAiABKAIMspUiAiAAKgJk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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAoAghBfGoO2wV1HssBtQG1AY0BjQG2AbYBjQGNAYwBjAGMAYsBywGuAa4BywEsqgGqAawBywHLAcsBywGvAQ+lAaUBpQHLAXBxqAFRC6UBywHLAcsBpQGnAU9PDjzLAUDLAXdLS50BS0tLCZgBmAGYAZgBNjc3nAHLAcsBywHLAcsBywHLAcsBrQGtAa0BsAGwAbQBtAG0AbQBbrwBvQG9AVNTEWO/Ab8BvwG/Ab8BvwFiYr4BvgG+Ab4BvgG+AWRkZGSpAakBqQFQywEiIlZDrgGuAVSxAbIBUizLAcsBywHLAcsBywHLAcsBeMsBlwEKywHLAcsBywHLAcsBywE6ywFJScsBywE/RpkBScsBSa8BrwGvARA9ogFIPssBywFOhAEjJyfLAYUBJCUlBYYBhgGGAYcBhwGHASYmJiYBAQEmEy0ulAGTAQShAYABgQHLAVXGAcYBywHLAcsBywHLAcsBqwGrAcsBywHLAcsBywHLAcsBQUHLATlEmwHLAcsBywHLAcsBywFYOwigAUXLAcsBgwHLARJ/ywF7e8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAX7LAcsBywF+ywHDAcsBywHLAcsBaXlrywHLAWvFAcUBa8QBassBywGVAcsBywHLAS+WAT63AbcBWVm3AbcBtwG3AbcBtwHLAcsBywFZWcsBywFlwAHAAcABZ8EBwgHCAcIBZWXAAcIBwgHCAcIBwgEVwAFowAGaAZoBmgGaAcsBywHLAcsBywHLAcsBywFJScsBywHLAcsBywFmZssBywHLAcsBgQGIAQICxQHFAcsBywHDAcUBigGKAcsBywEJa2XLAbMBswHLAcsBywHLAcsBywHLATPDAcsBSkrLAckBywHLAcsBQTnIAcsBywHLAUyfAZ8BbMsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHL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IAFGDQEgAkF8ahD8FyECDAALAAsgACABNgIQIAAoAgwQhgELIAALBABBGgsHACABQRpGCxsAAkAgAUE1Rw0AIAAgAhCDBTYCCAsgAUE1RgtJAQJ/IABBEGooAgAhAiAAKAIMIQADQAJAIAAgAkcNAEEADwsgACgCACEDIABBBGohACADIAEgAygCACgCHBECACIDRQ0ACyADC0kBAn8gAEEQaigCACECIAAoAgwhAANAAkAgACACRw0AQQAPCyAAKAIAIQMgAEEEaiEAIAMgASADKAIAKAIgEQIAIgNFDQALIAML9QIBB39BASECAkACQAJAIAEoAgAgASgCBEEZENIHIgFFDQAgAUEMaigCACIBRQ0AAkAgASgCBCIDQRBqKAIAIgEgA0EUaigCACICTw0AIAEgADYCACADIAFBBGo2AhBBAA8LIAEgAygCDCIEa0ECdSIFQQFqIgZBgICAgARPDQFBACEHAkAgAiAEayICQQF1IgggBiAIIAZLG0H/////AyACQfz///8HSRsiBkUNACAGQYCAgIAETw0DIAZBAnQQiAEhByADKAIMIQQgAygCECEBCyAHIAVBAnRqIgUgADYCACAFIQICQANAIAEgBEYNASABQXxqIgEoAgAhACABQQA2AgAgAkF8aiICIAA2AgAMAAsACyADKAIMIQAgAyACNgIMIAMoAhAhASADIAVBBGo2AhAgAyAHIAZBAnRqNgIUAkADQCABIABGDQEgAUF8ahDwFyEBDAALAAtBACECIABFDQAgABCGAQsgAg8LEAAACxCMBQALAgALKQEBfyAAKAIAIQEgAEEANgIAAkAgAUUNACABIAEoAgAoAgQRAAALIAALfgICfwF9AkAgACABIABrQQJ1IgRBf2oiAUECdGooAgAqAgwgAl0NAEEAIQQDQCAEIAFKDQECQCAAIAEgBGpBAXUiBUECdGooAgAqAgwiBiACXUUNACAFQQFqIQQMAQsCQCAGIAJeRQ0AIAVBf2ohAQwBCwsgBSADaiEECyAECzYBAX9BGBCIASIBQgA3AgwgAUHo0RI2AgAgAUF/NgIEIAFBFGpBADYCACABIAAoAgg2AgggAQsHACAAEIYBCwQAQQELigMBB39BASECAkACQAJAIAEoAgAgASgCBEEaENIHIgFFDQAgAUEMaigCACIBRQ0AIAAgACgCCLMg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QQAhECAAQQIgBhCgGSEWIABBACAGEKAZIRcgBCABIAUgAiAAQZQEaigCACAAQYwEaiIRKgIAIABBmARqKAIAIABBkARqKgIAIABBnARqKgIAIABBoARqKgIAIBYgFyAKELgsDQEgAEHEAmohEiAAQcACaigCACETQQEhFANAIBAgE0YNAyAQQRhsIREgEEEBaiEQIAQgASAFIAIgEiARaiIRKAIIIBEqAgAgESgCDCARKgIEIBEqAhAgESoCFCAWIBcgChC4LEUNAAwCCwALAkAgCA0AIABBxAJqIRMgAEHAAmooAgAhFUEBIRRBACEQA0AgECAVRg0DAkACQAJAIBMgEEEYbCISaiIRKgIAIhYgFlwgASABXHINACAWIAGTi0MXt9E4XQ0BDAILIBYgFlsNASABIAFbDQELAkACQCATIBJqIhIqAgQiFiAWXCACIAJccg0AIBYgApOLQxe30ThdDQEMAgsgFiAWWw0BIAIgAlsNAQsgEigCCCAERw0AIBIoAgwgBUYNAwsgEEEBaiEQDAALAAsCQAJAIABBjARqIhAqAgAiFiAWXCABIAFccg0AIBYgAZOLQxe30ThdDQFBACERQQEhFAwEC0EAIRFBASEUIBYgFlsNAyABIAFbDQMLAkACQCAAQZAEaioCACIWIBZcIhEgAiACXCITckUNACARIBNxIREMAQsgFiACk4tDF7fROF0hEQsgEEEAIABBmARqKAIAIAVGG0EAIABBlARqKAIAIARGG0EAIBEbIRELIA8gEUUiFHINASAAQYQEaiARKgIQOAIAIABBiARqIBEqAhQ4AgAgC0EMQRAgCBtqIhAgECgCAEEBajYCAEEDIRBBACEEDAILQQAhEQsgACABIAIgAyAEIAUgBiAHIAggCiALIAxBAWogDSAJELwsIABBvAJqIAM2AgACQCAUDQBBAyEQQQEhBAwBCwJAIABBwAJqKAIAIhBBAWoiEyALKAIITQ0AIAsgEzYCCAsCQCAQQQhHDQBBACEQIABBADYCwAILAkACQCAIRQ0AIABBjARqIRAMAQsgACAQQQFqNgLAAiAAIBBBGGxqQcQCaiEQCyAQIAU2AgwgECAENgIIIBAgAjgCBCAQIAE4AgAgECAAQYQEaioCADgCECAQIABBiARqKgIAOAIUQQEhBEEBIRALAkAgCEUNACAAQfQBaiAAQYQEaikCADcCACAAIAAtAAQiEEEBciIFQfsBcSAFIBBBBHEbOgAEQQAgESAAQYwEakZBAXQgDxshEAsgACANNgK4AiAOQQA2AgggDiAQNgIEIA4gDkEEajYCDCAAQQIgDkEMahCdGSAOQRBqJAAgBAsNACAAQf8BcUEAEKMsC+QBAgN/AX0gACAAKAIYQQIQnCwgAUEBIAAoAqgEGyIFEJ0sIgEgAhCbLCECIABBA0ECIAVBAkYbQQAgAUECSRsiBSADEJssIQMgACABIAQQkywhCCAAQeQBaiIGIAFBAnQiB0HAkxpqKAIAQQJ0aiACIAiSOAIAIAAgASAEEJUsIQggBiAHQdCTGmooAgBBAnRqIAIgCJI4AgAgACAFIAQQkywhAiAGIAVBAnQiAUHAkxpqKAIAQQJ0aiADIAKSOAIAIAAgBSAEEJUsIQQgBiABQdCTGmooAgBBAnRqIAMgBJI4AgAL2wMDA30FfwR8AkAgAUQAAAAAAAAAAGENACAAQfgBaioCACEEIABB9AFqKgIAIQUgAEHoAWoiByoCACEGIAAgACoC5AG7IgwgAUEAIAAtAARBCHEiCEEDdiIJELcsOALkASAHIAa7Ig0gAUEAIAkQtyw4AgAgDCACoCECIA0gA6AhAyAEuyENIAW7Ig4gAaJEAAAAAAAA8D8QeyIMIAxiIgogDJlELUMc6+I2Gj9jIgdBAXNyIQkCQCAHDQAgCg0AIAxEAAAAAAAA8L+gmUQtQxzr4jYaP2NBAXMhCQsgAiAOoCEOIAMgDaAhDyANIAGiRAAAAAAAAPA/EHsiDCAMYiILIAyZRC1DHOviNho/YyIHQQFzciEKAkAgBw0AIAsNACAMRAAAAAAAAPC/oJlELUMc6+I2Gj9jQQFzIQoLQQAhByAAIA4gASAIQQBHIgggCXEgCCAJQQFzcRC3LCACIAFBACAIELcskzgC9AEgACAPIAEgCCAKcSAIIApBAXNxELcsIAMgAUEAIAgQtyyTOAL4ASAAQbAEaiIIKAIAIABBrARqIgkoAgBrQQJ1IQADQCAHIABGDQEgCSgCACAIKAIAIAcQjBkgASACIAMQpRkgB0EBaiEHDAALAAsLFgEBf0HICRCIARCPByIBIAAQwwggAQsnAQF/AkAgACgCGCIBQZkDIAEoAgAoAgwRAgBFDQAgACgCGBDQGAsLxgEBAn8CQCAAKAIYIgFBmQMgASgCACgCDBECAEUNACAAKAIYIgEoAvwBIgBFDQACQCAAKALwAUEDQQEgAC0AqAEbIgJGDQAgACACNgLwASAAIAAoAgAoAvwBEQAAIAEoAvwBIQALAkAgACgC9AFBA0EBIAAtAKwBGyICRg0AIAAgAjYC9AEgACAAKAIAKAKAAhEAACABKAL8ASEAC0EBIQICQCAALQCoAUECRg0AIAAtAKwBQQJGIQILIAAgAhCDDCABENAYCwuQAQECfwJAIAAoAhgiAUGZAyABKAIAKAIMEQIARQ0AIAAoAhgiABDQGCAAQTxqKAIAIQIgACgCOCEAA0AgACACRg0BAkACQCAAKAIAIgFBmQMgASgCACgCDBECAEUNACABENAYDAELIAFBxAMgASgCACgCDBECAEUNACABEKoZIAEQqxkLIABBBGohAAwACwALC+QBAgJ/AX0CQCAAKALQAUUNAEEBIQECQCAAKAIYIgJBmQMgAigCACgCDBECAEUNACAAKAIYQfwBaigCABCTGSEBCwJAAkACQAJAIAAoAvwBDgMAAQIDCyAAKALQAUEAENMYIAAoAtABIQICQCAAKgLsASIDQwAAgL9cDQAgAioCoAshAwsgAiADIAAoAvQBIAEQzxgMAgsgACgC0AFBABDTGCAAKALQASECAkAgACoC7AEiA0MAAIC/XA0AIAIqAqALIQMLIAIgA0EDIAEQzxgMAQsgACgC0AFBARDTGAsgABCJCAsL7gECAn8BfQJAIAAoAtABRQ0AQQEhAQJAIAAoAhgiAkGZAyACKAIAKAIMEQIARQ0AIAAoAhhB/AFqKAIAEJMZIQELAkACQAJAAkAgACgCgAIOAgABAgsgACgC0AFBABDUGCAAKALQASECAkAgACoC8AEiA0MAAIC/XA0AIAIqAqQLIQMLIAIgAyAAKAL4ASABENIYDAILIAAoAtABQQAQ1BggACgC0AEhAgJAIAAqAvABIgNDAACAv1wNACACKgKkCyEDCyACIANBAyABENIYDAELIAAoAvwBQQJHDQAgACgC0AFBARDUGAsgABCJCAsLQgAgACABELsLGgJAIAEgACgCvAEgASgCACgCCBECACIBRQ0AIAFBrwEgASgCACgCDBECAEUNACAAIAE2AuQCC0EACwcAIAAQpxkLBwAgABCnGQsHACAAEKgZCwcAIAAQqBkLOgEBfwJAIAAoAhgiAUGZAyABKAIAKAIMEQIARQ0AIAAoAhgiACgC/AFFDQAgAEEBOgCcCSAAENAYCwsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwcAIAAQpxkLBwAgABCnGQsHACAAEKcZCwoAIAAQhAgQhgELBQBBpAMLDgAgAUGkA0YgAUEKRnILqwsAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQY58ag6fAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0seHyAhS0tLIiMkJSYnKCkqKywtLi8wMTIzNDU2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NgIAIApBBGohCgwFCyAKQQRqIQoMAAsACyAAKAIAIAcoAgAgAigCABECAEUNAAsgBSgCACEKIAUgACgCADYCACAAIAo2AgAgCEEBaiEICwJAIAVBBGoiCSAATw0AA0AgCSIKQQRqIQkgCigCACAHKAIAIAIoAgARAgANAANAIABBfGoiACgCACAHKAIAIAIoAgARAgBFDQALAkAgCiAATQ0AIAohCQwCCyAKKAIAIQYgCiAAKAIANgIAIAAgBjYCACAAIAcgByAKRhshByAIQQFqIQgMAAsACwJAIAkgB0YNACAHKAIAIAkoAgAgAigCABECAEUNACAJKAIAIQAgCSAHKAIANgIAIAcgADYCACAIQQFqIQgLAkAgCA0AIAUgCSACEKkaIQcCQCAJQQRqIgAgASACEKkaRQ0AIAUhACAJIQEgB0UNBQwECyAHDQILAkAgCSAFayABIAlrTg0AIAUgCSACIAMQpBogCUEEaiEADAILIAlBBGogASACIAMQpBogBSEAIAkhAQwDCyAEIQcgCiAERg0BA0AgCiIAQQRqIQogBSgCACAAKAIAIAIoAgARAgBFDQADQCAFKAIAIAdBfGoiBygCACACKAIAEQIADQALIAAgB08NASAAKAIAIQkgACAHKAIANgIAIAcgCTYCAAwACwALAAsLC7QBAQJ/IAAgASACIAQQpxohBQJAIAMoAgAgAigCACAEKAIAEQIARQ0AIAIoAgAhBiACIAMoAgA2AgAgAyAGNgIAAkAgAigCACABKAIAIAQoAgARAgANACAFQQFqDwsgASgCACEDIAEgAigCADYCACACIAM2AgACQCABKAIAIAAoAgAgBCgCABECAA0AIAVBAmoPCyAAKAIAIQIgACABKAIANgIAIAEgAjYCACAFQQNqIQULIAUL6wEBAn8gACABIAIgAyAFEKUaIQYCQCAEKAIAIAMoAgAgBSgCABECAEUNACADKAIAIQcgAyAEKAIANgIAIAQgBzYCAAJAIAMoAgAgAigCACAFKAIAEQIADQAgBkEBag8LIAIoAgAhBCACIAMoAgA2AgAgAyAENgIAAkAgAigCACABKAIAIAUoAgARAgANACAGQQJqDwsgASgCACEDIAEgAigCADYCACACIAM2AgACQCABKAIAIAAoAgAgBSgCABECAA0AIAZBA2oPCyAAKAIAIQMg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ZAEBfyMAQRBrIgckACAHQQxqIAAoAiAoAoALIgAgAioCACACKgIEIAMqAgAgAyoCBCAEIAUgBiAAKAIAKAIMEVUAIAEgB0EMaiABKAIAKAIgEQMAIAdBDGoQ5wYaIAdBEGokAAsHACAAEIEXCwsAIABBqH9qEIEXCw0AIABBwABBABC9BxoLDQAgAEHAAEEAEL0HGgsNACAAQcAAQQAQvQcaCw0AIABBwABBABC9BxoLBwAgABCBFwtYAQN/QQEhAQJAIAAqAlRDAACAP10NACAAQewAaigCACECIAAoAmghAANAIAAgAkchASAAIAJGDQEgACgCACEDIABBBGohACADKAI4Qf///3dLDQALCyABCwsAIABBqH9qELQaCzgBAX8gAEHw/BI2AlggAEH8+xI2AgACQCAAKAJoIgFFDQAgAEHsAGogATYCACABEIYBCyAAENYLCwoAIAAQthoQhgELBABBFgsQACABQRdJQYCYgAIgAXZxC3oAAkACQAJAAkACQAJAAkAgAUFfag4KAQIDBQUFBQUFAAQLIAAgAhDTBzgCREEBDwsgACACENMHOAJIQQEPCyAAIAIQ0wc4AkxBAQ8LIAAgAhDTBzgCUEEBDwsgAUEuRg0BCyAAIAEgAhDaBw8LIAAgAhDTBzgCVEEBCwsAIABBqH9qELYaCwsAIABBqH9qELcaCx0BAX9B/AAQiAFBAEH8ABA6EM0SIgEgABC+GiABCzsAIAAgASoCRDgCRCAAIAEqAkg4AkggACABKgJMOAJMIAAgASoCUDgCUCAAIAEqAlQ4AlQgACABEMcIC/YCAQd/QQEhAgJAAkACQCABKAIAIAEoAgRB8gAQ0gciAUUNACABQQxqKAIAIgFFDQACQCABKAIEIgNBJGooAgAiASADQShqKAIAIgJPDQAgASAANgIAIAMgAUEEajYCJEEADwsgASADKAIgIgRrQQJ1IgVBAWoiBkGAgICABE8NAUEAIQcCQCACIARrIgJBAXUiCCAGIAggBksbQf////8DIAJB/P///wdJGyIGRQ0AIAZBgICAgARPDQMgBkECdBCIASEHIAMoAiAhBCADKAIkIQELIAcgBUECdGoiBSAANgIAIAUhAgJAA0AgASAERg0BIAFBfGoiASgCACEAIAFBADYCACACQXxqIgIgADYCAAwACwALIAMoAiAhACAD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AygCBCADKAIAa0EBdSAEEPwaIQEgAigCJCIHIAU7AQAgAiAHQQJqNgIkIAMgARD9GiABEP4aGgsgAi0AFCEGIAIoAgwhBSACKAIIIQEgAigCECEHDAALAAsgAEHgAGogAkEYahD/GhogAigCGBCAGyACQTBqJAALLgACQCACQX9KDQAQAAALIAEgAGsiASACIAEgAksbQf////8HIAFB/v///wdJGwtmAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkACQCABRQ0AIAFBf0wNASABQQF0EIgBIQQLIAAgBDYCACAAIAQgAkEBdGoiAzYCCCAAIAQgAUEBdGo2AgwgACADNgIEIAAPCxCMBQALkwEBA38gASgCBCECIAAoAgAhAyAAKAIEIQQCQANAIAQgA0YNASACQX5qIgIgBEF+aiIELwEAOwEADAALAAsgASACNgIEIAAoAgAhBCAAIAI2AgAgASAENgIEIAAoAgQhBCAAIAEoAgg2AgQgASAENgIIIAAoAgghBCAAIAEoAgw2AgggASAENgIMIAEgASgCBDYCAAtCAQJ/IAAoAgghASAAKAIEIQICQANAIAEgAkYNASAAIAFBfmoiATYCCAwACwALAkAgACgCACIBRQ0AIAEQhgELIAALOAACQCAAIAFGDQACQCABKAIAIgENACAAQQAQgRsgAA8LIAEgASgCDEEBajYCDCAAIAEQgRsLIAALKgEBfwJAIABFDQAgACAAKAIMIgFBf2o2AgwgAUEBRw0AIAAQghsQhgELCxcBAX8gACgCACECIAAgATYCACACEIAbCx8BAX8CQCAAKAIAIgFFDQAgACABNgIEIAEQhgELIAALEgAgAEHgAGogAUHgAGoQ/xoaCwwAIABBIEEAEL0HGgsLACAAQbx/ahCEGwuWAQEDfyMAQRBrIgEkACAAKAIgKAKACyECIAAQhxsiA0EBOgBcIAFBDGogAkEBQQAgAEHoAGooAgAgACgCZGtBAXQgAigCACgCCBELACABKAIMIQIgAUEANgIMIANB1ABqIAIQiBsgASgCDBCJGyADQdgAaiAAQdgAahCKGxogA0HQAGogAEHQAGoQihsaIAFBEGokACADCywBAX9B8AAQiAFBAEHwABA6ENcSIgEgACABKAIAKAJMEQMAIAEgABDHCCABCxcBAX8gACgCACECIAAgATYC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ASgCACgCEBEDACAAKALMASIAIAEgACgCACgChAERAwALIAEgASgCACgCDBEAAAsL5QECAX8EfSMAQdAAayIDJAACQAJAIAAoAswBDQBBACEADAELIAMgADYCOCABQRBqIANBOGoQ+wcgA0EgaiACIABByABqEJMFIAAoAswBIgAqAsgBIQQgACoCyAkhBSAAKgLMASEGIAAqAswJIQcgA0KAgICAgICAwD83AhAgA0KAgID8AzcCCCADIAYgB4yUOAIcIAMgBCAFjJQ4AhggA0E4aiADQSBqIANBCGoQkwUgACABIANBOGogACgCACgCiAERBAAiAA0AIAFBFGoiASABKAIAQXxqNgIACyADQdAAaiQAIAALpwEBBH8jAEEgayICJAAgASgCBCEDIAEoAgAhAUEAIQQgAkEAOwEcIAIgATYCGCACIAM2AhQgAiABNgIQIABB4AFqIQUgASEAAkADQCAAIAEgA2pGDQEgBEH/AXENASACLQAdQf8BcQ0BIAIgAkEQahCDBTYCDCAFIAJBDGoQvgwgAi0AHCEEIAIoAhQhAyACKAIQIQEgAigCGCEADAALAAsgAkEgaiQACxIAIABB4AFqIAFB4AFqEMQMGgsCAAsCAAtmAQJ9AkACQCABKALQASIBDQBDAAAAACEGQwAAAAAhBwwBCyABKgLMASEHIAEqAsgBIQYLIAAgByAEQ///f38gBRsiBCAHIARdGzgCBCAAIAYgAkP//39/IAMbIgcgBiAHXRs4AgALAgALiwIBBn9BACEDAkAgACgCzAFFDQAgACAAKAIAKAJAEQEADQBBACEDAkAgAkEBcUUNACACQQhxIQQgAEHYAWooAgAhBSAAKALUASEDQQAhBgNAAkAgAyAFRw0AIAZBAXEhAwwCCyADKAIAIgcoAgAhCAJAAkAgBA0AIAdB3wAgCCgCDBECAEUNASAHKAJIIghFDQEgCBCdHEUNASAHKAIAIQgLQQEgBiAHIAEgBEEARyAIKAJMER8AGyEGCyADQQRqIQMMAAsACyAAKALMASIHQYAKaigCACAHQYQKaigCACABIAJB+/8DcRCoCCADciEDIAAoAswBLQAkQQRxRQ0AIABBBEEAEL0HGgsgAwtAAQJ/QQAhAUEAIQIDfwJAIAIgACgCREkNACABQQFxDwsgACgCSCACQThsakEBELEgIAFyIQEgAkEBaiECDAALCxUAIAAgAUGUf2ogAiADIAQgBRCaHAsCAAsPACAAQbh+aiABIAIQnBwLuAECAX8FfSMAQSBrIgMkAAJAAkAgACgCzAENAEEAIQAMAQsgA0EYakEAKQLYsRM3AwAgA0EQakEAKQLQsRM3AwAgA0EAKQLIsRM3AwggAEHIAGogA0EIahCSBSIARQ0AIAMqAhghBCADKgIQIQUgAyoCCCEGIAIgAyoCHCADKgIMIAGnviIHlCADKgIUIAFCIIinviIIlJKSOAIEIAIgBCAGIAeUIAUgCJSSkjgCAAsgA0EgaiQAIAALJQAgACABKALEATYCxAEgACABIAAoAgAoApwBEQMAIAAgARDECAslAQF/IAAQpBwhAQJAIAAoAswBIgBFDQAgASAAEJgFEKwLCyABC2UBAX9BhAIQiAFBAEGEAhA6ELkSIgEgACoC7AE4AuwBIAEgACoC8AE4AvABIAEgACgC9AE2AvQBIAEgACgC+AE2AvgBIAEgACgC/AE2AvwBIAEgACgCgAI2AoACIAEgABCiHCABC7cDAgJ/An0jAEEwayICJAAgACABEJMcAkAgAUGAAXFFDQAgACgC0AEiAUUNACABQYgCaioCACEEIAEqAoQCIQUCQAJAIAAoAhgiA0EBIAMoAgAoAgwRAgBFDQAgAiAAKAIYEKkIIAJCgICAgICAgMA/NwIgIAJCgICA/AM3AhggAiAEIAIqAgSSOAIsIAIgBSACKgIAkjgCKCACIAJBGGogAEHIAGoQkwUgAEHYAGogAkEQaikCADcCACAAQdAAaiACQQhqKQIANwIAIAAgAikCADcCSAwBCyACIAQ4AhQgAiAFOAIQIAJCgICAgICAgMA/NwIIIAJCgICA/AM3AgAgAkEYaiACIABByABqEJMFIABB2ABqIAJBKGopAgA3AgAgAEHQAGogAkEgaikCADcCACAAIAIpAhg3AkgLIAIgARCpCCACQoCAgICAgIDAPzcCICACQoCAgPwDNwIYIAIgAioCBIw4AiwgAiACKgIAjDgCKCACIAJBGGogAEHIAGoQkwUgAEHYAGogAkEQaikCADcCACAAQdAAaiACQQhqKQIANwIAIAAgAikCADcCSAsgAkEwaiQACxYAIAAgARCRHBogABCqGSAAEKsZQQALBwAgABCqGQsHACAAEKsZCwcAIAAQqhkLBwAgABCrGQsHACAAEKoZCwcAIAAQqxkLCgAgABCLHBCGAQsFAEHEAwtDAQF/AkACQCABQXZqIgJBHEsNAEEBIAJ0QYuAgIABcQ0BCyABQaV/akECSQ0AIAFBAkYNACABQcQDRg0AQQAPC0EBC4MBAAJAAkACQAJAAkACQAJAIAFB6XpqDgYAAQIDBAUGCyAAIAIQ0wc4AuwBQQEPCyAAIAIQ0wc4AvABQQEPCyAAIAIQgwU2AvQBQQEPCyAAIAIQgwU2AvgBQQEPCyAAIAIQgwU2AvwBQQEPCyAAIAIQgwU2AoACQQEPCyAAIAEgAhCOHAslAQF/IAAQshwhAQJAIAAoAswBIgBFDQAgASAAEJgFEKwLCyABC0EBAX9B+AEQiAFBAEH4ARA6EOASIgEgACgC7AE2AuwBIAEgACoC8AE4AvABIAEgACoC9AE4AvQBIAEgABCiHCABC8wBAgJ/An0jAEHAAGsiAiQAIAAgARCTHAJAIAFBgAFxRQ0AIAAoAtABIgNFDQACQAJAIAAoAhgiAUUNACABQZkDIAEoAgAoAgwRAgBFDQAgAkEwaiABIAEoAgAoAnARAwAMAQsgAkE4akIANwMAIAJCADcDMAsgACoC9AEhBCAAKgLwASEFIAAtAOwBIQEgAkEIaiADEKgFIAJBGGogASAFIAQgAkEwaiACQQhqQwAAgD8QjQUgAEHIAGogAkEYahCwBxoLIAJBwABqJAALCgAgABCLHBCGAQsFAEHDAwtDAQF/AkACQCABQXZqIgJBHEsNAEEBIAJ0QYuAgIABcQ0BCyABQaV/akECSQ0AIAFBAkYNACABQcMDRg0AQQAPC0EBC1QAAkACQAJAAkAgAUH8emoOAgECAAsgAUGaBEcNAiAAIAIQgwU2AuwBQQEPCyAAIAIQ0wc4AvABQQEPCyAAIAIQ0wc4AvQBQQEPCyAAIAEgAhCOHAsCAAsCAAsCAAsxAQF/AkAgABCmBSIBRQ0AIAEtAAwgAC0APCIARg0AIAEgADoADCABKAIEQQE6ADQLCzgBAX8CQCAAEKYFIgBFDQAgAC0ADCICQQBHIAFGDQAgAiABRg0AIAAgAToADCAAKAIEQQE6ADQLCxkAAkAgABCmBSIADQBBAA8LIAAtAAxBAEcLCgAgABCECBCGAQsFAEH7AAsqAQF/QQEhAgJAAkACQCABQYd/ag4DAgECAAsgAUEKRg0BC0EAIQILIAILIwACQCABQe4BRw0AIAAgAhDVBzoAPEEBDwsgACABIAIQohQLAgALJwEBf0HAABCIAUEAQcAAEDoQxRIiASAALQA8OgA8IAEgABDEHCABCxMAIAAgASgCODYCOCAAIAEQxwgLOwEBf0EAIQICQCAAIAEQugtFDQAgASAAKAIUIAEoAgAoAggRAgAiAUHcACABKAIAKAIMEQIAIQILIAILrgIBBX8gACABELsLGgJAAkACQAJAIAAoAhgiAkHYAWooAgAiASACQdwBaigCAEYNACABIAA2AgAgAiABQQRqNgLYAQwBCyABIAIoAtQBayIBQQJ1IgNBAWoiBEGAgICABE8NAQJAAkAgAUEBdSIFIAQgBSAESxtB/////wMgAUH8////B0kbIgUNAEEAIQYMAQsgBUGAgICABE8NAyAFQQJ0EIgBIQYLIAYgA0ECdGoiAyAANgIAIAIoAtQBIQQgAigC2AEhACADIQECQANAIAAgBEYNASABQXxqIgEgAEF8aiIAKAIANgIADAALAAsgAiADQQRqNgLYASACKALUASEAIAIgATYC1AEgAiAGIAVBAnRqNgLcASAARQ0AIAAQhgELQQAPCxAAAAsQjAUACwMAAAsZACAAEIUTIgBBxPMSNgIAIABBfzYCRCAACwMAAAsFAEHhAAssAQF/QQEhAgJAIAFBdmpBAkkNAAJAIAFBo39qDgUBAAAAAQALQQAhAgsgAgsjAAJAIAFByAFHDQAgACACENMHOAJIQQEPCyAAIAEgAhDNHAsjAAJAIAFBxgFHDQAgACACEIMFNgJEQQEPCyAAIAEgAhDaBwsCAAtuAQN/QQAhAgJAIAFB7AlqKAIAIAEoAugJIgNrQQJ1IAAoAkQiBE0NACADIARBAnRqKAIAIQILQcAAEIgBIAIgAUMAAIA/EKwFIQIgACgCTCEBIAAgAjYCTAJAIAFFDQAgASABKAIAKAIEEQAACwsCAAs1AQF/IABB3O8SNgIAIAAoAkwhASAAQQA2AkwCQCABRQ0AIAEgASgCACgCBBEAAAsgABDWCwsFAEHdAAsjAQF/QQEhAgJAIAFBdmpBAkkNACABQd0ARg0AQQAhAgsgAgszAgF/AX0CQCAAEKYFIgFFDQAgASoCDCAAKgI8IgJbDQAgASACOAIMIAEoAgRBAToANAsLKgACQCAAEKYFIgBFDQAgACoCDCABWw0AIAAgATgCDCAAKAIEQQE6ADQLCxkAAkAgABCmBSIADQBDAAAAAA8LIAAqAgwLCgAgABCECBCGAQsFAEH8AAsrAQF/QQEhAgJAAkACQCABQYd/ag4EAgEBAgALIAFBCkYNAQtBACECCyACCyMAAkAgAUHvAUcNACAAIAIQ0wc4AjxBAQ8LIAAgASACEKIUCwIACycBAX9BwAAQiAFBAEHAABA6EMkSIgEgACoCPDgCPCABIAAQxBwgAQvvAQICfwR9AkAgACgCTCIBRQ0AIAEoAhwhAiABIAEoAgAoAhgRDAAgACoCUJQhAwJAAkACQAJAIAIoAiAOAwABAgALIAIQoxAgA5IhAwwCCyADIAIQzhciBBBzIQMgAhCjECADIARDAAAAgCADQwAAAABdG5KSIQMMAQsgAhDOFyEEIARDAAAAgCADIAQQcyIFQwAAAABdGyEGAkACQCADIASVIgOLQwAAAE9dRQ0AIAOoIQAMAQtBgICAgHghAAsgBSAGkiEDAkAgAEEBcQ0AIAMgAhCjEJIhAwwBCyACEIsaIAOTIQMLIAEgAxD8AgsLFgAgACABEM8cIAAgACgCACgCWBEAAAsrAgF/AX0CQCAAKAJMIgNFDQAgACoCSCIEQwAAAABbDQAgAyAEEIMDC0EACwoAIAAQ0RwQhgELBQBB4gALMAEBfwJAAkAgAUGjf2oiAkEFSw0AQQEgAnRBMXENAQsgAUF2akECSQ0AQQAPC0EBCyMAAkAgAUHKAUcNACAAIAIQ0wc4AlBBAQ8LIAAgASACEMwcCycBAX9B1AAQiAFBAEHUABA6EMsSIgEgACoCUDgCUCABIAAQ5RwgAQsTACAAIAEqAkg4AkggACABEOYcCxMAIAAgASgCRDYCRCAAIAEQxwgLVQEBfwJAIAAoAkwiAw0AQQAPCwJAAkAgAC0AVA0AQQAhAwwBCyADIAAqAlAgAZQgAxCtBSEDCwJAIAAqAkgiAUMAAAAAWw0AIAAoAkwgARCDAwsgAwsKACAAENEcEIYBCwUAQeAACzABAX8CQAJAIAFBo39qIgJBBEsNAEEBIAJ0QRlxDQELIAFBdmpBAkkNAEEADwtBAQs6AAJAAkACQCABQbl+ag4DAAIBAgsgACACENMHOAJQQQEPCyAAIAIQ1Qc6AFRBAQ8LIAAgASACEMwcCwIACwIACzEBAX9B2AAQiAFBAEHYABA6EL4SIgEgACoCUDgCUCABIAAtAFQ6AFQgASAAEOUcIAELCgAgABDwHBCGAQs5AQF/IABB6PISNgIAAkAgACgCTCIBRQ0AIABB0ABqIAE2AgAgARCGAQsgAEHIAGoQoAwaIAAQ1gsLBQBB3wALKgEBf0EBIQICQCABQXZqQQJJDQACQCABQaN/ag4DAQABAAtBACECCyACCxoAAkAgACgCSCIADQBBAA8LIAAgASACEL4FC6gBAQJ/IAEgACgCRBDACCECIAAoAkghASAAIAI2AkgCQCABRQ0AIAEgASgCACgCBBEAAAsgAEHQAGooAgAgACgCTGtBAnUhA0EAIQICQANAIAIgA0YNAQJAAkAgACgCTCACQQJ0aigCACIBQfsAIAEoAgAoAgwRAgANACABQfwAIAEoAgAoAgwRAgBFDQELIAEgASgCACgCSBEAAAsgAkEBaiECDAALAAsLVgECfyAAIAE2AiAgAEHwAGooAgAhAiAAKAJsIQACQANAIAAgAkYNAQJAIAAoAgAiA0G/AyADKAIAKAIMEQIARQ0AIAMgARCxCAsgAEEEaiEADAALAAsLFgEBf0HYABCIARDIEiIBIAAQ5hwgAQsPACAAIAAoAgAoAkgRAAALJwACQCAAEKYFIgBFDQAgAC0ADA0AIABBAToADCAAKAIEQQE6ADQLCwoAIAAQhAgQhgELBQBB+gALIwEBf0EBIQICQCABQYd/akECSQ0AIAFBCkYNAEEAIQILIAILGwEBf0E8EIgBQQBBPBA6EL8SIgEgABDEHCABCwcAIAAQvwcLBwAgABC/BwsKACAAEI0NEIYBCwQAQQILOAEBfwJAAkAgAUF2aiICQRxLDQBBASACdEGDgICAAXENAQsgAUECRg0AIAFB2wBGDQBBAA8LQQELHQEBf0GkARCIAUEAQaQBEDoQtRIiASAAEMUIIAELNgEBf0HUABCIAUEAQdQAEDoQ3xIiAUHEAGogAEHEAGoQqgUgASAAKAJQNgJQIAEgABDHCCABCwoAIAAQ2hMQhgELRAECfSABKgLcASEGIAAgASoC4AEiByAEQ///f38gBRsiBCAHIARdGzgCBCAAIAYgAkP//39/IAMbIgQgBiAEXRs4AgALQgECfSABKgJwIQYgACABKgJ0IgcgBEP//39/IAUbIgQgByAEXRs4AgQgACAGIAJD//9/fyADGyIEIAYgBF0bOAIAC2sBAX0CQCAAKgLcASABKgIAIgRbDQAgACAEOALcASAAIAAoAgAoAowBEQAACwJAIAAqAuABIAEqAgQiBFsNACAAIAQ4AuABIAAgACgCACgCkAERAAALIAAQrBcgAEEAIAAoAgAoAoQBEQMACzABAX8jAEEQayIEJAAgBCABKQIANwMIIABBlH9qIARBCGpBAEEAEIcdIARBEGokAAttACAAQQAQih0CQCABRQ0AIAAhAQNAIAEoAhgiAUUNAQJAIAFBmQMgASgCACgCDBECAEUNACABENAYDwsgAUECIAEoAgAoAgwRAgBFDQAgAUEDIAEoAgAoAgwRAgBFDQEgASAAKAKoAUYNAAsLCx8AIABBEEEAEL0HGgJAIAAoAqgBIgBFDQAgABCaHQsLEgAgAEEBIAAoAgAoAoQBEQMACxIAIABBASAAKAIAKAKEAREDAAsSACAAQQEgACgCACgChAERAwALEgAgAEEBIAAoAgAoAoQBEQMACwoAIAAQrw4QhgELYgECfyMAQRBrIgIkACAAIAMQ/BEaIAAhAwJAA0AgAygCGCIDRQ0BIANBAyADKAIAKAIMEQIARQ0ACyAAIAM2AqgBIAIgADYCDCADQeQCaiACQQxqEPMVCyACQRBqJAAgA0ULBwAgABDKGAs3AAJAIAJBgICAgARJDQAQAAALIAEgAGsiAUEBdSIAIAIgACACSxtB/////wMgAUH8////B0kbC2oBAX9BACEEIABBADYCDCAAQRBqIAM2AgACQAJAIAFFDQAgAUGAgICABE8NASABQQJ0EIgBIQQLIAAgBDYCACAAIAQgAkECdGoiAzYCCCAAIAQgAUECdGo2AgwgACADNgIEIAAPCxCMBQALkwEBA38gASgCBCECIAAoAgAhAyAAKAIEIQQCQANAIAQgA0YNASACQXxqIgIgBEF8aiIEKAIANgIADAALAAsgASACNgIEIAAoAgAhBCAAIAI2AgAgASAENgIEIAAoAgQhBCAAIAEoAgg2AgQgASAENgIIIAAoAgghBCAAIAEoAgw2AgggASAENgIMIAEgASgCBDYCAAtCAQJ/IAAoAgghASAAKAIEIQICQANAIAEgAkYNASAAIAFBfGoiATYCCAwACwALAkAgACgCACIBRQ0AIAEQhgELIAALCAAgAEHIAGoLywECAX8BfSABKAIEIQIgAEHQ0RM2AgAgACACNgIEIABBCGogAUEIahCWBRogASgCFCECIABBhNETNgIAIAAgAjYCFCAAIAEpAhg3AhggAEEeaiABQR5qKQEANwEAIABBKGogAUEoahD2DBogAUE0aigCACECIABBtNATNgIAIABBNGogAjYCACAAQThqIAFBOGoQ9gwaIABBrL0TNgIAIAAgASkCRDcCRCAAIAEoAkw2AkwgASoCUCEDIABB6LsTNgIAIAAgAzgCUCAAC4kBAQR9AkACQCAAp74iAyABQiCIp74iBJQgAae+IgUgAEIgiKe+IgaUkyADIAWUIAYgBJSSEO8VIgSLIgND2w/JP11FDQAgBBChDkMAAIA/kiEEDAELQwAAAEAgAxDGDZMhBAsgAiAEQ9sPSUBD2w/JQCADlSIDIAOSlRCZHUOrqqo/lCAClJQQeQvQAgIDfwF8IwBBEGsiASQAAkACQCAAvCICQf////8HcSIDQdqfpPoDSw0AIANBgICAzANJDQEgALtBABCELSEADAELAkAgA0HRp+2DBEsNACAAuyEEAkAgA0Hjl9uABEsNAEQYLURU+yH5P0QYLURU+yH5vyACQQBIGyAEoEEBEIQtIQAMAgtEGC1EVPshCUBEGC1EVPshCcAgAkEASBsgBKBBABCELSEADAELAkAgA0HV44iHBEsNACAAuyEEAkAgA0Hf27+FBEsNAETSITN/fNkSQETSITN/fNkSwCACQQBIGyAEoEEBEIQtIQAMAgtEGC1EVPshGUBEGC1EVPshGcAgAkEASBsgBKBBABCELSEADAELAkAgA0GAgID8B0kNACAAIACTIQAMAQsgACABQQhqEIctIQMgASsDCCADQQFxEIQtIQALIAFBEGokACAAC5ABAQN/IABB3AFqQRBBARC9BxogAEGUAWooAgAhASAAKAKQASECA0ACQCACIAFHDQAgACgC0AEhAyAAKALMASECAkADQCACIANGDQECQCACKAIAIgFBGCABKAIAKAIMEQIARQ0AIAEQ/RgLIAJBBGohAgwACwALDwsgAigCAEEQQQAQvQcaIAJBBGohAgwACwALNQACQCABQYDBAHFFDQAgACgCqAEiAUUNACAB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kjgCiAEgAkEwaiADEPEVIARBEGogAkEwakEQaikCADcCACAEQQhqIAJBMGpBCGopAgA3AgAgBCACKQIwNwIACyACQeAAaiQAC0AAIAAgASoCADgCACAAIAEqAgQ4AgQgACABKgIIOAIIIAAgASoCDDgCDCAAIAEqAhA4AhAgACABKgIUOAIUIAALCgAgABCECBCGAQsFAEHZAAsuAQF/AkACQCABQbF/aiICQQtLDQBBASACdEHDGHENAQsgAUEKRg0AQQAPC0EBCwQAQQALHQEBf0GQARCIAUEAQZABEDoQtBIiASAAEPEdIAELWQAgACABKAJMNgJMIAAgASoCUDgCUCAAIAEqAlQ4AlQgACABKgJYOAJYIAAgAS0AXDoAXCAAIAEtAF06AF0gACABLQBeOgBeIAAgAS0AXzoAXyAAIAEQgxYLjg0CBH8EfSMAQdAAayICJAACQAJAAkAgACgCQCIDDQBBACEDDAELIAMgAygCACgCQBEBAA0BIAAoAkAhAwsgAkE4aiABQcgAaiIEEPAVIAAgAioCODgCcCAAQfQAaiACKgI8OAIAIABB+ABqIAIqAkA4AgAgAEH8AGogAioCRDgCACAAQYABaiACKgJIOAIAIABBhAFqIAIqAkw4AgACQAJAIAMNACACQThqQRBqIARBEGopAgA3AwAgAkE4akEIaiAEQQhqKQIANwMAIAIgBCkCADcDOCAAQYgBaiAAQfAAahDrHRoMAQsgAkE4akEQaiADQdgAaikCADcDACACQThqQQhqIANB0ABqKQIANwMAIAIgAykCSDcDOAJAIAAoAkRBAUcNACACQSBqQRBqQQApAtixEzcDACACQSBqQQhqQQApAtCxEzcDACACQQApAsixEzcDICADKAIYIgNByABqQbCXGyADQdsAIAMoAgAoAgwRAgAbIAJBIGoQkgVFDQIgAkEIaiACQSBqIAJBOGoQkwUgAkE4akEQaiACQQhqQRBqKQIANwMAIAJBOGpBCGogAkEIakEIaikCADcDACACIAIpAgg3AzgLIAJBIGogAkE4ahDwFSAAIAIqAiA4AogBIABBjAFqIAIqAiQ4AgAgAioCLCEGIAIqAighByAAQZgBaiACKgIwOAIAIABBnAFqIAIqAjQ4AgACQAJAAkAgAC0AXQ0AQwAAgD8gACoCeCAAKAJIQQFGGyEHDAELIAAgByAAKgJQlCIHOAKQASAALQBcRQ0BIAcgASoCZJQhBwsgACAHOAKQAQsCQAJAAkAgAC0AbA0AQwAAgD8gACoCfCAAKAJIQQFGGyEGDAELIAAgBiAAKgJglCIGOAKUASAALQBcRQ0BIAYgASoCaJQhBgsgACAGOAKUAQsgACgCSEEBRw0AIAJBOGogAEGIAWoQ8RUgAkEgaiABKAIYIgNByABqQbCXGyADQdsAIAMoAgAoAgwRAgAbIAJBOGoQkwUgAkE4akEQaiACQSBqQRBqKQIANwMAIAJBOGpBCGogAkEgakEIaikCADcDACACIAIpAiA3AzggAkEgaiACQThqEPAVIAAgAioCIDgCiAEgACACKgIkOAKMASAAIAIqAig4ApABIAAgAioCLDgClAEgACACKgIwOAKYASAAIAIqAjQ4ApwBCwJAIAAoAkwiA0EBRw0AIAJBOGogAEGIAWoQ8RUgAkEgakEQakEAKQLYsRM3AwAgAkEgakEIakEAKQLQsRM3AwAgAkEAKQLIsRM3AyAgASgCGCIFQcgAakGwlxsgBUHbACAFKAIAKAIMEQIAGyACQSBqEJIFRQ0BIAJBCGogAkEgaiACQThqEJMFIAJBOGpBEGogAkEIakEQaikCADcDACACQThqQQhqIAJBCGpBCGopAgA3AwAgAiACKQIINwM4IAJBCGogAkE4ahDwFSAAIAIqAgg4AogBIABBjAFqIAIqAgw4AgAgAEGQAWogAioCEDgCACAAQZQBaiACKgIUOAIAIABBmAFqIAIqAhg4AgAgAEGcAWogAioCHDgCAAsCQCAALQBfRQ0AIABBkAFqKgIAIAAqAlgiBl5FDQAgACAGOAKQAQsCQCAALQBeRQ0AIABBkAFqKgIAIAAqAlQiBl1FDQAgACAGOAKQAQsCQCAALQBuRQ0AIABBlAFqKgIAIAAqAmgiBl5FDQAgACAGOAKUAQsCQCAALQBtRQ0AIABBlAFqKgIAIAAqAmQiBl1FDQAgACAGOAKUAQsCQAJAIANBAUYNACAAQZQBaioCACEHIABBkAFqKgIAIQgMAQsgAkE4aiAAQYgBahDxFSACQSBqIAEoAhgiA0HIAGpBsJcbIANB2wAgAygCACgCDBECABsgAkE4ahCTBSACQThqQRBqIAJBIGpBEGopAgA3AwAgAkE4akEIaiACQSBqQQhqKQIANwMAIAIgAikCIDcDOCACQSBqIAJBOGoQ8BUgAioCLCEHIAIqAighCAsgACAAKQJwNwKIASAAQZgBaiAAKQKAATcCACAAQZABaiAAKgJ4QwAAgD8gACoCOCIGkyIJlCAGIAiUkjgCACAAQZQBaiAAKgJ8IAmUIAYgB5SSOAIAIAJBIGogAEGIAWoQ8RUgBEEQaiACQSBqQRBqKQIANwIAIARBCGogAkEgakEIaikCADcCACAEIAIpAiA3AgALIAJB0ABqJAALCgAgABCECBCGAQsFAEHYAAsuAQF/AkACQCABQbF/aiICQQtLDQBBASACdEHDFXENAQsgAUEKRg0AQQAPC0EBCwQAQQALHQEBf0GgARCIAUEAQaABEDoQsxIiASAAEPgdIAELRQAgACABKgJgOAJgIAAgASoCZDgCZCAAIAEqAmg4AmggACABLQBsOgBsIAAgAS0AbToAbSAAIAEtAG46AG4gACABEPEdC3gBAn8jAEEQayIEJAAgACgCCCIFIAEgBSgCACgC5AERAgAhASAEIAM4AgwgBCAAQQRqNgIIAkACQCACQYsDRg0AIAJBkQNHDQEgASAEQQhqIAEoAgAoAkwRAwAMAQsgASAEQQhqIAEoAgAoAkgRAwALIARBEGokAAsCAAsEAEEACwQAQQALBABBAAsEAEEACwQAQQALBABBAAsEAEEACwQAQQALBABBAAuYAQIBfwN9AkAgAC0AREUNACAAKAJ4IgFFDQAgACgCGCgCGCIAQYwCaioCACAAKgKUApMgAEGcAmoqAgCTIQJDAACAPyEDAkAgAUEYaigCACIAQYwCaioCACIEQwAAAABbDQAgACABQTxqKAIAEIUeIASVIgNDAACAPyADQwAAgD9dGyEDCyACIAOUDwsgACgCGEGMAmoqAgALPQEBfSAAKAIYQYwCaioCACECAkAgAUH/AXFBAUYNACACIAAqAoQCkyICQwAAAAAgAkMAAAAAXhshAgsgAgubAQIBfwN9AkAgAC0AREUNACAAKAJ4IgFFDQAgACgCGCgCGCIAQZACaioCACAAQZgCaioCAJMgAEGgAmoqAgCTIQJDAACAPyEDAkAgAUEYaigCACIAQZACaioCACIEQwAAAABbDQAgACABQTxqKAIAEIceIASVIgNDAACAPyADQwAAgD9dGyEDCyAC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KAJwIQQgAigCdCEBIAMhAAJAA0AgASAERg0BIABBfGoiACABQXxqIgEoAgA2AgAMAAsACyACIANBBGo2AnQgAigCcCEBIAIgADYCcCACIAUgBkECdGo2AngCQCABRQ0AIAEQhgELQQAPCxAAAAsKACAAEIQIEIYBCwoAIAAQwx4QhgELNwAgAEGYihM2AgAgAEGAAWoQ9h4aIABB/ABqEPYeGiAAQdwAahC3BxogAEE8ahC3BxogABCECAtIAQJ/IAAoAjggABCFCCAAKAI4IgFB6AJqKAIAIQIgASgC5AIhAQNAAkAgASACRw0ADwsgASgCACAAEIUIIAFBBGohAQwACwALFgACQCAALQCEAUUNACAAKAI4EJodCwvyBQEFfyMAQdAAayICJAACQCABQZDAAHFFDQACQCAAKAI4EJwdRQ0AIABBAToAhAEMAQsgAEEAOgCEAQJAIAAoAjhBAhCdHUUNACAAQfwAaiEDAkACQCAAKAJ8IgENACACQThqIAAoAiAoAoALIgEgASgCACgCGBEDACACKAI4IQEgAkEANgI4IAMgARDHHiACKAI4EPANDAELIAEgASgCACgCCBEAACAAQdgAakEAOgAAIABBwABqIAAoAjw2AgAgAEHMAGogAEHIAGooAgA2AgALIAJByABqIAAoAjgiAUHYAGopAgA3AwAgAkHAAGogAUHQAGopAgA3AwAgAiABKQJINwM4IABBPGohBCACQSBqIAJBOGoQkRcgAUHoAmooAgAhBSABKALkAiEBA0ACQCABIAVHDQAgBCADKAIAELoHDAILAkAgASgCACIGLQCkAUEBcQ0AIAYgBigCACgCQBEBAA0AIAJBCGogAkEgaiAGIAYoAgAoAoABEQEAEJMFIAIgBCAGQbwBaiACQQhqEPgVCyABQQRqIQEMAAsACwJAIAAoAjhBBBCdHUUNACAAQYABaiEDAkACQCAAKAKAASIBDQAgAkE4aiAAKAIgKAKACyIBIAEoAgAoAhgRAwAgAigCOCEBIAJBADYCOCADIAEQxx4gAigCOBDwDQwBCyABIAEoAgAoAggRAAAgAEH4AGpBADoAACAAQeAAaiAAKAJcNgIAIABB7ABqIABB6ABqKAIANgIACyAAQdwAaiEEIAAoAjgiAUHoAmooAgAhBSABKALkAiEBA0ACQCABIAVHDQAgBCAD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CwJAIAAgACgCACgCWBEBAEECcUUNACABIAMgASgCACgCEBEDACAHIQogBiELCyAAIAEgCigCACALIAAoAkwgACgCACgCXBELACABIAEoAgAoAgwRAAALIAlBBGohCQwACwALIAEgASgCACgCDBEAAAsL1QMBCn8jAEGgAWsiAyQAQQAhBAJAIAAqAogBQwAAAABbDQAgAEHIAGohBSADQdwAaiEGIABBAhCdHSEHIAAoAtABIQgDQCAIIAAoAswBRg0BIAhBfGoiCCgCACIJEKoIDQAgCSAJKAIAKAJIEQEARQ0AIAkgCSgCACgCWBEBACEJIANBiAFqQRBqIAJBEGopAgA3AwAgA0GIAWpBCGogAkEIaikCADcDACADIAIpAgA3A4gBAkAgCUECcUUNACADQYgBaiAFELAHGgsgA0EgaiABEMkeIQogACgC6AIhCyAAKALkAiEJA0ACQCAJIAtHDQAgChDUHiEJIAoQyx4aIAlFDQIgACEEDAMLIAkoAgAhDAJAAkAgB0UNACADQQhqIAIgDCAMKAIAKAKAAREBABCTBSAGQRBqIANBCGpBEGopAgA3AgAgBkEIaiADQQhqQQhqKQIANwIAIAYgAykCCDcCAAwBCyADQQhqIANBiAFqIAwgDCgCACgCgAERAQAQkwUgBkEQaiADQQhqQRBqKQIANwIAIAZBCGogA0EIakEIaikCADcCACAGIAMpAgg3AgALIAxBvAFqIAoQugcgCUEEaiEJDAALAAsACyADQaABaiQAIAQLBwAgACgCIAunAQIDfwR9IwBBEGsiBiQAIABCADcCACABQegCaigCACEHIAEoAuQCIQFDAAAAACEJQwAAAAAhCgNAAkAgASAHRw0AIAZBEGokAA8LIAZBCGogASgCACIIQewAaiACIAMgBCAFIAgoAmwoAgARFAAgBioCCCELIAAgBioCDCIMIAkgCSAMXRsiCTgCBCAAIAsgCiAKIAtdGyIKOAIAIAFBBGohAQwACwAL7QYCCH8QfSMAQcAAayICJAACQAJAIAAoAqgBIgNBEHFFDQAgAEH8AmoqAgAhCiAAQfgCaioCACELIABB9AJqKgIAIQwgACoC8AIhDQwBCwJAIAMgA0EQciIERg0AIAAgBDYCqAEgACAAKAIAKAKAAREAAAsgAkE8akEAOgAAIAJBGGpBEGpCADcCACACQTBqQgA3AgAgAkHoiRM2AhggAkEBNgIcIAJCADcCICAAQegCaigCACEFIAAoAuQCIQZD//9//yELQ///f38hDUP//39/IQxD//9//yEKQQEhBwJAA0AgBiAFRg0BAkAgBigCACIDIAMoAgAoAkARAQANACADQbwBaiACQRhqELoHIAJBEGogAyADKAIAKAKAAREBACIDQRBqKQIANwMAIAJBCGogA0EIaikCADcDACACIAMpAgA3AwAgAigCICACKAIkIAIQzh0CQAJAIAIoAiQiCCACKAIgIglrIgRBCHFFDQBBASEDIAkqAAAiDiEPIAkqAAQiECERDAELQQIhAwJAIAkgCEcNAEMAAAAAIQ5DAAAAACEQQwAAAAAhD0MAAAAAIREMAQsgCUEMaioAACERIAkqAAghDyAJKgAEIRAgCSoAACEOCyAEQQN1IQggDiESIBAhEyAPIRQgESEVAkADQCADIAhPDQEgCSADQQN0aiIEQQxqKgAAIRYgBCoAACEXIAQqAAQhGCAPIAQqAAgiGRB3IQ8gECAYEHchECAOIBcQdyEOIBQgGRB5IRQgEyAYEHkhEyASIBcQeSESIBEgFhB3IREgFSAWEHkhFSADQQJqIQMMAAsACyAOIA8QdyEWIBIgFBB5IRcgECAREHchGCATIBUQeSEOAkACQCAHQQFxRQ0AIBchDSAOIQwgFiELIBghCgwBCyAWIAsgCyAWXRshCyAXIA0gFyANXRshDSAYIAogCiAYXRshCiAOIAwgDiAMXRshDAsgAiAJNgIkQQAhByACQQA6ADwgAiACKAIsNgIwCyAGQQRqIQYMAAsACyACQRhqEOMeGiAAQfwCaiAKOAIAIABB+AJqIAs4AgAgAEH0AmogDDgCACAAIA04AvACC0EAIQMCQCABKgIAIhYgDWBFDQAgFiALX0UNACABKgIEIhYgDGBFDQAgFiAKXyEDCyACQcAAaiQAIAMLFgAgAEHoiRM2AgAgAEEIahC3BxogAAuCAgIFfwJ9IwBBgAFrIgMkACABKgIAIQggAyABKgIEIgkgApI4AhQgAyAIIAKSOAIQIAMgCSACkzgCDCADIAggApM4AgggA0HwAGogA0EIahCZFyADQQhqIANB8ABqEMkeIgRBPGohBSAAQegCaigCACEGIAAoAuQCIQECQANAIAEgBkYNAQJAIAEoAgAiACAAKAIAKAJAEQEADQAgBSAAIAAoAgAoAoABEQEAIgcpAgA3AgAgBUEQaiAHQRBqKQIANwIAIAVBCGogB0EIaikCADcCACAAQbwBaiAEELoHCyABQQRqIQEMAAsACyAEENQeIQEgBBDLHhogA0GAAWokACABCxUAIAAgAUGUf2ogAiADIAQgBRDhHgsLACAAQdx+aigCAAsLACAAQbx+ahDVHgsLACAAQbx+ahDWHgsNACAAQah+aiABEOIeCw8AIABBqH5qIAEgAhDkHgsLACAAQah+ahDVHgsLACAAQah+ahDWHgsKACAAEOMeEIYBCykAIABBDGogACgCCDYCACAAQSRqQQA6AAAgAEEYaiAAQRRqKAIANgIACwIACwIACw4AIABBCGogASACEKAWCw4AIABBCGogASACEKEWCxYAIABBCGogASACIAMgBCAFIAYQohYLCgAgAEEIahCjFgsEAEEACzYBAn8CQCAAKAIAIgFFDQAgASABKAIEIgJBf2o2AgQgAkEBRw0AIAEgASgCACgCBBEAAAsgAAsWAQF/QYgDEIgBENUSIgEgABDECCABC4MDAQZ/QeABIQJBASEDAkACQAJAAkACQAJAAkAgACgCGCIEIAQoAgAoAggRAQAiBUF/ag4DAwQBAAsgBUGJAUYNASAFQZkDRg0CIAVBgQRHDQMLQcQBIQIMAQtB1AAhAgtBACEDIAAoAlBFDQACQCAEIAJqIgJBDGooAgAiAyACQRBqKAIARg0AIAMgADYCACACIANBBGo2AgxBAA8LIAMgAigCCGsiA0ECdSIGQQFqIgRBgICAgARPDQECQAJAIANBAXUiBSAEIAUgBEsbQf////8DIANB/P///wdJGyIFDQBBACEHDAELIAVBgICAgARPDQMgBUECdBCIASEHCyAHIAZBAnRqIgYgADYCACACKAIIIQQgAigCDCEAIAYhAwJAA0AgACAERg0BIANBfGoiAyAAQXxqIgAoAgA2AgAMAAsACyACIAZBBGo2AgwgAigCCCEAIAIgAzYCCCACIAcgBUECdGo2AhBBACEDIABFDQAgABCGAQsgAw8LEAAACxCMBQALLwEBfwJAIABFDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAgACgCACgCBBEAAAsLAwAAC0IBAX8gAEHkihM2AgACQCAA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QAJAIAMgAkcNAEEADwsgAygCACEEIANBBGohAyAEIAEgBCgCACgCIBECACIERQ0ACwsgBAspAAJAIAEoAgAgASgCBBCHBSIBDQBBAQ8LIAEoAgRB9AlqIAAQoQhBAAspAQF/IAAoAgAhASAAQQA2AgACQCABRQ0AIAEgASgCACgCBBEAAAsgAAspAQF/IAAoAgAhASAAQQA2AgACQCABRQ0AIAEgASgCACgCBBEAAAsgAAspAQF/IAAoAgAhASAAQQA2AgACQCABRQ0AIAEgASgCACgCBBEAAAsgAAu1AgEHfwJAIABBJGooAgAiAiAAQShqKAIAIgNPDQAgAiABNgIAIAAgAkEEajYCJA8LAkACQCACIAAoAiAiBGtBAnUiBUEBaiIGQYCAgIAETw0AQQAhBwJAIAMgBGsiA0EBdSIIIAYgCCAGSxtB/////wMgA0H8////B0kbIgZFDQAgBkGAgICABE8NAiAGQQJ0EIgBIQcLIAcgBUECdGoiBSABNgIAIAUhAQJAA0AgAiAERg0BIAJBfGoiAigCACEDIAJBADYCACABQXxqIgEgAzYCAAwACwALIAAoAiAhAyAAIAE2AiAgACgCJCECIAAgBUEEajYCJCAAIAcgBkECdGo2AigCQANAIAIgA0YNASACQXxqEL0fIQIMAAsACwJAIANFDQAgAxCGAQsPCxAAAAsQjAUACxwBAX9BxAAQiAEQxhIiAUEIaiAAQQhqEKoFIAELQgEBf0EYEIgBIgFCADcDACABQRBqQgA3AwAgAUEIakIANwMAIAEQzBIiASAALQAUOgAUIAFBCGogAEEIahCqBSABC8cCAQV/QQEhAgJAAkACQCABKAIAIAEoAgRBwgAQ0gciAUUNACABQQxqKAIAIgFFDQACQCABKAIEIgNBDGooAgAiASADQRBqKAIARg0AIAEgADYCACADIAFBBGo2AgxBAA8LIAEgAygCCGsiAUECdSIEQQFqIgJBgICAgARPDQECQAJAIAFBAXUiBSACIAUgAksbQf////8DIAFB/P///wdJGyIFDQBBACEGDAELIAVBgICAgARPDQMgBUECdBCIASEGCyAGIARBAnRqIgQgADYCACADKAIIIQAgAygCDCEBIAQhAgJAA0AgASAARg0BIAJBfGoiAiABQXxqIgEoAgA2AgAMAAsACyADIARBBGo2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IAEgAnAhAQsCQCABIAdGDQACQCAAKAIAIAFBAnQiBWoiDCgCAA0AIAwgCDYCACABIQcMAQsgCCAEKAIANgIAIAQgACgCACAFaigCACgCADYCACAAKAIAIAVqKAIAIAQ2AgAMAQsgBCEIDAALAAsQjAUAC0EAIQQgAEEAEOQfIABBADYCBAwBCyACIQQLAkAgBCAEQX9qIgFxDQAgASADcSEFDAELAkAgAyAETw0AIAMhBQwBCyADIARwIQULAkACQAJAIAAoAgAgBUECdGoiAigCACIBDQAgBiAJKAIANgIAIAkgBjYCACACIAk2AgAgBigCACIBRQ0CIAEoAgQhAQJAAkAgBCAEQX9qIgJxDQAgASACcSEBDAELIAEgBEkNACABIARwIQELIAAoAgAgAUECdGohAQwBCyAGIAEoAgA2AgALIAEgBjYCAAsgACAAKAIMQQFqNgIMCyAGQQxqC9kCAQZ/AkAgACgCBCICIAAoAggiA08NACABKAIAIQMgAUEANgIAIAIgAzYCACAAIAJBBGo2AgQPCwJAAkAgAiAAKAIAIgRrQQJ1IgVBAWoiAkGAgICABE8NAEEAIQYCQCADIARrIgNBAXUiBCACIAQgAksbQf////8DIANB/P///wdJGyIHRQ0AIAdBgICAgARPDQIgB0ECdBCIASEGCyABKAIAIQIgAUEANgIAIAYgBUECdGoiBSACNgIAIAAoAgAhBCAAKAIEIQEgBSECAkADQCABIARGDQEgAUF8aiIBKAIAIQMgAUEANgIAIAJBfGoiAiADNgIADAALAAsgACgCACEDIAAgAjYCACAAKAIEIQEgACAFQQRqNgIEIAAgBiAHQQJ0ajYCCAJAA0AgASADRg0BIAFBfGoQ5R8hAQwACwALAkAgA0UNACADEIYBCw8LEAAACxCMBQAL5gIBBn8CQAJAIAEgACgCBCABKAIAKAIIEQIADQAgAEEAOgARDAELAkAgASAAKAIEIAEoAgAoAgwRAgBFDQAgAEEBOgASCyABIAAoAgQgASgCACgCEBECAEUNACAAQQE6ABMLAkAgAEEgaigCACICIABBJGooAgBGDQAgAiABNgIAIAAgAkEEajYCIA8LAkACQCACIAAoAhwiA2siBEECdSIFQQFqIgZBgICAgARPDQACQAJAIARBAXUiByAGIAcgBksbQf////8DIARB/P///wdJGyIEDQBBACEGDAELIARBgICAgARPDQIgBEECdBCIASEGCyAGIAVBAnRqIgUgATYCACAFIQECQANAIAIgA0YNASABQXxqIgEgAkF8aiICKAIANgIADAALAAsgACAFQQRqNgIgIAAoAhwhAiAAIAE2AhwgACAGIARBAnRqNgIkAkAgAkUNACACEIYBCw8LEAAACxCMBQALGgAgACABIAIgA0EAEN4fIgNBzJQTNgIAIAMLBwAgABD3DAsfAQF/IAAoAgAhAiAAIAE2AgACQCACRQ0AIAIQhgELCykBAX8gACgCACEBIABBADYCAAJAIAFFDQAgASABKAIAKAIEEQAACyAACwQAIAALBwAgABCGAQsuAQF/QRQQiAEiAUGUlRM2AgAgASAAKQIENwIEIAFBDGogAEEMaikCADcCACABCyUAIAFBlJUTNgIAIAEgACkCBDcCBCABQQxqIABBDGopAgA3AgALAgALBwAgABCGAQtDACABKAIAIQEgACgCBCABIAFBmQMgASgCACgCDBECACAAQQhqKAIAIABBDGooAgAoAgAgAEEQaigCAC0AABDcH0EBCysBAX8gAEHwlBM2AgACQCAAKAIoIgFFDQAgAUEAOgBoIAEQ7h8LIAAQ7x8LLgAgAEHcAGoQ4CEgAEHUAGpC////+////79/NwIAIABC////+/f//7//ADcCTAsrAQF/IABBqJQTNgIAAkAgACgCHCIBRQ0AIABBIGogATYCACABEIYBCyAACwoAIAAQ7R8QhgELjQICB38BfiMAQRBrIgQkAAJAAkAgAC0AEUUNAAJAIAJBAkcNACAALQASQf8BcQ0BC0EAIQUgAkEDRw0BIAAtABNB/wFxRQ0BCyAAQSBqKAIAIQYgASkCACELIAAoAhwhBUEAIQcDQAJAIAUgBkcNAEEAIQUgAC0AEEUNAiADRQ0CAkAgAC0AFA0AQQEhBSAAKAIYLQCoAUEDdiAHckEBcUUNAwtBAiEFDAILAkAgBSgCACIBLQAMDQAgACgCBCEIIAQgCzcDCCAAKAIIIQkgASgCACgCFCEKIAQgCzcDACABIAggBCACIAMgCSAKEQoAQQJGIAdyIQcLIAVBBGohBQwACwALIARBEGokACAFC60BAgF/AX4jAEEQayIDJAACQAJAIAAtABFFDQACQCACQQJHDQAg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QQA2AowBAkAgAkUNACACEIYBCyAAKAKAARC4ICAAKAJ4IQIgAEEANgJ4AkAgAkUNACACEIYBCyADEOQHGgJAIAAoAlgiBkUNACAAQdwAaigCACECAkADQCACIAZGDQEgAkF8ahCEICECDAALAAsgACAGNgJcIAAoAlgQhgELAkAgACgCTCIGRQ0AIABB0ABqKAIAIQICQANAIAIgBkYNASACQXxqEOUfIQIMAAsACyAAIAY2AlAgACgCTBCGAQsCQCAAKAI4IgJFDQAgACACNgI8IAIQhgELIABBJGoQlhoaIABBDGoQ2g8aIAALEAAgACABKAIwQQhqEJYFGgsEAEEACwQAQQELBwBDAACAvwvAAQEDfyAAIAFBARC+BSAAKAIIIgJBgApqKAIAIAJBhApqKAIAIAFBDxCoCHIhA0EAIQICQANAIAJBBUYNASAAKAIIQQEQpgghBAJAAkAgABCdHA0AIAQgA3IhBAwBCyAAQwAAAABBABC+BRpBASEECyAAKAIIIgNBgApqKAIAIANBhApqKAIAQwAAAABBBxCoCCAEciEDIAJBAWohAiAAKAIILQAkQQRxDQALCyADIAAoAiQgAEEoaigCAEdyQQFxCx4BAX9BCBCIASICIAE2AgQgAkEANgIAIAAgAhD1HAsTACAAQTxqKAIAIAAoAjhrQQJ1CzIBAX9BACECAkAgAEE8aigCACAAKAI4IgBrQQJ1IAFNDQAgACABQQJ0aigCACECCyACC2IBA38gAEE8aigCACECIAAoAjghAAJAA0ACQCAAIAJHDQBBACEDDAILAkAgACgCACIDKAIIIgRBOyAEKAIAKAIMEQIARQ0AIARBCGogARCXBQ0CCyAAQQRqIQAMAAsACyADC2IBA38gAEE8aigCACECIAAoAjghAAJAA0ACQCAAIAJHDQBBACEDDAILAkAgACgCACIDKAIIIgRBOCAEKAIAKAIMEQIARQ0AIARBCGogARCXBQ0CCyAAQQRqIQAMAAsACyADC2IBA38gAEE8aigCACECIAAoAjghAAJAA0ACQCAAIAJHDQBBACEDDAILAkAgACgCACIDKAIIIgRBOiAEKAIAKAIMEQIARQ0AIARBCGogARCXBQ0CCyAAQQRqIQAMAAsACyADCwsAIAAgASACEKUgC70EAQd/IwBBEGsiAyQAAkAgASgCBCAB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AgAgByAEKQMYNwIADAYLIAggCEEUaiAIQShqIAcgAhCYIRoMBQsgCCAIQRRqIAhBKGogCEE8aiAHIAIQmSEaDAQLAkAgAEHrBEoNACAIIAhBFGogCEEoaiILIAIQmiEaIAhBPGohAANAIAAiDSABRg0FAkAgAigCACgCACANQQxqIgAqAgAgDUEQaiIKKgIAIAtBDGoqAgAgC0EQaioCABCXIUUNACAEQRhqQQhqIgkgDUEIaigCADYCACAEIA0pAgA3AxggCioCACESIAAqAgAhEyANIQoCQANAIAogCyIAKQIANwIAIApBEGogAEEQaigCADYCACAKQQhqIABBCGopAgA3AgACQCAAIAhHDQAgCCEADAILIABBbGohCyAAIQogEiATIAIoAgAoAgAiDBsgAEF8aiAAQXhqIAwbKgIAXQ0ACwsgACAEKQMYNwIAIABBCGogCSgCADYCACAAIBI4AhAgACATOAIMCyANQRRqIQAgDSELDAALAAsgAw0BIAggAUYNAyAJQX5qQQF2Ig4hDwNAAkAgD0EATg0AA0AgCUECSA0GIARBGGpBEGoiDyAIQRBqKAIANgIAIARBGGpBCGoiECAIQQhqKQIANwMAIAQgCCkCADcDGCAJQX5qQQF2IQ5BACELIAghCgNAIAtBAXQiDEEBciENIAtBFGwgCmpBFGohAAJAAkAgDEECaiILIAlIDQAgDSELDAELIAsgDSACKAIAKAIAIABBDGoqAgAgAEEQaioCACAAQSBqKgIAIABBJGoqAgAQlyEiDBshCyAAIAxBFGxqIQALIAogACkCADcCACAKQRBqIABBEGoiDCgCADYCACAKQQhqIABBCGoiDSkCADcCACAAIQogCyAOTA0ACwJAAkAgACABQWxqIgFHDQAgACAEKQMYNwIAIAwgDygCADYCACANIBApAwA3AgAMAQsgACABKQIANwIAIAwgAUEQaiIKKAIANgIAIA0gAUEIaiILKQIANwIAIAEgBCkDGDcCACALIBApAwA3AgAgCiAPKAIANgIAIAAgCGtBFGoiCkEVSA0AIAIoAgAoAgAgCCAKQRRuQX5qQQF2Ig5BFGxqIgtBDGoqAgAgC0EQaioCACAAQQxqIgoqAgAgDCoCABCXIUUNACAEQQhqQQhqIg8gDSgCADYCACAEIAApAgA3AwggDCoCACESIAoq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ACgCACEMA0AgCyIAQRRqIQsgDCATIBIgAEEMaioCACAAQRBqIg0qAgAQlyFFDQALA0AgDCATIBIgCkFsaiIKQQxqKgIAIApBEGoiCSoCABCXIQ0ACyAAIApPDQEgBEEYakEQaiIMIA0oAgA2AgAgBEEYakEIaiIOIABBCGoiCCkCADcDACAEIAApAgA3AxggDSAJKAIANgIAIAggCkEIaiINKQIANwIAIAAgCikCADcCACAJIAwoAgA2AgAgDSAOKQMANwIAIAogBCkDGDcCAAwACwALAAsLIARBMGokAAtDAQJ/AkAgACgCACIBRQ0AIAAoAgQhAgJAA0AgAiABRg0BIAJBdGoQkwYhAgwACwALIAAgATYCBCAAKAIAEIYBCyAACx8BAX8CQCAAKAIAIgFFDQAgACABNgIEIAEQhgELIAALEQAgAiABIAAbIAQgAyAAG10LnQQBCX8jAEEgayIFJAAgACABIAIgBBCVISEGAkAgBCgCACgCACADQQxqKgIAIANBEGoiByoCACACQQxqIggqAgAgAkEQaiIJKgIAEJIhRQ0AIAVBCGpBEGoiCiAJKAIANgIAIAVBCGpBCGoiCyACQQhqIgwpAgA3AwAgBSACKQIANwMIIAkgBygCADYCACAMIANBCGoiDSkCADcCACACIAMpAgA3AgAgByAKKAIANgIAIA0gCykDADcCACADIAUpAwg3AgACQCAEKAIAKAIAIAgqAgAgCSoCACABQQxqKgIAIAFBEGoqAgAQkiENACAGQQFqIQYMAQsgBUEIakEQaiIJIAFBEGoiAygCADYCACALIAFBCGoiBykCADcDACAFIAEpAgA3AwggAyACQRBqIggoAgA2AgAgByAMKQIANwIAIAEgAikCADcCACAIIAkoAgA2AgAgDCALKQMANwIAIAIgBSkDCDcCAAJAIAQoAgAoAgAgAUEMaioCACADKgIAIABBDGoqAgAgAEEQaiICKgIAEJIhDQAgBkECaiEGDAELIAkgAigCADYCACAFQQhqQQhqIgQgAEEIaiIHKQIANwMAIAUgACkCADcDCCACIAMoAgA2AgAgByABQQhqIgIpAgA3AgAgACABKQIANwIAIAMgCSgCADYCACACIAQpAwA3AgAgASAFKQMINwIAIAZBA2ohBgsgBUEgaiQAIAYLxQUBCX8jAEEgayIGJAAg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BDYCCCAAKAIAIAZqIAw2AgAgAigCBCILKAIAIghFDQEgCCgCBCEIAkACQCAEIARBf2oiBnENACAIIAZxIQgMAQsgCCAESQ0AIAggBHAhCAsgACgCACAIQQJ0aiALNgIADAELIAsgCCgCADYCACAIIAIoAgQ2AgALIAJBADYCBCAAIAAoAgxBAWo2AgwgAkEEahCwIRoLIAJBEGokAAshAQF/IAAoAgAhASAAQQA2AgACQCABRQ0AIAEQhgELIAALHwEBfyAAKAIAIQIgACABNgIAAkAgAkUNACACEIYBCwtGAQJ/IAAoAgghAQJAA0AgAUUNASABKAIAIQIgARCGASACIQEMAAsACyAAKAIAIQEgAEEANgIAAkAgAUUNACABEIYBCyAACzIAIAEgASgCCCABKAIAa0EFdRC0ISAAIAEoAgA2AgAgACABKAIENgIEIAFCADcCACAAC30BAn8CQCAAKAIEIAFGDQAgACAAKAIAIAFBBXQiAhBIIgM2AgAgAyACaiECIAMgACgCBEEFdGohAwJAA0AgAyACTw0BIANCADcCACADQRhqQgA3AgAgA0EQakIANwIAIANBCGpCADcCACADQSBqIQMMAAsACyAAIAE2AgQLC14BA38gACAAKAIEQQJqIgM2AgQgASACQcQAbGohBCAAKAIAIQICQANAIAMgAkE8aigCACIBSSIFDQEgACACQcQAaiICNgIAIAAgAyABayIDNgIEIAIgBEcNAAsLIAULiAEBA38CQCAAKAIIIgIgACgCACIDIAAoAgQiBEEFdGpHDQAgACAEQQF0IgRBASAEQQFLGxC0ISAAKAIAIAIgA2tqIQILIAAgAkEgajYCCCACQRhqIAFBGGopAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACACIAEpAgA3AgALZgEFfyAAKAIAIQEgACgCCCECIAAoAgQiAygCACEEAkADQCACIAEgBBC4IUcNASAEIAEoAhRBfGooAgBGDQEgACADQQRqIgU2AgQgACABIAMoAgQiBBC5ISICNgIIIAUhAwwACwALCz4AAkAgAS0AQkEBcQ0AAkAgACgCBCABRw0AIAAoAgwPCyABQRRqKAIADwsgACgCCEF/akF/IAAoAgAgAUYbCzkAAkAgAS0AQkEBcQ0AIAAoAghBACAAKAIAIAFG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QawBaiINKAIANgIQIA0gDjYCACABKAIUIQ4gASAGQbABaiINKAIANgIUIA0gDjYCAAwCCyAOIAwoAhAgDmoiBSAGKAKQASAGKAKMAWtBAnUiByAFIAdJGyIHIA4gB0sbIQcCQANAIA4gB0YNAQJAIAYoAowBIA5BAnRqKgIAIhEgEFsNAAJAIA4gDUYNACAOIA1rIQ0CQAJAIBBDAAAAAFwNACADQcQAaiAMIA0QyCEgCiADQcQAahDJISADKAJEEMohDAELIANBKGogDCANEMghIANBxABqIAYgACgCjAIgA0EoaiAQEMshIAogA0HEAGoQySEgAygCRBDKISADKAIoEMohCyAOIQ0LIBEhEAsgDkEBaiEODAALAAsgBSANayEOAkACQCAQQwAAAABcDQAgA0HEAGogDCAOEMghIAogA0HEAGoQySEgAygCRBDKIQwBCyADQQxqIAwgDhDIISADQcQAaiAGIAAoAowCIANBDGogEBDLISAKIANBxABqEMkhIAMoAkQQyiEgAygCDBDKIQsgDEEcaiEMIAUhDSAHIQ4MAAsACyAJQQRqIQkMAAsACyABQRBqKAIAIQ4gASgCDCENIANB4ABqJAAgDSAORw8LAkAgBigCACINKAJsIg5FDQAgA0HEAGogDkHsAGoiCygCACAOQYgBaiIJKAIAEMwhIAMoAkQiDEUNACANQcAAaigCACEIIA0tAEchCiAMIAwoAgQiD0F/ajYCBAJAIA9BAUcNACAMIAwoAgAoAgQRAAALIAggCiAKQRh0QRh1QQBIG0UNACADQQhqIAsoAgAgCSgCABDMISAOKgJMIRAgDioCSCERIA4qAkQhEkEAIQ4gAyANKAI8IA1BPGogDSwAR0EASBsiDTYCKAJAA0AgDS0AAEUNASADIANBKGoQzSE2AkQgASADQcQAahDAISAOQQFqIQ4gAygCKCENDAALAAsgAygCCCENIANBADYCCCADQQA6AF4gAyAHOwFcIANBADYCWCADIA42AlQgAyAQOAJQIAMgETgCTCADIBI4AkggAyANNgJEIAQgA0HEAGoQySEgAygCRBDBIUEAEMEhCyAGQQRqIQYgB0EBaiEHDAALC+ABAQN/IABBADYCCCAAQgA3AgACQAJAIAEoAgQiAiABKAIAIgNGDQAgAiADa0EcbSIDQcqkkskATw0BIAAg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A0AgBUF0ahCTBiIFIAZHDQALIApBEGohCgwACwALAkACQCABKAKUASIEIAEoApgBIgVGDQAgBUFwaiIGQQRqIgkqAgAiJiADKgIEXA0AIAVBfGoqAgAiJyADKgIMXA0AIAVBeGoqAgAgAyoCAFwNACABIAY2ApgBIAMqAgghJAJAIAYgASgCnAEiCE8NACAGQQxqICc4AgAgBkEIaiAkOAIAIAkgJjgCACABIAU2ApgBDAILIAYqAgAhKiABQeAAaiAEIAggBiAEa0EEdUEBahDbISABKAKYASABKAKUAWtBBHUgHRDcISEJIAEoAmgiBSAnOAIMIAUgJDgCCCAFICY4AgQgBSAqOAIAIAEgASgCaEEQajYCaCABKAJkIQQgASgClAEhBiABKAKYASEFAkADQCAFIAZGDQEgBEFwaiIEIAVBcGoiBSkCADcCACAEQQhqIAVBCGopAgA3AgAMAAsACyABIAEoApQBIgU2AmQgASAENgKUASABKQOYASE2IAEgASkCaDcDmAEgASA2NwJoIAkgBTYCACAJEN0hGgwBCwJAIAUgASgCnAFGDQAgBSADKQIANwIAIAVBCGogA0EIaikCADcCACABIAVBEGo2ApgBDAELIAFB4ABqIAQgBSAFIARrQQR1QQFqENshIAEoApgBIAEoApQBa0EEdSAdENwhIQkgASgCaCIFIAMpAgA3AgAgBUEIaiADQQhqKQIANwIAIAEgASgCaEEQajYCaCABKAJkIQQgASgClAEhBiABKAKYASEFAkADQCAFIAZGDQEgBEFwaiIEIAVBcGoiBSkCADcCACAEQQhqIAVBCGopAgA3AgAMAAsACyABIAEoApQBIgU2AmQgASAENgKUASABKQOYASE2IAEgASkCaDcDmAEgASA2NwJoIAkgBTYCACAJEN0hGgsgA0EQaiEDDAALAAsDQAJAIAUgBEcNAEEAIQUgAUHgAWogASgCiAEQpCEiCSgCACIEIAEoAuQBIgZBAEE+IAYgBGtBA3VnQQF0ayAGIARGGxClISABQdQBaiABKAKIARCkISIIKAIAIgQgASgC2AEiBkEAQT4gBiAEa0EDdWdBAXRrIAYgBEYbEKohIAFB4ABqQQhqQgA3AwAgAUIANwNgIAFBgICA/AM2AnAgAUEoakEIakIANwMAIAFCADcDKCABQYCAgPwDNgI4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IAEgAygCdGsiAUECdSIEQQFqIgJBgICAgARPDQICQAJAIAFBAXUiBSACIAUgAksbQf////8DIAFB/P///wdJGyIFDQBBACEGDAELIAVBgICAgARPDQQgBUECdBCIASEGCyAGIARBAnRqIgcgADYCACADKAJ0IQQgAygCeCEBIAchAgJAA0AgASAERg0BIAJBfGoiAiABQXxqIgEoAgA2AgAMAAsACyADIAdBBGo2AnggAygCdCEBIAMgAjYCdCADIAYgBUECdGo2AnwgAUUNACABEIYBC0EAIQEgAEGhASAAKAIAKAIMEQIARQ0AAkAgA0GEAWooAgAiASADQYgBaigCACICTw0AIAEgADYCACADIAFBBGo2AoQBQQAPCyABIAMoAoABIgRrQQJ1IgVBAWoiAUGAgICABE8NAQJAAkAgAiAEayICQQF1IgQgASAEIAFLG0H/////AyACQfz///8HSRsiBA0AQQAhBgwBCyAEQYCAgIAETw0DIARBAnQQiAEhBgsgBiAFQQJ0aiIFIAA2AgAgAygCgAEhACADKAKEASEBIAUhAgJAA0AgASAARg0BIAJBfGoiAiABQXxqIgEoAgA2AgAMAAsACyADIAVBBGo2AoQBIAMoAoABIQAgAyACNgKAASADIAYgBEECdGo2AogBQQAhASAARQ0AIAAQhgELIAEPCxAAAAsQjAUAC9QCAQV/IAAgARC7CxpBASECAkACQAJAIAAoAhgiAUUNACABQYYBIAEoAgAoAgwRAgBFDQACQCAAKAIYIgNBrANqKAIAIgEgA0GwA2ooAgBGDQAgASAANgIAIAMgAUEEajYCrANBAA8LIAEgAygCqANrIgFBAnUiBEEBaiICQYCAgIAETw0BAkACQCABQQF1IgUgAiAFIAJLG0H/////AyABQfz///8HSRsiBQ0AQQAhBgwBCyAFQYCAgIAETw0DIAVBAnQQiAEhBgsgBiAEQQJ0aiIEIAA2AgAgAygCqAMhAiADKAKsAyEAIAQhAQJAA0AgACACRg0BIAFBfGoiASAAQXxqIgAoAgA2AgAMAAsACyADIARBBGo2AqwDIAMoAqgDIQAgAyABNgKoAyADIAYgBUECdGo2ArADQQAhAiAARQ0AIAAQhgELIAIPCxAAAAsQjAUACzkBAX8gACgCGCEBAkACQCAAKAKAASAAQYQBaigC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AmQgACoCaBD3GgsTACAAQgA3AgAgAEEIakIANwIAC6IBAQJ/IwBBIGsiASQAAkACQCAAKAKMASICRQ0AIAFBCGogAkHIAGogAEHwAGoQkwUgAEHYAGogAUEYaikCADcCACAAQdAAaiABQRBqKQIANwIAIAAgASkCCDcCSAwBCyAAIAApAnA3AkggAEHYAGogAEGAAWopAgA3AgAgAEHQAGogAEH4AGopAgA3AgALIAAgACgCACgCXBEAACABQSBqJAALBwAgABC/BwsHACAAEL8HCwcAIAAQvwcLAwAAC5gBAgJ/A30jAEEwayICJAAgAkEgaiABKAJAIgMgAygCACgCcBEDACABKgJMIQQgASoCUCEFIAJCgICAgICAgMA/NwIQIAJCgICA/AM3AgggAiAFIAIqAiwgAioCJCIGk5QgBpI4AhwgAiAEIAIqAiggAioCICIFk5QgBZI4AhggACABKAJAQcgAaiACQQhqEJMFIAJBMGokAAsPACAAIAAoAgAoAkgRAAALDwAgACAAKAIAKAJIEQAAC7YFAgN/AX0jAEGwAWsiAiQAAkAgACgCQCIDRQ0AIAMgAygCACgCQBEBAA0AIAJBmAFqIAAgACgCACgCaBEDAAJAIAAoAkRBAUcNACAAKAJAKAIYIgNB2wAgAygCACgCDBECACEEIAJBgAFqQRBqQQApAtixEzcDACACQYABakEIakEAKQLQsRM3AwAgAkEAKQLIsRM3A4ABIANByABqQbCXGyAEGyACQYABahCSBUUNASACQegAaiACQYABaiACQZgBahCTBSACQZgBakEQaiACQegAakEQaikCADcDACACQZgBakEIaiACQegAakEIaikCADcDACACIAIpAmg3A5gBCyABQcgAaiEDAkAgACgCSEEBRw0AIAJBgAFqIAEoAhgiBEHIAGpBsJcbIARB2wAgBCgCACgCDBECABsgAkGYAWoQkwUgAkGYAWpBEGogAkGAAWpBEGopAgA3AwAgAkGYAWpBCGogAkGAAWpBCGopAgA3AwAgAiACKQKAATcDmAELIAIgACoCVDgCUCACIABB2ABqKgIAOAJUIAIgAEHcAGoqAgA4AlggAiAAQeAAaioCADgCXCACIABB5ABqKgIAOAJgIAIgAEHoAGoqAgA4AmQgAiAAKgJsOAI4IAIgAEHwAGoqAgA4Ajwg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QCABIAIoAhhrIgFBAnUiA0EBaiIEQYCAgIAETw0AAkACQCABQQF1IgUgBCAFIARLG0H/////AyABQfz///8HSRsiBg0AQQAhBQwBCyAGEMMVIQULIAUgA0ECdGoiAyAANgIAIAIoAhghBCACKAIcIQEgAyEAAkADQCABIARGDQEgAEF8aiIAIAFBfGoiASgCADYCAAwACwALIAIgA0EEajYCHCACKAIYIQEgAiAANgIYIAIgBSAGQQJ0ajYCIAJAIAFFDQAgARCGAQtBAA8LEAAACwoAIAAQhBUQhgELBQBBrgMLEAAgAUHTfGpB//8DcUECSQs4AQF/QRQQiAEiAUIANwMAIAFBEGpBADYCACABQQhqQgA3AwAgARCeEiIBQQhqIABBCGoQqgUgAQs4AQF/QRQQiAEiAUIANwMAIAFBEGpBADYCACABQQhqQgA3AwAgARCoEiIBQQhqIABBCGoQqgUgAQs4AQF/QRQQiAEiAUIANwMAIAFBEGpBADYCACABQQhqQgA3AwAgARCpEiIBQQhqIABBCGoQqgUgAQsHACAAKAIUCwoAIAAQhBUQhgELBQBB/QMLJAEBf0EBIQICQCABQdN8akECSQ0AIAFB/QNGDQBBACECCyACCzgBAX9BGBCIASIBQgA3AwAgAUEQakIANwMAIAFBCGpCADcDACABEJ8SIgFBCGogAEEIahCqBSABC0wBAX9BHBCIASIBQgA3AwAgAUEYakEANgIAIAFBEGpCADcDACABQQhqQgA3AwAgARCgEiIBIAAoAhg2AhggAUEIaiAAQQhqEKoFIAELLwBBAEIANwKs2htBAEGYyxM2AqDaG0EAQv////8PNwKk2htB8wRBAEGAgBAQNhoLCgBBoNobEJgVGgtMAQF/QRwQiAEiAUIANwMAIAFBGGpBADYCACABQRBqQgA3AwAgAUEIakIANwMAIAEQpBIiASAAKAIYNgIYIAFBCGogAEEIahCqBSABCzgBAX9BFBCIASIBQgA3AwAgAUEQakEANgIAIAFBCGpCADcDACABEKMSIgFBCGogAEEIahCqBSABCzgBAX9BFBCIASIBQgA3AwAgAUEQakEANgIAIAFBCGpCADcDACABEKESIgFBCGogAEEIahCqBSABCzgBAX9BFBCIASIBQgA3AwAgAUEQakEANgIAIAFBCGpCADcDACAB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AhEAACAAKAIQIQELAkAgASgCECICRQ0AAkACQCAAKAIMIgENAEEAIQEMAQsgASgCECEBCyABIAIRAAAgACgCECEBCwJAIAEoAhQiAkUNAAJAAkAgACgCDCIBDQBBACEBDAELIAEoAhQhAQsgASACEQAAIAAoAhAhAQsCQCABKAIYIgJFDQACQAJAIAAoAgwiAQ0AQQAhAQwBCyABKAIYIQELIAEgAhEAACAAKAIQIQELAkAgASgCHCICRQ0AAkACQCAAKAIMIgENAEEAIQEMAQsgASgCHCEBCyABIAIRAAAgACgCECEBCwJAIAEoAiAiAkUNAAJAAkAgACgCDCIBDQBBACEBDAELIAEoAiAhAQsgASACEQAAIAAoAhAhAQsCQCABKAIkIgJFDQACQAJAIAAoAgwiAQ0AQQAhAQwBCyABKAIkIQELIAEgAhEAACAAKAIQIQELAkAgASgCKCICRQ0AAkACQCAAKAIMIgENAEEAIQEMAQsgASgCKCEBCyABIAIRAAAgACgCECEBCwJAIAEoAiwiAkUNAAJAAkAgACgCDCIBDQBBACEBDAELIAEoAiwhAQsgASACEQAAIAAoAhAhAQsCQCABKAIwIgJFDQACQAJAIAAoAgwiAQ0AQQAhAQwBCyABKAIwIQELIAEgAhEAACAAKAIQIQELAkAgASgCNCICRQ0AAkACQCAAKAIMIgENAEEAIQEMAQsgASgCNCEBCyABIAIRAAAgACgCECEBCwJAIAEoAjgiAkUNAAJAAkAgACgCDCIBDQBBACEBDAELIAEoAjghAQsgASACEQAAIAAoAhAhAQsCQCABKAI8IgJFDQACQAJAIAAoAgwiAQ0AQQAhAQwBCyABKAI8IQELIAEgAhEAACAAKAIQIQELAkAgASgCQCICRQ0AAkACQCAAKAIMIgENAEEAIQEMAQsgASgCQCEBCyABIAIRAAAgACgCECEBCyABKAJEIgJFDQACQAJAIAAoAgwiAQ0AQQAhAQwBCyABKAJEIQELIAEgAhEAACAAKAIQIQELIAEQRyAAKAIMEEcgABBHCwttAQJ/AkACQAJAAkACQCABRQ0AIAAoAgwNACAAQQFByAAQSyIDNgIMIANFDQELQQEhAyACRQ0DIAAoAhANA0EBIQMgAEEBQcgAEEsiBDYCECAERQ0BDAMLIAJFDQELIAEgAhEAAAtB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ACAAELElIABBOGoQwyYgAEHsAGoQwiYgAEH4AGoQwSYgACgCMBCXDSAAQQA2AjALKQACQCAAKAIARQ0AIABBABDEJiAAKAIIEEcLIABBADYCCCAAQgA3AgALKQACQCAAKAIARQ0AIABBABDFJiAAKAIIEEcLIABBADYCCCAAQgA3AgALKQACQCAAKAIARQ0AIABBADYCBCAAKAIIEEcLIABBADYCCCAAQgA3AgALSAECfyAAKAIEIgIgAWshAyAAKAIIIAJBHGxqIQICQANAIANFDQEgAkFoahDGJiACQWRqIQIgA0F/aiEDDAALAAsgACABNgIEC0gBAn8gACgCBCICIAFrIQMgACgCCCACQRxsaiECAkADQCADRQ0BIAJBaGoQwyYgAkFkaiECIANBf2ohAwwACwALIAAgATYCBAspAAJAIAAoAgBFDQAgAEEANgIEIAAoAggQRwsgAEEANgIIIABCADcCAAsxACAAELElIABB4ABqEMomIABBxAFqEMkmIABB0AFqEMgmIAAoAjAQlw0gAEEANgIwCykAAkAgACgCAEUNACAAQQAQyyYgACgCCBBHCyAAQQA2AgggAEIANwIACykAAkAgACgCAEUNACAAQQAQzCYgACgCCBBHCyAAQQA2AgggAEIANwIACykAAkAgACgCAEUNACAAQQA2AgQgACgCCBBHCyAAQQA2AgggAEIANwIAC0gBAn8gACgCBCICIAFrIQMgACgCCCACQRhsaiECAkADQCADRQ0BIAJBbGoQxiYgAkFoaiECIANBf2ohAwwACwALIAAgATYCBAtIAQJ/IAAoAgQiAiABayEDIAAoAgggAkEFdGohAgJAA0AgA0UNASACQWRqEMMmIAJBYGohAiADQX9qIQMMAAsACyAAIAE2AgQL5QIBCH9BACECAkAgAEGgkRlGDQACQAJAAkAgAC0AAA4FAAMDAQIDCyAAIAFqQQFqLQAADwsgAEEBaiABEM4mDwtBACECAkACQCAAKAABDQBBoJEZIQNBACEEDAELIABBBWohAyAAKAABIQQLIABBAWohBSAEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZyciIAQX5qIQYgAEF/aiEHA0ACQAJAAkAgAiAGSg0AIAMgAiAGakEBdiIIQQZsaiIJKAAAIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIAFLDQIgCSgABiIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZyciABSw0BIAhBAWohAgwDCwJAIAQNAEGgkRkhCQwBCyAFIAdBBmxqQQRqIQkLIAkvAAQiAEEIdCAAQQh2ckH//wNxIQIMAgsgCEF/aiEGDAALAAsgAgvbAQEIf0EAIQICQAJAIAAvAAANAEGgkRkhA0EAIQQMAQsgAEECaiEDIAAvAAAhBAsgBEEIdCAEQYD+A3FBCHZyQf//A3EiBUF+aiEGAkACQANAIAIgBkoNAQJAIAMgAiAGakEBdiIHQQNsaiIILwAAIglBCHQgCUEIdnJB//8DcSABTQ0AIAdBf2ohBgwBCyAILwADIgJBCHQgAkEIdnJB//8DcSABSw0CIAdBAWohAgwACwALAkAgBEH//wNxDQBBoJEZIQgMAQsgBUEDbCAAakF/aiEICyAILQACC/4CAgZ/AX4gAkGAAWooAgAgA0EcbCIGakGgkRkgAkH8AGooAgAgA0sbKAIUIQcgAigCVCEIQQAhCSAAQQhqIgpBADYCACAAQgA3AwAgAEEAOgAQIABBFGpBAEGMIBA6GiABKQIAIQwgAEIANwOgICAKQQA2AgAgACAMNwMAIABBqCBqIgpBADYCACAAQcQgahDQJhogAEGwImoiC0IANwMAIABCADcDqCIgASkCACEMIABCADcDqCIgAEEANgLAICAAQgA3A7ggIABBATsAtSAgAEGwIGpBADYCACAKQgA3AwAgACAMNwOgICALQgA3AwAgAEGUImogCBDRJiAAQZwiaiAHENEmIABBADsA2SIgAEHUImpBADYCACAAQgA3AswiIAAgBTYCvCIgACAENgK4IiAAIAIoAlgiATYCwCICQCAERQ0AIAVFDQAgAS8AAEEARyEJCyAAIAk6ANgiIAAgAigCgAEgBmpBoJEZIAIoAnwgA0sbKAIYNgLIIiAAC0MBAn8gAEEANgIEIABBADoAACAAQdABaiEBIABBCGohAgNAIAJCADcCACACQQhqQQA2AgAgAkEUaiICIAFHDQALIAALXgEBfyAAIAE2AgRB6wAhAgJAIAFFDQAgASgAACIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZyciIBQdgJSQ0AQesIQYCAAiABQeyIAkkbIQILIAAgAjYCAAspAAJAIAAoAgBFDQAgAEEANgIEIAAoAggQRwsgAEEANgIIIABCADcCAAspAAJAIAAoAghBAWogACgCBEsNACAAENQmDwtBC0EOIABByCBqKAIAGwttAQV/Qf//AyEBAkAgACgCCCICQQFqIgMgACgCBCIESw0AIAAoAgAiBSACai0AACEBIAAgAzYCCCABQQxHDQBB//8DIQEgAkECaiICIARLDQAgBSADai0AACEBIAAgAjYCCCABQYACciEBCyABCysBAX9BASEBAkAgAC0AxCANACAAKAIIIAAoAgRLIAAtABBBAEdyIQELIAELo1UDCn8EfAF+IwBB4ABrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEF/ag4fBRoGCgsMDQ4aAwEaGgIaGhoFBwcICQYPEBESGgQTFAALIABB3n1qDgQUFRYXGAsgARDXJgwgCyABQQE6ALQgIAFBFGpBADYCAAwfCyABIAFBnCJqQQIQ2CYMHgsgASABQZQiakEBENgmDB0LIAFBFGoiAigCACEAIAJBADYCACABIAEoArggIABBAXZqNgK4IAwcCyABQRRqIgIoAgAhACACQQA2AgAgASABKAK8ICAAQQF2ajYCvCAMGwsgARDZJiABKAIIIAEoAsAgaiICIAEoAgRLDRogASACNgIIIAFBFGpBADYCAAwaCyABQbAiaiIAKwMAIQ0gASsDqCIhDiABQRBqIgQQ2iYhBSAEENomKwMAIQ8gBSsDACEQIAJBADoAACAAIA0gEKA5AwAgASAOIA+gOQOoIiABENsmDBkLIAFBsCJqIgArAwAhDSABKwOoIiEOIAFBEGoQ2iYrAwAhDyACQQA6AAAgACANOQMAIAEgDiAPoDkDqCIgARDbJgwYCyABQbAiaiIAKwMAIQ0gASsDqCIhDiABQRBqENomKwMAIQ8gAkEAOgAAIAAgDSAPoDkDACABIA45A6giIAEQ2yYMFwsgAUGoImohBSABQRBqIQZBACEAAkADQCAAQQJqIgcgASgCFCIESw0BIANB0ABqQQhqIAVBCGopAwA3AwAgAyAFKQMANwNQAkACQCAEIABLDQAgBkEBOgAAQQBCADcD4NobQeDaGyEIDAELIAYgAEEDdGpBCGohCAsCQAJAIAQgAEEBciIASw0AIAZBAToAAEEAQgA3A+DaG0QAAAAAAAAAACEODAELIAYgAEEDdGpBCGorAwAhDgsgCCsDACENIAMgAysDWCAOoDkDWCADIA0gAysDUKA5A1AgASACIANB0ABqENwmIAchAAwACwALIAFBADYCFAwWCyABQagiaiEEIAFBEGohB0EAIQACQANAIABBAmoiBiABKAIUIgVLDQEgA0HQAGpBCGogBEEIaikDADcDACADIAQpAwA3A1ACQAJAIAUgAEsNACAHQQE6AABBAEIANwPg2htEAAAAAAAAAAAhDQwBCyAHIABBA3RqQQhqKwMAIQ0LIAMgAysDUCANoDkDUCABIAIgA0HQAGoQ3CYCQAJAIAEoAhQgAEEBciIASw0AIAdBAToAAEEAQgA3A+DaG0QAAAAAAAAAACENDAELIAcgAEEDdGpBCGorAwAhDQsgAyADKwNYIA2gOQNYIAEgAiADQdAAahDcJiAGIQAMAAsACwJAIAAgBU8NACADQdAAakEIaiAEQQhqKQMANwMAIAMgBCkDADcDUCADIAMrA1AgByAAQQN0akEIaisDAKA5A1AgASACIANB0ABqENwmCyABQQA2AhQMFQsgAUGoImohBCABQRBqIQdBACEAAkADQCAAQQJqIgYgASgCFCIFSw0BIANB0ABqQQhqIARBCGopAwA3AwAgAyAEKQMANwNQAkACQCAFIABLDQAgB0EBOgAAQQBCADcD4NobRAAAAAAAAAAAIQ0MAQsgByAAQQN0akEIaisDACENCyADIAMrA1ggDaA5A1ggASACIANB0ABqENwmAkACQCABKAIUIABBAXIiAEsNACAHQQE6AABBAEIANwPg2htEAAAAAAAAAAAhDQwBCyAHIABBA3RqQQhqKwMAIQ0LIAMgAysDUCANoDkDUCABIAIgA0HQAGoQ3CYgBiEADAALAAsCQCAAIAVPDQAgA0HQAGpBCGoiBSAEQQhqKQMANwMAIAMgBCkDADcDUCAFIAUrAwAgByAAQQN0akEIaisDAKA5AwAgASACIANB0ABqENwmCyABQQA2AhQMFAsgAUGoImohCCABQRBqIQVBACEAAkADQCAAQQZqIgkgASgCFCIESw0BIANB0ABqQQhqIgcgCEEIaikDADcDACAD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CGohCAsCQAJAIAUgBEECciILSw0AIABBAToAAEEAQgA3A+DaG0QAAAAAAAAAACEODAELIAAgC0EDdGpBCGorAwAhDgsgCCsDACENIAcgBysDACAOoDkDACADQTBqQQhqIgggBykDADcDACADIA0gAysDQKA5A0AgAyADKQNANwMwAkACQCAFIARBA3IiC0sNACAAQQE6AABBAEIANwPg2htEAAAAAAAAAAAhDQwBCyAAIAtBA3RqQQhqKwMAIQ0LIAggCCsDACANoDkDACABIAIgA0HQAGogA0HAAGogA0EwahDdJiAGIAgpAwA3AwAgAyADKQMwNwNQAkACQCABKAIUIgUgBEEEciILSw0AIABBAToAAEEAQgA3A+DaG0QAAAAAAAAAACENDAELIAAgC0EDdGpBCGorAwAhDQsgBiAGKwMAIA2gOQMAIAcgBikDADcDACADIAMpA1A3A0ACQAJAIAUgBEEFciIGSw0AIABBAToAAEEAQgA3A+DaG0Hg2hshBgwBCyAAIAZBA3RqQQhqIQYLAkACQCAFIARBBnIiC0sNACAAQQE6AABBAEIANwPg2htEAAAAAAAAAAAhDgwBCyAAIAtBA3RqQQhqKwMAIQ4LIAYrAwAhDSAHIAcrAwAgDqA5AwAgCCAHKQMANwMAIAMgDSADKwNAoDkDQCADIAMpA0A3AzACQAJAIAUgBEEHciIHSw0AIABBAToAAEEAQgA3A+DaG0QAAAAAAAAAACENDAELIAAgB0EDdGpBCGorAwAhDQsgAyADKwMwIA2gOQMwAkAgBSAEa0EPSw0AIAVBAXFFDQACQAJAIAUgCUsNACAAQQE6AABBAEIANwPg2htEAAAAAAAAAAAhDQwBCyAAIAlBA3RqQQhqKwMAIQ0LIAMgAysDOCANoDkDOAsgASACIANB0ABqIANBwABqIANBMGoQ3SYgASgCFCEFIAkhBAwACwALAkACQCABQRRqKAIAQQdHDQAgA0HQAGpBCGoiBCABQbAiaikDACIRNwMAIAMgASkDqCI3A1AgAyADKwNQIAFBGGorAwCgOQNQIANBwABqQQhqIgAgETcDACADIAMpA1A3A0AgAUEgaisDACENIAAgACsDACABQShqKwMAoDkDACADIA0gAysDQKA5A0AgA0EwakEIaiAAKQMAIhE3AwAgAyADKQNANwMwIAMgAysDMCABQTBqKwMAoDkDMCADQSBqQQhqIBE3AwAgAyADKQMwNwMgIAMgAysDICABQThqKwMAoDkDICADQRBqQQhqIgAgETcDACADIAMpAyA3AxAgAyADKwMQIAFBwABqKwMAoDkDECAAIAQpAwAiETcDACADQQhqIBE3AwAgAyADKQMQNwMAIAMgAysDACABQcgAaisDAKA5AwAgASACIANB0ABqIANBwABqIANBMGogA0EgaiADQRBqIAMQ3iYMAQsgASABKAIEQQFqNgIICyABQQA2AhQMDAsCQAJAIAFBFGooAgBBDUcNACADQdAAakEIaiIAIAFBsCJqKQMANwMAIAMgASkDqCI3A1AgAUEYaisDACENIAAgACsDACABQSBqKwMAoDkDACADIA0gAysDUKA5A1AgA0HAAGpBCGoiBCAAKQMANwMAIAMgAykDUDcDQCABQShqKwMAIQ0gBCAEKwMAIAFBMGorAwCgOQMAIAMgDSADKwNAoDkDQCADQTBqQQhqIgAgBCkDADcDACADIAMpA0A3AzAgAUE4aisDACENIAAgACsDACABQcAAaisDAKA5AwAgAyANIAMrAzCgOQMwIANBIGpBCGoiBCAAKQMANwMAIAMgAykDMDcDICABQcgAaisDACENIAQgBCsDACABQdAAaisDAKA5AwAgAyANIAMrAyCgOQMgIANBEGpBCGoiACAEKQMANwMAIAMgAykDIDcDECABQdgAaisDACENIAAgACsDACABQeAAaisDAKA5AwAgAyANIAMrAxCgOQMQIANBCGoiBCAAKQMANwMAIAMgAykDEDcDACABQegAaisDACENIAQgBCsDACABQfAAaisDAKA5AwAgAyANIAMrAwCgOQMAIAEgAiADQdAAaiADQcAAaiADQTBqIANBIGogA0EQaiADEN4mDAELIAEgASgCBEEBajYCCAsgAUEANgIUDAsLAkACQCABQRRqKAIAQQlHDQAgA0HQAGpBCGoiACABQbAiaiIFKQMANwMAIAMgASkDqCI3A1AgAUEYaisDACENIAAgACsDACABQSBqKwMAoDkDACADIA0gAysDUKA5A1AgA0HAAGpBCGoiBCAAKQMANwMAIAMgAykDUDcDQCABQShqKwMAIQ0gBCAEKwMAIAFBMGorAwCgOQMAIAMgDSADKwNAoDkDQCADQTBqQQhqIAQpAwAiETcDACADIAMpA0A3AzAgAyADKwMwIAFBOGorAwCgOQMwIANBIGpBCGogETcDACADIAMpAzA3AyAgAyADKwMgIAFBwABqKwMAoDkDICADQRBqQQhqIgAgETcDACADIAMpAyA3AxAgAUHIAGorAwAhDSAAIAArAwAgAUHQAGorAwCgOQMAIAMgDSADKwMQoDkDECADQQhqIgQgACkDADcDACADIAMpAxA3AwAgAyADKwMAIAFB2ABqKwMAoDkDACAEIAUpAwA3AwAgASACIANB0ABqIANBwABqIANBMGogA0EgaiADQRBqIAMQ3iYMAQsgASABKAIEQQFqNgIICyABQQA2AhQMCgsgAUEUaigCAEELRw0CQQAhAEQAAAAAAAAAACENIAFBEGpBCGohBEQAAAAAAAAAACEOA0ACQCAAQQpJDQAgA0HQAGpBCGoiACABQbAiaiIFKQMANwMAIAMgASkDqCI3A1AgAUEYaisDACEPIAAgACsDACABQSBqKwMAoDkDACADIA8gAysDUKA5A1AgA0HAAGpBCGoiBCAAKQMANwMAIAMgAykDUDcDQCABQShqKwMAIQ8gBCAEKwMAIAFBMGorAwCgOQMAIAMgDyADKwNAoDkDQCADQTBqQQhqIgAgBCkDADcDACADIAMpA0A3AzAgAUE4aisDACEPIAAgACsDACABQcAAaisDAKA5AwAgAyAPIAMrAzCgOQMwIANBIGpBCGoiBCAAKQMANwMAIAMgAykDMDcDICABQcgAaisDACEPIAQgBCsDACABQdAAaisDAKA5AwAgAyAPIAMrAyCgOQMgIANBEGpBCGoiACAEKQMANwMAIAMgAykDIDcDECABQdgAaisDACEPIAAgACsDACABQeAAaisDAKA5AwAgAyAPIAMrAxCgOQMQIANBCGogACkDADcDACADIAMpAxA3AwACQAJAIA2ZIA6ZZEUNACADIAMrAwAgAUHoAGorAwCgOQMAIAMgBSkDADcDCAwBCyADIAEpA6giNwMAIAMgAysDCCABQegAaisDAKA5AwgLIAEgAiADQdAAaiADQcAAaiADQTBqIANBIGogA0EQaiADEN4mDAULIA0gBCAAQQN0IgVqKwMAoCENIA4gBCAFQQhyaisDAKAhDiAAQQJqIQAMAAsACyAAQf8BRg0HCyAAIAEQ3yYM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dmoiATYCvCAgACABIAAoArggakEHakEDdjYCwCALCz0BAX8CQCAAKAIEIgFFDQAgACABQX9qIgE2AgQgACABQQN0akEIag8LIABBAToAAEEAQgA3A+DaG0Hg2hsLJAACQCAALQC1IA0AIAAQ2SYgAEEBOgC1IAsgAEEUakEANgIAC0UAAkAgAS0AAA0AIAFBAToAACABIABBqCJqEOomCyAAIAIpAwA3A6giIABBsCJqIAJBCGopAwA3AwAgASAAQagiahDqJgtTAAJAIAEtAAANACABQQE6AAAgASAAQagiahDqJgsgASACEOomIAEgAxDqJiAAQbAiaiAEQQhqKQMANwMAIAAgBCkDADcDqCIgASAAQagiahDqJgscACAAIAEgAiADIAQQ3SYgACABIAUgBiAHEN0mC4MDAQN/AkACQAJAAkAgAEGJfmoOCAEBAQECAgICAAsgAEEcRw0CIAFBEGohAAJAAkAgASgCCCICIAEoAgQiA0kNACABIANBAWo2AghBoJEZIQIMAQsgASgCACACaiECCyAAIAItAABBCHQgAUEBEL8nLQAAckEQdEEQdRDAJyABIAEoAghBAmo2AggPCyAAQQh0IQAgAUEQaiECAkACQCABKAIIIgMgASgCBCIESQ0AIAEgBEEBajYCCEGgkRkhAwwBCyABKAIAIANqIQMLIAIgACADLQAAakHsEmpB//8DcRDAJyABIAEoAghBAWo2AggPCyABQRBqIQIgAEEQdEGAgJR4akEIdiEAAkACQCABKAIIIgMgASgCBCIESQ0AIAEgBEEBajYCCEGgkRkhAwwBCyABKAIAIANqIQMLIAJBlH8gACADLQAAcmsQwCcgASABKAIIQQFqNgIIDwsCQCAAQWBqQdYBSw0AIAFBEGogAEH1fmoQwCcPCyABQRRqQQA2AgALjAEBAn8CQCABKAIIIgJBBGogASgCBCIDSw0AAkACQCACIANJDQAgASADQQFqNgIIQaCRGSECDAELIAEoAgAgAmohAgsgAigAACECIAAQ5yYgAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnK3RAAAAAAAAPA+ojkDACABIAEoAghBBGo2AggLC0MBAX8gAEEQahDiJiEBAkACQCAALQDZIiAALQDaInJFDQAgACAAKAIEQQFqNgIIDAELIAAgATYC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akEIaiIAIAFBsCJqKwMAIgogAUEoaisDAKAiDzkDACADIAsgDSAMoCIMoCILIAFBMGorAwCgOQMwIANBIGpBCGogACkDACITNwMAIAMgAykDMDcDICADIAMrAyAgAUE4aisDAKA5AyAgA0EQakEIaiIAIBM3AwAgAyADKQMgNwMQIAFBwABqKwMAIQ0gACAKOQMAIAMgDSADKwMQoDkDECADQQhqIAApAwA3AwAgAyADKQMQNwMAIAMgAysDACABQcgAaisDAKA5AwAgASACIAwgCiALIA8gA0EwaiADQSBqIANBEGogAxDwJgwBCyABIAEoAgRBAWo2AggLIAFBADYCFAwMCwJAAkAgAUEUaigCAEENRw0AIAFBKGorAwAhCiABQRhqKwMAIQsgASsDqCIhDCABQThqKwMAIQ0gA0EwakEIaiIEIAFBsCJqKwMAIAFBIGorAwCgIg8gAUEwaisDAKAiDiABQcAAaisDAKA5AwAgAyANIAogDCALoCILoCIKoDkDMCADQSBqQQhqIgAgBCkDADcDACADIAMpAzA3AyAgAUHIAGorAwAhDCAAIAArAwAgAUHQAGorAwCgOQMAIAMgDCADKwMgoDkDICADQRBqQQhqIgQgACkDADcDACADIAMpAyA3AxAgAUHYAGorAwAhDCAEIAQrAwAgAUHgAGorAwCgOQMAIAMgDCADKwMQoDkDECADQQhqIgAgBCkDADcDACADIAMpAxA3AwAgAUHoAGorAwAhDCAAIAArAwAgAUHwAGorAwCgOQMAIAMgDCADKwMAoDkDACABIAIgCyAPIAogDiADQTBqIANBIGogA0EQaiADEPAmDAELIAEgASgCBEEBajYCCAsgAUEANgIUDAsLAkACQCABQRRqKAIAQQlHDQAgAUEoaisDACEKIAFBGGorAwAhCyABKwOoIiEMIANBMGpBCGoiACABQbAiaisDACINIAFBIGorAwCgIg8gAUEwaisDAKAiDjkDACADIAogDCALoCILoCIKIAFBOGorAwCgOQMwIANBIGpBCGogACkDACITNwMAIAMgAykDMDcDICADIAMrAyAgAUHAAGorAwCgOQMgIANBEGpBCGoiACATNwMAIAMgAykDIDcDECABQcgAaisDACEMIAAgACsDACABQdAAaisDAKA5AwAgAyAMIAMrAxCgOQMQIANBCGoiBCAAKQMANwMAIAMgAykDEDcDACABQdgAaisDACEMIAQgDTkDACADIAwgAysDAKA5AwAgASACIAsgDyAKIA4gA0EwaiADQSBqIANBEGogAxDwJgwBCyABIAEoAgRBAWo2AggLIAFBADYCFAwKCyABQRRqKAIAQQtHDQJBACEARAAAAAAAAAAAIQogAUEQakEIaiEERAAAAAAAAAAAIQsDQAJAIABBCkkNACABQShqKwMAIQ0gAUEYaisDACEPIAErA6giIQwgAUE4aisDACEOIANBMGpBCGoiBCABQbAiaisDACIQIAFBIGorAwCgIhEgAUEwaisDAKAiEiABQcAAaisDAKA5AwAgAyAOIA0gDCAPoCIPoCINoDkDMCADQSBqQQhqIgAgBCkDADcDACADIAMpAzA3AyAgAUHIAGorAwAhDiAAIAArAwAgAUHQAGorAwCgOQMAIAMgDiADKwMgoDkDICADQRBqQQhqIgQgACkDADcDACADIAMpAyA3AxAgAUHYAGorAwAhDiAEIAQrAwAgAUHgAGorAwCgOQMAIAMgDiADKwMQoDkDECADQQhqIAQpAwA3AwAgAyADKQMQNwMAAkACQCAKmSALmWRFDQAgAUHoAGorAwAhCiADIBA5AwggAyAKIAMrAwCgOQMADAELIAMgDDkDACADIAMrAwggAUHoAGorAwCgOQMICyABIAIgDyARIA0gEiADQTBqIANBIGogA0EQaiADEPAmDAULIAogBCAAQQN0IgVqKwMAoCEKIAsgBCAFQQhyaisDAKAhCyAAQQJqIQAMAAsACyAAQf8BRg0HCyAAIAEQ3yYMBwsgASABKAIEQQFqNgIICyABQQA2AhQMBQsgAUGwImorAwAiCyABQShqKwMAoCINIAFBMGorAwCgIQwgASsDqCIgAUEYaisDAKAiDyABQSBqKwMAoCEKQQQhBAJAA0AgBEEIaiIGIAVLDQEgAigCACACKAIEIgVBwABqKgIAIAVBxABqKgIAIA8gCyAKIA0gCiAMEO8mIAEgDDkDsCIgASAKOQOoIgJAAkAgASgCFCIFIARLDQAgAEEBOgAAQQBCADcD4NobRAAAAAAAAAAAIQsMAQsgACAEQQN0akEIaisDACELCwJAAkAgBSAEQQFyIgdLDQAgAEEBOgAAQQBCADcD4NobQeDaGyEHDAELIAAg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IgogAykDADcDACAEIAQpA4AkNwPwIyABKwNIIRQgCiAKKwMAIAErA1CgOQMAIAQgFCAEKwPwI6A5A/AjIARB4CNqQQhqIgMgCikDADcDACAEIAQpA/AjNwPgIyABKwNYIRQgAyADKwMAIAErA2CgOQMAIAQgFCAEKwPgI6A5A+AjIARB0CNqQQhqIAMpAwA3AwAgBCAEKQPgIzcD0CMCQAJAIBKZIBOZZEUNACAEKwPQIyABKwNooCESIAErA7AiIRMMAQsgBCsD2CMgASsDaKAhEyABKwOoIiESCyAEIBM5A9gjIAQgEjkD0CMgASAEIARBsCNqIARBkCNqIARBgCRqIARB8CNqIARB4CNqIARB0CNqEP4mDAQLIBIgAEEIaiIKIANBA3QiC2orAwCgIRIgEyAKIAtBCHJqKwMAoCETIANBAmohAwwACwALIAsgARDfJgwCCyABIAEoAgRBAWo2AggLIAFBADYCFCABQQA2ArwiCyABEP8mIAlBf2oiCUVyIgMNASABLQC0IEUNAAsgAiAIKQMANwMAIAJBGGogCEEYaikDADcDACACQRBqIAhBEGopAwA3AwAgAkEIaiAIQQhqKQMANwMACyADQQFzIQULIARBkCRqJAAgBQtAAQF/QQAhAgJAIABBoJEZRg0AAkACQCAALQAADgQAAgIBAgsgACABakEBai0AAA8LIABBAWogARDOJiECCyACC7QBAQN/AkAgAS8AACIDQQh0IANBCHZyQf//A3EgAksNACAAQgA3AgAgAEEIakEANgIADwsgASACEL4nIQMCQAJAIAEgAkEBahC+JyICIANJDQAgAiABIAEvAAAiBEEIdCAEQQh2ckH//wNxIgQQvidNDQELIABCADcCACAAQQhqQQA2AgAPCyABLQACIQUgAEEANgIIIAAgAiADazYCBCAAIAFBAmogBSAEQQFqbGogA2o2AgALogICAn8BfiACQdgBaigCACADQRhsakGgkRkgAkHUAWooAgAgA0sbKAIUIQMgAigCSCECIABBCGoiBEEANgIAIABCADcDACAAQQA6ABAgAEEUakEAQYwgEDoaIAEpAgAhBiAAQgA3A6AgIARBADYCACAAIAY3AwAgAEGoIGoiBEEANgIAIABBxCBqENAmGiAAQbAiaiIFQgA3AwAgAEIANwOoIiABKQIAIQYgAEIANwOoIiAAQQA2AsAgIABCADcDuCAgAEEBOwC1ICAAQbAgakEANgIAIARCADcDACAAIAY3A6AgIAVCADcDACAAQZQiaiACEIAnIABBnCJqIAMQgCcgAEEAOgDIIiAAQQA2ArwiIABBADsBuCIgAEIANwPAIiAAC3EBAX8CQCABLQC4Ig0AIABBF0sNAAJAAkACQEEBIAB0IgJBioDxBHENACACQZCAgAJxDQEgAEEVRw0DIAFBFGooAgBBAkshAAwCCyABQRRqLQAAQQFxIQAMAQsgAUEUaigCAEEBSyEACyABIAAQgScLC74DAQZ/QQAhAgJAIAFB/wFLDQAgAUHQ6RNqLQAAIQMCQCAAKAI4IgRBoJEZRg0AIAAoAtwBIQUCQAJAAkAgBC0AAA4DAAECBAsgA0UNAyAEQQFqIQQgBUEBIAVBAUsbIQVBASEBA0AgASAFRg0EAkAgAUEBdCAEakF+ai8AACIAQQh0IABBCHZyQf//A3EgA0cNACABDwsgAUEBaiEBDAALAAtBACECIANFDQJBASEBIARBAWohBkEAIQADQCABIAVPDQMgBiAAQQNsaiIHLQACIQQCQCAHLwAAIgdBCHQgB0EIdnJB//8DcSIHIANLDQAgBCAHaiADSQ0AIAEgA2ogB2sPCyAAQQFqIQAgASAEakEBaiEBDAALAAtBACECIANFDQFBASEBIARBAWohBkEAIQADQCABIAVPDQIgBiAAQQJ0aiIHLwACIgRBCHQgBEEIdnJB//8DcSEEAkAgBy8AACIHQQh0IAdBCHZyQf//A3EiByADSw0AIAQgB2ogA0kNACABIANqIAdrDwsgAEEBaiEAIAEgBGpBAWohAQwACwALQQAgAyAAQbABaigCABtBACABQeUBSRshAgsgAgvqAQIBfwZ8IABBGGohAgJAAkAgACsDECIDIAArAwAiBGRFDQAgAisDACIFIAArAwgiBmQNAQsgACABKQMANwMAIAIgAUEYaikDADcDACAAQRBqIAFBEGopAwA3AwAgAEEIaiABQQhqKQMANwMADwsCQCABKwMQIgcgASsDACIIZEUNACABQRhqKwMAIAErAwhkRQ0AAkAgBCAIZEUNACAAIAg5AwAgASsDECEHCwJAIAcgA2RFDQAgACAHOQMQCwJAIAYgASsDCCIDZEUNACAAIAM5AwgLIAErAxgiAyAFZEUNACAAIAM5AxgLC3UCAn8BfgJAIAAoAgggACgCBCIBTQ0AIAAgAUEBajYCCAsgACAAQcQgahDmJiIBKQIANwKgICAAQbAgaiABQRBqKAIANgIAIABBqCBqIAFBCGoiAikCADcCACABKQIAIQMgAEEIaiACKAIANgIAIAAgAzcCAAvUAgIHfwF+IwBBEGsiAyQAAkACQAJAIABBEGoQ6CYgASgCAGoiBEEASA0AIAEoAgQiBUUNACAEIAUvAAAiBUEIdCAFQQh2ckH//wNxTw0AIABByCBqKAIAIgVBCkkNAQsgACAAKAIEQQFqNgIIDAELIAAgACkDACIKNwOgICAAIAVBAWo2AsggIABBqCBqIgYgAEEIaiIHKAIANgIAIAAgBUEUbGoiBUHcIGogAEGwIGoiCCgCADYCACAFQcwgaiAKNwIAIAVB1CBqIAYpAgA3AgAgAEGgIGohBUIAIQoCQCABKAIEIgFFDQAgBCABLwAAIglBCHQgCUEIdnJB//8DcU8NACADIAEgBBDzJiADKQMAIQoLIAAgCjcDoCAgCCAENgIAIABBrCBqIAI2AgAgBkEANgIAIAcgBUEIaigCADYCACAAIAUpAwA3AwALIANBEGokAAtGAQF/AkAgAC0AtiANACAAQQE6ALYgIAAgACgCvCAgAEEUaigCAEEBdmoiATYCvCAgACABIAAoArggakEHakEDdjYCwCALCywAAkAgAC0AtSANACAAEPomIABBAToAtSALIABBADYCvCIgAEEUakEANgIAC0sAAkAgAS0AAA0AIAFBAToAACABQQhqIABBqCJqEIInCyAAIAIpAwA3A6giIABBsCJqIAJBCGopAwA3AwAgAUEIaiAAQagiahCCJwtbAAJAIAEtAAANACABQQE6AAAgAUEIaiAAQagiahCCJwsgAUEIaiIBIAIQgicgASADEIInIABBsCJqIARBCGopAwA3AwAgACAEKQMANwOoIiABIABBqCJqEIInCxwAIAAgASACIAMgBBD9JiAAIAEgBSAGIAcQ/SYLKwEBf0EBIQECQCAALQDEIA0AIAAoAgggACgCBEsgAC0AEEEAR3IhAQsgAQtNAQF/IAAgATYCBEHrACECAkAgAUUNACABLwAAIgFBCHQgAUEIdnJB//8DcSIBQdgJSQ0AQesIQYCAAiABQeyIAkkb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AoABIBRBHGxqIQgLIAhCADcCACAIQQA2AhggCEGgkRk2AhQgCEEQakEANgIAIAhBCGpCADcCAAJAAkAgBygCfCAUSw0AQQBCADcD8NobQQBCADcD6NobQQBCADcD4NobQQBBADYC+NobQeDaGyENDAELIAcoAoABIBRBHGxqIQ0LIA1CADcCACANQQA2AhggDUGgkRk2AhQgDUEQakEANgIAIA1BCGpCADcCACABKAIEIQggASgCCCEJAkADQCAJQQFqIAhLDQEgARDUJiEIIAFBADoA3EAgAUKAgICA8P8/NwLUQAJAAkACQAJAAkACQAJAIAhBemoOEgQEBAQEBAEBAQEBAQEDAQECBQALIAhB931qIglBCUsNAEEBIAl0QZ8GcQ0DCyAIIAEQrScgASgCFEUNAwwECwJAAkAgAS0ApCBFDQAgASgCoCAhCQwBCyABIAQQ4iYiCTYCoCALIAFBAToApCAgDSAJNgIYDAELIA0gBBDoJjYCEAsgAUEANgIUCyABKAIIIAEoAgRLDQAgAS0AEEH/AXENACANIAggASABQdTAAGoQtScLIAEoAggiCSABKAIEIghLDQUgAS0AEEH/AXENBQwACwALIAxBoJEZIA4bIQgCQAJAIAcoAnwgFEsNAEEAIQlBAEIANwPw2htBAEIANwPo2htBAEIANwPg2htBAEEANgL42hsMAQsgBygCgAEgFEEcbGooAhAhCQsgCCAJIAcQrichCAJAAkAgBygCfCAUSw0AQQBCADcD8NobQQBCADcD6NobQQBCADcD4NobQQBBADYC+NobQeDaGyEJDAELIAcoAoABIBRBHGxqIQkLIAkgCDYCFCAUQQFqIRQMAAsACyAHQQE6ABwMAAsACyAHEMAmCyAAIAAoAgAiCCAHIAgbNgIAIAhFDQEgBxDDJQwACwALIAFB4MAAaiQAIAcLiyYCE38BfiMAQeDAAGsiASQAIABBUGohAiABQbggakEUaiEDIAFBCGpBFGohBCABQbggakEQaiEFAkADQCAAKAIAIgYNAQJAIAIoAgAiBw0AQaCRGSEGDAILAkACQEEBQegBEEsiBg0AQaCRGSEGDAELIAZCADcCACAGQgA3AiAgBkEAOwEsIAZBgIAENgIoIAZBCGpCADcCACAGQRBqQgA3AgAgBkEVakIANwAAIAZB6ABqQQA2AgAg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cWohCyAMQQFqIQwMAAsACwALIAIPC0EADwsgBwv5AQECf0EAIQICQCAAKAIAIgNBAEgNAAJAIAMgAUEAIAFBAEobIgFPDQAgAyECAkADQCACIAFPDQEgAiACQQF2akEIaiECDAALAAsCQAJAIAJB1arVqgFLDQAgACgCCCACQQxsEEgiAw0BIAIgACgCACIDTQ0CCyAAIANBf3M2AgBBAA8LIAAgAjYCACAAIAM2AggLAkACQCABIAAoAgQiAk0NAANAIAIgAU8NAiAAKAIIIAJBDGxqIgJCADcCACACQQhqQQA2AgAgACAAKAIEQQFqIgI2AgQMAAsACyABIAJPDQAgACABEO4nCyAAIAE2AgRBASECCyACC4EBAQN/IAAoAgQiAiABayEDIAAoAgggAkEMbGohBAJAA0AgA0UNAQJAIARBdGoiAigCAEUNACAEQXRqIgRBBGpBADYCACAEQQhqKAIAEEcLIANBf2ohAyACQQRqQQA2AgAgAkEANgIAIAJBCGpBADYCACACIQQMAAsACyAAIAE2AgQL4AEBA38CQCAAKAIEIgIgACgCACIDSA0AAkACQAJAIANBAEgNACADIAJBAWoiAk8NAiADIQQCQANAIAQgAk8NASAEIARBAXZqQQhqIQQMAAsACwJAIARB1arVqgFLDQAgACgCCCAEQQxsEEgiAg0CIAQgACgCACIDTQ0DCyAAIANBf3M2AgALQQBCADcD4NobQQBBADYC6NobDwsgACAENgIAIAAgAjYCCAsgACgCBCECCyAAIAJBAWo2AgQgACgCCCACQQxsaiIAQQhqIAFBCGooAgA2AgAgACABKQIANwIAC3IBBH9BACEEA0AgAEF/aiEFAkADQCAEIABODQECQCABIAQgBWpBAXYiBkEEdGoiBygCACAHQQRqKAIAIAIgAxDxJyIHQQBODQAgBiEADAMLIAdFDQEgBkEBaiEEDAALAAsLIAEgBkEEdGpBACAEIABIGwszAAJAIAIgAEYNAEF/QQEgAiAASBsPC0EAIQACQCADIAFGDQBBf0EBIAMgAUgbIQALIAALywQBCX8jAEEwayIBJAAgAEGMf2ohAiABQQhqIQMgAUEQaiEEIAFBFWohBQJAA0AgACgCACIGDQECQCACKAIAIgYNAEGgkRkhBgwCCyADQgA3AwAgBEIANwMAIAVCADcA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ASABIARBAWo2AiAgAS0AHEUNASAAQQA2AAALQQEhAwsgAwsoAAJAIAAgASgCBGsgASgCDE0gASgCCCAAa0EBS3EiAUEBRw0ACyABCzYBAX9BACECAkAgACABKAIEayABKAIMSw0AIAEoAgggAGtBBkkNACAAQQRqIAEQ+ighAgsgAgs2AQJ/QQAhAgJAIAEoAiAiA0EfSw0AIAEgA0EBajYCICABLQAcRQ0AIABBADsAAEEBIQILIAILpQIBBH8jAEEQayIDJABBACEEAkAgACABKAIEayABKAIMSw0AIAEoAgggAGtBBEkNACAAQQJqIAEQ+ihFDQACQCAALwAAIgVFDQBBACEEQQAhBgJAIAJFDQAgAigCACEGCyADIAY2AgwgACABIAAgA0EMahD7KEUNASACRQ0AIAAvAABB//8DcQ0AIAIoAgBB5fSlmwdHDQAgAigCBCIERQ0AIAQgAE8NACAEIABrIAVBCHQgBUEIdnJB//8DcWoiBEH//wNLDQAgASgCICIFQR9LDQAgASAFQQFqNgIgIAEtABxFDQAgACAEQQh0IARBgP4DcUEIdnI7AAAgAyACKAIANgIIIAAgASAAIANBCGoQ+yghBAwBC0EBIQQLIANBEGokACAEC7kCAQR/QQAhAgJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQBBASECAkACQAJAAkACQCAALwAAIgNBCHQgA0EIdnJB//8DcUF/ag4FAAECAwQFCyAAIAEoAgRrIAEoAgxNIAEoAgggAGtBB0txDwsgACABKAIEayABKAIMTSABKAIIIABrQQdLcQ8LQQAhAiAAQQJqIgMgARD8KEUNAiADLQAAIQRBACEDA0AgAyAERiICDQMgA0EDbCEFIANBAWohAyAAIAVqQQNqIAEgABD9KA0ADAMLAAtBACECIABBAmoiAyABEPwoRQ0BIAMtAAAhBEEAIQMDQCADIARGIgINAiADQQNsIQUgA0EBaiEDIAAgBWpBA2ogASAAEP0oDQAMAgsACyAAQQJqIAEgABD9KCECCyACC04BAX9BACECAkAgACABKAIEayABKAIMSw0AIAEoAgggAGtBAkkNACABIABBAmogAC8AACIAQQh0IABBCHZyQf//A3FBAXQQsyUhAgsgAgv1AwEEfwJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQBBASEEAkAgAC8AACIFRQ0AIAIgBUEIdCAFQQh2ckH//wNxaiEFAkACQCADKAIAIgNB5fSlmwdHDQAgBSABKAIEayABKAIMSw0BIAEoAgggBWtBCkkNASAFLwAAIgZFDQEgBS8ACCEHIAUvAAYhAyAFLwAEIQICQCAFLwACDQAgAkH//wNxDQAgA0H//wNxDQAgB0H//wNxRQ0DCyAGQQh0IAZBCHZyQf//A3EiBSADQQh0IANBgP4DcUEIdnJB//8DcUkNASAFIAdBCHQgB0GA/gNxQQh2ckH//wNxSw0BIAJBCHQgAkGA/gNxQQh2ckEQdEEQdUH/AUwNAQwCCwJAIANBgIB8cSIDQYCA2JsGRg0AIANBgIDMmwdHDQIgBSABKAIEayABKAIMSw0BIAEoAgggBWtBA00NAQwCCyAFIAEoAgQiA2sgASgCDCICSw0AIAEoAggiByAFa0EOSQ0AIAVBDGoiBiADayACSw0AIAcgBmtBAkkNACABIAVBDmogBS8ADCIFQQh0IAVBCHZyQf//A3FBA2wQsyUNAQsgASgCICIFQR9LDQEgASAFQQFqNgIgQQAhBCABLQAcRQ0AIABBADsAAEEBIQQLIAQPC0EACzsBAX9BACECAkAgACABKAIEayABKAIMSw0AIAEoAgggAEYNACABIABBAWogAC0AAEEDbBCzJSECCyACC4wBAQF/AkAgACABKAIEayABKAIMSw0AIAEoAgggAGtBA0kNAEEBIQMCQCAAEP4oDQAgAiAALQABQQh0IAAtAABBEHRyIAAtAAJyaiABEPkoDQAgASgCICIDQR9LDQEgASADQQFqNgIgQQAhAyABLQAcRQ0AIABBADoAAiAAQQA7AABBASEDCyADDwtBAAsaACAALQABQQh0IAAtAABBEHRyIAAtAAJyRQuBAQECfwJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQBBASEDAkAgAC8AACIERQ0AIAIgBEEIdCAEQQh2ckH//wNxaiABEI8pDQAgASgCICIEQR9LDQEgASAEQQFqNgIgQQAhAyABLQAcRQ0AIABBADsAAEEBIQMLIAMPC0EAC8ABAQR/QX8hAQJAAkACQCAALwAAIgJBCHQgAkEIdnJB//8DcUF/ag4CAQACCyAAQQRqIgIgAC8AAiIBQQh0IAFBCHZyQf//A3FBBmxqIQNBACEBA0AgAiADRg0CQQAgAi8AAiIAQQh0IABBCHZyQf//A3EiACACLwAAIgRBCHQgBEEIdnJB//8DcSIEa0EBaiAAIARJGyABaiEBIAJBBmohAgwACwALIAAvAAIiAkEIdCACQQh2ckH//wNxIQELIAELzAEBAX8gAyAAQQh0IABBgP4DcUEIdnIiBEEBcUEBdGogBEECcWogAEEJdkECcWogAEEKdkECcWohAAJAAkAgBEEQcUUNAEEAIQMgACABIAIQlSlFDQEgAEECaiEACwJAIARB//8DcSIEQSBxRQ0AQQAhAyAAIAEgAhCVKUUNASAAQQJqIQALAkAgBEHAAHFFDQBBACEDIAAgASACEJUpRQ0BIABBAmohAAsCQCAEQYABcUUNAEEAIQMgACABIAIQlSlFDQELQQEhAwsgAwtKAQJ/QQEhBgJAIAAvAABBgCBJDQBBACEHA0AgByAERiIGDQEgAC8AACABIAIgAxCBKUUNASAHQQFqIQcgAyAFaiEDDAALAAsgBgv0AQECfwJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQBBASEDAkAgAC8AACIERQ0AAkAgAiAEQQh0IARBCHZyQf//A3FqIgQgASgCBGsgASgCDEsNACABKAIIIARrQQJJDQACQAJAIAQvAAAiAkEIdCACQQh2ckH//wNxQX9qDgIAAQMLIAQgASgCBGsgASgCDEsNASABKAIIIARrQQVNDQEgBEEEaiABELgmDQIMAQsgBEECaiABEJApDQELIAEoAiAiBEEfSw0BIAEgBEEBajYCIEEAIQMgAS0AHEUNACAAQQA7AABBASEDCyADDwtBAAuBAQECfwJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQBBASEDAkAgAC8AACIERQ0AIAIgBEEIdCAEQQh2ckH//wNxaiABEJEpDQAgASgCICIEQR9LDQEgASAEQQFqNgIgQQAhAyABLQAcRQ0AIABBADsAAEEBIQMLIAMPC0EAC/wCAQh/QQAhAwJAIAAgASgCBGsgASgCDEsNACABKAIIIABrQQJJDQACQCAALwAAIgRFDQACQCACIARBCHQgBEEIdnJB//8DcWoiBSABKAIEayABKAIMSw0AIAEoAgggBWtBAkkNACABIAVBAmog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CHQgAkEIdnJB//8DcWohAAsgACADEOsoDwsgASABKAIIIgJBAWo2AgggASgCBCACQRxsaiICQgA3AhAgAkHBBTYCDCACQcIFNgIIIAJBwwU2AgQgAiAANgIAIAJBGGpBADYCACACQRBqIQMCQAJAIAAvAAIiAg0AQaCRGSEADAELIAAgAkEIdCACQQh2ckH//wNxaiEACyAAIAMQ6ygPCyAALwAAQYACRw0HIAEgASgCCCICQQFqNgIIIAEoAgQgAkEcbGoiAkIANwIQIAJBxAU2AgwgAkHFBTYCCCACQcYFNgIEIAIgADYCACACQRhqQQA2AgAgAkEQaiEDAkACQCAALwACIgINAEGgkRkhAAwBCyAAIAJBCHQgAkEIdnJB//8DcWohAAsgACADEOsoDwsgAC8AAEGAAkcNBiABIAEoAggiAkEBajYCCCABKAIEIAJBHGxqIgJCADcCECACQccFNgIMIAJByAU2AgggAkHJBTYCBCACIAA2AgAgAkEYakEANgIAIAJBEGohAwJAAkAgAC8AAiICDQBBoJEZIQAMAQsgACACQQh0IAJBCHZyQf//A3FqIQALIAAgAxDrKA8LIAAvAABBgAJHDQUgASABKAIIIgJBAWo2AgggASgCBCACQRxsaiICQgA3AhAgAkHKBTYCDCACQcsFNgIIIAJBzAU2AgQgAiAANgIAIAJBGGpBADYCACACQRBqIQMCQAJAIAAvAAIiAg0AQaCRGSEADAELIAAgAkEIdCACQQh2ckH//wNxaiEACyAAIAMQ6ygPCyAALwAAQYACRw0EIAEgASgCCCICQQFqNgIIIAEoAgQgAkEcbGoiAkIANwIQIAJBzQU2AgwgAkHOBTYCCCACQc8FNgIEIAIgADYCACACQRhqQQA2AgAgAkEQaiEDAkACQCAALwACIgINAEGgkRkhAAwBCyAAIAJBCHQgAkEIdnJB//8DcWohAAsgACADEOsoDwsgACABEMopDwsgAC8AAEGAAkcNAgJAAkAgACgABCICDQBBoJEZIQMMAQsgACACQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZycmohAwsgAC8AAiIAQQh0IABBCHZyQf//A3EhAiADIQAMAAsACyAAIAEQySkLCwQAQQALCQAgACABELAqCwkAIAAgARCwKgsEAEEACwkAIAAgARCv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ADYCCCAAQgA3AgAL2QEBAn9BACEEAkAgASAAQQYQ9SpFDQAgACADQQh0IANBgP4DcUEIdnI7AAIgACACQQh0IAJBgP4DcUEIdnI7AAAgASAAQQRqIgNBAhD2KkUNACADQYACOwAAIAEgA0EEEPYqRQ0AQQEhBCAALwACIgJBgCBxRQ0AQQAhBCABIAAgAC8ABCIFQQh0IAVBCHZyQf//A3FBAXQgA2ogAkELdkECcWogAGtBAmoQ9SpFDQAgAy8AACIAQQh0IABBCHZyQf//A3FBAXQgA2pBAmpBADsAAEEBIQQLIAQLeAECfwJAAkAgACgCGA0AIAJBAEgNAAJAAkAgASACaiICIAAoAgQiA2siBEEASA0AIAAoAgggA2sgBE4NAQsgAEEENgIYDAELAkAgAiADRg0AIANBACAEEDoaIAAoAgQhAgsgACACIARqNgIEIAINAQtBACEBCyABC3EBAn8CQAJAIAAoAhgNAAJAAkAgASACaiICIAAoAgQiA2siBEEASA0AIAAoAgggA2sgBE4NAQsgAEEENgIYDAELAkAgAiADRg0AIANBACAEEDoaIAAoAgQhAgsgACACIARqNgIEIAINAQtBACEBCyABC1cBAX8CQCAAKAIYDQACQCAAQRxqEPgqIgENACAAKAIYDQEgAEEBNgIYDAELIAEgACgCBDYCACABIAAoAgg2AgQgASAAKAIsNgIgIAAgATYCLAsgACgCBAviAQEDfwJAAkAgACgCACIBDQBBACEBIABBBGoiAiAAQQhqKAIAQQFqEJUrRQ0BQYAJEEYiA0UNAQJAAkACQCAAKAIIIgEgACgCBEgNACACIAFBAWoQlStFDQEgACgCCCEBCyAAIAFBAWo2AgggAEEMaigCACABQQJ0aiADNgIADAELQQBBADYC4NobC0EAIQECQANAIAFBH0YNASADIAFBJGxqIgIgAkEkajYCACABQQFqIQEMAAsACyADQQA2AtwIIAAgAzYCACADIQELIAAgASgCADYCACABQQBBJBA6GgsgAQuzCAEKf0EAIQICQCAAKAIsIgNFDQAgACgCGEEfdyIEQQhLDQBBASAEdEGTAnFFDQAgACADKAIgNgIsIAAoAgQhBUEAIQIgA0EANgIgIAMgBTYCBCADKAIAIQQgACgCECEGIABBADYCECAAIAYgBCAGGzYCBCAF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BgsgBCACQQFqIAdHaiEEIANB4ABqEIYrIAchAgwACwALIAVBgARBgAIgBiAKIARBA2xLckEBcSICGzsAAEEADQACQAJAIAIOAgABAAsgA0HgAGpBGGogA0EIakEYaigCADYCACADQeAAakEQaiADQQhqQRBqKQMAIg83AwAgA0HgAGpBCGogA0EIakEIaikDADcDACADIAMpAwg3A2AgBUECaiIEIAEgAygCZCICIA+nIgcgAiAHSRsiBxCNK0UNAUEAIQIDQCACIAdGDQMgBCACQQF0akECaiADQeAAahCMKy8AADsAACACQQFqIQIgA0HgAGoQhisMAAsACyADQShqQRhqIANBCGpBGGoiAigCADYCACADQShqQRBqIANBCGpBEGoiBykDADcDACADQShqQQhqIANBCGpBCGoiBCkDADcDACADIAMpAwg3AyggASAFEI4rRQ0AIANB4ABqQRhqIAIoAgA2AgAgA0HgAGpBEGogBykDADcDACADQeAAakEIaiAEKQMANwMAIAMgAykDCDcDYCADQcQAaiADQShqEIsrIANBxABqQRBqKAIAIQhBfiEHQQAhAiADKAJQIQkgAygCSCEGIAMoAkQhBANAAkACQAJAIAMoAmAgBEcNACADKAJkIAZGDQELIAMoAmwgCUcNASADKAJwIAhHDQELIAVBAmogASACEI8rRQ0CIAJFDQMgA0HgAGpBGGogA0EIakEYaigCADYCACADQeAAakEQaiADQQhqQRBqKQMANwMAIANB4ABqQQhqIANBCGpBCGopAwA3AwAgAyADKQMINwNgIANBxABqIANBKGoQiysgA0HEAGpBEGooAgAhDUF/IQZBACEHIAMoAlAhCyADKAJIIQogAygCRCEMQX4hBEEAIQ4DQAJAAkACQCADKAJgIAxHDQAgAygCZCAKRg0BCyADKAJsIAtHDQEgAygCcCANRw0BCyAORQ0FIAUvAAIhAiADQQA2AmggAyAFQQRqNgJgIAMgAkEIdCACQQh2ckH//wNxNgJkIANBxABqIANB4ABqEJArDAULAkAgBEEBaiIIIANB4ABqEIwrLwAAIgJBCHQgAkEIdnJB//8DcSIJRg0AAkAgBEF+Rg0AIAggCU0NAEEBIQ4LIAUgBkEBaiIGQQZsaiIEQQhqIAdBCHQgB0GA/gNxQQh2cjsAACAEQQRq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ADYCmDQgAyANNgKUNCADIANBwC9qNgKcNCADIANB0CdqNgKQNCADKALoIw0GIBBBBmoiEiADKALUIyIAayIPQQBIDQUgAygC2CMgAGsgD0gNBQJAAkAgEiAARw0AIAMgEiAPajYC1CMMAQsgAEEAIA8QOhogAyADKALUIyIAIA9qNgLUIyAARQ0HCyADQZmQFDYCyAJBACEAIANBADYCxAIgAyANNgLAAiADQQA2ArgCIAMgDTYCtAIgAyADQcAvajYCvAIgAyADQdAnajYCsAIgEEEEaiATIA0QjStFDQYCQANAIAAgDUYNAQJAIAMoArQCDQBBAEEAOwHg2hsLAkACQCADKALAAg0AQQAhD0EAQQA7AeDaGwwBCyADKAK8Ai8AACEPCyAQIABBAXRqQQZqIA87AAAgAEEBaiEAIANBsAJqEIYrDAALAAsgEEECaiATIANBkDRqEIgrDQQMBgsCQAJAIApBfGoOAwEEAwALIAxBJGpBADYCAAwKC0EAIRVBASEAA0ACQCAAQQFxDQAgA0H0AWogFSADQYwCahCmK0EAIRJBACEUQQAhD0EAIQ4DQAJAIBQgFUcNACAORQ0LQQAhESADQdAnaiADQZADakGwARDtKiIAEJkrIRAgA0GwAmpBCGpBADYCACADQZA0akEIakEANgIAIANBwDNqQQhqQQA2AgAgA0HgNGpBCGpBADYCACADQaQCakEIakEANgIAIANByABqQQhqQQA2AgAgA0E4akEIakEANgIAIAMgFTYCtAIgAyAVNgKUNCADIA42AsQzIAMgDjYC5DQgAyAPNgKoAiADIANB9AFqNgKwAiADIAMpArACNwNIIAMgA0GAAmo2ApA0IAMgAykCkDQ3AzggAyADQZgCajYCwDMgAyADQcAvajYC4DQgAyADQdAjajYCpAIgA0EoakEIakEANgIAIANBGGpBCGpBADYCACADQQhqQQhqQQA2AgAgAyADKQLAMzcDKCADIAMpAuA0NwMYIAMgAykCpAI3AwggECAAQQggA0HIAGogA0E4aiADQShqIANBGGogA0EIahCaKyEPIAAQlisCQCAPRQ0AIAMoAugnDQAgABCXKyERCyAAEJgrGgwMC0EAIRMgAygCjAIhDQNAAkAgE0EDRw0AIBRBAWohFAwCCwJAIAEgE0EGbCIAQcaEFGovAQAgA0GQA2oQpiZFDQAgDUEUbCAAakHChBRqIRFBACEAAkADQCAAQQJGDQEgESAAQQF0ai8BACIQRQ0CIAEgECADQdAnahCzFkUNAiADQdAjaiAPQQF0aiADLwHQJyIQQQh0IBBBCHZyOwAAIABBAWohACAPQQFqIQ8MAAsACyADQcAvaiAOQQJ0akEDNgIAIANBmAJqIA5BAXRqIAMvAZADIgBBCHQgAEEIdnI7AAAgAyASQQFqIhI2AoACIA5BAWohDgsgE0EBaiETDAALAAsACwJAIAFB3/0DIANBkANqEKYmRQ0AIANBADYCgAIgA0EANgKMAiADIAMvAZADIgBBCHQgAEEIdnI7AfQBIBVBAWohFQtBACEADAALAAsgC0EBOgAEIAsgCTYCAAJAIAlFDQAgCyEIDAsLIAsQRwwKC0EAIRVBASEAA0ACQCAAQQFxDQAgA0H0AWogFSADQYwCahCmK0EAIRJBACEUQQAhDkEAIQ0CQANAIBQgFUYNAUEAIRMDQAJAIBNBBUcNACAUQQFqIRQMAgsCQCABIBNBAnQiAEHkhBRqLwEAIANBkANqEKYmRQ0AIA5BAWohESAAQeKEFGovAQAhDyAOIQACQANAIAAgEUYNASAPRQ0CAkAgASAPIANB0CdqELMWDQAgACEODAMLIANBmAJqIABBAXRqIAMvAdAnIhBBCHQgEEEIdnI7AAAgAEEBaiEADAALAAsgA0HAL2ogDUECdGpBAjYCACADQaQCaiANQQF0aiADLwGQAyIAQQh0IABBCHZyOwAAIAMgEkEBaiISNgKAAiANQQFqIQ0gESEOCyATQQFqIRMMAAsACwALIA1FDQdBACERIANB0CdqIANBkANqQdABEO0qIgAQmSshDyADQdAjakEIakEANgIAIANBsAJqQQhqQQA2AgAgA0GQNGpBCGpBADYCACADQcAzakEIakEANgIAIANB4DRqQQhqQQA2AgAgA0HoAWpBCGpBADYCACADQdgBakEIakEANgIAIAMgFTYC1CMgAyAVNgK0AiADIA02ApQ0IAMgDTYCxDMgAyAONgLkNCADIANB9AFqNgLQIyADIAMpAtAjNwPoASADIANBgAJqNgKwAiADIAMpArACNwPYASADIANBpAJqNgKQNCADIANBwC9qNgLAMyADIANBmAJqNgLgNCADQcgBakEIakEANgIAIANBuAFqQQhqQQA2AgAgA0GoAWpBCGpBADYCACADIAMpApA0NwPIASADIAMpAsAzNwO4ASADIAMpAuA0NwOoASAPIABBACADQegBaiADQdgBaiADQcgBaiADQbgBaiADQagBahCaKyEPIAAQlisCQCAPRQ0AIAMoAugnDQAgABCXKyERCyAAEJgrGgwICwJAIAFB0QwgA0GQA2oQpiZFDQAgA0EANgKAAiADQQA2AowCIAMgAy8BkAMiAEEIdCAAQQh2cjsB9AEgFUEBaiEVC0EAIQAMAAsAC0EAIQBBACEWA0ACQCAAQRJHDQAgA0HgNGogFiADQZA0ahCmK0EAIRVBACEOQQAhEgNAAkAgFSAWRw0AIBJFDQhBACERIANBsAJqIANBkANqQcAgEO0qIgAQmSshDyADQaQCakEIakEANgIAIANBmAJqQQhqQQA2AgAgA0GMAmpBCGpBADYCACADQYACakEIakEANgIAIANB9AFqQQhqQQA2AgAgA0GYAWpBCGpBADYCACADQYgBakEIakEANgIAIAMgFjYCqAIgAyAWNgKcAiADIBI2ApACIAMgEjYChAIgAyAONgL4ASADIANB4DRqNgKkAiADIAMpAqQCNwOYASADIANBwDNqNgKYAiADIAMpApgCNwOIASADIANBwC9qNgKMAiADIANB0CdqNgKAAiADIANB0CNqNgL0ASADQfgAakEIakEANgIAIANB6ABqQQhqQQA2AgAgA0HYAGpBCGpBADYCACADIAMpAowCNwN4IAMgAykCgAI3A2ggAyADKQL0ATcDWCAPIABBCCADQZgBaiADQYgBaiADQfgAaiADQegAaiADQdgAahCaKyEPIAAQlisCQCAPRQ0AIAMoAsgCDQAgABCXKyERCyAAEJgrGgwJCyADQcAzaiAVQQJ0IgBqIRQgA0GQNGogAGooAgAhDUEAIRMDQAJAIBNBDkcNACAVQQFqIRUMAgsCQCABIA1BOmwgE0ECdGoiAEGkkRRqLwEAIANBkANqEKYmRQ0AIABBopEUai8BACEPIA5BAWohESAOIQACQANAIAAgEUYNASAPRQ0CAkAgASAPIANBsAJqELMWDQAgACEODAMLIANB0CNqIABBAXRqIAMvAbACIhBBCHQgEEEIdnI7AQAgAEEBaiEADAALAAsgA0HQJ2ogEkECdGpBAjYC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ABDbKyAAKAIMRQ0BIAAoAggtABJBBkYNAAsLIAALQgECfyAAQSBqIQECQANAIAAQ6CshAiAAKAIMRQ0BIAAoAhwgASgCACACKAIAIAAoAghBEmotAAAQ5ytFDQALCyACCxwAIAAgAUEwEDsiACABLQAwOgAwIAAgAhDxKxoLlgEBAn8gAS0AMCECAkAgAC0AMEUNACACQf8BcUEARw8LQQAhAwJAIAJB/wFxDQAgACgCACECAkAgAEEUaigCAA0AQQBCADcD6NobQQBCADcD4NobQQBBADYC8NobCyABKAIAIQACQCABQRRqKAIADQBBAEIANwPo2htBAEIANwPg2htBAEEANgLw2hsLIAIgAEYhAwsgAwuXAQECfyAAIAEtADA6ADAgACgCACECAkAgAEEUaigCAA0AQQBCADcD6NobQQBCADcD4NobQQBBADYC8NobCyABKAIAIQMCQCABQRRqKAIADQBBAEIANwPo2htBAEIANwPg2htBAEEANgLw2hsLAkAgAiADTw0AIAAgAyACaxDxKxoPCwJAIAIgA00NACAAIAIgA2sQ7isaCwsrACAAIAFBMBA7IAEtADA6ADAgASABKAIAIAEoAgRrNgIAIAFBCGoQ8isaC1kBAX8gASECAkADQCACRQ0BIAAgACgCACAAKAIEazYCACACQX9qIQIMAAsACyAAQQhqIQICQANAIAAoAhRFDQEgAUUNASACEPIrGiABQX9qIQEMAAsACyAAC1oBAn8gACACQQFqIgMgACADSxshBCABQQNqIQMgASACQRRsakEPai0AAEH/AXEhAQNAAkAgAkEBaiICIABJDQAgBA8LIAEgAyACQRRsakEMai0AAEYNAAsgAgszAQF/AkACQCABQf8BcSIBQQxGDQAgAUE1Rg0AQQAhAiABQSxHDQELIABBIHFFIQILIAILWQEBfyABIQICQANAIAJFDQEgACAAKAIAIAAoAgRqNgIAIAJBf2ohAgwACwALIABBCGohAgJAA0AgACgCFEUNASABRQ0BIAIQ6SsaIAFBf2ohAQwACwALIAALoQEBBn8gAEEMaigCACEBIABBEGooAgAhAiAAKAIAIQMgACgCBCEEIABBIGohBQNAIAAgAyAEayIDNgIAAkACQCACDQBBACECDAELIAAgAkF/aiICNgIQIAAgAUEBaiIBNgIMIAAg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A0AgAiAETA0BAkAgACgCGCIFIAAoAhwiBkkNACAAIAEsAAAQ6y0gACgCACgCNBECAEF/Rg0CIARBAWohBCABQQFqIQEMAQsgAyAGIAVrNgIMIAMgAiAEazYCCCAFIAEgA0EMaiADQQhqEOUtKAIAIgYQ5i0aIAAgBiAAKAIYajYCGCAGIARqIQQgASAGaiEBDAALAAsgA0EQaiQAIAQLBABBfwsUACABIAAgASgCACAAKAIAEMAtGwsPACAAIAAgAWogAhDxLRoLKwEBfyMAQRBrIgMkACADQQhqIAAgASACEPItIAMoAgwhAiADQRBqJAAgAgsNACAAIAEgAiADEPMtCw0AIAAgASACIAMQ9C0LWwEBfyMAQSBrIgQkACAEQRhqIAEgAhD1LSAEQRBqIAQoAhggBCgCHCADEPYtIAEgBCgCEBD3LSEBIAQgAyAEKAIUEPgtNgIMIAAgASAEQQxqEPktIARBIGokAAsLACAAIAEgAhD6LQsNACAAIAEgAiADEPstCwkAIAAgARD8LQsJACAAIAEQ/S0LDAAgACABIAIQ/i0aCygBAX8jAEEQayIDJAAgAyACNgIMIAAgASADQQxqEIMuGiADQRBqJAALNQECfyMAQRBrIgQkACAEIAMgASACIAFrIgUQciAFajYCDCAAIAIgBEEMahCBLiAEQRBqJAALCQAgACABEP8tCwQAIAELFQAgACABNgIAIAAgAigCADYCBCAACwkAIAAgARCALgsEACABCwwAIAAgASACEIIuGgsVACAAIAE2AgAgACACKAIANgIEIAALFQAgACABNgIAIAAgAigCADYCBCAACxgBAX8gABC1NigCACIBNgIAIAEQvTQgAAsNACAAQQhqEPMFGiAACwoAIAAQhS4QhgELEwAgACAAKAIAQXRqKAIAahCFLgsTACAAIAAoAgBBdGooAgBqEIYuCwcAIAAQii4LBQAgAEULfQECfyMAQRBrIgEkAAJAIAAgACgCAEF0aigCAGpBGGooAgBFDQACQCABQQhqIAAQtQUiAi0AABCMLkUNACAAIAAoAgBBdGooAgBqQRhqKAIAEI0uQX9HDQAgACAAKAIAQXRqKAIAakEBEI4uCyACELkFGgsgAUEQaiQAIAALCwAgAEH/AXFBAEcLDwAgACAAKAIAKAIYEQEACwkAIAAgARC4BQsJACAAIAEQkC4LEAAgABCRLiABEJEuc0EBcwsuAQF/AkAgACgCACIBRQ0AAkAgARCSLhCTLg0AIAAoAgBFDwsgAEEANgIAC0EBCywBAX8CQCAAKAIMIgEgACgCEEcNACAAIAAoAgAoAiQRAQAPCyABLAAAEOstCwcAIABBf0YLKwEBf0EAIQMCQCACQQBIDQAgACACQf8BcUECdGooAgAgAXFBAEchAwsgAwsNACAAEJIuQRh0QRh1Cw0AIAAoAgAQly4aIAALNgEBfwJAIAAoAgwiASAAKAIQRw0AIAAgACgCACgCKBEBAA8LIAAgAUEBajYCDCABLAAAEOstCz8BAX8CQCAAKAIYIgIgACgCHEcNACAAIAEQ6y0gACgCACgCNBECAA8LIAAgAkEBajYCGCACIAE6AAAgARDrLQsLACAAQeTpGxD5BQsdACAAIAEgASgCAEF0aigCAGpBGGooAgA2AgAgAAsFACAARQsXACAAIAEgAiADIAQgACgCACgCEBEIAAsnAQF/AkAgACgCACICRQ0AIAIgARCYLhCTLkUNACAAQQA2AgALIAALDQAgASACIAAQny4gAAsRACAAIAAgAUECdGogAhCgLgsiAQF/IwBBEGsiAyQAIANBCGogACABIAIQoS4gA0EQaiQACw0AIAAgASACIAMQoi4LDQAgACABIAIgAxCjLgtbAQF/IwBBIGsiBCQAIARBGGogASACEKQuIARBEGogBCgCGCAEKAIcIAMQpS4gASAEKAIQEKYuIQEgBCADIAQoAhQQpy42AgwgACABIARBDGoQqC4gBEEgaiQACwsAIAAgASACEKkuCw0AIAAgASACIAMQqi4LCQAgACABEKsuCwkAIAAgARCsLgsMACAAIAEgAhCtLhoLKAEBfyMAQRBrIgMkACADIAI2AgwgACABIANBDGoQsi4aIANBEGokAAs1AQJ/IwBBEGsiBCQAIAQgAyABIAIgAWsiBRByIAVqNgIMIAAgAiAEQQxqELAuIARBEGokAAsJACAAIAEQri4LBAAgAQsVACAAIAE2AgAgACACKAIANgIEIAALCQAgACABEK8uCwQAIAELDAAgACABIAIQsS4aCxUAIAAgATYCACAAIAIoAgA2AgQgAAsVACAAIAE2AgAgACACKAIANgIEIAALCwAgAEGI6xsQ+QULCQAgACABELUuCxAAIAAQti4gARC2LnNBAXMLLgEBfwJAIAAoAgAiAUUNAAJAIAEQty4QuC4NACAAKAIARQ8LIABBADYCAAtBAQspAQF/AkAgACgCDCIBIAAoAhBHDQAgACAAKAIAKAIkEQEADwsgASgCAAsHACAAQX9GCxMAIAAgASACIAAoAgAoAgwRBAALBwAgABC3LgsNACAAKAIAELwuGiAACzMBAX8CQCAAKAIMIgEgACgCEEcNACAAIAAoAgAoAigRAQAPCyAAIAFBBGo2AgwgASgCAAs5AQF/AkAgACgCGCICIAAoAhxHDQAgACABIAAoAgAoAjQRAgAPCyAAIAJBBGo2AhggAiABNgIAIAELJwEBfwJAIAAoAgAiAkUNACACIAEQvS4QuC5FDQAgAEEANgIACyAACxMAIAAgASACIAAoAgAoAjARBAALCQAgABDBLiAACxMAIABCADcCACAAQQhqQQA2AgALBwAgABDDLgsSACAAKAIAIAAgAC0ACxDELhsLCwAgAEGAAXFBB3YLCwAgACABENsHIAALFwAgACADNgIQIAAgAjYCDCAAIAE2AggLFwAgACACNgIcIAAgATYCFCAAIAE2AhgLDwAgACAAKAIYIAFqNgIYCw0AIAAgASACEMsuIAALCQAgABDBLiAAC6UBAQN/IwBBEGsiAyQAAkAgASACEMwuIgRB8P///wdPDQACQAJAIAQQzS5FDQAgACAEEM4uDAELIANBCGogBBDPLkEBahDQLiAAIAMoAggiBRDRLiAAIAMoAgwQ0i4gACAEENMuIAUhAAsCQANAIAEgAkYNASAAIAEtAAAQ1C4gAEEBaiEAIAFBAWohAQwACwALIABBABDULiADQRBqJAAPCxDVLgALCQAgACABENYuCwcAIABBC0kLCQAgACABOgALCy0BAX9BCiEBAkAgAEELSQ0AIABBAWoQ2C4iACAAQX9qIgAgAEELRhshAQsgAQsZAQF/IAEQ2S4hAiAAIAE2AgQgACACNgIACwkAIAAgATYCAAsQACAAIAFBgICAgHhyNgIICwkAIAAgATYCBAsJACAAIAE6AAALBgAQ1y4ACwcAIAEgAGsLBQAQAAALCgAgAEEPakFwcQsHACAAENouCwcAIAAQ2y4LBwAgABCIAQsVAAJAIAEQxC4NACABEN0uIQALIAALCAAgAEH/AHELCQAgACABEN8uCy4BAX8CQCABIAAoAgQgAC0ACxDcLiICTQ0AIAAgASACaxDENhoPCyAAIAEQ4C4LDwAgACAAEMMuIAEQ4S4aCxUAIAAgAhDiLiABIAJqQQAQ1C4gAAsfAAJAIAAtAAsQxC5FDQAgACABENMuDwsgACABEM4uCyUBAX9BCiEBAkAgAC0ACxDELkUNACAAKAIIEOQuQX9qIQELIAELCwAgAEH/////B3ELKQEBfyMAQRBrIgMkACADIAI6AA8gACABIANBD2oQ5i4gA0EQaiQAIAALCwAgACABIAIQ5y4LKAACQANAIAFFDQEgACACLQAAOgAAIAFBf2ohASAAQQFqIQAMAAsACwsJACAAIAEQ6S4LFAAgASAAIAAoAgAgASgCABDBLRsLBwAgABDrLgsHACAAEOwuCwcAIAAQ7S4LBwAgABDuLgsHACAAEIYBCw8AIAAgACgCGCABajYCGAt0AQN/AkAgACgCLCIBIAAoAhgiAk8NACAAIAI2AiwgAiEBC0F/IQICQCAALQAwQQhxRQ0AAkAgACgCECIDIAFPDQAgACAAKAIIIAAoAgwgARDGLiAAKAIQIQMLIAAoAgwiACADTw0AIAAsAAAQ6y0hAgsgAguhAQEFfwJAIAAoAiwiAiAAKAIYIgNPDQAgACADNgIsIAMhAgtBfyEDAkAgACgCCCIEIAAoAgwiBU8NAAJAIAEQky5FDQAgACAEIAVBf2ogAhDGLiABEPIuDwsgARDoLSEGAkAgACgCMEEQcQ0AQX8hAyAGQf8BcSAFQX9qLQAARw0BCyAAIAQgBUF/aiACEMYuIAAoAgwgBjoAACABIQMLIAMLDABBACAAIAAQky4bC5MCAQd/IwBBEGsiAiQAAkACQCABEJMuDQAgACgCCCEDIAAoAgwhBAJAIAAoAhgiBSAAKAIcRw0AQX8hBiAALQAwQRBxRQ0CIAAoAiwhByAAKAIUIQggAEEgaiIGQQAQ9C4gBiAGEOMuEN4uIAAgBhDCLiIGIAYgAEEkaigCACAALQArENwuahDHLiAAIAUgCGsQyC4gACAAKAIUIAcgCGtqNgIsIAAoAhghBQsgAiAFQQFqNgIMIAAgAkEMaiAAQSxqEPUuKAIAIgY2AiwCQCAALQAwQQhxRQ0AIAAgAEEgahDCLiIFIAUgBCADa2ogBhDGLgsgACABEOgtEJguIQYMAQsgARDyLiEGCyACQRBqJAAgBguRAQECfwJAAkACQAJAAkAgAC0ACyICEMQuRQ0AIAAoAgQiAiAAKAIIEOQuQX9qIgNGDQEMAgtBCiEDIAIQ3S4iAkEKRw0CCyAAIANBASADIAMQ5jIgAyECCyAAKAIAIQMgACACQQFqENMuDAELIAAgAkEBahDOLiAAIQMLIAMgAmoiACABENQuIABBAWpBABDULgsJACAAIAEQ9i4LFAAgASAAIAAoAgAgASgCABD3LhsLBwAgACABSQurAgIDfwN+AkAgASgCLCIFIAEoAhgiBk8NACABIAY2AiwgBiEFC0J/IQgCQCAEQRhxIgdFDQACQCADQQFHDQAgB0EYRg0BC0IAIQlCACEKAkAgBUUNACAFIAFBIGoQwi5rrCEKCwJAAkACQCADDgMCAAEDCwJAIARBCHFFDQAgASgCDCABKAIIa6whCQwCCyAGIAEoAhRrrCEJDAELIAohCQsgCSACfCICQgBTDQAgCiACUw0AIARBCHEhAwJAIAJQDQACQCADRQ0AIAEoAgxFDQILIARBEHFFDQAgBkUNAQsCQCADRQ0AIAEgASgCCCIGIAYgAqdqIAUQxi4LAkAgBEEQcUUNACABIAEoAhQgASgCHBDHLiABIAKnEO8uCyACIQgLIAAgCBDgLRoLCQAgACABEPouCxQAIAEgACABKAIAIAAoAgAQwS0bCwUAEAAACwoAIAAQ8gUQhgELGgAgACABIAIpAwhBACADIAEoAgAoAhARMQALCgAgABCzBRCGAQsKACAAQXhqELMFCwoAIABBeGoQ/i4LEwAgACAAKAIAQXRqKAIAahCzBQsTACAAIAAoAgBBdGooAgBqEP4uCwcAIAAQhC8LEgAgACgCACAAIAAtAAsQxC4bCxEAIAAgASAAKAIAKAIcEQIACxEAIAAgASAAKAIAKAIsEQIACwcAIAAQgy8LQAECfyAAKAIoIQEDQAJAIAENAA8LQQAgACAAKAIkIAFBf2oiAUECdCICaigCACAAKAIgIAJqKAIAEQUADAALAAsQACAAIAE2AgAgARC9NCAACwoAIAAQ2y0QhgELBQAQAAALBwAgABCNLwsGACAAEEILCwAgACABNgIAIAALCwAgAEGff2pBGkkLEAAgAEHfAHEgACAAEI8vGwsLACAAQb9/akEaSQsPACAAQSByIAAgABCRLxsLFwAgAEEgckGff2pBBkkgABCILUEAR3ILBwAgABCTLwtBAQJ/IwBBEGsiASQAQX8hAgJAIAAQ5ywNACAAIAFBD2pBASAAKAIgEQQAQQFHDQAgAS0ADyECCyABQRBqJAAgAgtHAQJ/IAAgATcDcCAAIAAoAiwgACgCBCICa6w3A3ggACgCCCEDAkAgAVANACADIAJrrCABVw0AIAIgAadqIQMLIAAgAzYCaAvdAQIDfwJ+IAApA3ggACgCBCIBIAAoAiwiAmusfCEEAkACQAJAIAApA3AiBVANACAEIAVZDQELIAAQlS8iAkF/Sg0BIAAoAgQhASAAKAIsIQILIABCfzcDcCAAIAE2AmggACAEIAIgAWusfDcDeEF/DwsgBEIBfCEEIAAoAgQhASAAKAIIIQMCQCAAKQNwIgVCAFENACAFIAR9IgUgAyABa6xZDQAgASAFp2ohAwsgACADNgJoIAAgBCAAKAIsIgMgAWusfDcDeAJAIAEgA0sNACABQX9qIAI6AAALIAIL2wIBBH8gA0HM6BsgAxsiBCgCACEDAkACQAJAAkAgAQ0AIAMNAUEADwtBfiEFIAJFDQECQAJAIANFDQAgAiEFDAELAkAgAS0AACIFQRh0QRh1IgNBAEgNAAJAIABFDQAgACAFNgIACyADQQBHDwsCQEEAKAKo4BsoAgANAEEBIQUgAEUNAyAAIANB/78DcTYCAEEBDwsgBUG+fmoiA0EySw0BIANBAnRBwNQaaigCACEDIAJBf2oiBUUNAyABQQFqIQELIAEtAAAiBkEDdiIHQXBqIANBGnUgB2pyQQdLDQADQCAFQX9qIQUCQCAGQf8BcUGAf2ogA0EGdHIiA0EASA0AIARBADYCAAJAIABFDQAgACADNgIACyACIAVrDwsgBUUNAyABQQFqIgEtAAAiBkHAAXFBgAFGDQALCyAEQQA2AgAQN0EZNgIAQX8hBQsgBQ8LIAQgAzYCAEF+CxIAAkAgAA0AQQEPCyAAKAIARQvwCgIGfwR+IwBBEGsiAiQAAkACQCABQQFHDQAQN0EcNgIAQgAhCAwBCwNAAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwsgAxCALQ0AC0EAIQQCQAJAIANBVWoOAwABAAELQX9BACADQS1GGyEEAkAgACgCBCIDIAAoAmhGDQAgACADQQFqNgIEIAMtAAAhAwwBCyAAEJcvIQMLAkACQAJAAkACQCABQQBHIAFBEEdxDQAgA0EwRw0AAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwsCQCADQV9xQdgARw0AAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwtBECEBIANB0bgaai0AAEEQSQ0DQgAhCAJAIAApA3BCAFMNACAAIAAoAgRBf2o2AgQLIABCABCWLwwGCyABDQFBCCEBDAILIAFBCiABGyIBIANB0bgaai0AAEsNAEIAIQgCQCAAKQNwQgBTDQAgACAAKAIEQX9qNgIECyAAQgAQli8QN0EcNgIADAQLIAFBCkcNAEIAIQgCQCADQVBqIgVBCUsNAEEAIQEDQAJAAkAgACgCBCIDIAAoAmhGDQAgACADQQFqNgIEIAMtAAAhAwwBCyAAEJcvIQMLIAFBCmwgBWohAQJAIANBUGoiBUEJSw0AIAFBmbPmzAFJDQELCyABrSEICwJAIAVBCUsNACAIQgp+IQkgBa0hCgNAAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwsgCSAKfCEIIANBUGoiBUEJSw0BIAhCmrPmzJmz5swZWg0BIAhCCn4iCSAFrSIKQn+FWA0AC0EKIQEMAgtBCiEBIAVBCU0NAQwCCwJAIAEgAUF/anFFDQBCACEIAkAgASADQdG4GmotAAAiBk0NAEEAIQUDQAJAAkAgACgCBCIDIAAoAmhGDQAgACADQQFqNgIEIAMtAAAhAwwBCyAAEJcvIQMLIAYgBSABbGohBQJAIAEgA0HRuBpqLQAAIgZNDQAgBUHH4/E4SQ0BCwsgBa0hCAsgASAGTQ0BIAGtIQkDQCAIIAl+IgogBq1C/wGDIgtCf4VWDQICQAJAIAAoAgQiAyAAKAJoRg0AIAAgA0EBajYCBCADLQAAIQMMAQsgABCXLyEDCyAKIAt8IQggASADQdG4GmotAAAiBk0NAiACIAlCACAIQgAQUiACKQMIQgBSDQIMAAsACyABQRdsQQV2QQdxQdG6GmosAAAhB0IAIQgCQCABIANB0bgaai0AACIFTQ0AQQAhBgNAAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwsgBSAGIAd0ciEGAkAgASADQdG4GmotAAAiBU0NACAGQYCAgMAASQ0BCwsgBq0hCAsgASAFTQ0AQn8gB60iCogiCyAIVA0AA0AgBa1C/wGDIQkCQAJAIAAoAgQiAyAAKAJoRg0AIAAgA0EBajYCBCADLQAAIQMMAQsgABCXLyEDCyAIIAqGIAmEIQggASADQdG4GmotAAAiBU0NASAIIAtYDQALCyABIANB0bgaai0AAE0NAANAAkACQCAAKAIEIgMgACgCaEYNACAAIANBAWo2AgQgAy0AACEDDAELIAAQly8hAwsgASADQdG4GmotAABLDQALEDdBxAA2AgBCfyEIQQAhBAsCQCAAKQNwQgBTDQAgACAAKAIEQX9qNgIECyAIIASsIgmFIAl9IQgLIAJBEGokACAICzUAIAAgATcDACAAIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGIAJC////////P4OENwMIC+ICAQF/IwBB0ABrIgQkAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AEFEgBEEgakEIaikDACECIAQpAyAhAQJAIANB//8BTw0AIANBgYB/aiEDDAILIARBEGogASACQgBCgICAgICAgP//ABBRIANB/f8CIANB/f8CSBtBgoB+aiEDIARBEGpBCGopAwAhAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEHAAGogASACQgBCgICAgICAgDkQUSAEQcAAakEIaikDACECIAQpA0AhAQJAIANB9IB+TQ0AIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQUSADQeiBfSADQeiBfUobQZr+AWohAyAEQTBqQQhqKQMAIQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQUSAAIARBCGopAwA3AwggACAEKQMANwMAIARB0ABqJAALHAAgACACQv///////////wCDNwMIIAAgATcDAAuECQIFfwN+IwBBMGsiBCQAQgAhCQJAAkAgAkECSw0AIAJBAnQiAkGcuxpqKAIAIQUgAkGQuxpqKAIAIQYDQAJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAIt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CiEJIAINAAwCCwALIAohCAsCQCAARQ0AIAEgCDYCAAsgBUGQCGokACAJCxEAQQRBAUEAKAKo4BsoAgAbCxQAQQAgACABIAJBwOkbIAIbEJgvCzUCAX8BfSMAQRBrIgIkACACIAAgAUEAELUvIAIpAwAgAkEIaikDABCCASEDIAJBEGokACADC4YBAgF/An4jAEGgAWsiBCQAIAQgATYCPCAEIAE2AhQgBEF/NgIYIARBEGpCABCWLyAEIARBEGogA0EBEJ4vIARBCGopAwAhBSAEKQMAIQYCQCACRQ0AIAIgASAEKAIUIAQoAogBaiAEKAI8a2o2AgALIAAgBTcDCCAAIAY3AwAgBEGgAWokAAs0AgF/AXwjAEEQayICJAAgAiAAIAFBARC1LyACKQMAIAJBCGopAwAQfSEDIAJBEGokACADCzwCAX8BfiMAQRBrIgMkACADIAEgAkECELUvIAMpAwAhBCAAIANBCGopAwA3AwggACAENwMAIANBEGokAAsJACAAIAEQtC8LCQAgACABELYvCzoCAX8BfiMAQRBrIgMkACADIAEgAhC3LyADKQMAIQQgACADQQhqKQMANwMIIAAgBDcDACADQRBqJAALBAAgAAsEACAACwcAIAAQhgELYQEEfyABIAQgA2tqIQUCQAJAA0AgAyAERg0BQX8hBiABIAJGDQIgASwAACIHIAMsAAAiCEgNAgJAIAggB04NAEEBDwsgA0EBaiEDIAFBAWohAQwACwALIAUgAkchBgsgBgsMACAAIAIgAxDALxoLDQAgACABIAIQwS8gAAulAQEDfyMAQRBrIgMkAAJAIAEgAhDCLyIEQfD///8HTw0AAkACQCAEEM0uRQ0AIAAgBBDOLgwBCyADQQhqIAQQzy5BAWoQ0C4gACADKAIIIgUQ0S4gACADKAIMENIuIAAgBBDTLiAFIQALAkADQCABIAJGDQEgACABLQAAENQuIABBAWohACABQQFqIQEMAAsACyAAQQAQ1C4gA0EQaiQADwsQ1S4ACwkAIAAgARDDLwsHACABIABrC0IBAn9BACEDA38CQCABIAJHDQAgAw8LIANBBHQgASwAAGoiA0GAgICAf3EiBEEYdiAEciADcyEDIAFBAWohAQwACwsEACAACwcAIAAQhgELVwEDfwJAAkADQCADIARGDQFBfyEFIAEgAkYN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AEEIRw0BQRAPC0EADwtBCgtAAQF/IwBBEGsiAyQAIANBDGogARD2BSACIAMoAgwQ2i8iARCIMDoAACAAIAEQiTAgA0EMahD4BRogA0EQaiQACwoAIAAQwy4gAWoL0wIBA38CQAJAIAMoAgAiCyACRw0AQSshDAJAIAotABggAEH/AXEiDUYNAEEtIQwgCi0AGSANRw0BCyADIAJBAWo2AgAgAiAMOgAADAELAkACQCAGIAcQ3C5FDQAgACAFRw0AQQAhByAJKAIAIgogCGtBnwFKDQEgBCgCACECIAkgCkEEajYCACAKIAI2AgAMAgtBfyEHIAogCkEaaiAAEIowIAprIgpBF0oNAAJAAkACQCABQXhqDgMAAgABCyAKIAFIDQEMAgsgAUEQRw0AIApBFkgNACALIAJGDQEgCyACa0ECSg0BQX8hByALQX9qLQAAQTBHDQEgBEEANgIAIAMgC0EBajYCACALIApBkNYaai0AADoAAEEADwsgAyALQQFqNgIAIAsgCkGQ1hpqLQAAOgAAIAQgBCgCAEEBajYCAEEAIQcLIAcPCyAEQQA2AgBBAAv2AQIDfwF+IwBBEGsiBCQAAkACQAJAAkAgACABRg0AEDciBSgCACEGIAVBADYCABCLMBogACAEQQxqIAMQjDAhBwJAAkACQCAFKAIAIgBFDQAgBCgCDCABRw0BIABBxABHDQIgAkEENgIAQf////8HIQAgB0IAVQ0GDAULIAUgBjYCACAEKAIMIAFGDQELIAJBBDYCAAwCCwJAIAdC/////3dVDQAgAkEENgIADAMLAkAgB0KAgICACFMNACACQQQ2AgBB/////wchAAwECyAHpyEADAMLIAJBBDYCAAtBACEADAELQYCAgIB4IQALIARBEGokACAAC7cBAQN/IAAoAgQgAC0ACxDcLiEEAkAgAiABa0EFSA0AIARFDQAgASACEI0wIAJBfGohBSAAEIMvIgIgACgCBCAALQALENwuaiEGAkACQANAIAIsAAAiBEGBf2ohACABIAVPDQECQCAAQf8BcUGCAUkNACABKAIAIARHDQMLIAFBBGohASACIAYgAmtBAUpqIQIMAAsACyAAQf8BcUGCAUkNASAFKAIAQX9qIARJDQELIANBBDYCAAsLDwAgACAAKAIAKAIQEQEACxEAIAAgASABKAIAKAIUEQMA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AXEbQX8gCEH/////B0kbIgcQSCIIRQ0AAkAgBg0AIAAQ2zIaCyADQcUENgIEIAAgA0EIaiAIIANBBGoQtDIiCBDcMiEAIAgQvzIaIAEgACgCACAEIAVrajYCACACIAAoAgAgB0F8cWo2AgAgA0EQaiQADwsQ5C8ACwsAIABBABDdMiAACxkAIAAgARDhMiIBQQRqIAIoAgAQji8aIAELCwAgAEGc6hsQ+QULEQAgACABIAEoAgAoAiwRAwALEQAgACABIAEoAgAoAiARAwALEQAgACABIAEoAgAoAhwRAwALDwAgACAAKAIAKAIMEQEACw8AIAAgACgCACgCEBEBAAsRACAAIAEgASgCACgCFBEDAAsRACAAIAEgASgCACgCGBEDAAsPACAAIAAoAgAoAiQRAQALCwAgAEGU6hsQ+QULEQAgACABIAEoAgAoAiwRAwALEQAgACABIAEoAgAoAiARAwALEQAgACABIAEoAgAoAhwRAwALDwAgACAAKAIAKAIMEQEACw8AIAAgACgCACgCEBEBAAsRACAAIAEgASgCACgCFBEDAAsRACAAIAEgASgCACgCGBEDAAsPACAAIAAoAgAoAiQRAQALEgAgACACNgIEIAAgAToAACAACwcAIAAgAUYLLAEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEOAyKAIAIQAgAkEQaiQAIAALaQEBfyMAQRBrIgMkACADIAI2AgggAyAANgIMAkADQCAAIAEQ6jAiAkUNASAALQAAIAMoAggtAAAQ3zJFDQEgA0EMahDrMCEAIANBCGoQ6zAaIAAoAgAhAAwACwALIANBEGokACACQQFzCwcAIAAQhzELFAEBfyAAKAIAIQEgAEEANgIAIAELIgAgACABENgyEIMxIAEQ1zIhASAAEIcxIAEoAgA2AgAgAAsHACAAEN4yCxQBAX8gACgCACEBIABBADYCACABCyIAIAAgARDbMhDdMiABENoyIQEgABDeMiABKAIANgIAIAALJwEBfyAAKAIAIQIgACABNgIAAkAgAkUNACACIAAQ3jIoAgARAAALCwcAIABBBGoLDwAgAEH/AXEgAUH/AXFGCxEAIAAgACgCACABajYCACAACwsAIAAgATYCACAAC7kCAQJ/IwBBkAFrIgckACAHIAI2AogBIAcgATYCjAEgB0HrBTYCFCAH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C5QBAQJ/AkACQAJAAkACQCAALQALIgIQwDBFDQAgACgCBCICIAAoAggQwTBBf2oiA0YNAQwCC0EBIQMgAhDGMCICQQFHDQILIAAgA0EBIAMgAxCYMyADIQILIAAoAgAhAyAAIAJBAWoQ0i8MAQsgACACQQFqEM0vIAAhAwsgAyACQQJ0aiIAIAEQ0y8gAEEEakEAENMvCwcAIAAQkTELCwAgACABNgIAIAALDAAgACABEIkzQQFzCxEAIAAgACgCAEEEajYCACAACwoAIAAgAWtBAnULDAAgAEEAIAFrEIozCwsAIAAgASACEIszC70BAQZ/IwBBEGsiAyQAIAEoAgAhBAJAQQAgACgCACIFIAAQjDMoAgBB6wVGIgYbQQQgAigCACIHIAVrIghBAXQgByAFRkEBcRtBfyAIQf////8HSRsiBxBIIghFDQACQCAGDQAgABCNMxoLIANBxQQ2AgQgACADQQhqIAggA0EEahCrMSIIEI4zIQAgCBCuMRogASAAKAIAIAQgBWtqNgIAIAIgACgCACAHQXxxajYCACADQRBqJAAPCxDkLwALCwAgAEGs6hsQ+QULEQAgACABIAEoAgAoAiwRAwALEQAgACABIAEoAgAoAiARAwALCwAgACABEJEzIAALEQAgACABIAEoAgAoAhwRAwALDwAgACAAKAIAKAIMEQEACw8AIAAgACgCACgCEBEBAAsRACAAIAEgASgCACgCFBEDAAsRACAAIAEgASgCACgCGBEDAAsPACAAIAAoAgAoAiQRAQALCwAgAEGk6hsQ+QULEQAgACABIAEoAgAoAiwRAwALEQAgACABIAEoAgAoAiARAwALEQAgACABIAEoAgAoAhwRAwALDwAgACAAKAIAKAIMEQEACw8AIAAgACgCACgCEBEBAAsRACAAIAEgASgCACgCFBEDAAsRACAAIAEgASgCACgCGBEDAAsPACAAIAAoAgAoAiQRAQALEgAgACACNgIEIAAgATYCACAACwcAIAAgAUYLLAEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEJAzKAIAIQAgAkEQaiQAIAALaQEBfyMAQRBrIgMkACADIAI2AgggAyAANgIMAkADQCAAIAEQjzEiAkUNASAAKAIAIAMoAggoAgAQjzNFDQEgA0EMahCQMSEAIANBCGoQkDEaIAAoAgAh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AQwACwALIAILEwAgASACIAFBgAFJG0EYdEEYdQs5AQF/AkADQCABIAJGDQEgBCABKAIAIgUgAyAFQYABSRs6AAAgBEEBaiEEIAFBBGohAQwACwALIAILCgAgABChNhCGAQstAQF/IABBnNgaNgIAAkAgACgCCCIBRQ0AIAAtAAxB/wFxRQ0AIAEQuBYLIAALJwACQCABQQBIDQAgAUH/AXFBAnRBwMwaaigCACEBCyABQRh0QRh1C0IBAX8CQANAIAEgAkYNAQJAIAEsAAAiA0EASA0AIANBAnRBwMwaaigCACEDCyABIAM6AAAgAUEBaiEBDAALAAsgAgsnAAJAIAFBAEgNACABQf8BcUECdEHAwBpqKAIAIQELIAFBGHRBGHULQgEBfwJAA0AgASACRg0BAkAgASwAACIDQQBIDQAgA0ECdEHAwBpqKAIAIQMLIAEgAzoAACABQQFqIQEMAAsACyACCwQAIAELLAACQANAIAEgAkYNASADIAEtAAA6AAAgA0EBaiEDIAFBAWohAQwACwALIAILDAAgAiABIAFBAEgbCzgBAX8CQANAIAEgAkYNASAEIAMgASwAACIFIAVBAEgbOgAAIARBAWohBCABQQFqIQEMAAsACyACCwcAIAAQqzYLCwAgAEEAOgB4IAALCgAgABCtNhCGAQtlAQN/IABBiNgaNgIAIABBCGohAUEAIQICQANAIAIgACgCCCIDIAAoAgwQ8S9PDQECQCADIAIQwDQoAgAiA0UNACADEP4vCyACQQFqIQIMAAsACyAAQZgBahCFBRogARCuNhogAAsjAQF/IwBBEGsiASQAIAFBDGogABCaNBCvNiABQRBqJAAgAAswAQF/AkAgACgCACIBKAIARQ0AIAEQnTQgACgCACIAEMo0IAAoAgAgABDSNBDmNAsLBwAgABCGAQsyAAJAQQAtAPTqG0UNAEEAKALw6hsPCxCyNkEAQQE6APTqG0EAQezqGzYC8OobQezqGwsQABCzNkEAQdj3GzYC7OobCwwAQdj3G0EBENgzGgsQAEH46hsQsTYoAgAQiS8aCzIAAkBBAC0AgOsbRQ0AQQAoAvzqGw8LELQ2QQBBAToAgOsbQQBB+OobNgL86htB+OobCyMAIAAgASkCADcCACAAQQhqIAFBCGooAgA2AgAgARDBLiAACwYAELg2AAsFABAA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YW5pbWF0aW9uQnlJbmRleAB2aWV3TW9kZWxCeUluZGV4AHN0YXRlTWFjaGluZUJ5SW5kZXgAc3RhdGVDaGFuZ2VkTmFtZUJ5SW5kZXgAaW5zdGFuY2VCeUluZGV4AGFydGJvYXJkQnlJbmRleAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AC10dwBkcmF3AHVsYXcAYWxhdwBOb3YAd2F2AFRodQB0ZXh0AHNvd3QAaW5wdXQAU01JSW5wdXQAbGF5b3V0AGJ1dHQAQXVndXN0AGxpc3QAdW5zaWduZWQgc2hvcnQAaW52ZXJ0AHdvcmtTdGFydAAtaGJvdABwcm9wZXJ0eUNvdW50AGlucHV0Q291bnQAZXZlbnRDb3VudAByZXBvcnRlZEV2ZW50Q291bnQAdGV4dFZhbHVlUnVuQ291bnQAYW5pbWF0aW9uQ291bnQAdmlld01vZGVsQ291bnQAc3RhdGVNYWNoaW5lQ291bnQAaW5zdGFuY2VDb3VudABhcnRib2FyZENvdW50AHN0YXRlQ2hhbmdlZENvdW50AHNldEZvbnQAaXNGb250AGRlY29kZUZvbnQAMzItYml0IElFRUUgRmxvYXRpbmcgUG9pbnQAbWFrZVJlbmRlclBhaW50AHVuc2lnbmVkIGludABfcGFyZW50AHRyYW5zZm9ybUNvbXBvbmVudABUcmFuc2Zvcm1Db21wb25lbnQAY29tcHV0ZUFsaWdubWVudABpbXBsZW1lbnQAbGluZWFyR3JhZGllbnQAY2xlYXJHcmFkaWVudAByYWRpYWxHcmFkaWVudABqeS1oYW50AHB4LWhhbnQAdXUtaGFudABzcC1oYW50AG5wLWhhbnQAem8taGFudABkby1oYW50AHNuLWhhbnQAbW4taGFudABhbi1oYW50AGFrLWhhbnQAemgtaGFudABleGl0AEZpdABoZWlnaHQAZHJhd0hlaWdodABmaXRIZWlnaHQAY2VudGVyUmlnaHQAdG9wUmlnaHQAYm90dG9tUmlnaHQAc29mdExpZ2h0AGhhcmRMaWdodABjZW50ZXJMZWZ0AHRvcExlZnQAYm90dG9tTGVmdABwdHJUb0ZvbnRBc3NldABwdHJUb0F1ZGlvQXNzZXQAcHRyVG9GaWxlQXNzZXQAcHRyVG9JbWFnZUFzc2V0AHJlc2V0AHRhcmdldABfX2Rlc3RydWN0AGFkZFJlY3QAZmFjdABPY3QAZmxvYXQAU2F0AHVpbnQ2NF90AHJlcG9ydGVkRXZlbnRBdABsb2FkQ29udGVudHMAdGhpY2tuZXNzAGhhc0xpc3RlbmVycwBmcHMAanktaGFucwBweC1oYW5zAHV1LWhhbnMAc3AtaGFucwBucC1oYW5zAHpvLWhhbnMAZG8taGFucwBzbi1oYW5zAG1uLWhhbnMAYW4taGFucwBhay1oYW5zAHpoLWhhbnMAdWUtaGFucwB2YWx1ZXMAZ2V0SW5zdGFuY2VOYW1lcwBwcm9wZXJ0aWVzAGdldFByb3BlcnRpZXMAY2xlYXJDaGFuZ2VzAGJvdW5kcwBBcHIAY29sb3IAVmlld01vZGVsSW5zdGFuY2VDb2xvcgBEeW5hbWljUmVjdGFuaXplcgBjb3ZlcgBzcmNPdmVyAGNlbnRlcgB0b3BDZW50ZXIAYm90dG9tQ2VudGVyAG1pdGVyAFJlbmRlcmVyAEZvbnRXcmFwcGVyAFJlbmRlclBhaW50V3JhcHBlcgBSZW5kZXJlcldyYXBwZXIARmlsZUFzc2V0TG9hZGVyV3JhcHBlcgBBdWRpb1dyYXBwZXIAUmVuZGVyUGF0aFdyYXBwZXIAUmVuZGVySW1hZ2VXcmFwcGVyAHRyaWdnZXIAYXNUcmlnZ2VyAFZpZXdNb2RlbEluc3RhbmNlVHJpZ2dlcgBTTUlUcmlnZ2VyADgtYml0IFVuc2lnbmVkIEludGVnZXIAMTYtYml0IFNpZ25lZCBJbnRlZ2VyADMyLWJpdCBTaWduZWQgSW50ZWdlcgBGaWxlQXNzZXRMb2FkZXIAc2hhZGVyAFJlbmRlclNoYWRlcgBPY3RvYmVyAG51bWJlcgBhc051bWJlcgBWaWV3TW9kZWxJbnN0YW5jZU51bWJlcgBTTUlOdW1iZXIATm92ZW1iZXIAU2VwdGVtYmVyAERlY2VtYmVyAHVuc2lnbmVkIGNoYXIATWFyAF90b3AAYWRkU3RvcABkaWRMb29wAFNlcABjYXAAU3Ryb2tlQ2FwAHBvaW50ZXJVcAAlSTolTTolUyAlcABub25aZXJvAGp5LWhhbnQtbW8AcHgtaGFudC1tbwB1dS1oYW50LW1vAHNwLWhhbnQtbW8AbnAtaGFudC1tbwB6by1oYW50LW1vAGRvLWhhbnQtbW8Ac24taGFudC1tbwBtbi1oYW50LW1vAGFuLWhhbnQtbW8AYWstaGFudC1tbwB6aC1oYW50LW1vAC1uYXZham8AaXNBdWRpbwBoYXNBdWRpbwBQdWxzZUF1ZGlvAGRlY29kZUF1ZGlvAEFBdWRpbwBDb3JlIEF1ZGlvAFdlYiBBdWRpbwBzbmRpbwBtb3ZlVG8AbGluZVRvAGN1YmljVG8Aby1ueW4AdW5rbm93bgBVbmtub3duAHBvaW50ZXJEb3duAHNjYWxlRG93bgBTdW4AdGV4dFJ1bgBUZXh0VmFsdWVSdW4ASnVuAC1zeXJuAGNvbG9yQnVybgAtcG9seXRvbgBub3RpZnlPbkRlc3RydWN0aW9uAHJvdGF0aW9uAHNhdHVyYXRpb24AZHVyYXRpb24ATGluZWFyQW5pbWF0aW9uAGV4Y2x1c2lvbgBmaWxlRXh0ZW5zaW9uAE1vbgBqb2luAFN0cm9rZUpvaW4AaC1taW4AZnJhbWVPcmlnaW4AY29udGFpbgBhbGlnbgBsaWdodGVuAGRhcmtlbgBzY3JlZW4AU3BhbgBoLW1pbi1uYW4AYm9vbGVhbgBWaWV3TW9kZWxJbnN0YW5jZUJvb2xlYW4AcnQtbG9qYmFuAEphbgBlbnVtAFZpZXdNb2RlbEluc3RhbmNlRW51bQB0cmFuc2Zvcm0Ad29ybGRUcmFuc2Zvcm0AcGFyZW50V29ybGRUcmFuc2Zvcm0AQ3VzdG9tAEp1bAB1cmwAY2RuQmFzZVVybABib29sAGFzQm9vbABTTUlCb29sAE51bGwAZmlsbABBcHJpbABiZXZlbAB2aWV3TW9kZWwAZGVmYXVsdEFydGJvYXJkVmlld01vZGVsAGVtc2NyaXB0ZW46OnZhbAAtZ2VvawBvLWJvawBfYmxhbmsAanktaGFudC1oawBweC1oYW50LWhrAHV1LWhhbnQtaGsAc3AtaGFudC1oawBucC1oYW50LWhrAHpvLWhhbnQtaGsAZG8taGFudC1oawBzbi1oYW50LWhrAG1uLWhhbnQtaGsAYW4taGFudC1oawBhay1oYW50LWhrAHpoLWhhbnQtaGsAUGxheWJhY2sALWhhawAtc3lyagBGcmkAbGVuZ3RoAGJ5dGVMZW5ndGgAd2lkdGgAZHJhd1dpZHRoAGZpdFdpZHRoAHRleHRCeVBhdGgAaW5wdXRCeVBhdGgAX2RyYXdQYXRoAG1ha2VSZW5kZXJQYXRoAF9jbGlwUGF0aABhZGRQYXRoAC10aABwdXNoAE1pc3NpbmcgbWVzaABfZHJhd0ltYWdlTWVzaABNYXJjaAAuLi8uLi8uLi8uLi9zcmMvc2tpYV9pbXBvcnRzL2luY2x1ZGUvcHJpdmF0ZS9Ta1REQXJyYXkuaABBdWcAYS1sYXRnAHBuZwB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBWaWV3TW9kZWxJbnN0YW5jZVN0cmluZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwB0dGYAaW5mAF9zZWxmAHJpZmYAdW5yZWYAJS4wTGYAJUxmACVmAHNpemUAcmVzZXRBcnRib2FyZFNpemUAcG9pbnRlck1vdmUAc2F2ZQB0cnVlAHZhbHVlAGxvb3BWYWx1ZQBWaWV3TW9kZWxJbnN0YW5jZVZhbHVlAGh1ZQBUdWUAY2xvc2UAZmFsc2UAY2xvY2t3aXNlAEFydGJvYXJkQmFzZQAtc3lyZQBDYXB0dXJlAHJlc3RvcmUAZmlyZQBzcXVhcmUAdHlwZQBlbnVtVHlwZQBKdW5lAG5vbmUAYm9uZQByb290Qm9uZQBSb290Qm9uZQBTdGF0ZU1hY2hpbmUAdm9sdW1lAHRpbWUAdW5pcXVlRmlsZW5hbWUAYW5pbWF0aW9uQnlOYW1lAHZpZXdNb2RlbEJ5TmFtZQBzdGF0ZU1hY2hpbmVCeU5hbWUAaW5zdGFuY2VCeU5hbWUAYXJ0Ym9hcmRCeU5hbWUAc3R5bGUAUmVuZGVyUGFpbnRTdHlsZQBmaWxsUnVsZQBGaWxsUnVsZQBGaWxlAGRvdWJsZQB1bmlzY3JpYmUtYnVnLWNvbXBhdGlibGUAc3Ryb2tlAGNvbG9yRG9kZ2UAaXNJbWFnZQBzZXRSZW5kZXJJbWFnZQBtYWtlUmVuZGVySW1hZ2UAX2RyYXdSaXZlSW1hZ2UAZGVjb2RlSW1hZ2UAbm9kZQBkZWNvZGUATm9kZQBibGVuZE1vZGUAQmxlbmRNb2RlAHNldEF1ZGlvU291cmNlAGRpZmZlcmVuY2UAYWR2YW5jZQBpbnN0YW5jZQBkZWZhdWx0SW5zdGFuY2UATGluZWFyQW5pbWF0aW9uSW5zdGFuY2UAc2V0RGF0YUNvbnRleHRGcm9tSW5zdGFuY2UAVmlld01vZGVsSW5zdGFuY2UAZGVsZXRlSW5zdGFuY2UAU3RhdGVNYWNoaW5lSW5zdGFuY2UARGVmYXVsdCBQbGF5YmFjayBEZXZpY2UARGVmYXVsdCBDYXB0dXJlIERldmljZQBkZWZhdWx0QXJ0Ym9hcmQAcm91bmQARGlyZWN0U291bmQAcmV3aW5kAGV4dGVuZAB3b3JrRW5kAC1tZABodHRwczovL3B1YmxpYy5yaXZlLmFwcC9jZG4vdXVpZABjZG5VdWlkAHZvaWQASW52YWxpZABhdmFpbGFibGVIZWlnaHQgaXMgaW5kZWZpbml0ZSBzbyBoZWlnaHRNZWFzdXJlTW9kZSBtdXN0IGJlIFlHTWVhc3VyZU1vZGVVbmRlZmluZWQAYXZhaWxhYmxlV2lkdGggaXMgaW5kZWZpbml0ZSBzbyB3aWR0aE1lYXN1cmVNb2RlIG11c3QgYmUgWUdNZWFzdXJlTW9kZVVuZGVmaW5lZABoYXNDaGFuZ2VkAHNwZWVkAFdlZABldmVuT2RkAGxvYWQALWhic2MALXByb3ZlbmMARGVjAHJiAGFyZ2IARmViAHJ3YQBkYXRhAC1mb25pcGEALWZvbm5hcGEAYWxwaGEAZW5hYmxlV29ya0FyZWEALWFyZXZtZGEAbWF4WQBtaW5ZAHNjYWxlWQBtYXBYWQAlYSAlYiAlZCAlSDolTTolUyAlWQBtYXhYAG1pblgAc2NhbGVYAFBPU0lYAFJJRlgAVUxBVwBBTEFXAEhCX1NIQVBFUl9MSVNUAENIQU5ORUxfVE9QX0ZST05UX1JJR0hUAENIQU5ORUxfRlJPTlRfUklHSFQAQ0hBTk5FTF9UT1BfQkFDS19SSUdIVABDSEFOTkVMX0JBQ0tfUklHSFQAQ0hBTk5FTF9TSURFX1JJR0hUAENIQU5ORUxfVE9QX0ZST05UX0xFRlQAQ0hBTk5FTF9GUk9OVF9MRUZUAENIQU5ORUxfVE9QX0JBQ0tfTEVGVABDSEFOTkVMX0JBQ0tfTEVGVABDSEFOTkVMX1NJREVfTEVGVABPU1MASEJfT1BUSU9OUwBPcGVuU0x8RVMAWUVTACVIOiVNOiVTAENIQU5ORUxfVE9QX0ZST05UX0NFTlRFUgBDSEFOTkVMX0ZST05UX0NFTlRFUgBDSEFOTkVMX0ZST05UX1JJR0hUX0NFTlRFUgBDSEFOTkVMX1RPUF9DRU5URVIAQ0hBTk5FTF9UT1BfQkFDS19DRU5URVIAQ0hBTk5FTF9CQUNLX0NFTlRFUgBDSEFOTkVMX01PTk8ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBVTktOT1dOAE5BTgBGT1JNAFBNAFdpbk1NAENPTU0AQU0ATENfQUxMAEpBQ0sAV0FTQVBJAExBTkcASU5GAFJJRkYAQUlGRgBSSVZFAFdBVkUAQ0hBTk5FTF9OT05FAExFAENIQU5ORUxfTEZFAFNTTkQATWF0MkQAVmVjMkQAQUlGQwBBQUJCAEFMU0EAMDEyMzQ1Njc4OS5FRT8tPwBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBDSEFOTkVMX0FVWF85ADAxMjM0NTY3ODkAQ0hBTk5FTF9BVVhfMjkAQ0hBTk5FTF9BVVhfMTkAQ0hBTk5FTF9BVVhfOABDSEFOTkVMX0FVWF8yOABDSEFOTkVMX0FVWF8xOABDLlVURi04AENIQU5ORUxfQVVYXzcAQ0hBTk5FTF9BVVhfMjcAQ0hBTk5FTF9BVVhfMTcAQ0hBTk5FTF9BVVhfNgBDSEFOTkVMX0FVWF8yNgBDSEFOTkVMX0FVWF8xNgBDSEFOTkVMX0FVWF81AENIQU5ORUxfQVVYXzI1AENIQU5ORUxfQVVYXzE1AENIQU5ORUxfQVVYXzQAZHM2NABmbDY0AEZMNjQAUkY2NABDSEFOTkVMX0FVWF8yNABDSEFOTkVMX0FVWF8xNABDSEFOTkVMX0FVWF8zAENIQU5ORUxfQVVYXzIzAENIQU5ORUxfQVVYXzEzAENIQU5ORUxfQVVYXzIAZmwzMgBGTDMyAENIQU5ORUxfQVVYXzIyAENIQU5ORUxfQVVYXzEyAENIQU5ORUxfQVVYXzEAQ0hBTk5FTF9BVVhfMzEAQ0hBTk5FTF9BVVhfMjEAQ0hBTk5FTF9BVVhfMTEAQ0hBTk5FTF9BVVhfMABDSEFOTkVMX0FVWF8zMABDSEFOTkVMX0FVWF8yMABDSEFOTkVMX0FVWF8xMAAvAEZhaWxlZCB0byBjb21taXQgY2FwdHVyZSBQQ00gZnJhbWVzIHRvIHJpbmcgYnVmZmVyLgBDYW5ub3Qgc2V0IG1lYXN1cmUgZnVuY3Rpb246IE5vZGVzIHdpdGggbWVhc3VyZSBmdW5jdGlvbnMgY2Fubm90IGhhdmUgY2hpbGRyZW4uAC4uLgBqeS0AcHgtAG53LQB1dS0Ac3AtAG5wLQB6by0AZG8tAHNuLQBtbi0AYW4tAGFrLQB6aC0AU2tURml0c0luPGludD4oY291bnQpAChudWxsKQBTa1RGaXRzSW48aW50PihyZXNlcnZlKQAyNC1iaXQgU2lnbmVkIEludGVnZXIgKFRpZ2h0bHkgUGFja2VkKQBhdWRpbyg0KQByYXcgAGZtdCAAQ0hBTk5FTF9GUk9OVF9MRUZUX0NFTlRFUiAAICAgICAgQ2hhbm5lbCBNYXAgT3V0OiAgICAgICAgeyVzfQoAICAgICAgQ2hhbm5lbCBNYXAgSW46ICAgICAgICAgeyVzfQoAICAgIEZvcm1hdDogICAgICAlcyAtPiAlcwoAICAgICAgUG9zdCBGb3JtYXQgQ29udmVyc2lvbjogJXMKACAgRW5kaWFuOiAlcwoAICAgICAgUHJlIEZvcm1hdCBDb252ZXJzaW9uOiAgJXMKACAgTkVPTjogICAlcwoAICBBVlgyOiAgICVzCgAgIFNTRTI6ICAgJXMKACAgICAgIENoYW5uZWwgUm91dGluZzogICAgICAgICVzCgAgICAgICBQYXNzdGhyb3VnaDogICAgICAgICAgICAlcwoAICAgICAgUmVzYW1wbGluZzogICAgICAgICAgICAgJXMKAEJhZCBoZWFkZXIKAGZvdW5kIHByb3BlcnR5IGlzIGJvb2xlYW4KAEF1ZGlvRW5naW5lOjpNYWtlIC0gZmFpbGVkIHRvIGluaXQgZW5naW5lCgBmb3VuZCBwcm9wZXJ0eSBieSBuYW1lCgBBdWRpb1NvdXJjZTo6cGxheSAtIGZhaWxlZCB0byBzdGFydCBzb3VuZAoARmFpbGVkIHRvIGltcG9ydCBvYmplY3Qgb2YgdHlwZSAlZAoAQXJ0Ym9hcmQ6OmluaXRpYWxpemUgLSBEcmF3IHJ1bGUgdGFyZ2V0cyBtaXNzaW5nIGNvbXBvbmVudCB3aWR0aCBpZCAlZAoAICAgIFNhbXBsZSBSYXRlOiAlZCAtPiAlZAoAICAgIENoYW5uZWxzOiAgICAlZCAtPiAlZAoAWyVzXQoAICAgIENvbnZlcnNpb246CgBTeXN0ZW0gQXJjaGl0ZWN0dXJlOgoAVW5zdXBwb3J0ZWQgdmVyc2lvbiAldS4ldSBleHBlY3RlZCAldS4ldS4KAFN0YXRlTWFjaGluZSBleGNlZWRlZCBtYXggaXRlcmF0aW9ucy4KAEF1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AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAD8AAAAAAAAAPwAAAAAAAAAAAACAPgAAAAAAAEA/AAAAAAAAAAAAAAAAAAAAAAAAgD4AAEA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA/w/WoPgAAAADD9ag+AAAAAAAAAAB7FK4+AAAAAAAAAAAAAAA/AAAAAAAAAAAAAAA/AAAAAMP1qD7D9ag+AAAAAAAAAAB7FK4+w/WoPgAAAAAAAAAAw/WoPgAAAAB7FK4+AAAAAAAAAAAAAAAAAAAAPwAAAAAAAAA/AAAAAMP1qD4AAAAAw/WoPgAAAAB7FK4+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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EQMRAxEDEQMQAxADEAMQAwEDAQMBAwEDAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEiASABAf8hBRIFAgUBAwEDAQMBAxECEQIRAhECEQIRAhECEQIQAhACEAIQAhACEAIQAhACAAIAAgACAAIAAgACAAIAAiIBIAED/8L+of6R/hEDEQMRAxEDEAMQAxADEAMBAwEDAQMBAwABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABMwMyAyMCIwITARMBEwETATECMAIDAiICIQESASABAgEC/+H+MQUTBSIFIAUhBCEEEgQSBAIEAgQQAxADEAMQAxECEQIRAhECEQIRAhECEQIBAwEDAQMBAwADAAMAAwADMwIwAjIBMgEjAQMBBP9j/iP+4v0SBcH9EQQRBBADEAMQAxADAQMBAwEDAQMAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAYH+cf5TBEQEUgQlBFEDUQMVAxUDUARDBAUDBQM0BDMEVQFUAUUBNQFCAyQDQQJBAhQCFAIEAgQCQAMyAyMDMAMxAjECEwITAgMCIgIhASEBIAECAQT/U/4T/tH9IQQhBBIEEgQRAhECEQIRAhECEQIRAhECEAMQAxADEAMBAwEDAQMBAwACAAIAAgACAAIAAgACAAKC/jUEYf5SBCUEUARRA1EDFQMVA0MENAQFBDMEQgNCA1UCRQJUAVQBUwFEASQDQQMUAhQCQAMEAzIDIwMxAxMDMAMDAyIBIgEiASIBIAECAQP/o/5i/kH+Mf4xBRMFIf4iBSAFIQQhBBIEEgQCBAIEEQMRAxEDEQMQAxADEAMQAwEDAQMBAwEDAAMAAwADAAPB/lMDNQOx/kQDUgMlA1EDVQFUAUUBUAEVAhUCQwJDAjQCNAIFA0ADQgIkAjMCBAJBARQBMgEjATABAwEF/8T9I/3C/KH8kfwRBBEEEAMQAxADEAMBAwEDAQMBAwABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAf7x/eH9dAVHBWUFVgVzBTcFZAXR/TYFcgRyBCcEJwRGBXAFBwQHBCYEJgRUBVMFYARgBDUFRAVxA3EDcQNxA3cBdgFnAXUBVwFmAVUBRQEXAxcDYwRiBEH9UQQVBDH9YQNhAxYDFgMGAwYDUAQFBFIBJQFDATQB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ANBKRgBpb8cA34FHAACgwAAAwEAAAMLCAADeQgAAI0MAAP7CAEC7xABAzEQAADlDAACQQwDEFcYAuBlGAHAFxgD8MkYA3HTHAAp/RwARAwQFBgcICQoLDA0ODxAAERIDEwQFBgcICQoLDA0QABESAxMEBRAAERIQABESEwQFBgcICQoLDA0ODwAREgMTBAUGBwgJCgsMDQ4AAgMEBQYHCAkKCwwNDg8QTAQgPAQELAMHLAITAAQDEAQIIAMMKAIHLAQCLAMKAAAAAAAAq6qqNE51hzTLBlc0JUkSNM826DP3TrgziYiIM7C7WDNvBSwzCCEEM+S90TLfeKYyIQiCMptpTjJq1CMyBAIBMojJzDEsiqIxgYCAMfH7SzH/5iExIEAAMcCVyzDjlaEwCCCAMM5iSzBzbSEwAhAAMF5Jyy9DWaEvAQiAL6k8Sy8tTyEvAAQAL082yy4iSqEuAAKALiIzSy6dRyEuAAEALosxyy1bRqEtgACALcAwSy25RSEtq6qqNE51hzTLBlc0zcxMNMSMIjQTBAE0OY7jM2ictDPcWY8zAAAAAP7////6////6f/////////V////6v///87////2////4f///+3////N/////////93////Q////0////+X////a////+////+7////4////6P////X////P/////////9/////O////6/////7////s////0v////H////k////9////+T////1//////////T////d////3f///93////3////7v////n////5////9v///////////////P///+L////Y////7v///+P////R////8v////D/////////2//////////9////+f////X//////////f///+b/////////1////9n////7////+v///+f////5////9v///97////t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2//////////////////////////////////////////v////////////////////////////////////g////3v///+D////d////////////////////////////////////3P//////////////+v////b////2///////////////////////////////U/////f///9b//////////////8//////////////////////////7P////n//////////////////////////////////////////////9giBADKIAQA4SAEANYzBAD3IAQAyhwEAOwtBABbLQQAYCwEAPgrBADsLAQA/C0EAIksBAAjLAQAEDQEAAEtBABHLQQAmywEADYsBAAcLQQASSwEANMsBADgKwQAcywEAC8tBAAMLAQAqDIEAG0yBAA3MgQACzIEAMsxBACfMQQAczEEAEcxBAATMQQA3DAEANQyBACZMgQAXjIEACgyBAD8MQQAvDEEAJAxBABkMQQAMDEEAAQxBADFMgQAijIEAE8yBAAZMgQA7TEEAK0xBACBMQQAVTEEACExBAD1MAQAtjIEAHsyBAAAAAAAAAAAANADAADRAwAA0gMAANMDAAAAAAAAAAAAANQDAADVAwAA1gMAANcDAAAAAAAAAAAAANgDAADZAwAA2gMAANsDAADcAwAA3QMAAN4DAAAAAAAAAAAAAN8DAAAAAAAAAAAAANgDAADgAwAA2gMAAOEDAADcAwAA3QMAAOIDAAAAAAAAAAAAANgDAADjAwAA2gMAAOQDAADcAwAA3QMAAOUDAAAAAAAAAAAAANgDAADmAwAA2gMAAOcDAADcAwAA3QMAAOgDAAAAAAAAAAAAAOkDAAAAAAAAAAAAANgDAADqAwAA2gMAAOsDAADcAwAA3QMAAOwDAAAAAAAAAAAAAO0DAAAAAAAAAAAAANgDAADuAwAA2gMAAO8DAADcAwAA3QMAAPADAAAAAAAAAAAAAPEDAAAAAAAAAAAAAPIDAADzAwAA9AMAAPUDAAD2AwAA3QMAAN4DAAAAAAAAAAAAANgDAAD3AwAA2gMAAPgDAADcAwAA3QMAAPkDAAAAAgICAgICAgICAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6AwAA+wMAAPwDAAD9AwAA/gMAAP8DAAAABAAAAQQAAAIEAAADBAAABAQAAAUEAAAGBAAABwQAAAgEAAAJBAAACgQAAAAAAAAAAAAA+gMAAAsEAAAMBAAADQQAAA4EAAAPBAAAAAQAABAEAAACBAAAAwQAABEEAAASBAAAEwQAABQEAAAVBAAAFgQAAAEAAAABAAAAAgAAAAEAAAADAAAAAAAAAAAAAAAAAAAAFwQAABgEAAAZBAAAGgQAABsEAAAcBAAASAMAAB0EAAAeBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAAAkBAAAJQQAAAAAAAAAAAAAFwQAACYEAAAZBAAAGgQAABsEAAAcBAAASAMAAB0EAAACBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAAAnBAAAKAQAAAAAAAAAAAAAKQQAACoEAAArBAAALAQAAC0EAAAuBAAASAMAAB0EAAAvBAAAHwQAAEwDAABNAwAAMAQAADEEAAAyBAAAMwQAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAADkEAAA6BAAAOwQAADwEAAA9BAAAPgQAAD8EAABABAAAQQQAAEIEAACU////AAAAAEMEAABEBAAAfgMAAAAAAAAAAAAARQQAAEYEAABHBAAASAQAAEkEAABKBAAAAAQAAEsEAAACBAAATAQAAE0EAABOBAAATwQAAFAEAABRBAAAUgQAAFMEAABUBAAAVQQAAAAAAAAAAAAA1AMAAFYEAABXBAAA0wMAAAAAAAAAAAAA1AMAAFgEAABZBAAA0wMAAAAAAAAAAAAA1AMAAFoEAABZBAAA0wMAAAAAAAAAAAAAWwQAAFwEAABdBAAAXgQAAF8EAABgBAAAAAAAAAAAAABhBAAAYgQAAGMEAAAAAAAAAAAAAGQEAABlBAAAZgQAAGcEAABoBAAAaQQAAAAAAAAAAAAAagQAAGsEAABsBAAAbQQAAGgEAABpBAAAAAAAAAAAAABuBAAAbwQAAHAEAABxBAAAcgQAAGkEAAAAAAAAAAAAAG4EAABzBAAAdAQAAHEEAAByBAAAaQQAAAAAAAAAAAAAdQQAAHYEAAB3BAAAeAQAAHkEAAB6BAAAAAQAAEsEAAACBAAAewQAAAAAAAAAAAAAdQQAAHwEAAB9BAAAfgQAAH8EAACABAAAAAQAAEsEAAACBAAAewQAAIEEAAAAAAAAAAAAAIIEAACDBAAAhAQAAIUEAACGBAAAhwQAAAAEAABLBAAAAgQAAIgEAACJBAAAigQAAAAAAAAAAAAAggQAAIsEAACEBAAAhQQAAIYEAACHBAAAAAQAAEsEAAACBAAAewQAAIkEAACKBAAAAAAAAAAAAAAXBAAAjAQAAI0EAACOBAAAjwQAAJAEAABIAwAAkQQAAJIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAJMEAACUBAAAAAAAAAAAAAAXBAAAlQQAAJYEAACXBAAAmAQAAJkEAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAJoEAAAAAAAAAAAAABcEAACbBAAAnAQAAJ0EAACeBAAAnwQAAEgDAAAdBAAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAAAAAAAAAAAAXBAAAoAQAAKEEAACiBAAAowQAAKQEAAClBAAApgQAAKcEAAAfBAAATAMAAE0DAAAgBAAAqAQAAKkEAAAjBAAAUgMAAKoEAACrBAAArAQAAK0EAACuBAAArwQAALAEAAAAAAAAAAAAABcEAACxBAAAsgQAALMEAAC0BAAAtQQAAEgDAAAdBAAAAgQAALYEAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAtwQAALgEAAC5BAAAugQAALsEAAC8BAAAvQQAAL4EAAC/BAAAwAQAAAAAAAAAAAAAFwQAAMEEAADCBAAAwwQAAMQEAADFBAAASAMAAB0EAAACBAAAtgQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAAC3BAAAxgQAAMcEAADIBAAAyQQAAMoEAAC9BAAAywQAAL8EAADMBAAAzQQAAM4EAADPBAAAAAAAAAAAAAAXBAAA0AQAANEEAADSBAAA0wQAANQEAABIAwAA1QQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAANYEAADXBAAAAAAAAAAAAAAXBAAA2AQAANkEAADaBAAA0wQAAJ8EAABIAwAA2wQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAANYEAADXBAAAAAAAAAAAAAAXBAAA3AQAAN0EAADeBAAA0wQAAN8EAABIAwAA4AQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAANYEAADXBAAAAAAAAAAAAADhBAAA4gQAAOMEAADkBAAA5QQAAOYEAAAABAAA5wQAAOgEAADpBAAA6gQAAOsEAADsBAAA7QQAAAAAAAAAAAAA+gMAAO4EAADvBAAA8AQAAPEEAADyBAAAAAQAAPMEAAD0BAAA9QQAAPYEAAD3BAAA+AQAAPkEAAAAAAAAAAAAAOEEAAD6BAAA+wQAAPwEAAD9BAAA/gQAAAAEAADnBAAA6AQAAOkEAADqBAAA/wQAAAAAAAAAAAAAAAUAAAEFAAACBQAAAwUAAAQFAAAFBQAAAAQAAOcEAADoBAAABgUAAOoEAAAHBQAACAUAAAAAAAAAAAAAAAUAAAkFAAAKBQAACwUAAP0EAACfBAAAAAQAAOcEAADoBAAA6QQAAOoEAAAHBQAAAAAAAAAAAAAABQAADAUAAA0FAAAOBQAA/QQAAJ8EAAAABAAA5wQAAOgEAADpBAAA6gQAAP8EAAAAAAAAAAAAABcEAAAPBQAAEAUAABEFAAASBQAAEwUAAEgDAAAUBQAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAFQUAABYFAAAXBQAAGAUAAAAAAAAAAAAA+gMAABkFAAAaBQAAGwUAAP4DAAAcBQAAAAQAAB0FAAACBAAAAwQAAB4FAAAfBQAABgQAAAcEAAAIBAAACQQAAAoEAAAAAAAAAAAAAOEEAAAgBQAAIQUAACIFAAD9BAAAIwUAAAAEAADnBAAA6AQAAOkEAADqBAAA/wQAAAAAAAAAAAAAAAUAACQFAAAlBQAAJgUAAP0EAAAnBQAAAAQAAOcEAADoBAAA6QQAAOoEAAAoBQAAAAAAAAAAAADhBAAAKQUAACoFAAArBQAA/QQAACwFAAAABAAA5wQAAOgEAADpBAAA6gQAAP8EAAAAAAAAAAAAAAAFAAAtBQAALgUAAC8FAAD9BAAAMAUAAAAEAADnBAAA6AQAADEFAADqBAAABwUAAAAAAAAAAAAAMgUAADMFAAA0BQAANQUAADYFAAA3BQAAAAQAADgFAAA5BQAAOgUAADsFAAA8BQAAPQUAAD4FAAA/BQAAQAUAAEEFAABCBQAAQwUAAEQFAAAAAAAAAAAAAPoDAABFBQAARgUAAEcFAABIBQAASQUAAAAEAABKBQAASwUAAEwFAAD2BAAATQUAAAAAAAAAAAAATgUAAE8FAABQBQAAUQUAAFIFAABTBQAASAMAAB0EAABUBQAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAVgUAAFcFAABYBQAAWQUAAID///8AAAAAWgUAAFsFAABcBQAAXQUAAAAAAAAAAAAAXgUAAF8FAABgBQAAYQUAAGIFAABjBQAASAMAAGQFAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAZQUAAGYFAABnBQAAaAUAAGkFAABqBQAAawUAAGwFAABtBQAAAAAAAAAAAABeBQAAbgUAAG8FAABwBQAAcQUAAJ8EAABIAwAAZAUAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAABlBQAAZgUAAGcFAABoBQAACAMAAAgDAAAAAAAAAAAAAF4FAAByBQAAcwUAAHQFAAB1BQAAdgUAAEgDAAB3BQAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAHgFAAB5BQAAegUAAHsFAAB8BQAAfQUAAAAAAAAAAAAAXgUAAH4FAAB/BQAAgAUAAIEFAACCBQAASAMAAGQFAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAZQUAAGYFAABnBQAAaAUAAIMFAACEBQAAhQUAAIYFAAAAAAAAAAAAAIcFAACIBQAAiQUAAIoFAACLBQAAjAUAAEgDAACNBQAAjgUAAB8EAABMAwAATQMAACAEAACPBQAAIgQAAJAFAABSAwAAkQUAAJIFAACTBQAAAAAAAAAAAABeBQAAlAUAAJUFAACWBQAAlwUAAJgFAABIAwAAZAUAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAABlBQAAZgUAAGcFAABoBQAAmQUAAJoFAACbBQAAnAUAAJ0FAACeBQAAAAAAAAAAAABeBQAAnwUAAKAFAAChBQAAogUAAKMFAABIAwAApAUAAKUFAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAACmBQAAAAAAAAAAAAAXBAAApwUAAKgFAACpBQAAqgUAAKsFAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAKwFAAAAAAAAAAAAAPoDAACtBQAArgUAAK8FAACwBQAAsQUAAAAEAABLBAAAAgQAAHsEAAAAAAAAAAAAAPoDAACyBQAAswUAALQFAAC1BQAAtgUAAAAEAABLBAAAAgQAAHsEAAC3BQAAAAAAAAAAAAD6AwAAuAUAALkFAAC6BQAAuwUAALwFAAAABAAASwQAAAIEAAB7BAAAvQUAAAAAAAAAAAAAvgUAAL8FAADABQAAwQUAAMIFAADDBQAAAAQAAMQFAAACBAAAxQUAAMYFAADHBQAAyAUAAMkFAADKBQAAywUAAMwFAADNBQAA7P///wAAAADOBQAAAAAAAAAAAADPBQAA0AUAANEFAADSBQAA0wUAANQFAAAABAAASwQAAAIEAADVBQAA1gUAANcFAADYBQAA2QUAANoFAADbBQAA3AUAAAAAAAAAAAAAzwUAAN0FAADeBQAA3wUAAOAFAACfBAAAAAQAAEsEAAACBAAA1QUAANYFAADXBQAA2AUAAOEFAADaBQAA2wUAAAAAAAAAAAAA4gUAAOMFAADeBQAA3wUAAOAFAACfBAAAAAQAAEsEAAACBAAAewQAANYFAAAAAAAAAAAAAOQFAAAAAAAAAAAAAM8FAADlBQAA5gUAAOcFAADoBQAA6QUAAAAEAABLBAAAAgQAANUFAADWBQAA6gUAAOsFAADZBQAA2gUAANsFAADcBQAA7AUAAAAAAAAAAAAAzwUAAO0FAADuBQAA7wUAAOgFAADwBQAAAAQAAEsEAAACBAAA1QUAANYFAADxBQAA8gUAANkFAADaBQAA2wUAANwFAADsBQAAAAAAAAAAAADPBQAA8wUAAPQFAAD1BQAA9gUAAPcFAAAABAAASwQAAAIEAADVBQAA1gUAAPgFAAD5BQAA+gUAANoFAADbBQAA+wUAAPwFAAD9BQAA/gUAAP8FAAAABgAAAQYAAAAAAAAAAAAAzwUAAAIGAAADBgAABAYAAOgFAAAFBgAAAAQAAEsEAAACBAAA1QUAANYFAAAGBgAABwYAANkFAADaBQAA2wUAANwFAADsBQAAAAAAAAAAAAAIBgAACQYAAAoGAAALBgAADAYAAA0GAAAABAAASwQAAAIEAAAOBgAADwYAAAAAAAAAAAAAEAYAABEGAAASBgAAEwYAAOAFAAAUBgAAAAQAAEsEAAACBAAA1QUAANYFAAAVBgAAFgYAABcGAAAYBgAAGQYAAAAAAAAAAAAAzwUAABoGAAAbBgAAHAYAAB0GAAAeBgAAAAQAAEsEAAACBAAA1QUAANYFAAAfBgAA2AUAACAGAADaBQAA2wUAACEGAAAAAAAAAAAAAM8FAAAiBgAAIwYAACQGAADgBQAAJQYAAAAEAABLBAAAAgQAANUFAADWBQAAJgYAANgFAAAnBgAA2gUAANsFAAAAAAAAAAAAACgGAAAAAAAAAAAAACkGAAAqBgAAKwYAACwGAAAtBgAALgYAAAAEAABLBAAAAgQAANUFAADWBQAALwYAADAGAADZBQAAMQYAANsFAADcBQAAMgYAADMGAAA0BgAAAAAAAAAAAAA1BgAANgYAADcGAAA4BgAA4AUAADkGAAAABAAASwQAAAIEAADVBQAA1gUAADoGAADYBQAAOwYAANoFAADbBQAAAAAAAAAAAAA8BgAAAAAAAAAAAAA9BgAAPgYAAD8GAABABgAAQQYAAEIGAAAABAAAxAUAAAIEAADFBQAAxgUAAMcFAADIBQAAyQUAAMoFAADLBQAAQwYAAM0FAABEBgAARQYAAEYGAADs////AAAAAM4FAAAAAAAAAAAAAPoDAABHBgAASAYAAEkGAABKBgAASwYAAAAEAABLBAAAAgQAAHsEAABMBgAAAAAAAAAAAAD6AwAATQYAAE4GAABPBgAAUAYAAFEGAAAABAAASwQAAAIEAAB7BAAAUgYAAAAAAAAAAAAA+gMAAFMGAABUBgAAVQYAAFYGAABXBgAAAAQAAEsEAAACBAAAewQAAFgGAAAAAAAAAAAAABcEAABZBgAAWgYAAFsGAABcBgAAXQYAAEgDAABeBgAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAXwYAAGAGAABhBgAAYgYAAGMGAABkBgAAAAAAAAAAAABlBgAAZgYAAGcGAABoBgAAaQYAAGoGAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAGsGAAAAAAAAAAAAAGUGAABsBgAAZwYAAGgGAABpBgAAagYAAEgDAAAdBAAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAawYAAAAAAAAAAAAAbQYAAG4GAABvBgAAcAYAAHEGAAByBgAASAMAAB0EAAACBAAAcwYAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAdAYAAHUGAAB2BgAAdwYAALj///8AAAAAeAYAAHkGAAB6BgAAewYAAHwGAAABAAAAAAAAAP////8CAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAD/////AgAAAAIAAAD/////AAAAAAIAAAACAAAAAgAAAP////////////////////8CAAAAAAAAAAIAAAACAAAAAgAAAP////8DAAAAAwAAAAIAAAAAAAAAAAAAAAIAAAD///////////////8CAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAP////8BAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAACAAAA//////////////////////////////////////////8CAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAADAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAACAAAAAAAAAAAAAAD//////////////////////////////////////////wEAAAD/////AgAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAP//////////AAAAAAAAAAACAAAAAAAAAP////8AAAAAAgAAAAIAAAACAAAAAAAAAAAAAAACAAAAAAAAAAAAAAD//////////wAAAAACAAAAAAAAAAAAAAAAAAAA/////wIAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAACAAAAAQAAAAAAAAD/////AAAAAAIAAAACAAAA////////////////AQAAAP//////////AgAAAAIAAAD///////////////////////////////8BAAAAAAAAAAAAAAD/////AAAAAAAAAAACAAAA////////////////////////////////AAAAAAAAAAAAAAAAAgAAAAAAAAD//////////wIAAAD/////AAAAAAEAAAD/////AQAAAAAAAAD///////////////////////////////////////////////////////////////////////////////////////////////8BAAAA////////////////AAAAAP////8CAAAA/////////////////////wAAAAABAAAAAAAAAP//////////AAAAAAIAAAACAAAAAAAAAAIAAAAAAAAA//////////8CAAAA////////////////AAAAAAIAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAP///////////////wAAAAAAAAAA//////////8AAAAAAgAAAAIAAAACAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAAAAAACAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAA//////////////////////////////////////////8AAAAAAAAAAP//////////////////////////AAAAAAAAAAD/////AQAAAP//////////AQAAAAIAAAAAAAAAAAAAAAIAAAACAAAA//////////8CAAAAAgAAAAIAAAACAAAA//////////8AAAAAAAAAAAAAAAD/////AgAAAAIAAAD/////////////////////////////////////AAAAAAIAAAD/////AAAAAAAAAAD//////////////////////////wAAAAAAAAAA/////////////////////wAAAAACAAAAAgAAAAAAAAD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAP///////////////wIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAP//////////////////////////AgAAAP//////////////////////////AAAAAAAAAAAAAAAA//////////8AAAAA//////////////////////////8AAAAA/////wAAAAAAAAAAAAAAAP//////////AAAAAAMAAAD/////AQAAAP//////////AAAAAAEAAAD//////////wAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAgAAAP////8AAAAAAQAAAAEAAAD//////////wEAAAAAAAAA//////////8AAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAP//////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAQAAAAIAAAAAAAAAAwAAAAAAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAD/////AAAAAAAAAAAAAAAAAAAAAAMAAAACAAAAAAAAAAEAAAAAAAAAAAAAAP///////////////wAAAAD/////AQAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////wAAAAAAAAAA/////wIAAAAAAAAAAAAAAP////8AAAAA/////wIAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAD/////AAAAAAIAAAAAAAAAAgAAAAAAAAD///////////////8CAAAAAgAAAAIAAAACAAAA//////////8AAAAA/////wAAAAACAAAAAgAAAAAAAAAAAAAA/////wEAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAP//////////AAAAAP////8AAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAAAAAP//////////AAAAAAAAAAAAAAAAfQYAAH4GAAB/BgAAgAYAAIEGAACCBgAAAAQAAEsEAAACBAAAgwYAAIQGAACFBgAAhgYAAAAAAAAAAAAAhwYAAIgGAACJBgAA0wMAAAAAAAAAAAAACAMAAAgDAACKBgAACAMAAHwGAAAAAAAAAAAAAIsGAACMBgAAjQYAAI4GAACPBgAAkAYAAEgDAAAdBAAAkQYAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAJIGAACTBgAAlAYAAJUGAACWBgAAlwYAAJgGAACZBgAAAAAAAAAAAACaBgAAmwYAAJwGAACdBgAAngYAAJ8GAAAABAAASwQAAAIEAAB7BAAATQQAAAAAAAAAAAAAoAYAAKEGAACiBgAAowYAAKQGAAClBgAApQQAAKYEAACmBgAAHwQAAEwDAABNAwAAIAQAAKcGAACpBAAAqAYAAFIDAACqBAAAqwQAAKkGAACtBAAArgQAAKoGAACrBgAArAYAAK0GAACuBgAAAAAAAAAAAACvBgAAsAYAALEGAACyBgAAswYAALQGAAAABAAASwQAAAIEAABMBAAATQQAAE4EAABPBAAAUAQAAFEEAABSBAAAtQYAALYGAAAAAAAAAAAAALcGAAC4BgAAuQYAALoGAAC7BgAAvAYAAL0GAAC+BgAAvwYAAMAGAADBBgAAwgYAAMMGAADEBgAAAAAAAAAAAADFBgAAxgYAAMcGAADIBgAAyQYAAMoGAABIAwAAywYAAMwGAAAfBAAATAMAAE0DAABOAwAAzQYAACIEAADOBgAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAYQMAAGIDAADPBgAA0AYAANEGAABmAwAAZwMAANIGAACU////AAAAANMGAAB9AwAAfgMAADz///8AAAAA1AYAANUGAADWBgAAAAAAAAAAAAAXBAAA1wYAANgGAADZBgAA2gYAANsGAABIAwAA3AYAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAN0GAADeBgAAAAAAAAAAAADfBgAA4AYAAOEGAADiBgAA4wYAAOQGAAClBAAApgQAAOUGAAAfBAAATAMAAE0DAAAgBAAA5gYAAKkEAAAjBAAAUgMAAKoEAADnBgAA6AYAAK0EAACuBAAA6QYAAOoGAAAAAAAAAAAAAOsGAADsBgAA7QYAAO4GAADvBgAA8AYAAAAEAABLBAAAAgQAAEwEAABNBAAATgQAAE8EAABQBAAAUQQAAFIEAADxBgAA8gYAAPMGAAD0BgAA9QYAALz///8AAAAA9gYAAAAAAAAAAAAA9wYAAPgGAAD5BgAA+gYAALMGAACfBAAAAAQAAEsEAAACBAAATAQAAE0EAABOBAAATwQAAFAEAABRBAAAUgQAAAgDAAAIAwAAAAAAAAAAAAD7BgAA/AYAAPkGAAD6BgAAswYAAJ8EAAAABAAASwQAAAIEAAB7BAAATQQAAAgDAAAIAwAAUAQAAFEEAABSBAAAAAAAAAAAAACaBgAA/QYAAP4GAAD/BgAAngYAAJ8EAAAABAAASwQAAAIEAAB7BAAATQQAAAAAAAAAAAAAmgYAAAAHAAD+BgAA/wYAAJ4GAACfBAAAAAQAAEsEAAACBAAAewQAAE0EAAAAAAAAAAAAAAEHAAACBwAAAwcAAAQHAAAFBwAABgcAAEgDAADLBgAAzAYAAAcHAABMAwAATQMAAE4DAADNBgAAIgQAAM4GAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAANAQAAFoDAAA1BAAANgQAADcEAAA4BAAAXwMAAGADAABhAwAAYgMAAAgHAAAJBwAA0QYAAGYDAABnAwAACgcAAAsHAAAMBwAADQcAAA4HAAAPBwAAEAcAABEHAACU////AAAAABIHAAATBwAAfgMAADD///8AAAAAFAcAABUHAAAWBwAAFwcAABgHAAAAAAAAAAAAABcEAAAZBwAAGgcAABsHAAAcBwAAHQcAAEgDAAAeBwAAHwcAAB8EAABMAwAATQMAACAEAAAgBwAAIgQAACEHAABSAwAAIgcAACMHAAAkBwAAJQcAACYHAAAnBwAAKAcAACkHAAAqBwAAKwcAACwHAAAtBwAALgcAAC8HAAAwBwAAmP///wAAAAAxBwAAMgcAADMHAAAAAAAAAAAAADQHAAA1BwAANgcAADcHAAA4BwAAOQcAAAAEAAA6BwAAOwcAADwHAAA9BwAAAAAAAAAAAADUAwAAPgcAAFkEAADTAwAAAAAAAAAAAAA/BwAAQAcAAEEHAABCBwAAQwcAAEQHAAAABAAARQcAAEYHAABHBwAASAcAAAAAAAAAAAAA1AMAAEkHAABZBAAASgcAAAAAAAAAAAAA+gMAAEsHAABMBwAATQcAAE4HAABPBwAAAAQAAFAHAAACBAAAUQcAAFIHAABTBwAAVAcAAFUHAABWBwAAVwcAAAAAAAAAAAAA+gMAAFgHAABZBwAAWgcAAFsHAABcBwAAAAQAAEsEAAACBAAAUQcAAFIHAAAAAAAAAAAAAPoDAABdBwAAXgcAAF8HAABgBwAAYQcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAABiBwAAYwcAAGQHAAAAAAAAAAAAAPoDAABlBwAAZgcAAGcHAABoBwAAaQcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAABqBwAAawcAAGwHAAAAAAAAAAAAAPoDAABtBwAAbgcAAG8HAABwBwAAcQcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAAByBwAAcwcAAHQHAAAAAAAAAAAAAHUHAAB2BwAAdwcAAHgHAAB5BwAAegcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAAAIAwAACAMAAHsHAAAAAAAAAAAAAHUHAAB8BwAAdwcAAHgHAAB5BwAAegcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAAB9BwAAfgcAAHsHAAAAAAAAAAAAAPoDAAB/BwAAgAcAAIEHAACCBwAAgwcAAAAEAABQBwAAAgQAAFEHAABSBwAAUwcAAFQHAACEBwAAhQcAAIYHAAAAAAAAAAAAANQDAACHBwAAiAcAANMDAAAAAIC/AACAvwAAAAAAAIC/AACAPwAAgL8AAIC/AAAAAAAAAAAAAAAAAACAPwAAAAAAAIC/AACAPwAAAAAAAIA/AACAPwAAgD8AAAAAAAAAAIkHAACKBwAAiwcAAIwHAACNBwAAjgcAAEgDAABJAwAASgMAAB8EAABMAwAATQMAAE4DAABPAwAAjwcAAJAHAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAAWQMAAFoDAAA1BAAAXAMAAF0DAABeAwAAXwMAAGADAABhAwAAYgMAAJEHAACSBwAAZQMAAGYDAABnAwAAaAMAAGkDAABqAwAAawMAAGwDAABtAwAAbgMAAG8DAABwAwAAkwcAAJQHAABzAwAAdAMAAJUHAAB2AwAAlP///wAAAAB8AwAAfQMAAH4DAAAk////AAAAAH8DAACAAwAAIP///wAAAACBAwAAlgcAAJcHAAAM////AAAAAIQDAAAI////AAAAAJgHAACZBwAAhwMAAAAAAAAAAAAAmgcAAJsHAACcBwAAnQcAAMkGAACeBwAASAMAAMsGAADMBgAAHwQAAEwDAABNAwAATgMAAM0GAAAiBAAAzgYAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAAGEDAABiAwAAnwcAAKAHAAChBwAAogcAAKMHAACU////AAAAANMGAAB9AwAAfgMAAAAAAAAAAAAAFwQAAKQHAAClBwAApgcAAKcHAACoBwAASAMAAKkHAAACBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAACqBwAAqwcAAKwHAACtBwAArgcAAK8HAACwBwAAsQcAALIHAACzBwAAtAcAALUHAAC2BwAAtwcAALgHAAC5BwAAugcAALsHAAC8BwAAvQcAAL4HAAC/BwAAwAcAAMEHAADCBwAAwwcAAMQHAADFBwAAxgcAAMcHAADIBwAAyQcAAMoHAADLBwAAzAcAAM0HAADOBwAAzwcAANAHAADRBwAA0gcAANMHAADUBwAA1QcAANYHAADXBwAA2AcAANkHAADaBwAA2wcAANwHAADdBwAA3gcAAN8HAADgBwAA4QcAAOIHAADjBwAA5AcAAOUHAADmBwAA5wcAAOgHAADpBwAA6gcAAOsHAADsBwAA7QcAAO4HAADvBwAA8AcAAPEHAADyBwAA8wcAAPQHAAAAAAAAAAAAAPUHAAD2BwAA9wcAAPgHAAD5BwAA+gcAAAAEAAD7BwAA/AcAAP0HAAD+BwAA/wcAAAAIAAABCAAAAggAAAMIAAAECAAABQgAAAYIAAAAAAAAAAAAANQDAAAHCAAAWQQAANMDAAAAAAAAAAAAAAgIAAAJCAAACggAAAsIAAAMCAAADQgAAA4IAAAPCAAAEAgAABEIAAASCAAAEwgAABQIAAAVCAAAFggAABcIAAAYCAAAGQgAABoIAAD8////AAAAABsIAAAcCAAAHQgAAB4IAAAAAAAAAAAAAPoDAAAfCAAAIAgAACEIAAAiCAAAIwgAAAAEAABLBAAAAgQAACQIAAAlCAAAJggAACcIAAAAAAAAAAAAAPoDAAAoCAAAKQgAACoIAAArCAAALAgAAAAEAABLBAAAAgQAAC0IAAAuCAAALwgAADAIAAAxCAAAMggAADMIAAAAAAAAAAAAAPoDAAA0CAAANQgAADYIAAA3CAAAOAgAAAAEAABLBAAAAgQAACQIAAA5CAAAOggAAAAAAAAAAAAA+gMAADsIAAA8CAAAPQgAAD4IAAA/CAAAAAQAAEsEAAACBAAALQgAAEAIAAAvCAAAMAgAAEEIAABCCAAAQwgAAAAAAAAAAAAA+gMAAEQIAABFCAAARggAAEcIAABICAAAAAQAAEsEAAACBAAALQgAAEkIAAAvCAAAMAgAAEoIAABLCAAAAAAAAAAAAAD6AwAATAgAAE0IAABOCAAATwgAAFAIAAAABAAASwQAAAIEAABRCAAAUggAAAAAAAAAAAAAUwgAAFQIAABVCAAAVggAAFcIAABYCAAASAMAAFkIAABaCAAAHwQAAEwDAABNAwAAVQUAAFsIAAAiBAAAXAgAAFIDAABTAwAAXQgAAF4IAABfCAAAYAgAAGEIAABiCAAAvP///wAAAABjCAAAZAgAAGUIAAC0////AAAAAGYIAABnCAAAaAgAAGkIAAAAAAAAAAAAAF4FAABqCAAAawgAAGwIAAB1BQAAbQgAAEgDAAB3BQAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAHgFAAB5BQAAegUAAHsFAAB8BQAAfQUAAAAAAAAAAAAAbggAAG8IAABwCAAAcQgAAHIIAABzCAAAdAgAAAAAAAAAAAAAdQgAAHYIAAB3CAAAeAgAAHkIAAB6CAAAewgAAAAAAAAAAAAAfAgAAH0IAAB+CAAAfwgAAIAIAACBCAAASAMAAB0EAADMBgAAHwQAAEwDAABNAwAATgMAAM0GAAAiBAAAgggAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAAIMIAACECAAAhQgAAIYIAACHCAAAiAgAAIkIAACKCAAAiwgAAIwIAACNCAAAjggAAI8IAACU////AAAAAJAIAACRCAAAkggAAEz///8AAAAAkwgAAJQIAACVCAAAHP///wAAAACWCAAAlwgAAJgIAACZCAAAmggAABj///8AAAAAmwgAAJwIAACdCAAAnggAAJ8IAAAAAAAAAAAAAG4IAACgCAAAoQgAAKIIAACjCAAApAgAAKUIAAAAAAAAAAAAAKYIAACnCAAAqAgAAKkIAACeBAAAqggAAEgDAACrCAAAAgQAAB8EAABMAwAATQMAAFUFAACsCAAAIgQAAK0IAABSAwAAUwMAAK4IAAC8////AAAAAK8IAACwCAAAsQgAAAAAAAAAAAAACAMAALIIAACzCAAAAAAAAAAAAAAXBAAAtAgAALUIAAC2CAAAtwgAALgIAABIAwAAuQgAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAALoIAAC7CAAAAAAAAAAAAAC8CAAAvQgAAL4IAAC/CAAAwAgAAMEIAABIAwAAywYAAMIIAADDCAAATAMAAE0DAABOAwAAzQYAACIEAADECAAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAYQMAAGIDAADFCAAAxggAANEGAABmAwAAZwMAAMcIAADICAAAyQgAAMoIAADLCAAAzAgAAM0IAACU////AAAAAM4IAADPCAAAfgMAADj///8AAAAA0AgAAAAAAAAAAAAAvAgAANEIAADSCAAA0wgAANQIAADVCAAASAMAAMsGAADWCAAAwwgAAEwDAABNAwAATgMAAM0GAAAiBAAA1wgAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAAGEDAABiAwAAxQgAAMYIAADRBgAAZgMAAGcDAADHCAAAyAgAAMkIAADKCAAAywgAAMwIAADNCAAA2AgAANkIAADaCAAA2wgAANwIAADdCAAAlP///wAAAADOCAAAzwgAAH4DAAA4////AAAAANAIAAAAAAAAAAAAALwIAADeCAAA3wgAAOAIAADhCAAA4ggAAEgDAADLBgAAwggAAMMIAABMAwAATQMAAE4DAADNBgAAIgQAAOMIAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAANAQAAFoDAAA1BAAANgQAADcEAAA4BAAAXwMAAGADAABhAwAAYgMAAMUIAADGCAAA0QYAAGYDAABnAwAAxwgAAMgIAADJCAAAyggAAMsIAADMCAAAzQgAAOQIAADlCAAA5ggAAJT///8AAAAAzggAAM8IAAB+AwAAOP///wAAAADQCAAAAAAAAAAAAAAXBAAA5wgAAOgIAADpCAAA6ggAAOsIAABIAwAA7AgAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAO0IAADuCAAA7wgAAPAIAADxCAAAAAAAAAAAAADyCAAA8wgAAPQIAAD1CAAA9ggAAJ8EAAD3CAAA+AgAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAAD5CAAACAMAAPoIAAD7CAAAAAAAAAAAAAAXBAAA/AgAAP0IAAD+CAAA/wgAAAAJAABIAwAA7AgAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAO0IAAABCQAAAgkAAAMJAAAECQAAAAAAAAAAAADyCAAABQkAAAYJAAAHCQAACAkAAAkJAAD3CAAA+AgAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAAD5CAAACgkAAAsJAAD7CAAADAkAAAAAAAAAAAAA8ggAAA0JAAAOCQAADwkAABAJAAARCQAA9wgAAPgIAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAA+QgAABIJAAD6CAAA+wgAABMJAAAUCQAAAAAAAAAAAAAVCQAAFgkAABcJAAAYCQAAGQkAABoJAAD3CAAA+AgAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAAD5CAAAGwkAABwJAAAAAAAAAAAAAF4FAAAdCQAAHgkAAB8JAAAZCQAAnwQAAPcIAAD4CAAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAPkIAAAIAwAACAMAAAAAAAAAAAAAFwQAACAJAAAhCQAAIgkAACMJAAAkCQAASAMAAOwIAAACBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAADtCAAAJQkAACYJAAAAAAAAAAAAABcEAAAnCQAAKAkAACkJAAAjCQAAnwQAAEgDAADsCAAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAA7QgAACoJAAAAAAAAAAAAACsJAAAsCQAALQkAAC4JAAAvCQAAMAkAAEgDAAAdBAAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAADEJAAAyCQAAMwkAAAAAAAAAAAAAKwkAADQJAAAtCQAALgkAAC8JAAAwCQAASAMAAB0EAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAMQkAADIJAAAzCQAAAAAAAAAAAABeBQAANQkAADYJAAA3CQAAngQAADgJAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAAAxCQAAAAAAAAAAAAA5CQAAOgkAADsJAAA8CQAAPQkAAD4JAABIAwAAHQQAAC8EAAAfBAAATAMAAE0DAAAwBAAAPwkAADIEAABACQAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAOQQAAEEJAABCCQAAQwkAAEQJAABFCQAAlP///wAAAADTBgAAfQMAAH4DAAAg////AAAAAEYJAABHCQAASAkAAAAAAAAAAAAASQkAAEoJAABLCQAATAkAAE0JAABOCQAASAMAAB0EAAAvBAAAHwQAAEwDAABNAwAAMAQAADEEAAAyBAAATwkAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAADkEAAA6BAAAOwQAADwEAAA9BAAAPgQAAD8EAABABAAAQQQAAEIEAABQCQAAUQkAAFIJAABTCQAAlP///wAAAABDBAAARAQAAH4DAAAAAAAAAAAAAFQJAABVCQAAVgkAAFcJAABYCQAAWQkAAEgDAABaCQAAAgQAAB8EAABMAwAATQMAAFUFAABbCQAAIgQAAFwJAABSAwAAUwMAAF0JAABeCQAAXwkAAGAJAABhCQAAYgkAAGMJAABkCQAAZQkAAKj///8AAAAAZgkAAGcJAABoCQAAaQkAAGoJAAAAAAAAAAAAAFQJAABrCQAAbAkAAG0JAABYCQAAbgkAAEgDAABaCQAAAgQAAB8EAABMAwAATQMAAFUFAABbCQAAIgQAAFwJAABSAwAAUwMAAF0JAABeCQAAXwkAAGAJAABhCQAAYgkAAGMJAABkCQAAbwkAAKj///8AAAAAZgkAAGcJAABwCQAAcQkAAGoJAAAAAAAA//////////8AAAAA//////////8AAAAAAAAAAHIJAABzCQAAdAkAAHUJAAB2CQAAdwkAAEgDAAAdBAAALwQAAB8EAABMAwAATQMAADAEAAAxBAAAMgQAAHgJAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAANAQAAFoDAAA1BAAANgQAADcEAAA4BAAAXwMAAGADAAA5BAAAOgQAADsEAAA8BAAAPQQAAD4EAAA/BAAAQAQAAEEEAABCBAAAeQkAAHoJAAB7CQAAfAkAAH0JAACU////AAAAAEMEAABEBAAAfgMAAAAAAAAAAAAAfgkAAH8JAACACQAAgQkAAIIJAACDCQAASAMAAB0EAACECQAAHwQAAEwDAABNAwAATgMAAM0GAAAiBAAAzgYAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAACFCQAAhgkAADgEAACHCQAAiAkAAIkJAACU////AAAAANMGAAB9AwAAfgMAAAAAAAAAAAAAfgkAAIoJAACLCQAAjAkAAI0JAACOCQAASAMAAB0EAACPCQAAHwQAAEwDAABNAwAATgMAAM0GAAAiBAAAzgYAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAACQCQAAkQkAADgEAACHCQAAlP///wAAAADTBgAAfQMAAH4DAAAAAAAAAAAAABcEAACSCQAAkwkAAJQJAACVCQAAlgkAAKUEAACmBAAApwQAAB8EAABMAwAATQMAACAEAACoBAAAqQQAACMEAABSAwAAqgQAAKsEAACXCQAArQQAAJgJAACqBgAAqwYAAJkJAACaCQAAmwkAAJwJAACdCQAAngkAAJ8JAACgCQAAAAAAAAAAAAAXBAAAoQkAAKIJAACjCQAApAkAAKUJAAClBAAApgQAAKcEAAAfBAAATAMAAE0DAAAgBAAAqAQAAKkEAAAjBAAAUgMAAKoEAACrBAAApgkAAK0EAACnCQAAqgYAAKsGAACZCQAAmgkAAJsJAACcCQAAnQkAAJ4JAACfCQAAoAkAAKgJAACpCQAAqgkAAKsJAACsCQAArQkAAAAAAAAAAAAAFwQAAK4JAACvCQAAsAkAALEJAACyCQAAswkAALQJAACnBAAAHwQAAEwDAABNAwAAIAQAALUJAACpBAAAIwQAAFIDAACqBAAAqwQAALYJAAC3CQAAuAkAALkJAAC6CQAAAAAAAAAAAAC7CQAAvAkAAL0JAAC+CQAAvwkAAMAJAAAAAAAAAAAAALsJAADBCQAAwgkAAMMJAADECQAAxQkAAAAAAAAAAAAAFwQAAMYJAADHCQAAyAkAAMkJAADKCQAASAMAAB0EAACnBAAAywkAAEwDAABNAwAAIAQAAMwJAACpBAAAIwQAAFIDAACqBAAAqwQAAM0JAAC3CQAAzgkAAM8JAADQCQAA0QkAANIJAADTCQAAtP///wAAAADUCQAAsP///wAAAADVCQAAAAAAAAAAAAAXBAAA1gkAANcJAADYCQAA2QkAAJ8EAABIAwAAHQQAAKcEAAAfBAAATAMAAE0DAAAgBAAA2gkAAKkEAAAjBAAAUgMAAKoEAACrBAAACAMAALcJAAAIAwAAAAAAAAAAAAC7CQAA2wkAANwJAADdCQAA3gkAAN8JAAAAAAAAAAAAABcEAADgCQAA4QkAAOIJAAC0BAAAnwQAAEgDAAAdBAAAAgQAALYEAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAtwQAALgEAAC5BAAAugQAAOMJAADkCQAAvQQAAOUJAAC/BAAAwAQAAAAAAAAAAAAA5gkAAOcJAADoCQAA6QkAAMkGAADqCQAASAMAAOsJAADsCQAAHwQAAEwDAABNAwAA7QkAAO4JAAAiBAAA7wkAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAAGEDAABiAwAA8AkAAPEJAADRBgAAZgMAAGcDAADyCQAA8wkAAPQJAAD1CQAAlP///wAAAAD2CQAAfQMAAH4DAAA8////AAAAAPcJAAD4CQAA+QkAACj///8AAAAA+gkAAPsJAAD8CQAA/QkAAAAAAAAAAAAA/gkAAP8JAAAACgAAAQoAAAIKAAADCgAABAoAAAUKAAAGCgAABwoAAAAAAAAAAAAACAoAAAkKAAAKCgAACwoAAJ4EAACfBAAASAMAAB0EAAACBAAAHwQAAEwDAABNAwAAIAQAAAwKAAANCgAADgoAAFIDAAAAAAAAAAAAAA8KAAAQCgAAEQoAABIKAAATCgAAFAoAAEgDAAAVCgAAAgQAAB8EAABMAwAATQMAAFUFAAAWCgAAFwoAABgKAABSAwAAUwMAABkKAAAaCgAAGwoAABwKAAAdCgAAHgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAAAAAABAAAAAAABAAMAAQACAAMAAAAAAAAAAAAfCgAAIAoAACEKAAAiCgAAAAAAAAAAAAAjCgAAJAoAAAgDAAAIAwAAAAAAAAAAAAAlCgAAJgoAACcKAAAoCgAAKQoAACoKAABIAwAAKwoAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAACwKAAAtCgAALgoAAC8KAADE////AAAAADAKAAAxCgAAMgoAADMKAAA0CgAAAAAAAAAAAAA1CgAANgoAADcKAAA4CgAAOQoAADoKAABIAwAAHQQAADsKAAAfBAAATAMAAE0DAAA8CgAAzQYAACIEAADOBgAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAPQoAAJT///8AAAAA0wYAAH0DAAB+AwAAAAAAAAAAAABJCQAAPgoAAD8KAABACgAAQQoAAEIKAABIAwAAHQQAAC8EAAAfBAAATAMAAE0DAAAwBAAAMQQAADIEAABDCgAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAOQQAADoEAAA7BAAAPAQAAD0EAAA+BAAAPwQAAEAEAABBBAAAQgQAAFAJAABRCQAARAoAAEUKAABGCgAAlP///wAAAABDBAAARAQAAH4DAAAAAAAAAAAAAEcKAABICgAASQoAAEoKAABLCgAATAoAAAAEAABNCgAATgoAAE8KAAD+BwAAAAAAAAAAAABQCgAAUQoAAFIKAABTCgAASwoAAFQKAAAABAAASwQAAAIEAAB7BAAA/gcAAAAAAAAAAAAAUAoAAFUKAABSCgAAUwoAAEsKAABUCgAAAAQAAEsEAAACBAAAewQAAP4HAAAAAAAAAAAAAFYKAABXCgAAWAoAAFkKAABaCgAAWwoAAAAEAABcCgAAXQoAAF4KAABfCgAAYAoAAAAAAAAAAAAA+gMAAGEKAABiCgAAYwoAAGQKAABlCgAAAAQAAEsEAAACBAAAZgoAAGcKAABoCgAAAAAAAAAAAADUAwAAaQoAAGoKAABrCgAAAAAAAAAAAABsCgAAbQoAAG4KAAAAAAAAAAAAAGwKAABtCgAAbwoAAAAAAAAAAAAAcAoAAG0KAABxCgAAAAAAAAAAAAByCgAAcwoAAAoIAAB0CgAAdQoAAHYKAAB3CgAAeAoAAHkKAAB6CgAAewoAAHwKAAB9CgAAfgoAAH8KAACACgAAgQoAAIIKAACDCgAAhAoAAIUKAAD8////AAAAAIYKAACHCgAAiAoAAIkKAADk////AAAAAIoKAACLCgAAjAoAAAAAAAAAAAAAjQoAAI4KAACPCgAAkAoAAJEKAACSCgAAkwoAAAAAAAAAAAAAjQoAAJQKAACPCgAAkAoAAJEKAACVCgAAkwoAAAAAAAAAAAAAjQoAAJYKAACPCgAAkAoAAJEKAACXCgAAmAoAAAAAAAAAAAAAmQoAAJoKAACPCgAAkAoAAJEKAACXCgAAmAoAAAAAAAAAAAAAmwoAAJwKAACdCgAAngoAAJ8KAACgCgAAoQoAAAAAAAAAAAAAogoAAKMKAACkCgAApQoAAKYKAACnCgAAAAAAAAAAAACiCgAAqAoAAKkKAACqCgAAqwoAAKwKAAAAAAAAAAAAAK0KAACuCgAArwoAALAKAACxCgAAAAAAAAAAAACyCgAAswoAALQKAAC1CgAAtgoAALcKAAAABAAAuAoAALkKAAC6CgAAXwoAAAAAAAAAAAAAuwoAALwKAAC9CgAAvgoAAL8KAACfBAAAAAQAAEsEAAACBAAAewQAAAAAAAAAAAAA1AMAAMAKAABZBAAA0wMAAAAAAAAAAAAA1AMAAMEKAADCCgAAwwoAAAAAAAAAAAAA4QQAAMQKAADFCgAAxgoAAP0EAACfBAAAAAQAAOcEAADoBAAA6QQAAOoEAAD/BAAAAAAAAAAAAADHCgAAyAoAAMkKAADKCgAAywoAAMwKAAAABAAASwQAAAIEAADNCgAAXwoAAM4KAADPCgAA0AoAAAAAAAAAAAAA1AMAANEKAADSCgAA0wMAAAAAAAAAAAAAVgoAANMKAADUCgAA1QoAANYKAADXCgAAAAQAAFwKAABdCgAAXgoAAF8KAADYCgAAAAAAAAAAAABWCgAA2QoAANoKAADbCgAAtgoAANwKAAAABAAAXAoAAF0KAABeCgAAXwoAAAAAAAAAAAAAVgoAAN0KAADeCgAA3woAALYKAACfBAAAAAQAAFwKAABdCgAAXgoAAF8KAAAAAAAAAAAAAFYKAADgCgAA4QoAAOIKAAC2CgAAnwQAAAAEAABLBAAAAgQAAHsEAABfCgAAAAAAAAAAAABWCgAA4woAAOEKAADiCgAAtgoAAJ8EAAAABAAASwQAAAIEAAB7BAAAXwoAAAAAAAAAAAAAMgUAAOQKAADlCgAA5goAAOcKAADoCgAAAAQAADgFAAA5BQAAOgUAADsFAAA8BQAAPQUAAD4FAAA/BQAAQAUAAEEFAADpCgAA6goAAAAAAAAAAAAA1AMAAOsKAADsCgAA0wMAAAAAAAAAAAAAiwYAAO0KAADuCgAA7woAAPAKAADxCgAASAMAAB0EAACRBgAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAA8goAAJMGAACUBgAA8woAAPQKAAD1CgAA9goAAPcKAAD4CgAA+QoAAPoKAAAAAAAAAAAAAIsGAAD7CgAA/AoAAP0KAAD+CgAAnwQAAEgDAAAdBAAAkQYAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAJIGAACTBgAAlAYAAP8KAAAIAwAACAMAAAgDAAAAAAAAAAAAAAALAAABCwAAAgsAAAMLAAAECwAAaQQAAAAAAAAAAAAAFwQAAAULAAAGCwAABwsAAAgLAAAJCwAASAMAAAoLAAALCwAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAAAMCwAADQsAAA4LAAAPCwAAEAsAABELAAASCwAAAAAAAAAAAAATCwAAFAsAABULAAAWCwAAFwsAABgLAABIAwAAywYAAMwGAAAfBAAATAMAAE0DAABOAwAAzQYAACIEAAAZCwAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAGgsAAF8DAABgAwAAYQMAAGIDAAAbCwAAHAsAANEGAABmAwAAZwMAAB0LAAAeCwAAHwsAACALAAAhCwAAIgsAACMLAAAkCwAAJQsAACYLAAAnCwAAKAsAACkLAAAqCwAAlP///wAAAAArCwAALAsAAH4DAAAAAAAAAAAAAJoHAAAtCwAAnAcAAJ0HAADJBgAAngcAAEgDAADLBgAAzAYAAB8EAABMAwAATQMAAE4DAADNBgAAIgQAAM4GAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAANAQAAFoDAAA1BAAANgQAADcEAAA4BAAAXwMAAGADAABhAwAAYgMAAAgDAAAIAwAA0QYAAGYDAABnAwAAlP///wAAAADTBgAAfQMAAH4DAAAAAAAAAAAAAC4LAAAvCwAAMAsAADELAAAyCwAAMwsAAEgDAAA0CwAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAADULAAA2CwAANwsAADgLAAA5CwAAOgsAADsLAAA8CwAAPQsAAAAAAAAAAAAAPgsAAD8LAABACwAAQQsAAEILAABDCwAASAMAAEQLAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABFCwAARgsAAEcLAABICwAASQsAAEoLAABLCwAATAsAAE0LAABOCwAATwsAAFALAAAAAAAAAAAAAFELAABSCwAAUwsAAFQLAABVCwAAVgsAAEgDAAAdBAAAVwsAAFgLAABMAwAATQMAAFUFAABZCwAAWgsAACMEAABSAwAAUwMAAFsLAABcCwAAXQsAAF4LAABfCwAAYAsAAGELAACs////AAAAAGILAABjCwAAZAsAAJj///8AAAAAZQsAAGYLAABnCwAAaAsAAHwGAAAAAAAAAAAAAAgDAABpCwAAagsAAAAAAAAAAAAAFwQAAGsLAAAKCgAACwoAAJ4EAACfBAAASAMAAB0EAAACBAAAHwQAAEwDAABNAwAAIAQAAGwLAAAiBAAAbQsAAFIDAAAAAAAAAAAAABcEAABuCwAAbwsAAHALAABxCwAAcgsAAEgDAABzCwAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAdAsAAHULAAAAAAAAAAAAABcEAAB2CwAAdwsAAHgLAAB5CwAAegsAAEgDAAB7CwAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAfAsAAH0LAAAAAAAAAAAAAH4LAAB/CwAAgAsAAIELAACCCwAAgwsAAIQLAACFCwAAhgsAAIcLAAAAAAAAAAAAAIgLAACJCwAAigsAAIsLAACMCwAAjQsAAEgDAAAdBAAAAgQAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAjgsAAI8LAAAAAAAAAAAAAJALAACRCwAAigsAAIsLAACMCwAAjQsAAEgDAACSCwAAkwsAAB8EAABMAwAATQMAACAEAAAhBAAAIgQAACMEAABSAwAAlAsAAJULAACWCwAAlwsAALj///8AAAAAmAsAAJkLAACaCwAAmwsAAAAAAAAAAAAAFwQAAJwLAACdCwAAngsAAJ8LAACgCwAASAMAAKELAAACBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAACiCwAAowsAAKQLAAAAAAAAAAAAABcEAAClCwAApgsAAKcLAACoCwAAqQsAAKUEAACmBAAApwQAAB8EAABMAwAATQMAACAEAACoBAAAqQQAACMEAABSAwAAqgQAAKsEAACqCwAArQQAAK4EAACqBgAAqwYAAKsLAACsCwAArQsAAAAAAAAAAAAA+gMAAK4LAACvCwAAsAsAALELAACyCwAAAAQAALMLAAC0CwAAtQsAALYLAAC3CwAAuAsAALkLAAC6CwAAAAAAAAAAAAD6AwAAuwsAALwLAAC9CwAAvgsAAL8LAAAABAAAswsAALQLAADACwAAwQsAAMILAADDCwAAxAsAAAAAAAAAAAAA+gMAAMULAADGCwAAxwsAAMgLAADJCwAAAAQAALMLAAC0CwAAwAsAAMoLAADLCwAAwwsAAMQLAADMCwAAAAAAAAAAAAD6AwAAzQsAAM4LAADPCwAA0AsAANELAAAABAAASwQAAAIEAADSCwAA0wsAANQLAAAAAAAAAAAAANULAADWCwAA1wsAANgLAADZCwAA2gsAAAAEAABLBAAAAgQAAHsEAADbCwAAAAAAAAAAAADVCwAA3AsAANcLAADYCwAA2QsAANoLAAAABAAASwQAAAIEAAB7BAAA2wsAAAAAAAAAAAAA+gMAAN0LAADeCwAA3wsAAOALAADhCwAAAAQAAEsEAAACBAAA4gsAAOMLAAAAAAAAAAAAAPoDAADkCwAA5QsAAOYLAADnCwAA6AsAAAAEAACzCwAAtAsAAMALAADpCwAA6gsAAMMLAAAAAAAAAAAAAPoDAADrCwAA7AsAAO0LAADuCwAA7wsAAAAEAABLBAAAAgQAANILAADwCwAA8QsAAAAAAAAAAAAA+gMAAPILAADzCwAA9AsAAPULAAD2CwAAAAQAAEsEAAACBAAA0gsAAPcLAAD4CwAAAAAAAAAAAAD6AwAA+QsAAPoLAAD7CwAA/AsAAP0LAAAABAAASwQAAAIEAADSCwAA/gsAAP8LAAAAAAAAAAAAAPoDAAAADAAAAQwAAAIMAAADDAAABAwAAAAEAABLBAAAAgQAANILAAAFDAAABgwAAAAAAAAAAAAABwwAAAgMAAAJDAAACgwAAAsMAAAMDAAAAAQAAEsEAAACBAAA0gsAAP4LAAANDAAAAAAAAAAAAAAHDAAADgwAAAkMAAAKDAAACwwAAAwMAAAABAAASwQAAAIEAADSCwAADwwAAA0MAAAAAAAAAAAAAPoDAAAQDAAAEQwAABIMAAATDAAAFAwAAAAEAABLBAAAAgQAANILAAD+CwAAFQwAAAAAAAAAAAAA+gMAABYMAAAXDAAAGAwAALELAAAZDAAAAAQAALMLAAC0CwAAtQsAALYLAAC3CwAAuAsAALkLAAC6CwAAAAAAAAAAAADUAwAAGgwAAFkEAADTAwAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAAAXBAAAGwwAABwMAAAdDAAApAkAAB4MAAClBAAApgQAAKcEAAAfBAAATAMAAE0DAAAgBAAAqAQAAKkEAAAjBAAAUgMAAKoEAACrBAAAHwwAAK0EAAAgDAAAqgYAAKsGAACZCQAAmgkAAJsJAACcCQAAnQkAAJ4JAACfCQAAoAkAAKgJAACpCQAAqgkAAKsJAACsCQAArQkAAAAAAAAAAAAAFwQAACEMAAAiDAAAIwwAAKQJAACfBAAApQQAAKYEAACnBAAAHwQAAEwDAABNAwAAIAQAAKgEAACpBAAAIwQAAFIDAACqBAAAqwQAAAgDAACtBAAArgQAAKoGAACrBgAAmQkAAJoJAACbCQAAnAkAAJ0JAACeCQAAnwkAAKAJAACoCQAAqQkAAKoJAACrCQAArAkAAK0JAAAAAAAAAAAAABcEAAAkDAAAJQwAACYMAACVCQAAnwQAAKUEAACmBAAApwQAAB8EAABMAwAATQMAACAEAACoBAAAqQQAACMEAABSAwAAqgQAAKsEAAAIAwAArQQAAK4EAACqBgAAqwYAAJkJAACaCQAAmwkAAJwJAACdCQAAngkAAJ8JAACgCQAAAAAAAAAAAAAXBAAAJwwAACgMAAApDAAAKgwAAJ8EAAClBAAApgQAAKcEAAAfBAAATAMAAE0DAAAgBAAAqAQAAKkEAAAjBAAAUgMAAKoEAACrBAAACAMAAK0EAACuBAAAqgYAAKsGAAAAAAAAAAAAABcEAAArDAAALAwAAC0MAAAuDAAAnwQAAKUEAACmBAAApwQAAB8EAABMAwAATQMAACAEAACoBAAAqQQAACMEAABSAwAAqgQAAKsEAAAIAwAArQQAAK4EAAAAAAAAAAAAABcEAAAvDAAAMAwAADEMAAAyDAAAnwQAAEgDAAAdBAAApwQAAB8EAABMAwAATQMAACAEAADaCQAAqQQAACMEAABSAwAAqgQAAKsEAAAIAwAAAAAAAAAAAAAzDAAANAwAADUMAAA2DAAALQQAADcMAABIAwAAHQQAAC8EAAAfBAAATAMAAE0DAAAwBAAAMQQAADIEAAA4DAAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAOQQAADoEAAA7BAAAPAQAAD0EAAA+BAAAPwQAAEAEAABBBAAAQgQAAJT///8AAAAAQwQAAEQEAAB+AwAAAAAAAAAAAAA5DAAAOgwAADsMAAA8DAAALQQAAJ4HAABIAwAAHQQAAC8EAAAfBAAATAMAAE0DAAAwBAAAMQQAADIEAAA9DAAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAOQQAADoEAAA7BAAAPAQAAD0EAAA+BAAAPwQAAEAEAABBBAAAQgQAAJT///8AAAAAQwQAAEQEAAB+AwAAAAAAAAAAAAA1CgAAPgwAAD8MAABADAAAQQwAAJ4HAABIAwAAHQQAAMwGAAAfBAAATAMAAE0DAABOAwAAzQYAACIEAADOBgAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAADQEAABaAwAANQQAADYEAAA3BAAAOAQAAF8DAABgAwAAlP///wAAAADTBgAAfQMAAH4DAAAAAAAAAAAAAF4FAABCDAAAQwwAAEQMAABFDAAARgwAAEgDAABkBQAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAHgFAAB5BQAAegUAAGgFAABHDAAAAAAAAAAAAABeBQAASAwAAEkMAABKDAAAcQUAAJ8EAABIAwAAZAUAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAAB4BQAAeQUAAHoFAABoBQAAAAAAAAAAAABeBQAASwwAAEwMAABNDAAAcQUAAJ8EAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAABVBQAAIQQAACIEAAAjBAAAUgMAAFMDAABODAAATwwAAAAAAAAAAAAAOQwAAFAMAABRDAAAUgwAAFMMAACeBwAASAMAAB0EAAAvBAAAHwQAAEwDAABNAwAAMAQAADEEAAAyBAAAPQwAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAA2BAAANwQAADgEAABfAwAAYAMAADkEAAA6BAAAVAwAADwEAACU////AAAAANMGAAB9AwAAfgMAAAAAAAAAAAAANQoAAFUMAABWDAAAVwwAAFgMAACfBAAASAMAAB0EAADMBgAAHwQAAEwDAABNAwAATgMAAM0GAAAiBAAAzgYAAFIDAABTAwAAVAMAAFUDAABWAwAAVwMAAFgDAAA0BAAAWgMAADUEAAAIAwAACAMAADgEAACU////AAAAANMGAAB9AwAAfgMAAAAAAAAAAAAAWQwAAFoMAABbDAAAXAwAAF0MAABeDAAASAMAAF8MAABgDAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAABhDAAAYgwAAGMMAABkDAAAZQwAAGYMAAC4////AAAAAGcMAABoDAAAaQwAAGoMAAAAAAAAAAAAAF4FAABrDAAATAwAAE0MAABxBQAAnwQAAEgDAAAdBAAAAgQAAB8EAABMAwAATQMAAFUFAAAhBAAAIgQAACMEAABSAwAAUwMAAHgFAAB5BQAAegUAAAgDAAAAAAAAAAAAAGwMAABtDAAAbgwAAG8MAABwDAAAcQwAAAAEAABLBAAAAgQAAHsEAAByDAAAcwwAAAAAAAAAAAAA1AMAAHQMAAB1DAAA0wMAAAAAAAAAAAAAdgwAAHcMAAB4DAAAeQwAAHoMAAB7DAAASAMAAB0EAAACBAAAfAwAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAAB9DAAAAAAAAAAAAAB+DAAAfwwAAIAMAACBDAAAggwAAIMMAAAABAAASwQAAAIEAACEDAAAhQwAAIYMAACHDAAAiAwAAAAAAAAAAAAAfgwAAIkMAACKDAAAiwwAAIwMAACNDAAAAAQAAEsEAAACBAAAhAwAAIUMAACGDAAAhwwAAI4MAAAAAAAAAAAAAH4MAACPDAAAkAwAAJEMAACSDAAAkwwAAAAEAABLBAAAAgQAAIQMAACFDAAAhgwAAIcMAACUDAAAAAAAAAAAAADUAwAAlQwAAJYMAADTAwAAAAAAAAAAAACXDAAAmAwAAJkMAACaDAAAmwwAAJwMAAAABAAASwQAAAIEAACEDAAAhQwAAIYMAACHDAAAAAAAAAAAAADUAwAAnQwAAJ4MAADTAwAAAAAAAAAAAAD6AwAAnwwAAKAMAAChDAAAogwAAKMMAAAABAAASwQAAAIEAACkDAAApQwAAKYMAACnDAAAqAwAAAAAAAAAAAAAfgwAAKkMAACqDAAAqwwAAKwMAACtDAAAAAQAAEsEAAACBAAAhAwAAIUMAACGDAAAhwwAAK4MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAALAMAACxDAAAsgwAALMMAAC0DAAAtQwAAAAEAABLBAAAAgQAAIQMAACFDAAAhgwAAIcMAAC2DAAAAAAAAAAAAACwDAAAtwwAALIMAACzDAAAtAwAALUMAAAABAAASwQAAAIEAACEDAAAhQwAAIYMAACHDAAAuAwAAAAAAAAAAAAAfgwAALkMAAC6DAAAuwwAALwMAAC9DAAAAAQAAEsEAAACBAAAhAwAAIUMAACGDAAAvgwAAL8MAAAAAAAAAAAAAK8MAAAAAAAAAAAAAMAMAADBDAAAwgwAAMMMAADEDAAAxQwAAAAEAABLBAAAAgQAAIQMAACFDAAAxgwAAMcMAADIDAAAAAAAAAAAAAB+DAAAyQwAAMoMAADLDAAAmwwAAJ8EAAAABAAASwQAAAIEAACEDAAAhQwAAIYMAACHDAAAAAAAAAAAAADMDAAAzQwAAM4MAADPDAAA0AwAANEMAAAABAAASwQAAAIEAADSDAAAcgwAAAAAAAAAAAAAzAwAANMMAADUDAAA1QwAANAMAADWDAAAAAQAAEsEAAACBAAA0gwAAHIMAAAAAAAAAAAAAMwMAADXDAAA2AwAANkMAADaDAAA2wwAAAAEAABLBAAAAgQAANIMAAByDAAA3AwAAN0MAAAAAAAAAAAAAHUEAADeDAAA3wwAAOAMAAB5BAAA4QwAAAAEAABLBAAAAgQAAHsEAAAAAAAAAAAAAMwMAADiDAAA4wwAAOQMAADlDAAA5gwAAAAEAABLBAAAAgQAANIMAAByDAAA5wwAAOgMAAAAAAAAAAAAAMwMAADpDAAA6gwAAOsMAADQDAAA7AwAAAAEAABLBAAAAgQAANIMAAByDAAA3AwAAAAAAAAAAAAAzAwAAO0MAADuDAAA7wwAANAMAADwDAAAAAQAAEsEAAACBAAA0gwAAHIMAAAAAAAAAAAAAMwMAADxDAAA8gwAAPMMAADQDAAA9AwAAAAEAABLBAAAAgQAANIMAAByDAAAAAAAAAAAAADMDAAA9QwAAPYMAAD3DAAA0AwAAPgMAAAABAAASwQAAAIEAADSDAAAcgwAAAAAAAAAAAAAzAwAAPkMAAD6DAAA+wwAANAMAAD8DAAAAAQAAEsEAAACBAAA0gwAAHIMAAAAAAAAAAAAAMwMAAD9DAAA/gwAAP8MAAAADQAAAQ0AAAAEAABLBAAAAgQAANIMAAByDAAAAg0AAAAAAAAAAAAAzAwAAAMNAAAEDQAABQ0AANAMAAAGDQAAAAQAAEsEAAACBAAA0gwAAHIMAAAAAAAAAAAAAMwMAAAHDQAACA0AAAkNAADQDAAACg0AAAAEAABLBAAAAgQAAHsEAAByDAAAAAAAAAAAAADMDAAACw0AAAgNAAAJDQAA0AwAAAoNAAAABAAASwQAAAIEAAB7BAAAcgwAAAAAAAAAAAAAFwQAAAwNAAANDQAADg0AAA8NAAAQDQAASAMAAF4GAAACBAAAHwQAAEwDAABNAwAAIAQAACEEAAAiBAAAIwQAAFIDAABfBgAAYAYAAAAAAAAAAAAAXgUAABENAAASDQAAEw0AAJ4EAACfBAAASAMAAB0EAAACBAAAHwQAAEwDAABNAwAAVQUAACEEAAAiBAAAIwQAAFIDAABTAwAAAAAAAAAAAAAXBAAAFA0AAAoKAAALCgAAngQAAJ8EAABIAwAAHQQAAAIEAAAfBAAATAMAAE0DAAAgBAAAIQQAACIEAAAjBAAAUgMAAAAAAAAAAAAAFQ0AABYNAAAKCgAACwoAAJ4EAACfBAAAAAQAAEsEAAACBAAAewQAAEwDAABNAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALQAAMDEyMzQ1Njc4OQAAAAAAAABhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5egAAAAAtAGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg8SHxIvEAAAAAJfEAAAAAKPEp8SrxK/Fe8S3xLvEv8bDxsfGy8bPxtPG18bbxt/G48bnxOvE78QAAPfEAAD/xAAAAAAAAW/Fc8V3xAAAAAAAAAAAAACPxAAAAAAAAAAAAAAAAAAAk8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAm8QAAAAAAAAAAAAAAAAAAJ/EAAAAAAAAAACzxAAAAAAAAAAAAAAAAO/EAAAAAAAA/8QAArfFF8UPxu/FH8brxQfFK8anxTPFO8VHxVPFX8VjxWfFa8WDxYvFk8WbxaPFp8WrxbvFy8QDxAPEA8QDxAPFf8XXxePF68XzxfvHh8aTxpfGs8ajxx/HI8cvxxPHF8crxyfHG8QDxAPEA8QDxAPEA8QDxAPEA8QDxAPEA8QAAMPEx8TLxM/E08TXxNvE38TjxOfEAAF7xXvEAAAAAAAAAAAAAAAAAAAzxDfEO8Q/xPPE+8QAAAAAAAAAAAAAAAAAARfFG8UPxRPG78bvxR/FI8brxr/Gu8a7xQfFC8UrxSvFJ8UnxqfGq8UzxTPFL8UvxTvFO8U3xTfFR8VDxT/FP8VTxU/FS8VLxV/FW8VXxVfFY8VjxWfFZ8VrxWvFg8WDxYvFi8WHxYfFk8WTxY/Fj8WbxZvFl8WXxaPFo8WfxZ/Fp8WnxafFp8WrxavFq8WrxbvFt8WvxbPFy8XHxb/Fw8XXxdfFz8XTxePF48Xbxd/F68XrxefF58XzxfPF78XvxfvF+8X3xffHh8eHxf/F/8aTxo/Gh8aLxpfGl8azxq/Go8afxpvGm8cDxwfG+8b/xwvHD8b3xvPEAAAAAAAAAAAAAAAAAACDyIfIi8gAAAAAl8gAAAAAo8inyKvIr8l7yLfIu8i/yAAAAADryO/IAAD3yAAA/8gAAAAAAAFvyAABd8gAAAAAAAAAAAAAj8gAAAAAAACTyAAAAAAAAJvIAAAAAAAAn8izyAAAAAAAAAAAAAAAAO/IAAAAAAAA/8gAA1fJF8kPy2vJH8tnyQfJM8tHyUPJU8ljyYPJk8mXyZ/Jp8mvycPJ08njyfvKi8qPyqvKu8gDyAPIA8gDyAPJf8rLytvK68r7ywvLG8sryy/LU8tDy5/Lo8uvy5PLl8ury6fLm8gDyAPIA8gDyAAAw8jHyMvIz8jTyNfI28jfyOPI58gAAXvJe8gAAAAAAAAzyDfIO8g/yPPI+8gAAAAAC8gAAHfIAAAAAAAAD8gAAHvIAAATyAAAAAAAAn/IAAAAAAAAAABLyE/IU8gXyAAAc8gAAAAAAAAAAAAAG8gAAH/IAAAAAAAAAAAAA7/IAAOzy7fLw8gAAAAAAABXyAAAAAJLyAAAAABbyAAAAAJPyAAAAAJXyAAAAABfyAAAAAJTyAAAAAAAAgPKB8oLylvIAAIPyhPKF8pfyAAAAAAAAmvIAAJvyAACc8gAAAAAAABjyAAAAAAAAAACG8ofyiPKd8hryifKK8ovynvKN8o7yAACY8gAAAAAAAAAAj/KQ8pHymfIAAAAAGfIAAAAAAAAAAAAAe/J98hDyAAAAAAAAAABF8kbyQ/JE8try2/JH8kjy2fLY8tby1/JB8kLyTPJL8knySvLR8tLyUPJP8k3yTvJU8lPyUfJS8ljyV/JV8lbyYPJc8lnyWvJk8mPyYfJi8mXyZvJn8mjyafJq8mvybPJw8m/ybfJu8nTyc/Jx8nLyePJ38nXydvJ+8nzyefJ68qLyofJ/8vHypvKl8qPypPKq8qnyp/Ko8q7yrfKr8qzysvKx8q/ysPK28rXys/K08rryufK38rjyvvK98rvyvPLC8sHyv/LA8sbyxfLD8sTyyvLJ8sfyyPLL8szy1PLT8tDyz/LN8s7y4PLh8t7y3/Li8uPy3PLd8gAAAAAAAFRWVVVVVVXVECIiIiIiIyIiIiIiIiIiIiQiIiIiIiIiIiIiIiIiUhAAAAAAAQIDBAAAAAUAAAAAAAAAAAAGAAcAAAgAAAAJAAAAAAAAAAAAAAAAAAAAAAAACgALDA0ODxAREhMUFQAAABYAFwAAAAAAAAAAAAAAABgZGhscHR4fICEiIyQlJicQIiIiIyIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiQhAyRERERERERERERGVEREREREREREREREdEREREREREmLpMTUT+EDIAAAAAAAAAAAECAwQAAAUGAAAAAAAABwgAAAAAAAAAAAAAAAAAAAAAAAAJAAAACgAAAAAAAAsAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAA4PEBESExQVFhcYGRobHBcXHR4fICEAAAAAAAAAIgAAACMAAAAAAAAAAAAAJCUmAAAAAAAAACcAACgpKgArLAAALS4ALzAxAAAAADIAADM0ADU2Nzg5OgAAAAAAOzw9Pj9AAAAAAAAAAAAAAAAAAAAAAAAAAABBAABCAABDAAAAAAAAAAAAAAAAAERFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjoADKAKEAwQCiAKIAowCjAKUAtACnAKQAqACsAKkAqQCqALsAqwDHAKwAwgCuAKgArwD4ALAAoQCxALEAtACrALUAtQC2AKYAtwDhALgA/AC6ALwAuwDIAL8AwADAAMsAwQDnAMIA5QDDAMwAxACAAMUAgQDGAK4AxwCCAMgA6QDJAIMAygDmAMsA6ADMAO0AzQDqAM4A6wDPAOwA0QCEANIA8QDTAO4A1ADvANUAzQDWAIUA2ACvANkA9ADaAPIA2wDzANwAhgDfAKcA4ACIAOEAhwDiAIkA4wCLAOQAigDlAIwA5gC+AOcAjQDoAI8A6QCOAOoAkADrAJEA7ACTAO0AkgDuAJQA7wCVAPEAlgDyAJgA8wCXAPQAmQD1AJsA9gCaAPcA1gD4AL8A+QCdAPoAnAD7AJ4A/ACfAP8A2AAxAfUAUgHOAFMBzwB4AdkAkgHEAMYC9gDHAv8A2AL5ANkC+gDaAvsA2wL+ANwC9wDdAv0AqQO9AMADuQATINAAFCDRABgg1AAZINUAGiDiABwg0gAdINMAHiDjACAgoAAhIOAAIiClACYgyQAwIOQAOSDcADog3QBEINoArCDbACIhqgACIrYABiLGAA8iuAARIrcAGiLDAB4isAArIroASCLFAGAirQBkIrIAZSKzAMol1wD/+PAAAfveAAL73wAAACs5LjkwOSs5MDkwZTA5LmUAAAAAAAAAAAAAAAAAAAABAgMBBAQEBAQEBAQEBAEDAQQEBAQEBAQEBAQBBQUFBQUFBQUFBQEGAQcBAQgICAgICAgICAgBCAgICAgICAgICAEFBQUFBQUFBQUFAQEBAQEBAQEBAQEJAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQkBCAgICAgICAgICAEDAQQEBAQEBAQEBAQBAQEBAQEBAQEBAQkBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBCQEAAAAQHSg4Q3qFAA8MCg8KNgo4AgACAwgGBQUHBAAAAQACAwAEBQAAAAAAAAAAAAAAADy/c3/dTxV1Mh0w+Uh3glr1+T/pA084TRduBbW1uJNGAIDgN3nDQUMAAAAAhNeXQQAAAAAAiMNAAAAAAAAAWUAAAAAAAAAkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eXwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgYWJjZGVmZ2hpamtsbW4Ab3BxcgBzdHV2d3h5egB7AHx9fn+AgYKDAISFAIaHiIkAAAAAAAAAAAAAAAAAAAAAigCLAAAAAIyNjo8AAAAAAJAAAACRAACSk5SVAAAAAGNyZmELAAAAAQAAAAAAAABjcDJjJgAAAAIAAAAAAAAAY3MyYyYAAAABAAAAAAAAAHRsYWMkAAAAAAAAAAEAAABlc2FjIQAAAAAAAAABAAAAZ2lsYwEAAAASAAAAEwAAAHBzcGMhAAAAAgAAAAMAAABod3NjJAAAAAQAAAAFAAAAZ2lsZAEAAAAEAAAABQAAAHRweGUUAAAACgAAABAAAABjYXJmCwAAAAIAAAAAAAAAZGl3ZhYAAAABAAAABwAAAHRsYWgWAAAABgAAAAcAAAB0c2loKAAAAAAAAAABAAAAYW5raCIAAAAAAAAAAQAAAGdpbGgBAAAAFAAAABUAAABsZ25oFwAAAAEAAAAAAAAAb2pvaBQAAAAMAAAAEAAAAGRpd2gWAAAAAgAAAAcAAABsYXRpIAAAAAIAAAADAAAANDBwahQAAAALAAAAEAAAADg3cGoUAAAAAgAAABAAAAAzOHBqFAAAAAMAAAAQAAAAMDlwahQAAAAEAAAAEAAAAGFnaWwBAAAAAgAAAAMAAABtdW5sFQAAAAEAAAACAAAAa3JnbQ8AAAAKAAAACwAAAGtjbG4UAAAADQAAABAAAABtdW5vFQAAAAAAAAACAAAAbmRybwoAAAADAAAAAAAAAHRsYXAWAAAABQAAAAcAAABwYWNwJQAAAAIAAAAAAAAAYW5rcBYAAAAAAAAABwAAAG11bnAGAAAAAQAAAAQAAABkaXdwFgAAAAAAAAAHAAAAZGl3cRYAAAAEAAAABwAAAGdpbHIBAAAAAAAAAAEAAAB5YnVyHAAAAAIAAAADAAAAZm5pcwoAAAAEAAAAAAAAAHBjbXMlAAAAAQAAAAAAAABscG1zFAAAAAEAAAAQAAAAMTBzcyMAAAACAAAAAwAAADIwc3MjAAAABAAAAAUAAAAzMHNzIwAAAAYAAAAHAAAANDBzcyMAAAAIAAAACQAAADUwc3MjAAAACgAAAAsAAAA2MHNzIwAAAAwAAAANAAAANzBzcyMAAAAOAAAADwAAADgwc3MjAAAAEAAAABEAAAA5MHNzIwAAABIAAAATAAAAMDFzcyMAAAAUAAAAFQAAADExc3MjAAAAFgAAABcAAAAyMXNzIwAAABgAAAAZAAAAMzFzcyMAAAAaAAAAGwAAADQxc3MjAAAAHAAAAB0AAAA1MXNzIwAAAB4AAAAfAAAANjFzcyMAAAAgAAAAIQAAADcxc3MjAAAAIgAAACMAAAA4MXNzIwAAACQAAAAlAAAAOTFzcyMAAAAmAAAAJwAAADAyc3MjAAAAKAAAACkAAABzYnVzCgAAAAIAAAAAAAAAc3B1cwoAAAABAAAAAAAAAGhzd3MkAAAAAgAAAAMAAABsdGl0EwAAAAQAAAAAAAAAbWFudBQAAAAOAAAAEAAAAG11bnQGAAAAAAAAAAQAAABkYXJ0FAAAAAAAAAAQAAAAZGl3dBYAAAADAAAABwAAAGNpbnUDAAAADgAAAA8AAAB0bGF2FgAAAAUAAAAHAAAAdHJldgQAAAAAAAAAAQAAAGxhaHYWAAAABgAAAAcAAABhbmt2IgAAAAIAAAADAAAAbGFwdhYAAAAFAAAABwAAADJ0cnYEAAAAAAAAAAEAAABydHJ2BAAAAAIAAAADAAAAb3Jleg4AAAAEAAAABQAAAAAQAREgMAIDEhMhMSIyIzMAAAAAAAAAALcCAAAAAAAAtwIAALcCAAC3AgAAAAAAAAAAAAAAAAAAAAAAAAAAAABtdmJhAQAAAG13bGIBAAAAcG1jYwEAAABsY29sAQAAAGtyYW0NAAAAa21rbQ0AAABnaWxyAQAAAAAAAAAAAAAAdGxhYwEAAABnaWxjAQAAAHNydWMBAAAAdHNpZAEAAABucmVrAwAAAGFnaWwBAAAAdGxjcgEAAAAAAAAAAAAAAGxvc2lhbmlmMm5pZjNuaWZpZGVtMmRlbXRpbmkAAAAAPQ0AAAAAAAA+DQAAPw0AAAAAAABADQAAAAAAAAAAAABBDQAAQg0AAAAAAAAEAAAAAgAAAAEAAAAAAAAAAAAAAAcHAAAHAAIABwABAAcAAgAHAAEABwAGAAcHAAAHAAIABwABAAcAAgAHAgUABwAGAAcHAAAHAAIABgEBAAYBAwAGAQQABgEGAAcHAAAHAAIABAEBAAQBAwAEAQQABAEGAAcHAAAHAAIABQABAAUAAgAFAgUABQAGAAcHAAAHAAIAAAABAAAAAgAAAgUAAAAGAAcHAAAHAAIABwABAAcAAgAHAwUABwAGAAAAAAAAAAAAAAAAAAAACAgACAgACAgICAgICAgICAgICAgICAgICAgDAAICAgIDAgMCAwMDAwMCAgICAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDAwgCAgIAAgICAwMDAwMDAwMDAwMDAwMDAwICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDAgICAgICAgICAwIDAgMDAgIIAggICAgICAgACAgICAgICAgICAgICAgICAICCAgICAgICAgICAMDAwgIAwgICAgICAgICAgICAgICAcECAMDAwUFAgICAwMDAwIDAwMDAwMDAwMCAwUDAgMDBQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgMDAwMDAwMDAwMDAgICAwMDAwMDAwMDAwMDAwMDAgIDAwMDAgMCAgMDAwICAwMDAwMDCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMICAgICAgICAgICAgICAgDCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgMDAwMDAgIDAgMDAwMDAwMDAwMCAwICAggICAgICAgDAAMDAwMAAgMCAggICAgIAgICAgICAgICAgICAgICAgICAgMDAwMAAAMDAwMDAggAAAgICAgICAgICAgICAgIAwMDAwMDAwMDAwICAgACAwMCAgMDAwMDAwIDAwMDAwMDAwMDAwMDAwMICAgICAgICAgICAgICAgICAgICAgICAgIAAADCAgDCAgIAAgICAgICAgICAgICAgICAgIAwMDAwMDAwMDAwMDAwMD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AQQBBAEEAQQBBAEEAQQBBAEEAA4BBAEEAQQBBAEEAQQPBAAOAQQBBAAOAQQBBAAOAQQBBAAOAA4DDgAOBwwHAg0MBwwHDAAOAA4ADgAOBwwHDAAOAA4HDAcMBAgADgAOAA4HCAAOAA4ADgAOAA4ADgAOAQQBBAEEAQQADgEEAA4ADgAOAA4ADgAOAA4KBAoECgQKBAoECgQKBAoECgQKBAgNCA0BBAEEAA4QBAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4IDQgNCA0ADgIEAgQCBAIEAgQCBAIEAgQCBAAOAgQCBAIEAA4CBAIEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAAOAQQBBAEEAQQBBAEEDwQADgEEAQQADgEEAQQBBAEEAQQADgAOAw4RDQcMBwIHDAcMBwwHDAcMBwkADgcJBwkHDAAOBwwHDAQIAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAgQCBAcMBwwADgAOCgQKBAoECgQKBAoECgQKBAoECgQADgAOAA4ADgAOAA4ADgAOAA4BBAkNAw4JDQMOAw4DDgAOCAcIDQgNAA4CBAIEAgQCBAIEAgQCBAIEAA4ADgIEAgQADgAOAgQCBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQADgEEAQQBBAEEAQQBBA8EAA4BBAEEAA4BBAEEAQQBBAEEAA4ADgMOEQ0HDAcFBwwHCQcJBwkHCQAOAA4HAgcFAA4ADgcMBwwECAAOAA4ADgAOAA4ADgAOAw4HBQcMAA4ADgAOAA4BBAEEAA4BBAIEAgQHCQcJAA4ADgoECgQKBAoECgQKBAoECgQKBAoEAA4BBAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOCA0ADgAOAgQCBAIEAgQCBAIEAA4ADgAOAgQCBAIEAA4CBAIEAgQBBAAOAA4ADgEEAQQADgEEAA4BBAEEAA4ADgAOAQQBBAAOAA4ADgEEAQQBBAAOAA4ADgEEAQQPBAEEAQQBBAEEAQQBBAEEAQQBBAAOAA4ADgAOBwwHDAcJBwwHDAAOAA4ADgcCBwIHAgAOBwwHDAcMBAYADgAOAA4ADgAOAA4ADgAOAA4HDAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4KBAoECgQKBAoECgQKBAoECgQKBAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOCA0IDQgNCA0IDQIEAgQCBAIEAgQCBAIEAgQADgIEAgQCBAAOAgQCBAIEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAAOAQQBBAEEAQQBBAEEDwQBBAEEAQQBBAEEAQQBBAEEAQQADgAOAw4RDQcHBwcHBwcHBwcHCQcJAA4HBwcHBwcADgcHBwcHBwQGAA4ADgAOAA4ADgAOAA4HBwcHAA4BBAEEAQQADgAOAQQADgAOAgQCBAcHBwcADgAOCgQKBAoECgQKBAoECgQKBAoECgQADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgoECA0IDQgNAA4CBAIEAgQCBAIEAgQCBAIEAA4CBAIEAgQADgIEAgQCBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQADgEEAQQBBAEEAQQBBA8EAQQBBAEEAA4BBAEEAQQBBAEEAA4ADgMOEQ0HBwcHBwcHBwcHBwkHCQAOBwcHCQcJAA4HCQcJBwcEBgAOAA4ADgAOAA4ADgAOBwkHCQAOAA4ADgAOAA4ADgEEAQQADgIEAgQHBwcHAA4ADgoECgQKBAoECgQKBAoECgQKBAoEAA4SBBIECA0ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4IDQgNCA0IDQoEAgQCBAIEAgQCBAIEAgQCBAAOAgQCBAIEAA4CBAIEAgQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQPBAEEAQQBBAEEAQQBBAEEAQQBBAEEBwkHCRENBwwHDAcMBwwHDAcMBwwADgcCBwIHAgAOBwwHDAcMBAYODgAOAA4ADgAOAA4BBAEEAQQHDAAOAA4ADgAOAA4ADgAOAgQCBAIEBwwHDAAOAA4KBAoECgQKBAoECgQKBAoECgQKBAAOAA4ADgAOAA4ADgAOAA4ADgAOAQQBBAEEAQQBBAEEAQQBBAEEAQQPBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEDwQBBAEEAQQBBAEEAgQCBAIEAgQCBAIEAgQCBAIEAgQXCxcLFAYUBhUIFQgWAwkNFAYUBhQGCQ0DDggNBA4gDiYOJA4lDiMOAQQKBAoECgQKBAoECgQKBAoECgQKBAoECgQADgAOAQQADgEEAQQCBAIEAgQCBBcLFwsVCBUIDwQBBAEEAQQmDiYOKQ4BBBcLJw4nDgEEAQQXCxcLJw4nDicOJw4nDgEEAQQBBBQGFAYUBhQGAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQlDhcLFgMUBhQGCA0IDQgNCA0IDQgNCA0BBAgNCgQKBAoECgQKBAoECgQKBAoECgQIDQgNCA0UBgAOAA4BBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEDwQBBAEEAQQBBAEEAQQBBAEEAgQCBAIEAgQCBAIEAgQCBAIEAgQCBAIEAgQCBAIEAgQCBAAOAA4XCxQGFAYUBhQGFQgVCBUIFAYXCxcLFgMWAxYDFwsXCxoOGw4bDhkOGQ4aDhkOGg4aDhoOGg4aDgQOGw4ADgAOAA4ADgAOCgQADgAOEQ0bDgAOAA4KBAoECgQKBAoECgQKBAoECgQKBAAOAA4ADgAOAA4ADgkNCQ0JDQAOCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNEQ0RDRENEQ0JDRENEQ0RDRENAQQBBAkNAQQBBAkNCQ0JDQoEAA4ADgAOAA4ADgAOAA4ADgAOBQ4GDgAOAA4KBAoECgQKBAoECgQADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4KBAAOAA4ADgAOAA4ADgAOAA4ADggNAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4IDQgNCA0ADgAOAA4ADgAOAA4KBAoECgQKBAAOCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNEQ0RDRENEQ0RDRENAA4ADgAOAA4ADgAOAgQHCQEEAQQBBAEEAQQUBgAOAQQBBAEEAQQBBAEEAQQBBAEECgQKBAoECgQKBAoECgQKBAoECgQBBAEEAQQBBAEEAA4BBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAEEAQQBBAAOAQQBBAEECgQKBAoEAA4ADgAOAQQnDgMOAw4BBAEEKA4oDigOKA4oDigO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c3ZiYXN3bGJzdHNwASkDKQUnBQgDKQMnAycFJwUnAycDJwMpBScBDwMnAycDKAMnAykDKQMnAykDKQMpAykDKQUnBQgDKQMnAycFJwUnAycDJwMpBScBDwMpAycDJwMoAycDKQMpAycDKQMpAykDKQMpAykDKQEpAQ8AAAEBAgMEBAAFBgEBAAAABwAACAAJCgsMAAAAAAAAAAANAAAODxAREhMUABYXGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVHxUVICEiIyQlJhUYGBUZFRUVFRUVFRUVFRUVFRUeFRUVFRUVFRUnFRUVFRUVJBUYGBUZFRYVGBgVGRoVFRUVFRUVFRUVKBUVHhUVFRUVFRUVKRUVKhUVFSQVKRUWFRgYFRkaFRUVFRUVFRUVFRUVFR4VFRUVFRUVFRUVFRUVFRUkFSsVGBgVGSQVFRUVFRUVFRUVFRUVFRUVFRUVFRUVLBUVFRUVFSQVGBgVGRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVLBUVFRUVFSQVGBgVGRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFSQVFhUYGBUZGhUVFRUVFRUVFRUoFRUeFRUVFRUVFRUVFRUVFRUVJBUWFRgYFRkaFRUVFRUVFRUVFSgVFR4VFRUVFRUVFSkVFRUVFRUkFRYVGBgVGRoVFRUVFRUVFRUVKBUVHhUVFRUVFRUVKRUVFRUVFSQVKRUYGBUZFRUVFRUVFRUVFRUVFRUeFRUVFRUVFRUVFRUVFRUVJBUBARUVFRUVFRUVFRUVFQEVFhUYGBUZGhUVFRUVFRUVFRUbHBUeFRUVFRUVFRUVFRUVFRUVJBUWFRgYFRkaFRUVFRUVFRUVFRUcFR4VFRUVFRUVFRUVFRUVFRUkFRYVGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVFRUVFRUVFSQtFRYVGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVFRUVFRUVFSQVFhUYGBUZGhUVFRUVFRUVFRUbHB0eFRUVFRUVFRUfFRUgISIjJBUmFRYVGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVLRUVFRUVFSQVJhUWFRgYFRkaFRUVFRUVFRUVFRscHR4VFRUVFRUVFS0VFRUVFRUkFRYVGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVFRUVIBUiFSQVJhUWFRgYFRkaFRUVFRUVFRUVFRscHR4VFRUVFRUVFS0VFSAVFRUkFSYVFhUYGBUZGhUVFRUVFRUVFRUbHB0eFRUVFRUVFRUuFRUgISIVJBUmFRYVGBgVGRoVFRUVFRUVFRUVGxwdHhUVFRUVFRUVFRUVICEiFSQVJhUWFxgYFRkaFRUVFRUVFRUVFRscHR4VFRUVFRUVFR8VFSAhIiMkFSYVMDAvBS8vLy8vLy8vLy8vLy8vDC8vLy8vLy8vMS8vLy8vLxIvMDAvBS8CLzAwLwUGLy8vLy8vLy8vLzIvLwwvLy8vLy8vLzMvLzQvLy8SLzMvAi8wMC8FBi8vLy8vLy8vLy8vLy8MLy8vLy8vLy8vLy8vLy8vEi81LzAwLwUSLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzYvLy8vLy8SLzAwLwUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzYvLy8vLy8SLzAwLwUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8SLwIvMDAvBQYvLy8vLy8vLy8vMi8vDC8vLy8vLy8vLy8vLy8vLxIvAi8wMC8FBi8vLy8vLy8vLy8yLy8MLy8vLy8vLy8zLy8vLy8vEi8CLzAwLwUGLy8vLy8vLy8vLzIvLwwvLy8vLy8vLzMvLy8vLy8SLzMvMDAvBS8vLy8vLy8vLy8vLy8vDC8vLy8vLy8vLy8vLy8vLxIvNzcvLy8vLy8vLy8vLy83LwIDMDAvBQYvLy8vLy8vLy8vCQoLDC8vLy8vLy8vDS8vDg8QERITFC8CLzAwLwUGLy8vLy8vLy8vLwkKLwwvLy8vLy8vLy8vLy8vLy8SLwIvMDAvBQYvLy8vLy8vLy8vLwovDC8vLy8vLy8vLy8vLy8vLxIvAi8wMC8FBi8vLy8vLy8vLy8JCgsMLy8vLy8vLy8vLy8vLy8vEjgvAi8wMC8FBi8vLy8vLy8vLy8JCgsMLy8vLy8vLy8vLy8vLy8vEi8CLzAwLwUGLy8vLy8vLy8vLwkKCwwvLy8vLy8vLw0vLw4PEBESLxQvAi8wMC8FBi8vLy8vLy8vLy8JCgsMLy8vLy8vLy84Ly8vLy8vEi8ULwIvMDAvBQYvLy8vLy8vLy8vCQoLDC8vLy8vLy8vOC8vLy8vLxIvAi8wMC8FBi8vLy8vLy8vLy8J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FhcYGQUaGxwFHR4fICEiIyABBSQFJQUFIwUnKCYpJiYmJiYmJiorLC0uLzAxMiczNDU2Jjc4OSY6OyY8PT4/PCYmJiZAJiY/JicoJikmJiYmJiYmKissLS4vMDEyJzM0NTYmNzg5JiYmJjw9Pj88JiYmJkAmJj8mJyYmJiYmJiYmJiYmJikmJiYmJiYmJissLS4mJiYmJiYmJiYmNzg5JiYmJiY9Pj9BJiYmJismKSYmJiYmJiYmKywtLiYmJiYmJiYmJiY3ODkmJiYmJj0+P0EmKSYmJiYmJiYmJiwtLiYmJiYmJiYmJiYmJiYmJiYmJj0+PyYpJiYmJiYmJiYmJi0uJiYmJiYmJiYmJiYmJiYmJiYmPT4/JikmJiYmJiYmJiYmJi4mJiYmJiYmJiYmJiYmJiYmJiY9Pj8mKSYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJj0+JikmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmPiYpJikmJiYmJiYmJiYsLS4mJiYmJiYmJiYmNzg5JiYmJiY9Pj9BJikmJiYmJiYmJiYsLS4mJiYmJiYmJiYmJjg5JiYmJiY9Pj9BJikmJiYmJiYmJiYsLS4mJiYmJiYmJiYmJiY5JiYmJiY9Pj9BJkImJiYmJiYmJiYmJiYpJikmJiYmJiYmJiYsLS4mJiYmJiYmJiYmJiYmJiYmJiY9Pj9BJikmJiYmJiYmKissLS4mJiYmJiY0NTYmNzg5JiYmJiY9Pj9BJiYmJismKSYmJiYmJiYmKywtLiYmJiYmJjQ1NiY3ODkmJiYmJj0+P0EmJiYmKyYpJiYmJiYmJiYrLC0uJiYmJiYmJjU2Jjc4OSYmJiYmPT4/QSYmJiYrJikmJiYmJiYmJissLS4mJiYmJiYmJjYmNzg5JiYmJiY9Pj9BJiYmJismQyYpJiYmJiYmJiorLC0uJjAxJiYmNDU2Jjc4OSYmJiYmPT4/QSYmJiYrJikmJiYmJiYmJissLS4mJiYmJiYmJiYmNzg5JiYmJiY9Pj9BJiYmJismQyYpJiYmJiYmJiorLC0uJiYxJiYmNDU2Jjc4OSYmJiYmPT4/QSYmJiYrJkMmKSYmJiYmJiYqKywtLiYmJiYmJjQ1NiY3ODkmJiYmJj0+P0EmJiYmKyZDJikmJiYmJiYmKissLS4vMDEmJiY0NTYmNzg5JiYmJiY9Pj9BJiYmJismJygmKSYmJiYmJiYqKywtLi8wMTImMzQ1NiY3ODkmJiYmPD0+PzwmJiYmQCYmPyYnJiYmJiYmJiYmJiYmKSYnJiYmJiYmJiYmJiYmKSYmJiYmJiYmKywtLiYmJiYmJiYmJiY3ODkmJiYmJj0+P0EmKSYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmOjsmKSYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJjsmBEVERkRERERERERHSElKS0xNTk8EUFFSU0RUVVZEREREV1hZWltEREREXEREXUQERERERERERERERERERkRERERERERESElKS0RERERERERERERUVVZERERERFhZWl5ERERESERGRERERERERERISUpLRERERERERERERFRVVkREREREWFlaXkRGRERERERERERESUpLREREREREREREREREREREREREWFlaREZERERERERERERESktERERERERERERERERERERERERYWVpERkRERERERERERERES0RERERERERERERERERERERERFhZWkRGREREREREREREREREREREREREREREREREREREREREWFlERkRERERERERERERERERERERERERERERERERERERERERZREZERkRERERERERERElKS0RERERERERERERUVVZERERERFhZWl5ERkRERERERERERElKS0REREREREREREREVVZERERERFhZWl5ERkRERERERERERElKS0RERERERERERERERFZERERERFhZWl5EYF9fX19fX19fX19fX2FfRkRERERERERERElKS0RERERERERERERERERERERERFhZWl5ERkRERERERERHSElKS0RERERERFFSU0RUVVZERERERFhZWl5ERERESERGRERERERERERISUpLREREREREUVJTRFRVVkREREREWFlaXkRERERIREZEREREREREREhJSktEREREREREUlNEVFVWRERERERYWVpeREREREhERkRERERERERESElKS0REREREREREU0RUVVZERERERFhZWl5ERERESERiREZERERERERER0hJSktETU5ERERRUlNEVFVWRERERERYWVpeREREREhERkRERERERERESElKS0RERERERERERERUVVZERERERFhZWl5ERERESERiREZERERERERER0hJSktERE5ERERRUlNEVFVWRERERERYWVpeREREREhEYkRGREREREREREdISUpLREREREREUVJTRFRVVkREREREWFlaXkRERERIRGJERkRERERERERHSElKS0xNTkRERFFSU0RUVVZERERERFhZWl5ERERESEQERURGREREREREREdISUpLTE1OT0RQUVJTRFRVVkRERERXWFlaW0RERERcRERdRARjY2NjY2NjY2NjY2NkYwRfX19fX19fX19fX19hXwRERERERERERERERERGRERERERERERISUpLRERERERERERERFRVVkREREREWFlaXkRkY2ZnZQZoaGhoaGhoaGhpaGprREZEREREREREbG1ub3BxcnN0anV2d3hEeXp7RDo7RHx9fn+ARERERIFERIJEamtERkRERERERERsbW5vcHFyc3RqdXZ3eER5entEREREfH1+f4BEREREgUREgkRqRERERERERERERERERkREREREREREbW5vcERERERERERERER5entERERERH1+f4NEREREbURGRERERERERERtbm9wRERERERERERERHl6e0REREREfX5/g0RGREREREREREREbm9wREREREREREREREREREREREREfX5/REZEREREREREREREb3BERERERERERERERERERERERER9fn9ERkREREREREREREREcERERERERERERERERERERERERH1+f0RGREREREREREREREREREREREREREREREREREREREREfX5ERkRERERERERERERERERERERERERERERERERERERERER+REZERkRERERERERERG5vcERERERERERERER5entERERERH1+f4NERkRERERERERERG5vcEREREREREREREREentERERERH1+f4NERkRERERERERERG5vcERERERERERERERERHtERERERH1+f4NEhF9fX19fX19fX19fX2FfRkRERERERERERG5vcERERERERERERERERERERERERH1+f4NERkRERERERERsbW5vcERERERERHZ3eER5entERERERH1+f4NEREREbURGRERERERERERtbm9wREREREREdnd4RHl6e0REREREfX5/g0RERERtREZERERERERERG1ub3BEREREREREd3hEeXp7RERERER9fn+DRERERG1ERkREREREREREbW5vcEREREREREREeER5entERERERH1+f4NEREREbUSFREZEREREREREbG1ub3BEcnNERER2d3hEeXp7RERERER9fn+DRERERG1ERkREREREREREbW5vcERERERERERERER5entERERERH1+f4NEREREbUSFREZEREREREREbG1ub3BERHNERER2d3hEeXp7RERERER9fn+DRERERG1EhURGRERERERERGxtbm9wREREREREdnd4RHl6e0REREREfX5/g0RERERtRIVERkRERERERERsbW5vcHFyc0RERHZ3eER5entERERERH1+f4NEREREbURqa0RGRERERERERGxtbm9wcXJzdER1dnd4RHl6e0RERER8fX5/gERERESBRESCRGpjY2NjY2NjY2NjY2NkY2pfX19fX19fX19fX19hX2pERERERERERERERERGRERERERERERtbm9wRERERERERERERHl6e0REREREfX5/g0RkYwgJhguGhoaGhoaGDQ4PEBESExQVCBYXGBmGGhschoaGhiAhIiMghoaGhiWGhiOGCIaGhoaGhoaGhoaGhguGhoaGhoaGhg4PEBGGhoaGhoaGhoaGGhschoaGhoYhIiOHhoaGhg6GC4aGhoaGhoaGDg8QEYaGhoaGhoaGhoYaGxyGhoaGhiEiI4eGC4aGhoaGhoaGhg8QEYaGhoaGhoaGhoaGhoaGhoaGhiEiI4YLhoaGhoaGhoaGhhARhoaGhoaGhoaGhoaGhoaGhoaGISIjhguGhoaGhoaGhoaGhhGGhoaGhoaGhoaGhoaGhoaGhoYhIiOGC4aGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhiEihguGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGIoYLhguGhoaGhoaGhoYPEBGGhoaGhoaGhoaGGhschoaGhoYhIiOHhguGhoaGhoaGhoYPEBGGhoaGhoaGhoaGhhschoaGhoYhIiOHhguGhoaGhoaGhoYPEBGGhoaGhoaGhoaGhoYchoaGhoYhIiOHhoiGhoaGhoaGhoaGhoYLhguGhoaGhoaGhoYPEBGGhoaGhoaGhoaGhoaGhoaGhoYhIiOHhguGhoaGhoaGDQ4PEBGGhoaGhoYXGBmG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AABljGWNjo8AkJGSk5SVlgCXmJmalJucnZ6foAChoqOkpaanqKmqq6w4ra6vsLGyAAAAAAA4s7QAOLW2ADi3uLm6u7wAAAAAADi9AAAAAAAAvr/AAADBwsPExcY4xwAAAMjJysvMzQAAzs/Q0dJDAAAAAAAAAAAA09TV1gAAAAAA19fX19fX19fX2NnX19fX19fX19fX19fa29wAAAAAAAAAAAAAAABDADjdAAAAAAAAAADe3wAAAAA4OODh4gAA4zg4ODg4ODg4ODg4ODg45OU4ODjm5wAAAAAAAOgAAAAAOOnqAAAAAAAAAAAAZes47AAAAAAAAGXtAAAAAAAAZe44OO8AAAAAAPDw8PDw8PDw8fHx8fHx8fIAAAAAAAAAAAAAAAAAAAEAAgICAgIAAAAAAAAAAAMEAAUAAAAAAAYAAAcAAAAAAAAAAAABAAAAAAAAAAAAAAAICQAAAAAAAAAAAAAAAAICAgICAgICAgICAgICAgIKCwsLCwAAAAkMAAICAgINDgAACw8CAgICAgICAgICAhAREhMUFRYQFxgZDBobFAICAgICFAACAgICAgACAgICAgICHB0eAgICCR4JHgICAgICAgICAgIJAgICCQkAAgIAERITFB8gISAiAAAAACMAAAIeAgAAAAAACSQMDx4CAgkAHgkCHgkCACUSEx8AGyYbJwAoAAAAHgIJCQAAAAICAgICKSorAAAAAAAMDx4CAgICHgIeAgICAgICCQIeAgIAERITFBUbFiMYAAAAAAAeKSksDB0eAgICCR4JAh4CAgARLQAAGxYAAAIeHgAAAAAAAAAALh4CAgkAAgkCAgAeCQkCAB4JAAIJAAICAgICAgAAFxAvADAhMCIAAAAAIwAAAAAPHTECAgIJAgkCAgICAgICAgICAgIAERYQFy8WJhYnAAAAGx8CCQAACh0eAgICCQICAh4CAgARLQAAIy8AAAAJMjMAAAAAAAALHQICAgIJAgICAgICNDUXExQfMCEwIjYAAAAjAAAAHgwdHgICAgICAgICCQACAgICHgICAgIeAAICAgkANwAjFxYfHxIwMBkAFwAAAAAAAAIAAgkAAAAAAAAAABQAAAACAjg4OQAAEgICAgIeAgICAgICAgICCQA6FTsWFhQULhULHwsCAjw9PT09PT49PT09PT09PT09PT09PT09PT8AAAAAQAAAAAACAgICAkEtO0IWFkNERUZHAgICAgIBAAUCAgIXFAICSEdJSkFJHR0CNBY1AgICAgICS0xNHR1OTwICAgICHS0AAjtQAAAAAB4COy8AAAAAAAI7AAAAAAAAAgICAgICCQIJOwAAAAAAAAICUS0WOxQwMDAwD1JTVFVWVwAAAABYAAkAAB4AWVFaAgICAgkAAAAqKltcAgICAgICAgINCQAAXQICAgICAgICAgICAgICCRZQLRZePQAAX2BfX2FiAAACAgICAgICAAICCQAAAAAAAgICAgICAAACAgICHQAAAAICAgICCQAAAgICNGMtAAACAmRlZmc9P2gQLRY7FVAwMEwLCwtpLigLakoCAgICAgICaxYUFBYwMBZsAgICCQAAAAAAAG1ubm5uAAAAAAAAakoCAgICAgI8PTsZFm89AgICAmsWFy0tZnAAAAAAAAACAj0SMBdxZmZmcnMAAAAAAgICAgIAHgILLnR0dAt0dA90dHQaACgAAAB1MwsFAAAAAAAAAHYAAAAAAAAABnd4KioFAAAAAAAAAAAAAHh4eXh4eHh4eHh4AAB6AAAAAAAAB3oAAAAAAC4AAAAAAAAAAAAAAAAACQAAAAB7ewAAAAICAgIAAAAeAAAAAAAAAHwAe3sAAAAAAAI1AmwCCgICAkETEAAAHwACAgAAAAAAAB0CAgICAgICAgJ9FxcXFxcXF34AAAAAAAsLCwsLCwsLCwIAAAAAADQCAgIWFn90AAICAoAUOxRxZoEAAAAAAAALggICAgICAgKDFxYUMISFhgAAAAAAAAACAjQeAgICAgICAgIKFjtjTIeIiQAAAAACigICAgKLAB4CKgUATw8CNRaMNDUCAmkKCQAAAAAAAAICAgICjRUZAACOjwAAAAACQS0XUC+QAFFRUVFRUVFRAAAAAAAAAAZ4eHh4eQAAAAICAgICCQICAgkCHgICAgICHgICAh4JAIAUGx8AAJGSAgIeAh4CAgICAgIADiUAkwICDSUAHgICAgAAAAAAAAAAAAAAHgICCQICCykAAAAAAgICABsWFh4CAgIAAAAAAAICAgICGyYAAgICdHR0dHSUAgkAAAAAAAIODgAAAAAACQICCQICAgIeAgkAHgIAAJWWlwICAgICAgICAhYWFBQUFhaGAAAAAACYmJiYmJiYmJiYAgICAgI1NDUAAAAAmQtKAgICAgICEhMVEBglAAAAHwAAAAAAAAsxAgICAgICAgICgBQWmhYVm5wCAgICAgAAQZ0AAAAAAg0AAAAAAAACQRkUFBQWFmyeAAA4nx+gHgICAgICAgICAgICAgIXExYWoSwAAAAxgAAAAAAAAAACAgIJCQICHgICAgICAgIeAgICAgICAgoSExUWoh8AAAsLHgICAgkeCQIeAgI6ERcQFy8gISAiAAAAACMAAAACAhcACwsLLgALCy4AAAAAAAICAgICHgAJAgICHi07FBQfISAgGaMdpKUlAAAAAAAADBoAAAAAAAACAkEZFBQUFhd+DxEAAAAAAgICAgIAAKanAAAAAAAAABITFBRCYxmgC6gJAAAAAAACAgICAgICQRkUFAAwMAupJQAAAAAAAAAAAAAAAgIUABcTFBQVEFKpJgAAAAAAAAACAgICAgqqGRQWFqgJAAAAAgICAgIJK4gXFhRMFRYAAAICAgkAAAAAAgICAgICEhMUFRZpqSUAAAICAgkeAAICAgIeCQICAgIXFxIgIQyrpaytAAAAAAAAAgICAgACAgJBGRQUABYXHWwAIQAAAAAANBQWFhaMAgICrq8LD7A9sQAAAZMAAAAANBQWEBMUAgICAp6enrKysrKysg+zAB4AFhQUHxYWC6kAPT09PT09PUIVUi4AAAAAAgICCQIeAgI0FhYfACYWGwuftLUAAAAAAgICHgkCAgICAgICAhcXLxYjUkQAAAAAArZCLwAAAAALtwICAgICAgICFxYUHwAwEI8AAAAAAAACAgICApwAALi4uLi4uLi4ubm5uru5uLi8uLi9vr6+vr6+vgAAAAAAuLi4uLi/AAACAgICAgICFhYWFhYWwMHCCwsLLgAAAAAdSgICAgICAgICAgICQS8AAgICAgIJADrDFBQUFBQUFBQUFBQUFBQUFBQUFAAAACh0GgAAAAAAAAAACQAAAAAAAAAAAAAAAB4CAgICAgA6JQAGeHh4eQAACwsLMQICAgACAgICAgAAAgICAgICAgIuAgICAgICCwsCAgICAgIWFgICAgICAgIUAgIsLCxcAAAAAAAFAQEAMwA0BQAAEC8vAAYBAAElJSUAJQEgICAlJyEjIAEjFiMiIiIiISEhIyMjDBYjJgAAIQUlJycAASIAABYWABYMACMtACAAIQAhDAAmJR8FBQAcHx8j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IE5VSCAgeWgwRVlIICB5aCBFWUggIHpoIFJFSCAgYWkgQU5JICBkaSBETkkgIGRpIFlMTSAgZWkgRUxJICBnaSBPQkkgIGlpIE1JWSAga2kgS1BJICBuaSBETkkgIG5pIFlMTSAgb2kgT0RJICBzaSBMU0kgIHRpIEFUSSAgdWkgVU5JICB1aUtVTkkgIHdpIFJXSSAgYWogTkFKICBpaiBJSUogIHZqIFZBSiAgd2ogVkFKICBhayBUQUsgIGdrME5PSyAgaWsgS0lLICBqayBBVUsgIGtrIFpBSyAgbGsgTlJHICBtayBNSEsgIG5rIE5BSyAgb2sgUk9LICBvayBIT0sgIHJrIFJOSyAgc2sgSFNLICB1ayBSVUsgIHZrIE1PSyAgd2sgUk9DICB5ayBSSUsgIGFsIFRBTCAgYmwgWlRMICBnbCBHVUwgIGlsIE1JTCAgbmwgTklMICBvbCBPQUwgIHRsIEhUTCAgdWwgQlVMICB2bCBJVkwgIGdtIEdMTSAgaG0gSEFNICBpbSBJUk0gIGttIERLTSAgbG0gTEFNICBsbSBSTE0gIG5tIEdOTSAgb20gTE9NICBvbSBNT1IgIHJtIFJBTSAgc20gWUxNICB0bSBTVE0gIHltIE1SQiAgYW4gVUFOICBibiBST04gIGRuIEJETiAgZW4gUEVOICBnbiBHRE4gIGxuIERMTiAgbm4gTllOICBvbiBST04gIHJuIEJETiAgdm4gVkFOICB2biBIVEEgIHluIElIQyAgY28gSUNPICBqbyBCSk8gIG1vIE9STyAgcm8gSVJPICBzbyBTU08gIGFwIE5BUCAgaXAgTEFQICBscCBLTFAgIHNwIFNBUCAgdHAgR1RQICB1cSBaVVEgIG1yIFNNUiAgbnIgTlVSICBvciBNT1IgIHVyIFNVUiAgd3IgQVVSICBhcyBOQVMgIGNzIERSUyAgZHMgRE5TICBlcyBNU04gIGdzIE9HUyAgaHMgU09CICBocyBWUkggIGhzIEJSUyAgaXMgSE5TICBrcyBZS1MgIGxzIFZMUyAgbXMgT01TICBuczBBTlMgIG9zIExNUyAgcXMgSVFTICBycyBCUlMgIHNzIFpXUyAgdHMgVE9TICB1cyBOVVMgIHZzIEVWUyAgd3MgS1dTICBhdCBNQVQgIGV0IExFVCAgZ3QgSkFU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IGN1cSBDVVEgY3VxIE5ZTSBkdXEgSVZRIGR1cSBaVVEgZnVxIFpVUSBndXEgSVZRIGd1cSBaVVEgaHVxIEhVUSBodXEgWlVRIGt1cSBaVVEgbHVxIEhVUSBsdXEgWlVRIG11cSBOWU0gcHVxIElWUSBwdXEgWlVRIHJ1cSBIV1EgcnVxIFpVUSBzdXEgSFVRIHN1cSBaVVEgdnVxIE5ZTSB3dXEgSVZRIHd1cSBaVVEgeHVxIEhXUSB4dXEgWlVRIHl1cSBaVVEgYXZxIEhXUSBhdnEgWlVRIGN2cSBaVVEgZXZxIFpVUSBodnEgSFdRIGh2cSBaVVEgaXZxIElWUSBpdnEgWlVRIGp2cSBJVlEganZxIFpVUSBsdnEgSFdRIGx2cSBaVVEgbXZxIEhXUSBtdnEgWlVRIG52cSBIV1EgbnZxIFpVUSBvdnEgSVZRIG92cSBaVVEgcHZxIEhXUSBwdnEgWlVRIHN2cSBaVVEgd3ZxIEhXUSB3dnEgWlVRIHp2cSBJVlEgenZxIFpVUSBhd3EgSFdRIGF3cSBaVVEgY3dxIFpVUSBod3EgSFdRIGh3cSBaVVEgc3dxIEhXUSBzd3EgWlVRIHR3cSBIVEEgYXhxIEhXUSBheHEgWlVRIGN4cSBIV1EgY3hxIFpVUSBoeHEgSFdRIGh4cSBaVVEgbHhxIElWUSBseHEgWlVRIG54cSBIV1EgbnhxIFpVUSBveHEgSFdRIG94cSBaVVEgcHhxIFpVUSByeHEgSVZRIHJ4cSBaVVEgdHhxIEhXUSB0eHEgWlVRIHV4cSBaVVEgd3hxIEhXUSB3eHEgWlVRIGdhciBIVUwgbGFyIE5JUSBiYnIgR0xQIGxiciBLSUIgZmNyIFBQQyBmaXIgRklSIGZpciBSQkIgaWtyIEtSQSBjbXIgWU9SIGZtciBZT1IgbG1yIFlPUiBubXIgWU9SIG9tciBZT1Igc21yAAAAACB3bXIgWU9SIHltciBZTVIgeW1yIFlPUiB6bXIgS1JBIG1vciBZT1IgcG9yIFBQQyBjdHIgTklRIGV1ciBZU1IgcndyIFdBTSBkYXMAAAAAIGhhcyBLQVkgbWFzIEFBUCB5YXMAAAAAIGZjcyBQUEMgaGNzIE5JUSBpY3MgUFBDIGtjcyBEQVMgc2NzIFNDUyBzY3MgQUxTIHNjcyBIVEEgY2Rz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tBsbGxsbGxsbGxsbGxssLBsbLCwsLD4kmyQkJCS1LCwkJCQrK1AsLCQkJCQkJCRdJCQsLCQkJCS2aWksLCwsLAsLCwsQEBAQCwssLBAQEBAQEBAQEBAsLCQkJCQsLCwsJCQsLCwsLF0LCwsLCy8LCwsvC5YQEBAQEJYQEBAQEBAQlhAQEJZuLCgoKDQoKCgoUSgoKChRLCwkJCQsPSQkJCQkJD49LD0+JCQkXRsbGxskJCRNoxsbGywsLLMbGxsbJD0kLCyzGxskJCQbGxssXSQkJCQkLCxdJCQkJCwsGyQsGxsbGxsbG0YrOVAsLCsrJCQ+JD4kJCQkJCQsK1AsORsbGxtkLCwsAgICAkAsLCwkJCQkJCS3HiQkJCQkJLcbJCQkJE4kJCQkJEZQLLMbGwICAkAsLCwsJCQkLF0CAgIkJCQsGxsbGyQ9LCwbGxsbJCwsLF0CQCwsLCwssxsbGwsvLCwsLCwsEG4sLCwbGxskJCsrLCwsLAcHBwcHJCRFCwsLLDkrK58QEBAsLCwsCBsbGxsbGxtkJCQkJCQ5uCwkLCwsLCwsLCwkPSwsLCwsLCwsLCwsKysbGxtfLCwsLLQbHgICLCwsJCsrAgIsLCwkJLcbGxssLFdiJCQkJCQkJCQkJCsrKysrKys8AgICLBsbGwcHBwcHR0ZHLCwsLDlWVytVVzy5AgJQLCwsLE8sK0ckJCQkJCQkJCRGKytXKysrUAcHBwcHAgJeYiwsLCwkRgI9LCwsLCReVisrKytVYiQ/AjsrPFcHBwcHBz8/ArMbGxsbGxsbGxtkLCwsLCwkJCQkJCRWVytWVSsCAgJHRiwsLCwsLCwkJCQ9PSQkPiQkJCQkJCQ+JCQkJD8sLCwkJCQkJCQkRlZXKysrUCwsK1Y+JCQkPT49JD4kJDlHVlVWWllaWVYsPSwsWSwsPiQkViwrKytQLCsrUCwsLCwsJCQkJCQ+LD0kJCQ+VlcrK1BaWVlWWlZVR0cCXUAsLCw5UCwsLCwsLCQkXlYrKysrVitVRyQ/AgIHBwcHBwJdR1ZXKytVVVZXVSskSCwsLCwkJCQkJCQkXlYrKyxWVitXPAICAgICAgICAgICJCQrLFZXKysrVVdXPAI9LCwsLCwCAgICAgJALCQkJCQkRldWKysrVz8sLCwHBwcHBwcHBwcHLCwsLCwsJCQkJCQ9OVdWKytXKyssLAcHBwcHGwJhKysrK1c8LCwbZCwsLCwsPiQkJD0+LCQkJCQ+PSQkJCRWVlZZWjlVR2JXAkAsLCwsJCQkJCwkJCReVisrLCtWVkdIWiwsLCwsRisrKytHJCQkRisrVUYrPAICAjssLCwsRisrVVcrJCQkJCQkJCsrKysrK1UrAkgCAkAsLCwsLCwCAgICAiwsLD8sLCwsLCwsKysrUCsrK1c/AgIsLCwsLAIkJCQkJCQkLCsrKysrKysrKysrWSsrK1UrV1AsLCwsJCQkPSQ+JCRGKytQLFArOSsrK0YsLCwsJCQkPj0kJCQkJCQkJFZWWitZV1c9LCwsJEZVa0AsLCwrXiQkJCQkJCQkVisrUCxWVTwCAgICAgIHBwcHB1AsLBsbW0NDQzgUqENDQ0NDQ0NDLCwsLCwsXWlpaWlpaWm1AgJALCwsLCw/QCwsLCwsLEFBQUFBQUFBRyQkRisrKysrKyssLCwsLCQkJCQkJCQrKysrKytWVysrKzwsLCwsLCsrKzwCAkNDKChhLCwsLCwHBwcHB7MbGxs+JCQkJCQkJCQkJCwsPiQoRSQkJCQkJCQkJCQkU6QCGxsbHgJALCwkJCQkJD0sOV5WVlZWVlZWVlZWVlZWVlZWVlZWLCwsOStKKCgoKCgoKFhQLCwsLCxWLCwsLCwsLCwsLCwsLCw+KCg0KCgoNFEkPSwsLCwsLCw9LCwsLCwsJD0+LCwsLCwsLCQkLCwsLCQkJCQkLDI8QUEsLCwsLCwrKysrKysrLCsrK1AsLCwsQ0NDXDdDQ0NDQ7pXK0O6Vla7QUFBVCsrK0wyKysrQ0NDQ0NDQysrQ0MrTCwsLCwsGxssLCwsLCwLCwsLCxAQEBAQCwsLCwsLCwsLCwsLCxAQEG4QEBAQEAsQEBAQEBAQEBAQEBAQLwssLzAvMAsvCwsLCxAQlpYQEBCWEBAQEBAQEAswCy8wCwsLLwsLCy8QEBAQEAswCy8LCy8vLAsLCy8QEBAQEBAQEBAQEBAQCwsLCwsQEBAQEBAQECwLCwsLHxAQEBAQEBAQEBAQECEQEBALCwsLCwsLCwsLCwsfEBAQECEQEBALCwsLHxAQEBAQEBAQEBAQECEQEBALCwsLCwsLCwsLCwsfEBAQECEQEBALCwsLHxAQEBAhEBAQICwHKysrTEMyKysrKysrKytMQ0NDMkNDQ0ND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BgYGBgYGBgEBBgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAgQEBAICBAQEAg4ODg4ODg4ODg4ODg4ODgICAgICAgICDg4OAgICAg4ODg4ODgICAgMDAwMDAAMDAwMDAwADAwMDAwMDAwMDAwMDAwADAwMAAAMDAwMDAwMDAwMBAQEBAQEBAQEBAQMDAQMDAwMDAwMlJSUlJSUlJSUlJSUlJQIlJSUlAgIlJSUmJiYmJiYmJiYmAgICAgICQEBAQEBAQEBAQEACAkBAQFpaWlpaWlpaWlpaWlpaAgJaWlpaWlpaAl9fX19fX19fX19fXwICXwIlJSUCAgICAgMDAwMDAwMCAwMCAgICAgMDAwADAwMDAwcHBwcHBwcHBwEBAQEHBwcHBwcHAAAHBwUFBQUCBQUFBQUFBQUCAgUFAgIFBQUFBQUFBQUFBQUFBQIFBQUFBQUFAgUCAgIFBQUFAgIFBQUFBQICBQUFBQICAgICAgICBQICAgIFBQIFBQUFBQICBQUFBQUFBQUFAgILCwsCCwsLCwsLAgICAgsLAgILCwsLCwsLCwsLCwsLCwILCwsLCwsLAgsLAgsLAgsLAgILAgsLCwICCwsLAgICCwICAgICAgILCwsLAgsCAgICAgICCwsLCwsLCwsLAgIKCgoCCgoKCgoKCgoKAgoKCgIKCgoKCgoKCgoKCgoKCgIKCgoKCgoKAgoKAgoKCgoKAgIKCgoKCgoCCgoKAgIKAgICAgICAgoKCgoCAgoKCgoCAgICAgICCgoKCgoKCgIVFRUCFRUVFRUVFRUCAhUVAgIVFRUVFRUVFRUVFRUVFQIVFRUVFRUVAhUVAhUVFRUVAgIVFRUVFQICFRUVAgICAgICAhUVFQICAgIVFQIVFRUVFQICFRUCAhYWAhYWFhYWFgICAhYWFgIWFhYWAgICFhYCFgIWFgICAhYWAgICFhYWFhYWFhYWFgICAgIWFhYCAgICAgIWAgICAgICFhYWFhYCAgICAhcXFxcXFxcXFxcXFxcCFxcXAhcXFxcXFxcXAgIXFxcXFwIXFxcXAgICAgICAhcXAhcXFwICFwICFxcXFwICFxcCAgICAgICFxAQEBAQEBAQEBAQEBACEBAQAhAQEBAQEBAQEBACEBAQEBACAhAQEBAQAhAQEBACAgICAgICEBACEBAQEAICEBACEBAQAgICAhQUFBQUFBQUFBQUFBQCFBQUAhQUFBQUFAICAgIUFBQUFBQUFAICFBQCJCQkAiQkJCQkJCQkJCQkJCQkJCQkJAICAiQkJCQkJCQkAiQkJCQkJCQkJAIkAgICAiQCAgICJCQkJCQkAiQCAgICAgICJCQCAiQkJAICAgIYGBgYGBgYGBgYGBgYGBgYGBgCAgICABgYGBgCAgICAhISAhICEhISEhICEhISEhISEhISEhISEhISEgISAhISEhISEhICAhISEhISAhICEhISEhISEgISEgICEhISEhkZGRkZGRkZAhkZGRkZGRkZGRkZGQICAhkZGRkZAhkZGRkZGRkAAAAAGRkCAgICAiEhISEhISEhCAgICAgICAgICAgICAgCCAICAgICCAICCAgIAAgICAgMDAwMDAwMDB4eHh4eHh4eHgIeHh4eAgIeHh4eHh4eAh4eHgICHh4eHh4eHh4CAgIeHgICAgICAh0dHR0dHR0dHR0dHR0dAgIcHBwcHBwcHCIiIiIiIiIiIiIiIiICAgIjIyMjIyMjIyMjIwAAACMjIwICAgICAgItLS0tLS0tLS0tLS0tLQICAgICAgICAi0sLCwsLCwsLCwsLCwsAAACKysrKysrKysrKysrAgICAi4uLi4uLi4uLi4uLi4CLi4uAi4uAgICAh8fHx8fHx8fHx8fHx8fAgIfHwICAgICAiAgAAAgACAgICAgICAgICAgIAICAgICAiACAgICAgICICAgAgICAgIcHBwcHBwCAjAwMDAwMDAwMDAwMDAwMAIwMDAwAgICAjACAgIwMDAwNDQ0NDQ0NDQ0NDQ0NDQCAjQ0NDQ0AgICOjo6Ojo6Ojo6Ojo6AgICAjo6AgICAgICOjo6AgICOjo2NjY2NjY2NjY2NjYCAjY2W1tbW1tbW1tbW1tbW1tbAltbW1tbAgJbW1sCAgICAgJbW1tbW1sCAgEBAQEBAQECPj4+Pj4+Pj4+Pj4+PgI+PkxMTExMTExMXV1dXV1dXV1dXV1dAgICAgICAgJdXV1dRkZGRkZGRkYCAgJGRkZGRkZGAgICRkZGSUlJSUlJSUkGBgYCAgICAggICAICCAgIAQEBAAEBAQEBAAEBAQEBAQEAAAAAAQAAAAAAAAEAAAABAQACAgICAhMTExMTEwkJCQkJBhMTExMTExMTEwkJCQkJExMTEwkJCQkJExMTExMGExMTExMTExMTExMTExMJCQkJCQkJAgICCQIJAgkCCQkJCQkJAgkJCQkJCQICCQkJCQkJAgkJCQICCQkJAgkJCQkJCQkJCQIAAAAAAQEAAAAAAAAAAgAAABMCAgAAAAAAAAAAAAAAEwAAAAAAAAACExMTExMCAgIAAgICAgICAgECAgICAgICAAAAAAAACQAAABMTAAAAAAAAAAAAABMAEwAAAAICAgIAAAICAgICAgAAAAICAgICGxsbGxsbGxsAAAAAAgIAAAAAAAAAAAIAODg4ODg4ODg3Nzc3AgICAgI3Nzc3Nzc3PT09PT09PT0CAgICAgICPT0CAgICAgICAAAAAAAAAgINDQ0NDQ0NDQ0NAg0NDQ0NDQ0NDQICAgINDQ0NDQ0CAgAAAAAADQANAA0NDQ0NDQ0NDQEBAQEMDA0NDQ0AAAAAAg8PDw8PDw8PDw8PDw8PDw8PDw8PDw8CAgEBAAAPDw8AERERERERERERERERERERERERAAARERECAgICAhoaGhoaGhoaGhoaAgwMDAwMDAwMDAwMDAwMAgICAgICAgIADAwMDAwMDAARERERERERACcnJycnJycnJycnJycCAgInJycnJycnAlZWVlZWVlZWTU1NTU1NTU1NTU1NAgICAk9PT09PT09PAAATExMTExMAAAATExMTExMTExMTEwICExMCEwITExMCAhMTExMTEzw8PDw8PDw8PDw8PDwCAgJBQUFBQUFBQUtLS0tLS0tLS0tLS0tLAgICAgICAgJLS0tLAgICAgICRUVFRUVFRUVFRUVFRUUARUpKSkpKSkpKSkpKSgICAgICAgICAgICSgwMDAwMAgICVFRUVFRUVFRUVFRUVFQCAFRUAgICAlRUISEhISEhIQJEREREREREREREREREREQCREREREREAgJERAICRERERFxcXFxcXFxcXFxcAgICAgICAgJcXFxcXFdXV1dXV1dXV1dXV1dXVwICHh4eHh4eAhMTEwATExMTExMTExMJExMTEwAAAgICAldXV1dXVwICV1cCAgICAgIMDAwMAgICAgICAgwMDAwMDQ0CAgICAgITExMTExMTAgICAgQEBAQEAgICAgIODg4ODg4ODg4OAg4ODg4OAg4CDg4CDg4CDg4DAwMCAgICAgICAgMDAwMDAwMDAwMDAAACAgMDAwMDAwICAgICAgIDAQEBAQEBBgYAAAACAAAAAAAAAAACAgICAwMDAwMCAwMDAwMDAwICAAIAAAAAAAAAAAAAAAAAEREREREREREAAAICDAwMDAwMAgIMDAwCAgICAAAAAAACAjExMTExMTExMTExMQIxMTExMTExMTExAjExMQIxMQIxMTExMTExAgIxMTECAgICAgAAAAICAgIAAAAAAAICAgAAAAAAAAICAgkCAgICAgICAAAAAAABAgJHR0dHR0dHR0dHR0dHAgICQ0NDQ0NDQ0NDAgICAgICAgEAAAAAAAAAKioqKioqKioqKioqAgICAgICAgICKioqKSkpKSkpKSkpKSkCAgICAnZ2dnZ2dnZ2dnZ2AgICAgI1NTU1NTU1NTU1NTU1NQI1Ozs7Ozs7Ozs7Ozs7AgICAjs7Ozs7OwICKCgoKCgoKCgzMzMzMzMzMzIyMjIyMjIyMjIyMjIyAgIyMgICAgICAoeHh4eHh4eHh4eHhwICAgJqampqampqamhoaGhoaGhoaGhoaAICAgICAgICAgICaKGhoaGhoaGhoaGhAqGhoaGhoaECoaECoaGhAqGhoaGhoaECoaECAgKqqqqqqqqqqqqqqqoCAgICbm5ubm5ubm5ubm5ubm5uAm5ubm5ubgICExMTExMTAhMTAhMTExMTExMTEwICAgICLy8vLy8vAgIvAi8vLy8vLy8vLy8vLy8vLy8vLy8vAi8vAgICLwICL1FRUVFRUVFRUVFRUVFRAlF4eHh4eHh4eHR0dHR0dHR0dHR0dHR0dAICAgICAgICdICAgICAgICAgICAAoCAAgICAgKAgICAgEJCQkJCQkJCQkJCQgICAkJISEhISEhISEhIAgICAgJIYmJiYmJiYmJhYWFhYWFhYQICAgJhYWFhAgJhYWFhYWE5OTk5Ajk5AgICAgI5OTk5OTk5OQI5OTkCOTk5OTk5OTk5OTk5OTk5OTk5OTk5AgI5OTkCAgICOTkCAgICAgICWFhYWFhYWFh1dXV1dXV1dXBwcHBwcHBwcHBwcHBwcAICAgJwcHBwcE5OTk5OTk5OTk5OTk5OAgICTk5OTk5OTlNTU1NTU1NTU1NTU1NTAgJSUlJSUlJSUlJSUgICAgICenp6enp6enp6egICAgICAgJ6enp6AgICAnp6enp6enpZWVlZWVlZWVkCAgICAgICgoKCgoKCgoKCgoICAgICAgICgoKCgoKCkJCQkJCQkJCQkAICAgICAqWlpaWlpaWlpaWlpaWlAgICpaWlpaWlpQICAgICAqWlnJycnJycnJycnAKcnJwCApycAgICAgICAgIDAwMCAgICAgICAwMDA5OTk5OTk5OTlJSUlJSUlJSUlAICAgICAp6enp6enp6enp4CAgICAgKZmZmZmZmZmZmZmZkCAgIClZWVlZWVlZWVlZWVlZWVAl5eXl5eXl5eXl5eXl5eAgICAl5eXl5eXgICAgICAgJeVVVVVVVVVVVVVVUCAgICAgICAgICVQICZWVlZWVlZWVlAgICAgICAmVlAgICAgICYGBgYGBgYGBgYGBgYAJgYG9vb29vb29vb29vb29vbwJkZGRkZGRkZAIkJCQkJCQkJCQkJCQCAgJsbGxsbGxsbGxsAmxsbGxsbGwCAgICAgKBgYGBgYGBAoECgYGBgQKBgYGBgYGBgYGBgYGBgYECgYGBAgICAgICbW1tbW1tbW1tbW0CAgICAm1tAgICAgICa2trawJra2tra2trawICa2sCAmtra2tra2tra2tra2trAmtra2tra2sCa2sCa2tra2sCAWtra2trAgJra2sCAmsCAgICAgJrAgICAgJra2tra2trAgJra2tra2trAgICq6urq6urq6urqwKrAgKrAqurq6urqwKrqwKrAgKrAqurq6sCq6urq6sCAgICAgICAqurAgICAgKJiYmJiYmJiYmJiYkCiYmJiYkCAgICAgJ8fHx8fHx8fHx8AgICAgICe3t7e3t7e3t7e3t7e3sCAnJycnJycnJycnJycnICAgJycgICAgICAiAgICAgAgICZmZmZmZmZmZmZgICAgICAiEhISECAgICfn5+fn5+fn5+fn4CAn5+fn5+fn4CAgICfn5+fn5+fgKOjo6Ojo6Ojo6Ojo4CAgICfX19fX19fX19fX0CAgICAgICAgICAgJ9mpqampqamgICmgICmpqampqampoCmpoCmpqampqampqampqampoCmpoCApqampqampoCAgICAgKWlpaWlpaWlgIClpaWlpaWlpaWlpYCAgKNjY2NjY2NjYyMjIyMjIyMjIyMAgICAgJ5eXl5eXl5eXkCAgICAgICBwcCAgICAgKpqampqampqampAgICAgIChYWFhYWFhYWFAoWFhYWFhYWF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MAAwADAAOAA5ADoAOwA8ADAAIAA9ADAAMAAwADAAMAA+AD8AQAAwAEEAQgAwAEMARABFADAARgBHADAASABJADAAMABKACAASwAgAEwAMAAwAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBTAFQAWwBcAF0AXgBfAGAAYQBUAGIAYwBkAFgAZQBmAFMAVABnAGgAaQBYAGoAawBsAG0AbgBvAHAAXgBxAHIAcwBUAHQAdQB2AFgAdwB4AHMAVAB5AHoAewBYAHwAfQBzADAAfgB/AIAAWACBAIIAgwAwAIQAhQCGAF4AhwCIADAAMACJAIoAiwCMAIwAjQAwAI4AjwCQAJEAjACMAJIAkwCUAJUAlgAwAJcAmACZAJoAIACbAJwAnQCMAIwAMAAwAJ4AnwCgAKEAogCjAKQApQAJAAkApgALAAsApwAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAqACpADAAMACoADAAMACqAKsArAAwADAAMACrADAAMAAwAK0ArgCvADAAsAAJAAkACQAJAAkAsQCyADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwALMAMAC0ALUAMAAwADAAMAC2ALcAMAC4ADAAuQAwALoAuwC8ADAAMAAwAL0AvgC/AMAAwQDCAMAAMAAwAMMAMAAwAMQAxQAwAMYAMAAwADAAMADHADAAyADJAMoAywAwAMwAzQAwADAAzgAwAM8A0ADRANEAMADSADAAMAAwANMA1ADVAMAAwADWANcA2ACMAIwAjADZADAAMADaANsAoADcAN0A3gAwAN8AQAAwADAA4ADhADAAMADiAOMA5ABAADAA5QDmAAkACQDnAOgA6QDqAOsACwALAOwAGwAbABsA7QDuAAsA7wAbABsAIAAgACAAIAANAA0ADQANAA0ADQANAA0ADQDwAA0ADQANAA0ADQANAPEA8gDxAPEA8gDzAPEA9AD1APUA9QD2APcA+AD5APoA+wD8AP0A/gD/AAABAQECAQMBBAEFAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQARABEQESARMB0QAUARUB0QAWARcBFwEXARcBFwEXARcBFwEXARcBFwEXARcBFwEXARcBGAHRABkB0QDRANEA0QAaAdEAGwEXARwB0QAdAR4B0QDRANEAsACMAB8BjAAPAQ8BDwEgAdEA0QDRANEAIQEPAdEA0QDRANEA0QDRANEA0QDRANEA0QAiASMB0QDRACQB0QDRANEA0QDRANEAJQHRANEA0QDRANEA0QDRANEA0QDRANEA0QDRANEA0QAmAScBDwEoAdEA0QApARcBKgEXAdEA0QDRANEA0QDRANEA0QDRANEA0QDRANEA0QDRANEAFwEXARcBFwEXARcBFwEXASsBLAEXARcBFwEtARcBLgHRANEA0QAXAS8B0QDRADAB0QAxAdEA0QDRANEA0QDRAAkACQAJAAsACwALADIBMwENAA0ADQANAA0ADQA0ATUBCwALADYBMAAwADAANwE4ATAAOQE6AToBOgE6ASAAIAA7ATwBPQE+AT8BQAGMAIwA0QBBAdEA0QDRANEA0QBCAdEA0QDRANEA0QDRANEA0QDRANEA0QDRANEAQwGMANEARAFFAUYBRwGIADAAMAAwADAASAGyADAAMAAwADAASQFKATAAMACIADAAMAAwADAAyABLATAAMADRANEATAEwANEATQFOAdEATwFQAdEA0QBOAdEA0QBQAdEA0QDRANEAMAAwADAAMAAwADAAMAAwADAAMAAwADAA0QDRANEA0QAwAFEBMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACXANEA0QDRAFIBMAAwAOUAUwEwAFQBjAANAA0AVQFWAQ0AVwEwADAAMAAwAFgBWQEfAFoBWwFcAQ0ADQANAF0BXgFfAWABYQFiAWMBjABkAWUBMABmAWcBMAAwADAAaAFpATAAMABqAWsBwAAgAGwBQAAwAG0BMABuAW8BMACXAEwAMAAwAHABcQFyAXMBdAEwADAAdQF2AXcBeAEwAHkBMAAwADAAegF7AXwBfQF+AX8BgAE6AQsACwCBAYIBCwALAAsACwALADAAMACDAcAAMAAwADAAMAAwADAAMAAwADAAMACEATAAhQEwADAAzgCGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYcBhwGHAYcBhwGHAYcBhwGHAYcBhwGHAYcBhwGHAYcBMAAwADAAMAAwADAAzAAwADAAMAAwADAAMADPAIwAjACIAYkBigGLAYwBMAAwADAAMAAwADAAjQGOAY8BMAAwADAAMAAwAJAB0QAwADAAMAAwAJEBMAAwAJIBjACMAJMBIACUASAAlQGWAZcBmAGZATAAMAAwADAAMAAwADAAmgGbAQIAAwAEAAUAnAGdAZ4BMACfATAAyACgAaEBogGjAaQBMACsAKUBzADMAIwAjAAwADAAMAAwADAAMAAwAEcApgEPAQ8BpwEQARABEAGoAakBqgGrAYwAjADRANEArAGMAIwAjACMAIwAjACMAIwAMACXADAAMAAwAGQArQGuATAAMACvATAAsAEwADAAsQEwALIBMAAwALMBtAGMAIwACQAJALUBCwALADAAMAAwADAAzADAAAkACQC2AQsAtwEwADAAuAEwADAAMAC5AboBugG7AbwBvQEwADAAMACEATAAMAAwADkBMADHALgBjAC+ARsAGwC/AYwAjACMAIwAwAEwADAAwQEwAMIBMADDATAAyADEAYwAjACMADAAxQEwAMYBMADHAYwAjACMAIwAMAAwADAAyAEPAckBDwEPAcoBywEwAMwBzQHOATAAzwEwANABjACMANEBMADSAdMBMAAwADAA1AEwANUBMADWATAA1wHYAYwAjACMAIwAjAAwADAAMAAwAMQAjACMAIwACQAJAAkA2QELAAsACwDaATAAMADbAcAA3AEJAN0BCwDeAYwAjACMAIwAjACMAIwAjACMAIwAjACMAIwADwHfATAAMADgAeEB4gGMAIwA4wEwANAB5AEwAD4A5QGMADAA5gGMAIwAMADnAYwAMAA5AegBMAAwAOkB6gHJAesB7AHeADAAMADtAe4BMADEAMAA7wEwAPAB8QHyATAAMADzAd4AMAAwAPQB9QH2AfcB+AEwAGEA+QH6AfsBjACMAIwA/AH9Af4BMAAwAP8BAALAAAECUwBUAAICAwIEAgUCBgIHAjAAMAAIAgkCCgILAowAMAAwADAADAINAg4C4QGMADAAMAAwAA8CEALAAIwAjACMAIwAjACMAIwAjACMAIwAMAAwABECEgITAhQCjACMADAAMAAwABUCFgLAABcCjAAwADAAGAIZAsAAGgIbAowAMAAcAh0CHgI5AYwAjACMAIwAjACMAIwAjACMAIwAjAAwADAA+QEfAowAjACMAIwAjACMAAkACQALAAsAlAAgAiECIgIwACMCJALAAIwAjACMAIwAJQIwADAAJgInAowAKAIwADAAKQIqAisCMAAwACwCLQIuAjAAMAAwADAAxAAvAowAjACMAIwAjACMAIwAjACMAIwAjAAwADAAMALAAFQAMAARAjECMgKUAK8AMwIwADQCNQI2AowAjACMAIwANwIwADAAOAI5AsAAOgIwADsCPALAAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAMAA9Aj4CcwAwAD8CQAJBAowAjACMAIwAjABkAA8BQgJDAkQCMAAwADAAMAAwADAAMAAwADAAzwCMAIwAjACMAIwAjAAQARABEAEQARABEAFFAkYCMAAwADAAMAAwADAAMAAwADAAMAAwADAAhAGMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjAAwADAAMAAwADAAMABHAjAAMAAwAEgCSQJKAjAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAARwAwADAAMAAwADkBjACMAIwAjACMAIwAjACMAIwAjACMADAASwJMAsAAjACMAIwAjACMAIwAjACMAIwAjACMAIwAMAAwADAAxAAwAMgAcgEwADAAMAAwAMgAwAAwAMwATQIwADAAMABOAk8CUAJRAlICMACMAIwAjACMAIwAjACMAIwAjACMAIwAUwIwAFQCwACMAIwAjACMAIwAjACMAIwAjACMAIwAjAAJAAkACwALAA8BVQKMAIwAjACMAIwAjAAwADAAMAAwAFYCVwJYAlgCWQJaAowAjACMAIwAWwJcAjAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwALgBMAAwADAAMAAwADAAMAAwADAAMAAwADAAMADHAIwAXQLEAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAF4CMAAwAF8CYAKMAGECYgIwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMADOADAAMAAwADAAMAAwAEcAlwDEAGMCZAKMAIwAjACMAIwA0QDRANEA0QDRANEA0QDRANEA0QDRANEA0QDRANEAwADRANEA0QDRANEA0QDRANEA0QDRANEAQgGMAIwAjACMACAAIABlAiAAZgLRANEA0QDRANEA0QDRAEIBjACMAIwA0QDRANEA0QDRANEA0QDRANEA0QDRANEA0QDRANEAQwHRANEAZwLRANEA0QBoAmkCagLRAGsC0QDRANEAHwGMANEA0QDRANEAbAKMAIwAjACMAIwAjACMAA8BbQIPAW0C0QDRANEA0QDRAFIBDwHNAYwAjACMAIwAjACMAIwAjAAJAG4CCwBvAnACcQLxAAkAcgJzAnQCdQJ2AgkAbgILAHcCeAILAHkCegJ7AnwCCQB9AgsACQBuAgsAbwJwAgsA8QAJAHICfAIJAH0CCwAJAG4CCwB+AgkAfwKAAoECggILAIMCCQCEAoUChgKHAgsAiAIJAIkCCwCKAhoCGgIaAiAAIAAgAIsCIAAgAIwCjQKOAo8CLQCMAIwAjACMAIwAkAKRApICjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACTApQClQIbABsAGwCWAowAlwKMAIwAjACMAIwAjACMADAAMACXAJgCmQKMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAMACaAowAMAAwAJsCnAKMAIwAjACMAIwAjACMAIwAjACMAIwAjACMADAAnQLAAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAMABLAp4CjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAJ8CyAAwADAAMAAwADAAMAAwADAAMAAwADAAMACgAmYCjACMAAkACQByAgsAoQJyAYwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjAD3AQ8BDwGiAqMCjACMAIwAjAD3AQ8BpAKlAowAjACMAIwAjACMAIwAjACMAIwAjACMAKYCMACnAqgCqQKqAqsCrAKtAs4ArgLOAIwAjACMAK8C0QDRALAC0QDRANEA0QDRANEAQgFNAbECsQKxAtEAQwGyAtEA0QDRANEA0QDRANEA0QDRALMCjACMAIwAtALRALUC0QDRALACtgK3AkMBjACMAIwAjACMAIwAjACMAIwA0QDRANEA0QDRANEA0QDRANEA0QDRANEA0QDRANEAuALRANEA0QDRANEA0QDRANEA0QDRANEA0QDRALkCqgGqAdEA0QDRANEA0QDRANEAugLRANEA0QDRANEAsACwAqsBsALRANEA0QC7ArAA0QDRALsC0QCzArACtwKMAIwAjADRANEA0QDRANEAQgGzAqoBvALRANEA0QC9Ar4CsAC2AtEA0QDRANEA0QDRANEA0QDRAL8C0QDRANEA0QDRAMAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIwAjAAwADAAMADPADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAzAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMADhATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAZAAwADAAMAAwADAAMADMAIwAjACMAIwAjACMAIwAjACMAIwAMADMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjAAwADAAMAAwAEcAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACMAIwAjACMAIwAwAKMAEgCSAJIAkgCSAJIAowAjACMAIwAjACMAIwAjAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIACMAIcBhwGHAYcBhwGHAYcBhwGHAYcBhwGHAYcBhwGHAcEChwGHAYcBhwGHAYcBhwGHAYcBhwGHAYcBhwGHAYcBwgIAAAAAAQABAAAAAgADAAMABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAFAAAABgAHAAcABwAIAAkACgALAAwADQANAA0ADQAOAA0ADQANAA0ADwAQABEAEgATABQAFQAWABcAGAAZABcAFwAaABcAGwAcAB0AFwAeAB8AIAAhACIAIwAkACUAJgAXABcAJwAoACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAUgBWAFYAVwBYAFkAWgBbAFIAXABcAFwAXABcAF0AXgBfAGAAYABgAGAAYABgAGAAYABhAGEAYgBhAGMAZABlAGEAZgBhAGcAaABpAGoAagBrAGwAbABsAGwAbABsAGwAbABsAGwAbABsAG0AbgBuAG8AcABxAHIAcwB0AHQAdQB2AHcAeAB4AHkAeAB6AGwAewB8AH0AfgB/AIAAgQCCAHQAgwCEAIUAhgCHAIgAiQBSAIoAigCLAIoAjACMAI0AjgCPAJAAkQCSAJMAlACVAJYABACXAJgAmQAEAJoABwAHAJsACwCcAJ0ACwCeAJ8AoAChAAAAAACiAKMAAACkAKUAAACmAKcABACoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKkAqgAAAAAAAAAAAAAAqwCrAKsAqwCrAKsAqwCrAAAAAAAAAKwArQAAAAAAAACuAK4ArgAEAK8ArwCvALAAXQCxALIAswC0ALUAtQANAAAAAAC2AFIAtwC4ALgAuQC4ALgAuAC4ALgAuAC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQBgAGAAxgDHAAAAyADJAAAAAADKAAAAAADLAMwAwgDCAM0AAAAAAAAAAAAAALgAuAC4ALgAuAC4ALgAuAC4ALgAuAC4ALgAuAAAAAAAzgDOAM4AzgDOAM4AzgDOAM4AzgDOAM4AzwDOANAA0QDSANIA0gDSANIA0gDSANIA0gDTAA0ADQANANQA1ADVAAAA1gAEAAQA1wAEANgA2QDaANsA3ADdAN4A3gDfACgA4ADhAOIA4wDkAOQA5QDmAOcA6ADpAFwA6gDqAOsA7ADtAO4A7wDwAGoAagDxAPIAYABgAGAAYABgAPMA9AD1AFIAUgBSAFIAUgBSAFIAUgC4ALgAuAD2ALgAuAD3AFIA+AD5APoAFwAXABcA+wAXABcAFwAXABcAFwAXABcAFwAXAPwAFwAXAP0AFwD+AP8AAAEBAQIBAwEXABcAFwAEAQUBAQABAAYBBwHJAAgBCQEKAQsBDAFSAA0BDQENAQ4BDwEQAQsACwARARIBuwATAVIAUgBSAFIAFAEVARYBFwEYARkBGgEbARwBHQEeAVIAHwEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS4BLgEuAS4BLgEuAS4BLgEvATABMQEyATMBUgBSADQBNQE2ATcBOAE5AVIAOgE7ATwBUgBSAD0BPgE/AUABQQFCAUMBRAFFAVIARgFHAUgBSQFKAUsBTAFNAVIAUgBOAU4BTwFSAFABUQFQAVIBUwFUAVUBVgFXAVIAUgBSAFIAUgBSAFgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFlAWYBZwFoAWgBaQFqAWsBbAFtAW4BbwFvAW8BcAFxAXIBcwFSAHQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgAGBAYIBgwGDAYQBUgBSAFIAUgBSAIUBhgGHAVIAiAGIAYkBigGLAYwBjQGOAY8BkAGRAVIAUgBSAFIAUgCSAZMBUgBSAFIAlAGUAZUBlgGXAZgBUgBSAJkBmgGbAZwBnAGdAZ4BngGfAaABoQGiAVIAUgBSAFIAUgCjAaQBpQGmAacBqAGpAaoBUgBSAKsBrAGtAa4BrwGwAVIAUgBSAFIAUgBSAFIAUgBSALEBsgGzAbQBUgBSALUBtgG3AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbkBUgBSAFIAuAG4AbgBugG4AbgBuAG4AbgBuAG7AVIAUgBSAFIAUgBSAFIAUgBSALwBvQG9Ab4BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwHAAb8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/AcEBwgHCAcIBwgHCAcIBwgHCAcIBwgHDAVIAUgBSAFIAUgDEAcUBUgBSAFIAUgBSAFIA1ADUANQA1ADUANQA1ADUANQAxgHHAcgByQHKAcsBzAHNAc0BzgHPAdABUgBSAFIAUgBSANEB0gFSAFIAUgBSAFIAUgDTAdMB1AFSAFIAUgDVAdUB1gHVAdcBUgBSANgB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2gHbAdsB2wHbAdsB2wHbAdsB2wHbAdsB2wHbAdsB3AHdAd4BUgBSAFIAUgBSAFIAUgBSAFIAUgBSAFIAUgBSAN8B4AG/AL8AvwC/AL8AvwC/AL8A4QHiAeMB5AHkAeQB5AHkAeQB5AHkAeQB5AHkAeUB5gHmAeYB5wHoAekBUgBSAAAAAAAAAAAAAAAAAAAA6gEAAAAAAAAAAAAA6wFSAFIABwDsAe0BAAAAAAAA6QFSAAAAAAAAAAAAAAAAAAAA7gEAAO8BAADwAfEB8gEAAKoACwALAPMBUgBSAFIA6wHrAQAAAAD0AfUBUgBSAFIAUgAAAAAA9gEAAPcB+AH5AQAA+gH7AfwBAAAAAAAAAAAAAAAAAAAAAAAAAAD9AQAAAAAAAAAAAAAAAAAAAAD+AQAA/wH/Af8B/wH/Af8B/wH/Af8B/wH/Af8BAAIBAlIAUgACAgMCUgBSAFIAUgBSAFIABAIFAg0ABgIHAlIAUgBSAAgCCQIKAlIAUgBSAFIAUgBSAFIAUgBSAAsCDAINAg4CUgBSAFIAUgBSAFIADwIQAlIAUgBSAFIAUgBSABECEgJSAFIAUgBSAFIAUgBSABMCFAIUAhQCFAIUAhQCFQJSABYCFgIXAlIAUgBSAFIAUgBSAFIAUgAYAgAAGQJSAFIABQG2AFIAUgBSAFIAUgBSABoCGwIcAh0CHgIfAlIAIAIAACECAAAAAOsBIgIjAu4BAAAAAAAAAAAAACQCUgAlAiYCJwIoAikCUgBSAFIAUgAAAAAAAAAAAAAAAAAqAisCAAAAAAAALAIAAAAA6gEtAiECAAAuAgAALwIwAjECUgAAAAAA6wEyAjMCAAA0AjUCAAAAAAAAAAACAQAAAADqAbgAuAC4ALgAuAC4ALgAUgC4APcAuAC4ALgAuAC4ALgANgK4ALgAuAC4ALgAuAC4ALgAuAC4ALgAuAA3ArgAuAC4ALgAuAC4ALgAuAC4ADgCuAC4ADYCUgBSAFIAUgBSADYCUgBSAFIAUgBSAFIAUgC4ALgAOQK4ALgAuAC4ALgAuAC4ALgAuAC4ADoCUgBSADsCAAAAAAAAUgBSAFIAUgAHAAcABwAHAAcABwAHADwCAAAAAAAAAAABAAIAAgADAAAABAAAAAQAAgACAAUAAgACAAIAAgACAAIAAgACAAYABwAIAAAAAAAJAAkACQAJAAkACQAKAAsADAANAA4ADgAPAA4ADgAOAA4ADgAOAA4AEAARAA4ADgASABIAEgASABMAEgASABIAEgASABQAFQAVABUAFgAUABUAFQAVABUAFQAXABgAGQAZABkAGQAZABkAGgAZABkAGQAbABwAGgAdAB4AHwAgAB8AHwAfAB8AIQAiACMAHwAfAB8AJAAfAB8AHwAfAB0AJQAmACUAJQAlACUAJQAlACUAJwAfAB8AKAAoACgAKAAoACgAKQAaACoAKgAqACoAKgAqACoAKwAsACwALAAsACwALQAsAC4ALwAvAC8AMAAlADEAHwAfAB8AMgAzAB8ANAAfAB8AHwA1ADUANQA1ADUANQA2ADUANwA1ADUANQA4ADkAOgA7ADsAPAA9AD4AOQA/AEAAQQBCADsAOwBDAEQARQBGAEcARwBIAEkASgBFAEsATABNAE4ARwBPABoAUABRAFIAUwBTAFQAVQBWAFEAVwBYABoAWQBTAFoAWwBcAF0AXgBfAF8AYABhAGIAXQBjAGQAZQBmAF8AXwAaAGcAaABpAGoAawBoAGwAbQBoAGkAbgAaAG8AbABsAHAAcQByAHMAcQBxAHMAcQB0AHIAdQB2AHcAeABxAHkAcQB6AHsAfAB6AHoAfAB9AH4AewB/AIAAgACBAHoAggAaAIMAhACFAIMAgwCDAIMAgwCEAIUAhgCDAIcAgwCDAIMAiACJAIoAiwCJAIkAjACNAIoAjgCPAIkAkACJAJEAGgCSAJMAkwCTAJMAkwCTAJQAkwCTAJMAlQAaABoAGgAaAJYAlwCYAJgAmQCYAJgAmgCbAJwAmACdAJ4AngCeAJ4AngCfAJ4AngCeAKAAnwCeAJ4AngCeAJ8AngCeAJ4AoQCeAKEAogCjAKQApACkAKQApQClAKUApQCmAKcApQClAKUApQClAKgAqQCpAKkAqQCqAKoAqgCqAKoAqwCsAKsAqgCrAKoAqgCqAKoAqwCsAKsAqgCsAKoAqgCqAKsAqgCqAKoAqgCtAKoAqgCqAK4AqgCqAKoArwCwALAAsACwALAAsACxALEAsgCyALIAsgCzALMAswC0ALUAtQC1ALUAtQC2ALUAtwC4ALgAuQC6ALsAuwC8ABoAvQC9AL4AGgC/AMAAwQAaAMIAwgDCAMIAwgDCAMIAwwDCAMQAwgDEAMUAxgDGAMcAxgDGAMYAxgDGAMYAxgDIAMYAyQCyALIAsgCyAMoAGgDLAMsAywDMAMsAzQDLAM0AzgDLAM8AzwDPANAA0QAaANIA0gDSANIA0gDTANIA0gDSANQA0gDVANYA1gDWANcA2ADYANgA2ADYANgA2ADZANgA2ADYANoA2ADbANgA2wDYANwACQAJAAkA3QAaABoA3gDeAN4A3gDeAN8A3gDeAOAA4ADgAOAA4QDhAOEA4QDhAOEA4gDjAOQA5ADkAOQA5ADkAOQA5QDkAOYA5wDnAOcA5wDnAOcAEgDoAKUApQClAKUApQDpAOAAGgDqAAkA6wDsAO0A7gDvAPAAAgACAAIAAgACAPEA8gDzAAIA9AACAAIAAgD1AA4ADgD2APYA9gD2AA4A9wAOAA4ADgD2AA4ADgD4AA4A+AAOAPkA+gAOAA4A+wD8AAAA/QAAAAAA/gAAAP8AAAEAAAEBAgACAQMBGgAJAAkACQAJAAQBGgAFAQYBBAAAAAAABwEAAAAAAgAIAQAAAAAAAAkBGgAaAAAACgEaABoACwELAQsBCwEAAAAADAEAAAAAAAANAQAADgEOAQ4BDgERABEAEQARABEAEQAPARABpgCnABEBEQERAREBEQERAREBEgETARIBqgCqAKwAGgCsAKwArACsAAAAAAAAABQBFQEVARUBFgEVARUBFQEVARUBFQEXARoAFQEVARgBGgAaABoAAAAAABkBAAAAAAAAGgEbAQAAHAEdAR4BHgEeAR4BHgEeAR4BHgEeAR8BIAEhASIBIgEiASIBIgEiASIBIgEiASIBIwEkASUBJQElASUBJQEmAakAqQAnAQAAAAAlASUBJQElARQBKAEiASIBqQCpAKkAJwGpAKkAqQApAQAAAAAiASIBIgEiASIBKgEiASIBIgEAACsBKwErASsBKwEsASsBKwEtARoALgEuAS4BLgEuAS4BLwEvAS8BLwEvATABGgAaADEBMQExATEBMQExATEBGgAyAQIAAgACAAIAMwECAAIAAgA0ATUBAgEaABoANgECADcBNwE3ATcBNwE4AQAACQE5ATkBOQE5ATkBOQE5ARoAOgE6AToBOgE7ATwBOgE9AT4BPgE+AT4BPgE/AUABQAFAAUABQQFCAakAqQCpAEMBRAFEAUQBRAFEAUUBRAFGAaQApACkAEcBSAFIAUgBSAFIAUgBSQEaAEgBSgFIAUsBTAFMAUwBTAFNARoAGgBOAU8BTwFQARoAUQFRAVEBGgCsAKwAAgACAAIAAgACAFIBUwFUAbAAsABPAU8BTwFPAU8BVQFPAVYBVwEaAKkAqQAnAVgBqQCpAKkAqQCpAFcBFQEYARUBFQEVARUBFQFZAVoBGgBbAVwBGQAZAF0BXgFfARkAHwAfAGABGgBhAR8AHwAfAB8AYgEfAB8AYwEfAB8AZAEaABoAGgAaAB8AHwAJAAkAAAAJAQkAZQEAAAAAAAAAAGYBAAABAWcBaAEfAB8AHwAfAGkBagEAAAAAAABrASIBIQEiASIBIgEiAWwBbQFtAW0BbgEBAQEBGgBvAXABcQFwAXABcgFwAXABcwFwAXQBcAF0AXABcAFwAXABcAFwAXABdQF2AQAAAAAAAAAAAAB3AQAADgD8AAAAeAF5ARoAGgAaAAAAAAAAAHoBewF7AXsBfAF9AX0BfQF9AX0BfQF+ARoAfwEAAAAAZwGAAYABgAGAAYEBggGDAYMBgwGEAYUBhQGFAYUBhQGGAYcBhwGHAYgBiQGJAYkBiQGKAYkBiwEaAIwBjAGMAYwBjAGMAY0BjQGNAY0BjQGNAY4BjgGOAY8BjgGQAZEBkQGRAZEBkgGRAZEBkQGRAZIBkwGTAZMBkwGTARoAlAGUAZQBlAGUAZQBlQGWAZcBmAGXAZgBmQGXAZoBlwGaAZsBnAGcAZwBnAGcAZwBnQEaAJ4BngGeAZ4BngGeAZ8BGgCeAZ4BoAEaAJ4BGgAaABoAoQECAAIAAgACAAIAogGjAaQBpQGmAaYBpgGmAacBqAGpAakBqgGpAasBqwGrAasBrAGsAawBrQGuAawBGgAaAK8BrwGwAbEBsgGyAbIBswG0AbQBtAG1AbYBtgG2AbYBtwG3AbcBuAG3AbcBuQG3AbcBtwG3AbcBugG7AbwBvQG+Ab4BvwHAAb4BwQG+AcEBwgHCAcIBwgHDAcMBwwHDAcQBxAHEAcQBxQHGAcUBGgDHAccBxwHHAccBxwHIAckBygHKAcsBygHMAcwBzQHMAc4BzgHPAdABGgDRARoAGgDSAdIB0gHSAdIB0wEaABoA1AHUAdQB1AHUAdQB1QEaANQB1AHVAdYB1wHXAdcB1wHXARoA1wHYAdkB2QHZAdkB2gHbAdkB2QHaAdwBGgAaAB8AHwAfADIA3QHdAd0B3QHdAd4B3wEaAOABGgAaABoAGgAaABoA4QHiAeIB4gHiAeIBGgDjAeMB4wHjAeMB5AEaABoA5QHlAeUB5gEaABoAGgAaAOcB5wHnAegBGgAaAOkB6QHqARoA6wHrAesB6wHrAewB7QHrAesB6wHsAe4B7wHvAe8B7wHwAfEB8gHyAfIB8wHyAfQB9QH1AfUB9QH1AfUB9gH1AfUBGgD3AfcB9wH3AfgBGgD5AfkB+QH5AfoBiQD7ARoA/AH8Af0B/AH8AfwB/AH8Af4BGgAaABoA/wEAAgECAgIBAgMCBAIEAgQCBAIEAgQCBAIFAgQCBgIHAggCCQIKAgoCCwIMAg0CCAIOAg8CEAIRAhICEgIaABMCFAITAhMCEwITAhUCEwIWAhcCFQIYAhkCGgAaABoAGgIaAhoCGgIaAhoCGgIbAhwCGgAaABoAHQIdAh0CHQIdAhoAHQIeAh8CHwIfAh8CHwIfAiACHwIfAh8CHwIgAiECIQIhAiECIgIaACECIwLGACQCGgAaACUCJQIlAiUCJQIlAiUCJgIlAiYCpACkACcCGgAaABoAKAIoAigCKQIoAioCKAIoAisCGgAaABoALAIsAiwCLAIsAiwCLAItAi4CLgIuAi4CLgIuAi8CMAIxAjICMwI0AjQCNAI1AjYCMQIaADQCNwI4AjkCOAI4AjgCOAI4AjkCOgIaABoAGgA7AjsCOwI7AjsCGgA8AjwCPAI8AjwCPAI9AhoAsgCyAD4CPgI+Aj4CPgI+Aj4CPwI1AEACGgAaAEECQQJBAkECQgIaAEECQgJDAkQCQwJDAkMCQwJFAkMCRgIaAEMCQwJDAkcCSAJIAkgCSAJJAkgCSAJKAksCGgBMAk0CTgJOAk4CTgJMAk8CTgIaAE4CUAJRAlICUwJTAlMCVAJVAlYCUwJXAhoAGgBYAlgCWAJZAloCWgJbAloCWgJaAloCXAJaAloCWgJdAhoAGgBeAhoAbABsAGwAbABsAGwAXwJgAmECYQJhAmECYQJhAmECYgJhAmMCZAIaAGUCGgAaABoAGgAaAGYCZgJmAmYCZgJmAmYCZgJnAhoAaAJoAmgCaAJoAmgCaQIaAGgCaAJoAmoCawJrAmsCawJsAhoAGgAaAG0CbQJtAm0CbQJtAm0CbgIxATEBMQFvAnACcAJwAnECcAJyAnMCcwJzAnMCcwJzAnMCcwJzAnQCcwJ1AnYCdgJ2AncCdwIaAHgCeAJ4AngCeQIaAHgCegJ6AngCeAJ7AngCeAIaABoAfAJ8AnwCfAJ8AnwCfAJ9An4CfgJ+An4CfgJ+An4CfwKAAoACgAKAAoACgQKAAoACgAKCAoACgAKDAhoAWQEaAIQChAKEAoQChAKEAoQCGgCFAoUChQKFAoUChQKGAhoAGgAaABoAhwKEAogCGgAaABoAGgCJAooCiwIeAR4BHgGMAhoAjQIaABoAGgCOAhoAjwIaAJACkAKQApACkAKQApACkAKQApECkgKSApICkgKSApMCkgKUApIClQKSApYCZwEaABoAGgAAAAAAAAAJAQAAAABnARoACQCXAgkACQDdABoAAAAAAAAAAAAUARoAAQFqAQAAAACYApkCAACaApsCnAIAAAAAAACdAgAAAAD2ABoAGgAaAAAAAAABARoA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vAe7B70HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAagBoAGsAOgNyAHYAdwB5AHsAfAB/AH0AIgA+A4IAgwCEAIkAOwMjAIUAiwA9A44AjwBwAJAAkQCcA5cAmAAlAJ0AngCfAKAAJgClAKYAqQCrAKwArQCuALAAsQCyALMAtQC2ALYAtgBBA9QBuAC5AEIDuwC8AL0AxADAAMIAwwDFAMcAyADJAMsAzADMAM4A0ADRANMA2gDVANsA1gDYAJkA6gDdAN4A3wDcAOEA4ADmAEMD6wDsAO0A7gDvAPQARANFA/cA+AD5APYA+wAnACgA/QD/AP8ARgMBAQIBAwEFAUcDBgEHAS0BCAEpAAoBDgEQAQ8BSQMSAUoDFQEUARYBGQEaASoAGwEcAR0BHgErAEsDLAAhASIBIwElAaYDKgFNA00DbQIsASwBLQBUA34DLgEwAS4AMgE1ATYBOAE8ATAALwA9AU4DPgFDAUQBRQFEAUgBSQFNAUsBTAFOAU8BUAFSAVMBVgFXAVsBXwFRA14BXAFgAWIBZwFSA2kBZgFkATEAawFtAW8BbAEyAHEBcwFTA3gBggF6ATUAfQE0ADMAjACNAIMBfgFmAk4AhAGFAYYBigGIAVgDNgCPAYwBkgGUAVoDlQGRAZcBNwCYAZkBmgGdAVsDnwE4AKEBXAOiATkAowGmAagBqQFdA0gDXgOqAV8DrQGvAasBsQG1AbkBtgG3AboBuwFgA7QBwQHCAToAxgHFAWEDvwHMAWIDYwPNAdIB0QHQATsA0wHWAdUB2AE8A9sBZAPeAWYD4wHlAeYBZwPoAekBaANpA+8B8QE8APIBPQA9APgB+QH7AfwB/wE+AAECagMDAmsDBgJMAwgCbANtA24DPwBAABACcANvA3EDcgMSAhMCEwIVAkIAFgJDAEQAdAMYAhoCHQJFAHUDJQJ2A3cDLAIvAkYAMQIyAjMCeAN5A3kDNwJHAHoDOgI7AkgAewNBAkkARQJDAkYCfQNLAkoATgJQAlQCSwB/A4ADTACBA1gCggNaAl0CXwKDA4QDYQKFA2MCVQNNAGcCaAJPAGkC/ACGA4cDVgNXA20CbgLbAlAAcwJyAnQCpAB1AnYCdwJ5AogDeAJ6An8CgAJ7AoEChgKLAn4CgwKEAoUCiQOLA4oDUQCNAo4CkAKPA5ECjANSAFMAjQOOA1QAmAKZApoCmwKdApwCnwKeAqICoAKhAqMCVQClAqYCVgCpAqoCkAOtAq4CVwCxAiQAkQOSA1gAWQC4Ar4CxQLHApMDyALJAs4CzwKVAz8D0QLQAtMCQAPVAtgClgOXA+MC5gLoApgD6QLxAvQC9QLzAvgC+QKZA/oCWgD8ApoDWwAHAxcBDAObA50DXABdABEDngNeAJ8DEwMTAxUDoAMYA18AHAMdAx4DIANgAKEDIgMkAyYDYQBiACcDogNjAKMDpAOlAy4DZAAwAzEDMgMzAzQDNQOnAwAAAAAAAAAAAAAAAAAAAAABAP//AgAAAP7/AAAAAAIAAAD+/wAAEAAAAPD/AAABAP//AAADAAMAAwD9//3//f8AAOAHAADfCYMHegd+BwAAyggAAAAAigAAAAcA+f8AAP//AQAgBwAAOAgAADwIOggAADoIJAUAAP//dv8IAAgACAAAAAcABwD4//j/+P/5/9z6AQD//wMA/f8BAAAAhviC+AAAAAB9+OD4AAAAACD4yPcAAAAAxvfE98b3NvcAACH2AAAAAAAAAAAAAHl5eVpobmlaenp6WmJhckFubXJBZ25lQmxyeUNhdmVEcm9lR2tlckdyanVHdXJ1R2duYUhpbmFIcmJlSGFyaUhhZG5LYW5hS29vYUxudGFMbXlsTWF5ck9sbWFUdWxlVGlhaFR0YmlUb3BvQmlhckJzbmFDcmVoQ2lodEVybWhLZ25vTXJteU1tYWdPcm51UmhuaVNjcnlTYWFoVGlpaVl0cnNEaHRvR2xhdElkaHVCb25hSGdsZ1RiZ2FUdHJwQ2JtaUxibmlMYW1zT3dhaFNlbGFUcmFnVWlndUJ0cG9DZ2FsR3JhaEt1bGFUb2VwWG9seVNnbmZUaWxhQnh1c1hvb2tOZ2FoUHhuaFBpcmFDbWFoQ2lsYUtjcGVMaWN5TGlkeUxrY2xPZ25qUnJ1YVNkbnVTaWlhVnRzdkF1bWFCcHlnRWltckFpbGhQaXRyUGF2YUppaHRLdXNpTGlldE1icmFTaGtyT3JtYVNhbmFMdHZhVGt0YUJoYXJCZG5hTW1rYUNjcmVNb3JlTWRybFBkcmhTYXJvU3JrYVRzc2FCYmhnQWxwdURhYmxFbmFyR2pvaEtkbmlTYW5pTGpoYU1pbmFNZG5lTWlkb01vb3JNdGFiTmJyYU5tcmVQ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Z1FoUWlRbVF3UYBRjVGSUZVRl1GkUaxRtVG3UclRzFHcUd5R9VEDUgdSF1IpUjpSO1JGUnJSd1KJUptSo1KzUsdSyVLSUt5S5FL1UvpSBVMGUxdTP1NJU1FTWlNzU3VTfVN/U8NTylPfU+VT61PxUwZUD1QdVDhUQlRIVGhUnlSiVL1U9lQQVVNVVVVjVYRVh1WZVZ1Vq1WzVcBVwlXiVQZWUVZoVnRW+VYWVxdXi1fOV/RXDVgxWDJYQFhaWF5YqFisWLNY2FjfWO5Y8lj3WAZZGlkiWURZSFlRWVRZYllzWdhZ7FkbWidaYlpmWrVaCFsoWz5bhVvDW9hb51vuW/Nb/1sGXCJcP1xgXGJcZFxlXG5cjVzAXBldQ11QXWtdbl18XbJdul3hXeJd/V0oXj1eaV50XqZesF6zXrZeyV7KXtJe017ZXuxe/l4EXyJfU19iX2lfa1+LX5pfqV+tX81f11/1X/lfEmAcYHVggWCUYMdg2GDhYAhhRGFIYUxhTmFgYWhhemGOYZBhpGGvYbJh3mHyYfZhAGIQYhtiLmI0Yl1isWLJYs9i02LUYvxi/mI9Y1BjaGN7Y4NjoGOpY8RjxWPkYxxkImRSZGlkd2R+ZJpknWTEZE9lVmVsZXhlmWXFZeJl42UTZklmdGaIZpFmnGa0ZsZm9Gb4ZgBnF2cbZyFnTmdTZ1ZnXmd7Z4Vnl2fzZ/pnF2gfaFJogWiFaI5oqGgUaUJpo2nqaQJqE2qoatNq22oEayFrVGtya3dreWufa65rumu7a05sZ2yIbL9szGzNbOVsFm0bbR5tNG0+bUFtaW1qbXdteG2Fbctt2m3qbfltGm4vbm5unG66bsduy27RbttuD28ibyNvbm/Gb+tv/m8bcB5wOXBKcHBwd3B9cJlwrXDIcNlwRXFJcW5xnHHOcdBxEHIbcihyK3I1clByYnKAcpVyr3LAcvxyKnN1c3pzh3OLc6VzsnPecwZ0CXQidEd0XHRpdHF0hXSJdJh0ynQGdSR1O3U+dVl1ZXVwdeJ1EHYddh92QnZpdsp223bndvR2AXcedx93QHdKd4t3p3dOeGt4jHiReMp4zHj7eCp5PHk+eUh5SXlQeVZ5XXleeWV5f3mNeY55j3muecp563kcekB6SnpPeoF6sXrLeu56IHvAe8Z7yXs+fGB8e3ySfL580nzWfON853zofAB9EH0ifS99W31jfaB9vn3HffR9An4Jfjd+QX5Ffj5/cn95f3p/hX+Vf5p/vX/6fwGABYBGgGCAb4BwgH6Ai4CtgLKAA4E+gdiB6IHtgQGCBIIYgm+CeYKLgpGCnYKxgrOCvYLlguaCHYMjgzaDUoNTg2ODrYO9g8mDyoPMg9yD54Pvg/GDPYRJhFeE7oTxhPOE/IQWhWSFzYX6hQaGEoYthj+GUIZchmeGaYaIhqmG4oYOhyiHa4d5h4aHuofhhwGIH4hMiGCIY4jCiM+I14jeiOGI+Ij6iBCJQYlkiYaJi4mWiaCKqoq/isuK0orWiu2K+Ir+igGLOYtYi4CLiotIjFWMq4zBjMKMyIzTjAiNG413jbyNy43vjfCNyo7UjiaPKo84jzuPYo+ej7CPto8jkDiQcpB8kI+QlJDOkN6Q8ZD9kBGRG5FqkZmRtJHMkc+R0ZE0kjiSdpJ8kteS2JIEk0qT+ZMVlIuVrZW3lS6WS5ZNlnWWeJZ8loaWo5a3lriWw5biluOW9pb3liOXMpdIl1aX25fgl/+XC5gYmCmYO5hemOKY75j8mCiZKZmnmcKZ8Zn+mWqaEptvm0CcV5z9nGedtJ36nR6ef56Xnp+eu57Onvme/p4Fnw+fFp87n0OfjZ+On5yfAAAAAAAAAAAAAAAAAAAiARwFJQVLBToGBAjeCCwKYwvkFKgW6hbIGRgbCx3kHeYdgyGfITEj1CZEKEooDCvxKwowuDJfM5MznDPDM9UzbTSjNqc4jTr6Orw8Hj3RPl4/jj9jQu5Cq0MIRjVHFEg2TJJMoU+4T0RQ8lDzUBlRM1FJUh1UJlaaVsVWfFmnWqtbgFzQXIZf2mEoYkdi2WI+Y9pkI2WoZadntWc8azZs1WxrbSxvsW/ScMpzZ3aueGZ5qHzTfi9/0oXthS6H+ot3jUWR35EakgqUlpS2lTCbzqAFoQ6ikaKSowCmAAAAAAABAgMEBQYHCAkWDxARFxITFBUOGAwZDQoLGhwdHh8gIRsiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSUwRVVldYWVoFXF1eX2BhYmNkZWYDaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGEg4OFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8QERERMhQVEREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREXaYAAEAAAAAAAAAAAAAAAAAAAIAAwQAAAUGAAcACAkKCwwAAA0AAAAOAA8AAAAAEAAAERESExQRERURERYRFxEYGRobHBEREQAAERERERERER0AAAAAAAEAAAACAwAABAAABQYAAAcIAAAIAAkKAAALAAAMDQ4PEBAQERAQEBITFBUWFwAAABgAABkAGgAAGwAAHAAAABAQEBAdCQAeHyAQISIjJBAQEBAlECYnEBAQKAAAAAApAAAqECsALAAtLhAQLzAxEBAQECYAAAAAAEIAAAAAABAAAgAABAAAAgAA8AMABgAAAAAADAABAAAAgAAAAP4PBwQAAAAADEAAAQAAAAAAAHi///f//////z8A//8//1cgAgEYAJBQuAD4AAAAAADgAAIAAYAAADAA4AAAGAAAIQAAAAEgAACAAgDgAAAA8APAAED+BwDg//8/AAAA/v8ABACA/PcA/v//////B////z/A//////8AAAAA8P8AAOD/APAAAAD/APwA/wAAAMD//wDw///////3v////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQMDQwLDQQEBAQEBAQEBAQEBAQEDQ0NDAsODggICA4ODg4OCQoJCgoHBwcHBwcHBwcHCg4ODg4ODgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBDg4ODg4BAQEBAQEBAQEBAQ4ODg4EBAQEBAQNBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQKDggICAgODg4OAQ4OBA4OCAgHBw4BDg4OBwEODg4ODgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBDgEBAQEBAQEBAQEBAQEBAQEBDg4BAQEBAQEBDg4ODg4ODg4ODg4ODg4BAQEBAQ4ODg4ODg4ODgEODg4ODg4ODg4ODg4ODg4ODgUFBQUFBQUFBQUFBQUFBQUBAQEBDg4BAQEBAQEBAQ4BAQEBAQ4OAQ4BAQEBAQEBAQEBAQEBAQ4BAQEBAQEBAQEBAQEFBQUFBQUFAQEBAQEBAQEBAQEBAQEBAQ4BAQ4OCAIFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQIFAgUFAgUFAgUCAgICAgICAgICAgICAgICAgICAgICAgIGBgYGBgYODgMICAMKAw4OBQUFBQUFBQUFBQUDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwUFBQUFBgYGBgYGBgYGBggGBgMDAwUDAwMDAwMDAwMDAwMDAwMDAwMDAwMFBQUFBQUFBg4FBQUFBQUDAwUFDgUFBQUDAwcHBwcHBwcHBwcDAwMDAwMDBQMDAwMDAwMDAwMDAwMDAwMDAwMDBQUFBQUFBQUFBQICAgICAgICAgICBQUFBQUFBQUFAgIODg4OAgICBQICAgICAgICBQUFBQIFBQUFBQUFBQUCBQUFAgUFBQUFAgICAgICAgICAgIFBQUCAgICBgYDAwMDAwMFBQUFBQUFBQMDAwMDAwMDAwMFBQUFBQUFBQYFBQUFBQUFBQUFBQUFBQUFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFAQUBAQEBBQUFBQUFBQUBAQEBBQEBAQUFBQUFBQUBAQEBAQEBAQEBBQUBAQEBAQEBAQEBAQEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBQEBAQEFBQUFAQEBAQEBAQEFAQEBAQgIAQEBAQEBAQgBAQUBAQUFAQEBAQEBAQEBAQEBAQEFBQEBAQEFBQEBBQUFAQEFBQEBAQUBAQEBAQEBAQEBAQUFBQUFAQUFAQEBAQUBAQEIAQEBAQEBAQEFBQUFBQUBAQEBAQEBAQEBAQEFAQEFAQEBAQEFBQEBAQEBAQEBAQEBBQEBAQEBAQEBAQEBAQEFAQEBAQEBAQEBAQEBBQEBAQEBDg4ODg4OCA4BAQEBAQUBAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFAQUFBQEBAQEBBQUFAQUFBQUBAQEBAQEBAQEBDg4ODg4ODgEBAQEBAQEBAQEBAQEFBQEBBQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBQUBAQEBAQEBAQEBAQEBBQEBAQEBAQEFBQUBBQEBAQEBAQEBAQEFAQEFBQUFBQUFAQEBAQgBAQEBAQEBBQUFBQUFBQUBAQUBAQUFBQUFBQUFBQEBAQEBAQEBAQEBBQUFBQUFAQEBAQEBAQEBAQUFAQEBAQEBAQEBAQEFAQUBBQ4ODg4BAQEFBQUFBQUFBQUFBQUFBQEFBQUFBQEFBQEBAQEBBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBQUFBQUBAQEBAQEBAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQUFBQUBBQUFBQUFAQUFAQEFBQEBAQEBAQEBAQUFAQEBAQUFBQEBAQEBAQEBAQEBAQEBAQEFBQUFAQEBAQEBAQEBAQEBAQUBAQUFAQEBAQEBBQEBAQEBAQEBAQEBAQEBAQUBAQ4ODg4ODg4ODg4BAQEBAQELAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEODgEBAQEBBQUFAQEBAQEBAQEBAQEBAQEBBQUBBQUFBQUFBQEBAQEBAQEBBQEBBQUFBQUFBQUFBQUBAQEBAQEBCAEFAQEODg4ODg4ODg4ODgUFBQQFAQEBAQEBAQEBBQEBAQEBAQUFBQEBAQEFBQEBAQEBAQEBAQUBAQEBAQEFBQUBAQEBDgEBAQ4OAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBDg4BAQEBAQEBBQUBAQUBAQEBAQEBAQEBBQEFBQUFBQUFAQUBBQEBBQUFBQUFBQUBAQEBAQEFBQUFBQUFBQUFAQEFBQUFBQUFBQUFBQUFBQUFAQUFBQUBAQEBAQEBAQEBAQEBAQEBBQEFBQUFBQEFAQEBAQEBAQEBAQEBAQEFBQUFBQEBBQUFBQEBBQUBBQUFAQEBAQEBAQEFAQUFAQEBBQEFAQEBAQEBAQEBAQEBBQUFBQUFBQUBAQUFAQEBAQEBAQEFBQUBBQUFBQUFBQUFBQUFBQEFBQUFBQUFAQEBAQUBAQEBAQEFAQEBBQUBAQEBAQEBAQEBAQEBAQEBAQEBDgEODg4BAQEBAQEBAQEBAQ4ODgEBAQEBAQEBAQEBAQEODg4BAQEBAQEBAQEBAQEBDg4BCwsLCwsLCwsLCwsEBAQBAg4ODg4ODg4OCw0TFBcVFgoICAgICA4ODg4ODg4ODg4ODg4ODgoODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgsEBAQEBAQPEBESBAQEBAQEBwEBAQcHBwcHBwkJDg4OAQcHBwcHBwcHBwcJCQ4ODgEICAgICAgICAgICAgICAgIDg4BDg4ODgEODgEBAQEBAQEBAQEOAQ4ODgEBAQEBDg4ODg4OAQ4BDgEOAQEBAQgBAQEBAQEBAQEBAQ4OAQEBAQ4ODg4OAQEBAQEODg4OAQEBAQEBAQEBAQEODg4BAQEBDg4JCA4ODg4ODg4ODg4ODg4ODg4ODgEBAQEBAQEBAQEODg4ODgEODg4ODg4ODg4ODg4ODg4ODgEBAQEBAQEBAQ4ODg4ODg4ODg4OAQEBAQEODg4ODg4ODgcHBwcHBwcHBwcHBwcHBwcHBwcHAQEBAQEBAQEBAQEBAQEODg4ODg4ODg4ODg4ODg4ODg4BDg4ODg4ODgEBDg4ODg4ODg4ODg4ODg4ODgEODg4ODg4ODg4BAQEBAQ4ODg4ODgEBAQEFBQUBAQEBAQEBDg4ODg4ODgEBAQEBAQEBAQEBAQEBAQUODg4ODg4ODg4ODg4ODgEBDg4ODg4ODg4ODgEODg4ODg4ODg4BAQEBAQEBAQEBAQEODg4ODg4ODg4ODg4BAQEBCw4ODg4BAQEODg4ODg4ODg4BAQEBAQEBAQEFBQUFAQEOAQEBAQEODgEBAQEBDg4OAQEBAQEBAQEBBQUODgEBAQEBAQEBAQEBAQEBDgEBAQEBAQEBAQEBAQEBAQEODg4BAQ4ODg4ODg4ODg4ODg4ODgEBAQEBAQEBAQEBAQ4ODg4BAQEBAQEBDg4ODgEBAQEBAQEBAQEBAQEBAQEBAQEBDgUFBQ4FBQUFBQUFBQUFDg4BAQEBAQEBAQEBAQEBAQUFDg4BAQEBAQEBAQEBAQEBAQEBAQEBAQEBDgEBAQEBAQEBAQUBAQEFAQEBAQUBAQEBAQEBAQEFBQEODg4OBQEBAQEBAQEBAQEBCAgBAQEBAQEBAQEBDg4ODgEBAQEBAQEBAQEBAQUFAQEBAQEBAQEBAQUFAQEBAQEBAQEBAQEBAQUBAQEBAQEFBQUFBQUFBQEBAQEBAQEBAQUFBQUFBQUFBQEBAQUBAQUFBQUBAQUFAQEBAQEBAQUBAQEBAQEBAQEBAQEBAQEBAQEBBQUFBQUFAQEFBQEBBQUBAQEBAQEBAQEBAQEFAQEBAQEBAQEFAQEBBQEFBQUBAQUFAQEBAQEFBQEBAQEBBQEBBQEBAQEFAQEBAQEBAQEBAQEBAQEBAgUCAgICAgICAgICCQICAgICAgMDAwMDAwMDAwMDAwMDDg4DAwMDAwMDAwMDAwMDAwMOAwMDAwMDAwMDAwMDAw4ODgoOCgEOCg4ODg4ODg4ODggODgkJDg4OAQ4ICA4BAQEBAwMDAwMDAwMDAwMDAwMDBAEODggICA4ODg4OCQoJCgoICA4ODggIAQ4ODg4ODg4BBAQEBAQEBAQEDg4ODg4EBAEOAQEBAQEBAQEBAQEBAQEODg4ODg4ODg4ODg4OAQEBBQcHBwcHBwcHBwcHBwcHBwEBAQEBAQUFBQUFAQEBAQECAgICAgICAgICAgICAgIOAgUFBQIFBQICAgICBQUFBQICAgICAgICBQUFAgICAgUCAgICAgUFAgICAgICAgICAgICAgICAgICDg4ODg4ODgMDAwMFBQUFAwMDAwMDAwMGBgYGBgYGBgYGAwMDAwMDBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgICAgICAgICAgICAgUFAgICAgIFBQUFAgICAgICAgICAgEBAQEBAQEBBQUFBQUFBQUFBQUFBQUFAQEBAQEBAQEBBQEBBQUBAQEBAQEBAQEBBQEBAQUFBQUBAQUFAQEBAQEBAQEBAQEBBQUFBQUBBQUFBQUFBQUBAQEBAQEBAQEBAQEBAQUBAQEBAQEBAQEBAQEBAQEBAQEFBQUFBQUFBQUBAQEBAQEBAQEBBQUFBQEBBQUFAQEFAQUFAQEBAQEBBQEBAQEFBQUFBQUFBQEBAQEBAQEBAQEBBQUFBQUFBQEBAQEBAQEBAQEBAQEBAQEBBQEBAQEFBQUFBQUBBQEBAQEFBQEFBQEBAQEBAQEBAQEBAQEBBQUFBQEBAQEBAQUFAQUBAQEFBQUFBQUFBQEBBQEFAQEBAQEBAQEBAQEFAQUBAQUFBQUFBQEFAQEBAQEBAQEBAQUFBQUBBQUFBQUBAQEBBQUFBQUFBQUBBQUBAQEBAQEBAQEBAQEBAQEBBQUBBQEBAQEBBQUFBQEBBQUBAQEBAQUFBQUFBQEBBQUBAQEBAQEBAQUFBQUFBQEBBQUFBQEBAQEBAQEBBQEBAQEBAQEBAQUFBQUFBQEBBQUFAQEBAQEBAQEBAQEBAQEFBQUFBQUFBQUFBQUFAQUFAQEBAQEBBQUFBQUFBQEFBQUFBQUBAQEBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQEBBQUFBQUFBQEFBQEFBQEBAQEBAQEBAQEFBQUFBQUBAQEFAQUFAQUFBQEBAQUBBQEBAQEBAQEBAQEBBQUBAQEBAQEBAQEBAQEBAQEBDg4ODg4ODg4ICAgIDg4ODg4ODg4ODg4ODg4OAQEOAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFBQEEBAQEAQEBAQEBAQEBAQEBBQUFBQUFBQUFBQUFBQUBAQEBAQEBAQEFBQUBAQEBAQEBAQEEBAQEBAQEBAUFBQUFBQUFAQEFBQUFBQUFAQEBAQEBAQEBAQEBAQEFBQUFAQEODgUFBQ4BAQEBAQEBAQEBAQEBAQEOAQEBAQEBAQEBAQEBAQEBAQEBAQ4BAQEBAQEBAQEOAQEBAQEBAQEBAQcHBwcHBwcHBwcHBwcHBwcHBwUFBQUFBQUBAQEBBQUFBQUBAQEBBQEBAQEBAQEBAQEBAQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBQUBAQUFBQUFBQUBBQUBBQUFBQUBAQEBAQEBAQEBAQEBAQEBAQEBAQgFBQUFBQUFAgICAgICAgICAgICAgUFBQUFBQUCAgICAg4OAwMDAwMDAwMDAwMDAwMODg4ODg4ODg4ODg4ODg4BBwcHBwcHBwcHBwcODg4ODgEBAQEBAQEBAQEBAQEOAQEODg4ODg4ODgEBAQEBDg4ODg4ODg4ODg4OAQEBAQEBAQ4ODg4ODg4OAQEBAQEBAQEODg4ODgEBAQ4ODg4OAQEBDg4OAQ4ODg4ODg4ODg4ODgcHBwcHBwcHBwcBAQEBAQEBAQEBAQEBAQEBAQEBAQQEAAAQACAAMABAAFAAQABgAHAAgACQAKAAsADAALAAwACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsADQAOAA4ADwAAABEAEQARABEAEQARABEAEgATABsACwALAAsACwALAAQAGwALAAsACwALAAsACwALAAUAGwALAAsACwALAAsACwALAAsACwALAAsACwALAAsABgAXABEAGAAZABoAGgAaABsAHAAdAB0AHgARAB8AEAAtAB0AHQAdAB0AEQAiACMALQAUAC0AEQAcAB0AHQAdAB0AHQAVACAAKgAaABYAJwAqABgAKQAqABoAGgAtAB0AHQAbAC0AHQAcACEAHQAhAB4AKwALAA8AIAAxADIAOwADADsACwAEADUAOwACADYANwA7AAsABAA4ADMAOwAJADcAOwALAAQAOgA7AAIAOwAzADsACwAMADUAPQAyADsADgA7AAsACwAPADsACwAAAEEASwALAAIAQwBNADIANABDADsACwAEADUASwACADsABgBLAAsABwBFADsAAgA7AAMAOwALAAsACABJAEsACwALAAsACwAKAEsASwALAAsACwALAAsADABNAEsACwALAAsADgBLAA8ASwALAAsAAABRAFIAUQATAFQAWwALAAsACwALAAUAVgBbAAcAWABZAFoAWwBbAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAUAWwALAAsADABbAAsACwALAAsACwAEAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAA0AXgBbAAsACwALAAsACwALAA8AWwACADsAAgA7AAIAOwALAAsAAABhAGIAawAMAFMAawALAAsACwALAAsACwANADsABABrAAsACwALAAsACwALAAUAZgBnAGsACwALAAsACwALAAsACwAIAGAAEAAbAAkAawALAAsACgBrAGwAawALAAsAAQAdAGsACwALAA4AawALAA8AbgA7AAAAfgBmAEsAAQB7AAsACwACAHYASwALAAMAdAB7AAsACwALAAsACwALAAsACwAFAHYAdwB7AAsACwALAAsACwALAAsACwALAAsACwABABEAEQARABsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAgAeQB6AHoAewB8AHAAHQB+AH8AcACBAIIAgwCLAAQAhACEAIEAEQAYAFUAhgCHAIgAiQCAABsACwAKAIAAEAAQABAAEAAQABAAEAAbAIAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAcAIsACwALAAUAAAAdAIAAEAAQABAAEAAQABAAEAAeAIsADwCLAAAAEAAQAJEAmwALAAsACwACAJAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABMAkAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAGwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAUAJAAFQCQABAAEAAQABAAEAAbAAsACwALAAsACwALAAsACwALAAsACwALAAsABgCXAJsACwALAAsACwALAAsACACbAAsACwALAAsACwABABEAEAAQABAAEAAQABkAmwALAAAAGgCQABAAEAAQABAAGwCQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABwAiwAMAJ0AkAAeAJ8AmwALAAsACwALAAAApAALAAsACwALAAEAqwALAAsACwALAAsACwALAAsACwALAAsAAAAQABsAmwALAAsAewALAAsAAAAbAAIAqwALAAsAAwCkAKsACwALAAsACwALAAsACwALAAsABQCrAAsACwALAAsACABrAAYAqwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAAAEAAQABAAGwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAAAEAAQAB4AiwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwAKAHsACwALAAsACwAIAJcAqwAIAKsACwALAAsACwAGAEAAEAAZAKsACwALAAsACwAKAKsACwALAAsACwALAAsACwCrAAwArQCrAAsACwAOAKsACwALAAsADwCrAAEAEAC7AAsAAQC7AAIAtgBLAAsADgArAAsAAwC7AAsABAC7AAsACwAFALYAtwC7AAsABAA7AAsACwAIALMAOwAFAEQAWwALAAsACwALAAsACACLAAsACwALAAsACwALAAkAuwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAoAuwC6ABoAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHACwAB0AHQAdAB0AHQAdAB0AHQC4AAgADgCxABwAUQAQABAAHwCwAM0AHQAdAB0AHQAdAB0AHQARAMIAwwAEAAUABAAFAAwAiwALAAsACwALAAsACwADAMQAywALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwAFAMsACwALAAAAEAAQABAAFgDGAMQACwALAAsACwALAFsACwALAAsACwALAAsACwALAAsACwALAAsACwAHAMEAmwALAAsACwALAAsACwAIAMsACwALAAsACwALAAsACwAKABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGQDKABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgDKABoAGwDKABoAGgAaABoAGgAaABoAGgAaABwAygAaABoAGgAdAMoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAHQAdAB4AzwDKABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAQANEA2gAaABIA2gAaABoAGgAaABoAGgAaAB0AFQAgAC0AGgATANoAGgAaABoAGgAaABoAEwA7AAsABADVAN4ADACGANYASwALAAcA3gA7AAsACwAOACsACADZANsACwALAAoA1gBLAAsACwDcANsACwALAAsACwAIAJ0A2wALAAsACwALAAsACwALAAsACACeANsABgBLAAsABwBIAFsADwDZANsACwALAAsACwALAAsACwALAAsACwAEANkAQADrAAsACwALAAsAAQDiAOsACwALAAsACwALAAsACwALAAsACwALAAsACwADAOgAVQBLAAsACwALAAsABADoAFsABgDLAAsACwAFAOYA6wALAAsACwALAAUAVwDrAAsACwALAAsACwALAAsACwALAAsACwALAAsACwAIAJgA6wALAAsACwALAAsACwALAAsACwALAAsACwALAAsACQDqANsACwALAAsACwALAAsACwAKAOgAWwALAOsACwAMAO0A7gDrAAsADwDgAPsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsAAQD7AAsACwALAAsAAgDzAPQA+wALAAsACwALAAsACwAFAPYA6wALAAsACwAGAPsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAcA+wALAAsACwALAAsACwALAAsACwALAAsACwAIAPkA+QCrAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACQDbAAsACwAFANsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACACbAAsACwAIAJ4AKwALAAsACwAKAPsACwALAAsACwALAAsACwALAAsACwD8APsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwABABEAHQDxABUA2wALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsADgD/APABCwABAQsACwALAA0ACwAAABAAEAAQABIBCwALAAsACwALAAsACwALAAsACwALAAAAEAAQABAAEAAeAIsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsAAQCrAAsACwADAQsACwAGAKsACwALAAQBCwALAAsABQEGAQYBBgELAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsAAQARABEAFwEBABEAEwBUALgBAAB5AQsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAoBCwEMAQsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsABQDbAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAAA6wALAAsAAwB9AQsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAeAQoAGgAaABoAGgAaAB8BCgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaAB0AHQAdAB0AHQAaABoAGgAaAB0AHQAdAB0AHQAaABoAGgAaABoAGgAaABoAGgAaABoAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AEAEaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABAAEAAcAJAAEAAQABAAEAAQABsAkQETAKMAowCgABwAggEbAAYAqwALAAsAAgCbAAsACwADARsACwALAAsACwALAAsACwALAAsACwAMAIsACwALAAsACwALAAsACwALAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAFAEWAMYAwAAQABAAEAAQABAAEAAbAJAAEAAQABAAEAAVARwAlAAMAJAAEAAQABYBHABQABAAFgEQABkAmQCrAAsACwALAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABsAmQCXAR4AgAAWAM8AjACMAFYBHgCAABAAEAAQABAAEAAQABAAEAAYARAAEAAfAIsACwAJARsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAoBGAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAABABEAEQARABEAEQARABEAEQARABEAEQARABEAEQAYAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAABAAIAAwAAAAUABgAHAAQACQAKAAsACAANAA0ADQANAA0ADQAOAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8ADAARAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AEgATABEADAAVABYAFwAUABkAGQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADgAbABkADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADAAdAA0ADQANAB4AHwAcACEADQAhAA4AIwAgACUAJgAnACUADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8AJQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADwAlAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQAPACUADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8AJQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADwAlAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQAPACUADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8AJQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADwAlAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQAPACUADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8AJQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADwAlAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQAPACQAKQApACkAKQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA8AJQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADwAlAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQAPACQAAAQD//wIA/v8QAPD/AwD9/+AH3wmDB3oHfgfKCIoABwD5/yAHOAg8CDoIJAV2/wgA+P/c+ob4gvh9+OD4IPjI98b3xPc29yH2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCAAAAAAAAAAAAAAAAAAAAAAAAAwAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEMAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwCEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCQYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgAAAAAAAAAAAABBggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCAAAAAAAAAAAAAAAAAABBggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHCAgIAAAAAAAAAAkAAAAAAAAAAAAKCwwNAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECAAAAAAAPABAAAAAAAAARAAAAAAABAgECAAAAAAAAAAAAAAAAAAABAgECAQIBAgAAAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAAAAAQIBAgAAAAAAEgAAAAAAAAAAAAECAAATABQVABUAAAAAAQIBAgECAQIWAAAAAAAAAAAAAAAAAAAAAAECAQIXAAABAgAAAAABAgECAQIBAgECAQIBAgECAQIBAgECAQIAAAECGBgYABAQAAAZGRkREQAAAAAAAAAAAEGCQYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCQYJBgkGCQYJBgkGCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAkGCAAECAAMABAAAAAAAAAABAgAAAAAAGgECAAAAAQIBAkGCQYJBgkGCQYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQYJBgkGCQYJBgkeBQohBgkGCQYJBggAAGwAAAAAcAAAdAQIAAAECAQIBAgECAAAAAAAAAAAeAAAAAAAAAAECAAABAgAAAAAAAAAAAAECAQIAAQIAAEGCQYIAAAAAAAAAAAAAAAABAgAAAAAAAAAAAAAAHwAAAQIAAEGCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIBAgAAAAAAAQIAAAAAAAABAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIAAAAAAAAAAAAAAAAAAAAAAAAAAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAAAAAQIBAgECAQIAAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgAAAAAAAAAgAAAAACEiIQAAAAAAAAECIwAAAAAAAAAAAQIBAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgECAAAAAQIAAQIAAAAAAAAAAAAAAAAAAAECAAABAkGCQYJBgkGCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCQYJBgkGCAAAAQYJBgkGCQYJBggAAQYJBgkGCQYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQYJBgkGCAAAAAAABAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGCAAAAAAAAAAAAAAAAAAAAAAAAAwAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEMAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQwCEAEGCAEGCAAAAAAAAAAAAAAAAagDUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUAD4B1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUAKgB1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1AASAnwC1ADUANQA5gJQA7oD1ADUANQA1ADUANQA1ADUANQA1AAkBI4E1ADUANQA+ARiBcwFNgbUANQAoAbUANQA1ADUAAoH1ADUANQA1AB0B9QA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADUANQA1ADeB0gIsggAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQKAvwEDoL8BA4C/AQOAnwEEkL8BBIC/AQSAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEB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MTFjaGFyX3RyYWl0c0ljRUVFRQDwxwYAxJoGAAMAAAACAAAAZJoGAAIAAACsmgYAAggAAE5TdDNfXzIxNWJhc2ljX3N0cmluZ2J1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAAjMgGABSbBgAsmgYAQAAAAAAAAAAQnAYAgA0AAIENAAA4AAAA+P///xCcBgCCDQAAgw0AAMD////A////EJwGAIQNAACFDQAAQAAAAAAAAABkmgYAhg0AAIcNAADA////wP///2SaBgCIDQAAiQ0AAE5TdDNfXzIxOGJhc2ljX3N0cmluZ3N0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAAAIzIBgDImwYA9JoGAAAAAABAnAYAig0AAIsNAABOU3QzX18yOGlvc19iYXNlRQAAAEzIBgAsnAYAAAAAAAAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wABAgQHAwYFAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAA3hIElQAAAAD///////////////8AAAAAAAAAAAAAAABMQ19DVFlQRQAAAABMQ19OVU1FUklDAABMQ19USU1FAAAAAABMQ19DT0xMQVRFAABMQ19NT05FVEFSWQBMQ19NRVNTQUdFUwCwnQYAFAAAAEMuVVRGLTgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAGEAAABiAAAAYwAAAGQAAABlAAAAZgAAAGcAAABoAAAAaQAAAGoAAABrAAAAbAAAAG0AAABuAAAAbwAAAHAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAHkAAAB6AAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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BQIAAAUAAAAFAAAABQAAAAUAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAADAgAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAAAqAQAAKgEAACoBAAAqAQAAKgEAACoBAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAADIBAAAyAQAAMgEAADIBAAAyAQAAMgEAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAggAAAIIAAACCAAAAggAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDPBgDYzwYABQAAAAAAAAAAAAAAaQ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAA5gIAAGoNAABI8AYAAAQAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAP////8KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfw4AAABB7KAbC5gxeyBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gMDsgfSBpZiAodHlwZW9mKHdpbmRvdy5taW5pYXVkaW8pID09PSAndW5kZWZpbmVkJykgeyB3aW5kb3cubWluaWF1ZGlvID0geyByZWZlcmVuY2VDb3VudDogMCB9OyB3aW5kb3cubWluaWF1ZGlvLmRldmljZV90eXBlID0ge307IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3R5cGUucGxheWJhY2sgPSAkMDsgd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5jYXB0dXJlID0gJDE7IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3R5cGUuZHVwbGV4ID0gJDI7IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3N0YXRlID0ge307IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3N0YXRlLnN0b3BwZWQgPSAkMzsgd2luZG93Lm1pbmlhdWRpby5kZXZpY2Vfc3RhdGUuc3RhcnRlZCA9ICQ0OyBsZXQgbWluaWF1ZGlvID0gd2luZG93Lm1pbmlhdWRpbzsgbWluaWF1ZGlvLmRldmljZXMgPSBbXTsgbWluaWF1ZGlvLnRyYWNrX2RldmljZSA9IGZ1bmN0aW9uKGRldmljZSkgeyBmb3IgKHZhciBpRGV2aWNlID0gMDsgaURldmljZSA8IG1pbmlhdWRpby5kZXZpY2VzLmxlbmd0aDsgKytpRGV2aWNlKSB7IGlmIChtaW5pYXVkaW8uZGV2aWNlc1tpRGV2aWNlXSA9PSBudWxsKSB7IG1pbmlhdWRpby5kZXZpY2VzW2lEZXZpY2VdID0gZGV2aWNlOyByZXR1cm4gaURldmljZTsgfSB9IG1pbmlhdWRpby5kZXZpY2VzLnB1c2goZGV2aWNlKTsgcmV0dXJuIG1pbmlhdWRpby5kZXZpY2VzLmxlbmd0aCAtIDE7IH07IG1pbmlhdWRpby51bnRyYWNrX2RldmljZV9ieV9pbmRleCA9IGZ1bmN0aW9uKGRldmljZUluZGV4KSB7IG1pbmlhdWRpby5kZXZpY2VzW2RldmljZUluZGV4XSA9IG51bGw7IHdoaWxlIChtaW5pYXVkaW8uZGV2aWNlcy5sZW5ndGggPiAwKSB7IGlmIChtaW5pYXVkaW8uZGV2aWNlc1ttaW5pYXVkaW8uZGV2aWNlcy5sZW5ndGgtMV0gPT0gbnVsbCkgeyBtaW5pYXVkaW8uZGV2aWNlcy5wb3AoKTsgfSBlbHNlIHsgYnJlYWs7IH0gfSB9OyBtaW5pYXVkaW8udW50cmFja19kZXZpY2UgPSBmdW5jdGlvbihkZXZpY2UpIHsgZm9yICh2YXIgaURldmljZSA9IDA7IGlEZXZpY2UgPCBtaW5pYXVkaW8uZGV2aWNlcy5sZW5ndGg7ICsraURldmljZSkgeyBpZiAobWluaWF1ZGlvLmRldmljZXNbaURldmljZV0gPT0gZGV2aWNlKSB7IHJldHVybiBtaW5pYXVkaW8udW50cmFja19kZXZpY2VfYnlfaW5kZXgoaURldmljZSk7IH0gfSB9OyBtaW5pYXVkaW8uZ2V0X2RldmljZV9ieV9pbmRleCA9IGZ1bmN0aW9uKGRldmljZUluZGV4KSB7IHJldHVybiBtaW5pYXVkaW8uZGV2aWNlc1tkZXZpY2VJbmRleF07IH07IG1pbmlhdWRpby51bmxvY2tfZXZlbnRfdHlwZXMgPSAoZnVuY3Rpb24oKXsgcmV0dXJuIFsndG91Y2hlbmQnLCAnY2xpY2snXTsgfSkoKTsgbWluaWF1ZGlvLnVubG9jayA9IGZ1bmN0aW9uKCkgeyBmb3IodmFyIGkgPSAwOyBpIDwgbWluaWF1ZGlvLmRldmljZXMubGVuZ3RoOyArK2kpIHsgdmFyIGRldmljZSA9IG1pbmlhdWRpby5kZXZpY2VzW2ldOyBpZiAoZGV2aWNlICE9IG51bGwgJiYgZGV2aWNlLndlYmF1ZGlvICE9IG51bGwgJiYgZGV2aWNlLnN0YXRlID09PSBtaW5pYXVkaW8uZGV2aWNlX3N0YXRlLnN0YXJ0ZWQpIHsgZGV2aWNlLndlYmF1ZGlvLnJlc3VtZSgpLnRoZW4oKCkgPT4geyBfbWFfZGV2aWNlX19vbl9ub3RpZmljYXRpb25fdW5sb2NrZWQoZGV2aWNlLnBEZXZpY2UpOyB9LCAoZXJyb3IpID0+IHtjb25zb2xlLmVycm9yKCJGYWlsZWQgdG8gcmVzdW1lIGF1ZGlvY29udGV4dCIsIGVycm9yKTsgfSk7IH0gfSBtaW5pYXVkaW8udW5sb2NrX2V2ZW50X3R5cGVzLm1hcChmdW5jdGlvbihldmVudF90eXBlKSB7IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfdHlwZSwgbWluaWF1ZGlvLnVubG9jaywgdHJ1ZSk7IH0pOyB9OyBtaW5pYXVkaW8udW5sb2NrX2V2ZW50X3R5cGVzLm1hcChmdW5jdGlvbihldmVudF90eXBlKSB7IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfdHlwZSwgbWluaWF1ZGlvLnVubG9jaywgdHJ1ZSk7IH0pOyB9IHdpbmRvdy5taW5pYXVkaW8ucmVmZXJlbmNlQ291bnQgKz0gMTsgcmV0dXJuIDE7IH0AeyBpZiAodHlwZW9mKHdpbmRvdy5taW5pYXVkaW8pICE9PSAndW5kZWZpbmVkJykgeyB3aW5kb3cubWluaWF1ZGlvLnJlZmVyZW5jZUNvdW50IC09IDE7IGlmICh3aW5kb3cubWluaWF1ZGlvLnJlZmVyZW5jZUNvdW50ID09PSAwKSB7IGRlbGV0ZSB3aW5kb3cubWluaWF1ZGlvOyB9IH0gfQB7IHJldHVybiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhICE9PSB1bmRlZmluZWQpOyB9AHsgdHJ5IHsgdmFyIHRlbXAgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTsgdmFyIHNhbXBsZVJhdGUgPSB0ZW1wLnNhbXBsZVJhdGU7IHRlbXAuY2xvc2UoKTsgcmV0dXJuIHNhbXBsZVJhdGU7IH0gY2F0Y2goZSkgeyByZXR1cm4gMDsgfSB9AHsgdmFyIGRldmljZVR5cGUgPSAkMDsgdmFyIGNoYW5uZWxzID0gJDE7IHZhciBzYW1wbGVSYXRlID0gJDI7IHZhciBidWZmZXJTaXplID0gJDM7IHZhciBwSW50ZXJtZWRpYXJ5QnVmZmVyID0gJDQ7IHZhciBwRGV2aWNlID0gJDU7IGlmICh0eXBlb2Yod2luZG93Lm1pbmlhdWRpbykgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiAtMTsgfSB2YXIgZGV2aWNlID0ge307IHZhciBhdWRpb0NvbnRleHRPcHRpb25zID0ge307IGlmIChkZXZpY2VUeXBlID09IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3R5cGUucGxheWJhY2sgJiYgc2FtcGxlUmF0ZSAhPSAwKSB7IGF1ZGlvQ29udGV4dE9wdGlvbnMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7IH0gZGV2aWNlLndlYmF1ZGlvID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKGF1ZGlvQ29udGV4dE9wdGlvbnMpOyBkZXZpY2Uud2ViYXVkaW8uc3VzcGVuZCgpOyBkZXZpY2Uuc3RhdGUgPSB3aW5kb3cubWluaWF1ZGlvLmRldmljZV9zdGF0ZS5zdG9wcGVkOyB2YXIgY2hhbm5lbENvdW50SW4gPSAwOyB2YXIgY2hhbm5lbENvdW50T3V0ID0gY2hhbm5lbHM7IGlmIChkZXZpY2VUeXBlICE9IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3R5cGUucGxheWJhY2spIHsgY2hhbm5lbENvdW50SW4gPSBjaGFubmVsczsgfSBkZXZpY2Uuc2NyaXB0Tm9kZSA9IGRldmljZS53ZWJhdWRpby5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoYnVmZmVyU2l6ZSwgY2hhbm5lbENvdW50SW4sIGNoYW5uZWxDb3VudE91dCk7IGRldmljZS5zY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oZSkgeyBpZiAoZGV2aWNlLmludGVybWVkaWFyeUJ1ZmZlclZpZXcgPT0gbnVsbCB8fCBkZXZpY2UuaW50ZXJtZWRpYXJ5QnVmZmVyVmlldy5sZW5ndGggPT0gMCkgeyBkZXZpY2UuaW50ZXJtZWRpYXJ5QnVmZmVyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoSEVBUEYzMi5idWZmZXIsIHBJbnRlcm1lZGlhcnlCdWZmZXIsIGJ1ZmZlclNpemUgKiBjaGFubmVscyk7IH0gaWYgKGRldmljZVR5cGUgPT0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5jYXB0dXJlIHx8IGRldmljZVR5cGUgPT0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5kdXBsZXgpIHsgZm9yICh2YXIgaUNoYW5uZWwgPSAwOyBpQ2hhbm5lbCA8IGNoYW5uZWxzOyBpQ2hhbm5lbCArPSAxKSB7IHZhciBpbnB1dEJ1ZmZlciA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaUNoYW5uZWwpOyB2YXIgaW50ZXJtZWRpYXJ5QnVmZmVyID0gZGV2aWNlLmludGVybWVkaWFyeUJ1ZmZlclZpZXc7IGZvciAodmFyIGlGcmFtZSA9IDA7IGlGcmFtZSA8IGJ1ZmZlclNpemU7IGlGcmFtZSArPSAxKSB7IGludGVybWVkaWFyeUJ1ZmZlcltpRnJhbWUqY2hhbm5lbHMgKyBpQ2hhbm5lbF0gPSBpbnB1dEJ1ZmZlcltpRnJhbWVdOyB9IH0gX21hX2RldmljZV9wcm9jZXNzX3BjbV9mcmFtZXNfY2FwdHVyZV9fd2ViYXVkaW8ocERldmljZSwgYnVmZmVyU2l6ZSwgcEludGVybWVkaWFyeUJ1ZmZlcik7IH0gaWYgKGRldmljZVR5cGUgPT0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5wbGF5YmFjayB8fCBkZXZpY2VUeXBlID09IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3R5cGUuZHVwbGV4KSB7IF9tYV9kZXZpY2VfcHJvY2Vzc19wY21fZnJhbWVzX3BsYXliYWNrX193ZWJhdWRpbyhwRGV2aWNlLCBidWZmZXJTaXplLCBwSW50ZXJtZWRpYXJ5QnVmZmVyKTsgZm9yICh2YXIgaUNoYW5uZWwgPSAwOyBpQ2hhbm5lbCA8IGUub3V0cHV0QnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7ICsraUNoYW5uZWwpIHsgdmFyIG91dHB1dEJ1ZmZlciA9IGUub3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKGlDaGFubmVsKTsgdmFyIGludGVybWVkaWFyeUJ1ZmZlciA9IGRldmljZS5pbnRlcm1lZGlhcnlCdWZmZXJWaWV3OyBmb3IgKHZhciBpRnJhbWUgPSAwOyBpRnJhbWUgPCBidWZmZXJTaXplOyBpRnJhbWUgKz0gMSkgeyBvdXRwdXRCdWZmZXJbaUZyYW1lXSA9IGludGVybWVkaWFyeUJ1ZmZlcltpRnJhbWUqY2hhbm5lbHMgKyBpQ2hhbm5lbF07IH0gfSB9IGVsc2UgeyBmb3IgKHZhciBpQ2hhbm5lbCA9IDA7IGlDaGFubmVsIDwgZS5vdXRwdXRCdWZmZXIubnVtYmVyT2ZDaGFubmVsczsgKytpQ2hhbm5lbCkgeyBlLm91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShpQ2hhbm5lbCkuZmlsbCgwLjApOyB9IH0gfTsgaWYgKGRldmljZVR5cGUgPT0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5jYXB0dXJlIHx8IGRldmljZVR5cGUgPT0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2VfdHlwZS5kdXBsZXgpIHsgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOnRydWUsIHZpZGVvOmZhbHNlfSkgLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7IGRldmljZS5zdHJlYW1Ob2RlID0gZGV2aWNlLndlYmF1ZGlvLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7IGRldmljZS5zdHJlYW1Ob2RlLmNvbm5lY3QoZGV2aWNlLnNjcmlwdE5vZGUpOyBkZXZpY2Uuc2NyaXB0Tm9kZS5jb25uZWN0KGRldmljZS53ZWJhdWRpby5kZXN0aW5hdGlvbik7IH0pIC5jYXRjaChmdW5jdGlvbihlcnJvcikgeyBjb25zb2xlLmxvZygiRmFpbGVkIHRvIGdldCB1c2VyIG1lZGlhOiAiICsgZXJyb3IpOyB9KTsgfSBpZiAoZGV2aWNlVHlwZSA9PSB3aW5kb3cubWluaWF1ZGlvLmRldmljZV90eXBlLnBsYXliYWNrKSB7IGRldmljZS5zY3JpcHROb2RlLmNvbm5lY3QoZGV2aWNlLndlYmF1ZGlvLmRlc3RpbmF0aW9uKTsgfSBkZXZpY2UucERldmljZSA9IHBEZXZpY2U7IHJldHVybiB3aW5kb3cubWluaWF1ZGlvLnRyYWNrX2RldmljZShkZXZpY2UpOyB9AHsgcmV0dXJuIHdpbmRvdy5taW5pYXVkaW8uZ2V0X2RldmljZV9ieV9pbmRleCgkMCkud2ViYXVkaW8uc2FtcGxlUmF0ZTsgfQB7IHZhciBkZXZpY2UgPSB3aW5kb3cubWluaWF1ZGlvLmdldF9kZXZpY2VfYnlfaW5kZXgoJDApOyBpZiAoZGV2aWNlLnNjcmlwdE5vZGUgIT09IHVuZGVmaW5lZCkgeyBkZXZpY2Uuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uKGUpIHt9OyBkZXZpY2Uuc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCk7IGRldmljZS5zY3JpcHROb2RlID0gdW5kZWZpbmVkOyB9IGlmIChkZXZpY2Uuc3RyZWFtTm9kZSAhPT0gdW5kZWZpbmVkKSB7IGRldmljZS5zdHJlYW1Ob2RlLmRpc2Nvbm5lY3QoKTsgZGV2aWNlLnN0cmVhbU5vZGUgPSB1bmRlZmluZWQ7IH0gZGV2aWNlLndlYmF1ZGlvLmNsb3NlKCk7IGRldmljZS53ZWJhdWRpbyA9IHVuZGVmaW5lZDsgZGV2aWNlLnBEZXZpY2UgPSB1bmRlZmluZWQ7IH0AeyB3aW5kb3cubWluaWF1ZGlvLnVudHJhY2tfZGV2aWNlX2J5X2luZGV4KCQwKTsgfQB7IHZhciBkZXZpY2UgPSB3aW5kb3cubWluaWF1ZGlvLmdldF9kZXZpY2VfYnlfaW5kZXgoJDApOyBkZXZpY2Uud2ViYXVkaW8ucmVzdW1lKCk7IGRldmljZS5zdGF0ZSA9IHdpbmRvdy5taW5pYXVkaW8uZGV2aWNlX3N0YXRlLnN0YXJ0ZWQ7IH0AeyB2YXIgZGV2aWNlID0gd2luZG93Lm1pbmlhdWRpby5nZXRfZGV2aWNlX2J5X2luZGV4KCQwKTsgZGV2aWNlLndlYmF1ZGlvLnN1c3BlbmQoKTsgZGV2aWNlLnN0YXRlID0gd2luZG93Lm1pbmlhdWRpby5kZXZpY2Vfc3RhdGUuc3RvcHBlZDsgfQA=";
          if (!Qa(Ra)) {
            var Sa = Ra;
            Ra = m.locateFile ? m.locateFile(Sa, pa) : pa + Sa;
          }
          function Ta() {
            var a = Ra;
            return Promise.resolve().then(function () {
              if (a == Ra && wa) {
                var b = new Uint8Array(wa);
              } else {
                if (Qa(a)) {
                  try {
                    b = atob(a.slice(37));
                    for (var c = new Uint8Array(b.length), d = 0; d < b.length; ++d) {
                      c[d] = b.charCodeAt(d);
                    }
                  } catch (e) {
                    throw Error("Converting base64 string to bytes failed.");
                  }
                  b = c;
                } else {
                  b = void 0;
                }
                if (!b) {
                  if (qa) {
                    b = qa(a);
                  } else {
                    throw "both async and sync fetching of the wasm failed";
                  }
                }
              }
              return b;
            });
          }
          function Ua(a, b) {
            return Ta().then(function (c) {
              return WebAssembly.instantiate(c, a);
            }).then(function (c) {
              return c;
            }).then(b, function (c) {
              va("failed to asynchronously prepare wasm: " + c);
              xa(c);
            });
          }
          function Va(a, b) {
            return Ua(a, b);
          }
          var Wa,
            Xa,
            ab = {
              446572: function _(a, b, c, d, e) {
                if ("undefined" === typeof window || void 0 === (window.AudioContext || window.webkitAudioContext)) {
                  return 0;
                }
                if ("undefined" === typeof window.h) {
                  window.h = {
                    Aa: 0
                  };
                  window.h.I = {};
                  window.h.I.ya = a;
                  window.h.I.capture = b;
                  window.h.I.La = c;
                  window.h.ga = {};
                  window.h.ga.stopped = d;
                  window.h.ga.xb = e;
                  var f = window.h;
                  f.D = [];
                  f.yc = function (g) {
                    for (var n = 0; n < f.D.length; ++n) {
                      if (null == f.D[n]) {
                        return f.D[n] = g, n;
                      }
                    }
                    f.D.push(g);
                    return f.D.length - 1;
                  };
                  f.Cb = function (g) {
                    for (f.D[g] = null; 0 < f.D.length;) {
                      if (null == f.D[f.D.length - 1]) {
                        f.D.pop();
                      } else {
                        break;
                      }
                    }
                  };
                  f.Sc = function (g) {
                    for (var n = 0; n < f.D.length; ++n) {
                      if (f.D[n] == g) {
                        return f.Cb(n);
                      }
                    }
                  };
                  f.ra = function (g) {
                    return f.D[g];
                  };
                  f.Bb = ["touchend", "click"];
                  f.unlock = function () {
                    for (var g = 0; g < f.D.length; ++g) {
                      var n = f.D[g];
                      null != n && null != n.J && n.state === f.ga.xb && n.J.resume().then(function () {
                        Ya(n.pb);
                      }, function (p) {
                        console.error("Failed to resume audiocontext", p);
                      });
                    }
                    f.Bb.map(function (p) {
                      document.removeEventListener(p, f.unlock, !0);
                    });
                  };
                  f.Bb.map(function (g) {
                    document.addEventListener(g, f.unlock, !0);
                  });
                }
                window.h.Aa += 1;
                return 1;
              },
              448750: function _() {
                "undefined" !== typeof window.h && (--window.h.Aa, 0 === window.h.Aa && delete window.h);
              },
              448914: function _() {
                return void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia;
              },
              449018: function _() {
                try {
                  var a = new (window.AudioContext || window.webkitAudioContext)(),
                    b = a.sampleRate;
                  a.close();
                  return b;
                } catch (c) {
                  return 0;
                }
              },
              449189: function _(a, b, c, d, e, f) {
                if ("undefined" === typeof window.h) {
                  return -1;
                }
                var g = {},
                  n = {};
                a == window.h.I.ya && 0 != c && (n.sampleRate = c);
                g.J = new (window.AudioContext || window.webkitAudioContext)(n);
                g.J.suspend();
                g.state = window.h.ga.stopped;
                c = 0;
                a != window.h.I.ya && (c = b);
                g.Z = g.J.createScriptProcessor(d, c, b);
                g.Z.onaudioprocess = function (p) {
                  if (null == g.sa || 0 == g.sa.length) {
                    g.sa = new Float32Array(Da.buffer, e, d * b);
                  }
                  if (a == window.h.I.capture || a == window.h.I.La) {
                    for (var l = 0; l < b; l += 1) {
                      for (var u = p.inputBuffer.getChannelData(l), v = g.sa, x = 0; x < d; x += 1) {
                        v[x * b + l] = u[x];
                      }
                    }
                    Za(f, d, e);
                  }
                  if (a == window.h.I.ya || a == window.h.I.La) {
                    for ($a(f, d, e), l = 0; l < p.outputBuffer.numberOfChannels; ++l) {
                      for (u = p.outputBuffer.getChannelData(l), v = g.sa, x = 0; x < d; x += 1) {
                        u[x] = v[x * b + l];
                      }
                    }
                  } else {
                    for (l = 0; l < p.outputBuffer.numberOfChannels; ++l) {
                      p.outputBuffer.getChannelData(l).fill(0.0);
                    }
                  }
                };
                a != window.h.I.capture && a != window.h.I.La || navigator.mediaDevices.getUserMedia({
                  audio: !0,
                  video: !1
                }).then(function (p) {
                  g.Da = g.J.createMediaStreamSource(p);
                  g.Da.connect(g.Z);
                  g.Z.connect(g.J.destination);
                }).catch(function (p) {
                  console.log("Failed to get user media: " + p);
                });
                a == window.h.I.ya && g.Z.connect(g.J.destination);
                g.pb = f;
                return window.h.yc(g);
              },
              452066: function _(a) {
                return window.h.ra(a).J.sampleRate;
              },
              452139: function _(a) {
                a = window.h.ra(a);
                void 0 !== a.Z && (a.Z.onaudioprocess = function () {}, a.Z.disconnect(), a.Z = void 0);
                void 0 !== a.Da && (a.Da.disconnect(), a.Da = void 0);
                a.J.close();
                a.J = void 0;
                a.pb = void 0;
              },
              452539: function _(a) {
                window.h.Cb(a);
              },
              452589: function _(a) {
                a = window.h.ra(a);
                a.J.resume();
                a.state = window.h.ga.xb;
              },
              452728: function _(a) {
                a = window.h.ra(a);
                a.J.suspend();
                a.state = window.h.ga.stopped;
              }
            },
            bb = function bb(a) {
              for (; 0 < a.length;) {
                a.shift()(m);
              }
            },
            cb = function cb(a, b) {
              for (var c = 0, d = a.length - 1; 0 <= d; d--) {
                var e = a[d];
                "." === e ? a.splice(d, 1) : ".." === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);
              }
              if (b) {
                for (; c; c--) {
                  a.unshift("..");
                }
              }
              return a;
            },
            db = function db(a) {
              var b = "/" === a.charAt(0),
                c = "/" === a.substr(-1);
              (a = cb(a.split("/").filter(function (d) {
                return !!d;
              }), !b).join("/")) || b || (a = ".");
              a && c && (a += "/");
              return (b ? "/" : "") + a;
            },
            eb = function eb(a) {
              var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
              a = b[0];
              b = b[1];
              if (!a && !b) {
                return ".";
              }
              b && (b = b.substr(0, b.length - 1));
              return a + b;
            },
            fb = function fb(a) {
              if ("/" === a) {
                return "/";
              }
              a = db(a);
              a = a.replace(/\/$/, "");
              var b = a.lastIndexOf("/");
              return -1 === b ? a : a.substr(b + 1);
            },
            gb = function gb() {
              if ("object" == (typeof crypto === "undefined" ? "undefined" : _typeof(crypto)) && "function" == typeof crypto.getRandomValues) {
                return function (a) {
                  return crypto.getRandomValues(a);
                };
              }
              xa("initRandomDevice");
            },
            _hb = function hb(a) {
              return (_hb = gb())(a);
            };
          function ib() {
            for (var a = "", b = !1, c = arguments.length - 1; -1 <= c && !b; c--) {
              b = 0 <= c ? arguments[c] : "/";
              if ("string" != typeof b) {
                throw new TypeError("Arguments to path.resolve must be strings");
              }
              if (!b) {
                return "";
              }
              a = b + "/" + a;
              b = "/" === b.charAt(0);
            }
            a = cb(a.split("/").filter(function (d) {
              return !!d;
            }), !b).join("/");
            return (b ? "/" : "") + a || ".";
          }
          var jb = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0,
            kb = function kb(a, b, c) {
              var d = b + c;
              for (c = b; a[c] && !(c >= d);) {
                ++c;
              }
              if (16 < c - b && a.buffer && jb) {
                return jb.decode(a.subarray(b, c));
              }
              for (d = ""; b < c;) {
                var e = a[b++];
                if (e & 128) {
                  var f = a[b++] & 63;
                  if (192 == (e & 224)) {
                    d += String.fromCharCode((e & 31) << 6 | f);
                  } else {
                    var g = a[b++] & 63;
                    e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a[b++] & 63;
                    65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
                  }
                } else {
                  d += String.fromCharCode(e);
                }
              }
              return d;
            },
            lb = [],
            mb = function mb(a) {
              for (var b = 0, c = 0; c < a.length; ++c) {
                var d = a.charCodeAt(c);
                127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
              }
              return b;
            },
            nb = function nb(a, b, c, d) {
              if (!(0 < d)) {
                return 0;
              }
              var e = c;
              d = c + d - 1;
              for (var f = 0; f < a.length; ++f) {
                var g = a.charCodeAt(f);
                if (55296 <= g && 57343 >= g) {
                  var n = a.charCodeAt(++f);
                  g = 65536 + ((g & 1023) << 10) | n & 1023;
                }
                if (127 >= g) {
                  if (c >= d) {
                    break;
                  }
                  b[c++] = g;
                } else {
                  if (2047 >= g) {
                    if (c + 1 >= d) {
                      break;
                    }
                    b[c++] = 192 | g >> 6;
                  } else {
                    if (65535 >= g) {
                      if (c + 2 >= d) {
                        break;
                      }
                      b[c++] = 224 | g >> 12;
                    } else {
                      if (c + 3 >= d) {
                        break;
                      }
                      b[c++] = 240 | g >> 18;
                      b[c++] = 128 | g >> 12 & 63;
                    }
                    b[c++] = 128 | g >> 6 & 63;
                  }
                  b[c++] = 128 | g & 63;
                }
              }
              b[c] = 0;
              return c - e;
            };
          function ob(a, b) {
            var c = Array(mb(a) + 1);
            a = nb(a, c, 0, c.length);
            b && (c.length = a);
            return c;
          }
          var pb = [];
          function qb(a, b) {
            pb[a] = {
              input: [],
              F: [],
              V: b
            };
            rb(a, sb);
          }
          var sb = {
              open: function open(a) {
                var b = pb[a.node.za];
                if (!b) {
                  throw new O(43);
                }
                a.s = b;
                a.seekable = !1;
              },
              close: function close(a) {
                a.s.V.qa(a.s);
              },
              qa: function qa(a) {
                a.s.V.qa(a.s);
              },
              read: function read(a, b, c, d) {
                if (!a.s || !a.s.V.ib) {
                  throw new O(60);
                }
                for (var e = 0, f = 0; f < d; f++) {
                  try {
                    var g = a.s.V.ib(a.s);
                  } catch (n) {
                    throw new O(29);
                  }
                  if (void 0 === g && 0 === e) {
                    throw new O(6);
                  }
                  if (null === g || void 0 === g) {
                    break;
                  }
                  e++;
                  b[c + f] = g;
                }
                e && (a.node.timestamp = Date.now());
                return e;
              },
              write: function write(a, b, c, d) {
                if (!a.s || !a.s.V.Oa) {
                  throw new O(60);
                }
                try {
                  for (var e = 0; e < d; e++) {
                    a.s.V.Oa(a.s, b[c + e]);
                  }
                } catch (f) {
                  throw new O(29);
                }
                d && (a.node.timestamp = Date.now());
                return e;
              }
            },
            tb = {
              ib: function ib() {
                a: {
                  if (!lb.length) {
                    var a = null;
                    "undefined" != typeof window && "function" == typeof window.prompt ? (a = window.prompt("Input: "), null !== a && (a += "\n")) : "function" == typeof readline && (a = readline(), null !== a && (a += "\n"));
                    if (!a) {
                      a = null;
                      break a;
                    }
                    lb = ob(a, !0);
                  }
                  a = lb.shift();
                }
                return a;
              },
              Oa: function Oa(a, b) {
                null === b || 10 === b ? (ua(kb(a.F, 0)), a.F = []) : 0 != b && a.F.push(b);
              },
              qa: function qa(a) {
                a.F && 0 < a.F.length && (ua(kb(a.F, 0)), a.F = []);
              },
              bc: function bc() {
                return {
                  Fc: 25856,
                  Hc: 5,
                  Ec: 191,
                  Gc: 35387,
                  Dc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                };
              },
              cc: function cc() {
                return 0;
              },
              dc: function dc() {
                return [24, 80];
              }
            },
            ub = {
              Oa: function Oa(a, b) {
                null === b || 10 === b ? (va(kb(a.F, 0)), a.F = []) : 0 != b && a.F.push(b);
              },
              qa: function qa(a) {
                a.F && 0 < a.F.length && (va(kb(a.F, 0)), a.F = []);
              }
            };
          function vb(a, b) {
            var c = a.j ? a.j.length : 0;
            c >= b || (b = Math.max(b, c * (1048576 > c ? 2.0 : 1.125) >>> 0), 0 != c && (b = Math.max(b, 256)), c = a.j, a.j = new Uint8Array(b), 0 < a.v && a.j.set(c.subarray(0, a.v), 0));
          }
          var P = {
            O: null,
            U: function U() {
              return P.createNode(null, "/", 16895, 0);
            },
            createNode: function createNode(a, b, c, d) {
              if (24576 === (c & 61440) || 4096 === (c & 61440)) {
                throw new O(63);
              }
              P.O || (P.O = {
                dir: {
                  node: {
                    Y: P.l.Y,
                    P: P.l.P,
                    ka: P.l.ka,
                    va: P.l.va,
                    ub: P.l.ub,
                    Ab: P.l.Ab,
                    vb: P.l.vb,
                    sb: P.l.sb,
                    Ea: P.l.Ea
                  },
                  stream: {
                    ba: P.m.ba
                  }
                },
                file: {
                  node: {
                    Y: P.l.Y,
                    P: P.l.P
                  },
                  stream: {
                    ba: P.m.ba,
                    read: P.m.read,
                    write: P.m.write,
                    pa: P.m.pa,
                    lb: P.m.lb,
                    nb: P.m.nb
                  }
                },
                link: {
                  node: {
                    Y: P.l.Y,
                    P: P.l.P,
                    ma: P.l.ma
                  },
                  stream: {}
                },
                $a: {
                  node: {
                    Y: P.l.Y,
                    P: P.l.P
                  },
                  stream: wb
                }
              });
              c = xb(a, b, c, d);
              16384 === (c.mode & 61440) ? (c.l = P.O.dir.node, c.m = P.O.dir.stream, c.j = {}) : 32768 === (c.mode & 61440) ? (c.l = P.O.file.node, c.m = P.O.file.stream, c.v = 0, c.j = null) : 40960 === (c.mode & 61440) ? (c.l = P.O.link.node, c.m = P.O.link.stream) : 8192 === (c.mode & 61440) && (c.l = P.O.$a.node, c.m = P.O.$a.stream);
              c.timestamp = Date.now();
              a && (a.j[b] = c, a.timestamp = c.timestamp);
              return c;
            },
            Kc: function Kc(a) {
              return a.j ? a.j.subarray ? a.j.subarray(0, a.v) : new Uint8Array(a.j) : new Uint8Array(0);
            },
            l: {
              Y: function Y(a) {
                var b = {};
                b.Jc = 8192 === (a.mode & 61440) ? a.id : 1;
                b.Mc = a.id;
                b.mode = a.mode;
                b.Oc = 1;
                b.uid = 0;
                b.Lc = 0;
                b.za = a.za;
                16384 === (a.mode & 61440) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.v : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;
                b.Bc = new Date(a.timestamp);
                b.Nc = new Date(a.timestamp);
                b.Ic = new Date(a.timestamp);
                b.Jb = 4096;
                b.Cc = Math.ceil(b.size / b.Jb);
                return b;
              },
              P: function P(a, b) {
                void 0 !== b.mode && (a.mode = b.mode);
                void 0 !== b.timestamp && (a.timestamp = b.timestamp);
                if (void 0 !== b.size && (b = b.size, a.v != b)) {
                  if (0 == b) {
                    a.j = null, a.v = 0;
                  } else {
                    var c = a.j;
                    a.j = new Uint8Array(b);
                    c && a.j.set(c.subarray(0, Math.min(b, a.v)));
                    a.v = b;
                  }
                }
              },
              ka: function ka() {
                throw yb[44];
              },
              va: function va(a, b, c, d) {
                return P.createNode(a, b, c, d);
              },
              ub: function ub(a, b, c) {
                if (16384 === (a.mode & 61440)) {
                  try {
                    var d = zb(b, c);
                  } catch (f) {}
                  if (d) {
                    for (var e in d.j) {
                      throw new O(55);
                    }
                  }
                }
                delete a.parent.j[a.name];
                a.parent.timestamp = Date.now();
                a.name = c;
                b.j[c] = a;
                b.timestamp = a.parent.timestamp;
                a.parent = b;
              },
              Ab: function Ab(a, b) {
                delete a.j[b];
                a.timestamp = Date.now();
              },
              vb: function vb(a, b) {
                var c = zb(a, b),
                  d;
                for (d in c.j) {
                  throw new O(55);
                }
                delete a.j[b];
                a.timestamp = Date.now();
              },
              sb: function sb(a) {
                var b = [".", ".."],
                  c;
                for (c in a.j) {
                  a.j.hasOwnProperty(c) && b.push(c);
                }
                return b;
              },
              Ea: function Ea(a, b, c) {
                a = P.createNode(a, b, 41471, 0);
                a.link = c;
                return a;
              },
              ma: function ma(a) {
                if (40960 !== (a.mode & 61440)) {
                  throw new O(28);
                }
                return a.link;
              }
            },
            m: {
              read: function read(a, b, c, d, e) {
                var f = a.node.j;
                if (e >= a.node.v) {
                  return 0;
                }
                a = Math.min(a.node.v - e, d);
                if (8 < a && f.subarray) {
                  b.set(f.subarray(e, e + a), c);
                } else {
                  for (d = 0; d < a; d++) {
                    b[c + d] = f[e + d];
                  }
                }
                return a;
              },
              write: function write(a, b, c, d, e, f) {
                b.buffer === C.buffer && (f = !1);
                if (!d) {
                  return 0;
                }
                a = a.node;
                a.timestamp = Date.now();
                if (b.subarray && (!a.j || a.j.subarray)) {
                  if (f) {
                    return a.j = b.subarray(c, c + d), a.v = d;
                  }
                  if (0 === a.v && 0 === e) {
                    return a.j = b.slice(c, c + d), a.v = d;
                  }
                  if (e + d <= a.v) {
                    return a.j.set(b.subarray(c, c + d), e), d;
                  }
                }
                vb(a, e + d);
                if (a.j.subarray && b.subarray) {
                  a.j.set(b.subarray(c, c + d), e);
                } else {
                  for (f = 0; f < d; f++) {
                    a.j[e + f] = b[c + f];
                  }
                }
                a.v = Math.max(a.v, e + d);
                return d;
              },
              ba: function ba(a, b, c) {
                1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.v);
                if (0 > b) {
                  throw new O(28);
                }
                return b;
              },
              pa: function pa(a, b, c) {
                vb(a.node, b + c);
                a.node.v = Math.max(a.node.v, b + c);
              },
              lb: function lb(a, b, c, d, e) {
                if (32768 !== (a.node.mode & 61440)) {
                  throw new O(43);
                }
                a = a.node.j;
                if (e & 2 || a.buffer !== C.buffer) {
                  if (0 < c || c + b < a.length) {
                    a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);
                  }
                  c = !0;
                  xa();
                  b = void 0;
                  if (!b) {
                    throw new O(48);
                  }
                  C.set(a, b);
                } else {
                  c = !1, b = a.byteOffset;
                }
                return {
                  o: b,
                  M: c
                };
              },
              nb: function nb(a, b, c, d) {
                P.m.write(a, b, 0, d, c, !1);
                return 0;
              }
            }
          };
          function Ab(a, b) {
            var c = 0;
            a && (c |= 365);
            b && (c |= 146);
            return c;
          }
          var Bb = null,
            Cb = {},
            Db = [],
            Eb = 1,
            Fb = null,
            Gb = !0,
            O = null,
            yb = {},
            _Ib = function Ib(a) {
              var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              a = ib(a);
              if (!a) {
                return {
                  path: "",
                  node: null
                };
              }
              b = Object.assign({
                gb: !0,
                Qa: 0
              }, b);
              if (8 < b.Qa) {
                throw new O(32);
              }
              a = a.split("/").filter(function (g) {
                return !!g;
              });
              for (var c = Bb, d = "/", e = 0; e < a.length; e++) {
                var f = e === a.length - 1;
                if (f && b.parent) {
                  break;
                }
                c = zb(c, a[e]);
                d = db(d + "/" + a[e]);
                c.wa && (!f || f && b.gb) && (c = c.wa.root);
                if (!f || b.fb) {
                  for (f = 0; 40960 === (c.mode & 61440);) {
                    if (c = Hb(d), d = ib(eb(d), c), c = _Ib(d, {
                      Qa: b.Qa + 1
                    }).node, 40 < f++) {
                      throw new O(32);
                    }
                  }
                }
              }
              return {
                path: d,
                node: c
              };
            },
            Jb = function Jb(a) {
              for (var b;;) {
                if (a === a.parent) {
                  return a = a.U.mb, b ? "/" !== a[a.length - 1] ? "".concat(a, "/").concat(b) : a + b : a;
                }
                b = b ? "".concat(a.name, "/").concat(b) : a.name;
                a = a.parent;
              }
            },
            Kb = function Kb(a, b) {
              for (var c = 0, d = 0; d < b.length; d++) {
                c = (c << 5) - c + b.charCodeAt(d) | 0;
              }
              return (a + c >>> 0) % Fb.length;
            },
            zb = function zb(a, b) {
              var c;
              if (c = (c = Lb(a, "x")) ? c : a.l.ka ? 0 : 2) {
                throw new O(c, a);
              }
              for (c = Fb[Kb(a.id, b)]; c; c = c.lc) {
                var d = c.name;
                if (c.parent.id === a.id && d === b) {
                  return c;
                }
              }
              return a.l.ka(a, b);
            },
            xb = function xb(a, b, c, d) {
              a = new Mb(a, b, c, d);
              b = Kb(a.parent.id, a.name);
              a.lc = Fb[b];
              return Fb[b] = a;
            },
            Nb = function Nb(a) {
              var b = ["r", "w", "rw"][a & 3];
              a & 512 && (b += "w");
              return b;
            },
            Lb = function Lb(a, b) {
              if (Gb) {
                return 0;
              }
              if (!b.includes("r") || a.mode & 292) {
                if (b.includes("w") && !(a.mode & 146) || b.includes("x") && !(a.mode & 73)) {
                  return 2;
                }
              } else {
                return 2;
              }
              return 0;
            },
            Ob = function Ob(a, b) {
              try {
                return zb(a, b), 20;
              } catch (c) {}
              return Lb(a, "wx");
            },
            Pb = function Pb() {
              for (var a = 0; 4096 >= a; a++) {
                if (!Db[a]) {
                  return a;
                }
              }
              throw new O(33);
            },
            Qb = function Qb(a) {
              a = Db[a];
              if (!a) {
                throw new O(8);
              }
              return a;
            },
            Sb = function Sb(a) {
              var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
              Rb || (Rb = function Rb() {
                this.h = {};
              }, Rb.prototype = {}, Object.defineProperties(Rb.prototype, {
                object: {
                  get: function get() {
                    return this.node;
                  },
                  set: function set(c) {
                    this.node = c;
                  }
                },
                flags: {
                  get: function get() {
                    return this.h.flags;
                  },
                  set: function set(c) {
                    this.h.flags = c;
                  }
                },
                position: {
                  get: function get() {
                    return this.h.position;
                  },
                  set: function set(c) {
                    this.h.position = c;
                  }
                }
              }));
              a = Object.assign(new Rb(), a);
              -1 == b && (b = Pb());
              a.X = b;
              return Db[b] = a;
            },
            wb = {
              open: function open(a) {
                a.m = Cb[a.node.za].m;
                a.m.open && a.m.open(a);
              },
              ba: function ba() {
                throw new O(70);
              }
            },
            rb = function rb(a, b) {
              Cb[a] = {
                m: b
              };
            },
            Tb = function Tb(a, b) {
              var c = "/" === b,
                d = !b;
              if (c && Bb) {
                throw new O(10);
              }
              if (!c && !d) {
                var e = _Ib(b, {
                  gb: !1
                });
                b = e.path;
                e = e.node;
                if (e.wa) {
                  throw new O(10);
                }
                if (16384 !== (e.mode & 61440)) {
                  throw new O(54);
                }
              }
              b = {
                type: a,
                Qc: {},
                mb: b,
                kc: []
              };
              a = a.U(b);
              a.U = b;
              b.root = a;
              c ? Bb = a : e && (e.wa = b, e.U && e.U.kc.push(b));
            },
            S = function S(a, b, c) {
              var d = _Ib(a, {
                parent: !0
              }).node;
              a = fb(a);
              if (!a || "." === a || ".." === a) {
                throw new O(28);
              }
              var e = Ob(d, a);
              if (e) {
                throw new O(e);
              }
              if (!d.l.va) {
                throw new O(63);
              }
              return d.l.va(d, a, b, c);
            },
            Ub = function Ub(a, b, c) {
              "undefined" == typeof c && (c = b, b = 438);
              S(a, b | 8192, c);
            },
            Vb = function Vb(a, b) {
              if (!ib(a)) {
                throw new O(44);
              }
              var c = _Ib(b, {
                parent: !0
              }).node;
              if (!c) {
                throw new O(44);
              }
              b = fb(b);
              var d = Ob(c, b);
              if (d) {
                throw new O(d);
              }
              if (!c.l.Ea) {
                throw new O(63);
              }
              c.l.Ea(c, b, a);
            },
            Hb = function Hb(a) {
              a = _Ib(a).node;
              if (!a) {
                throw new O(44);
              }
              if (!a.l.ma) {
                throw new O(28);
              }
              return ib(Jb(a.parent), a.l.ma(a));
            },
            bc = function bc(a, b, c) {
              if ("" === a) {
                throw new O(44);
              }
              if ("string" == typeof b) {
                var d = {
                  r: 0,
                  "r+": 2,
                  w: 577,
                  "w+": 578,
                  a: 1089,
                  "a+": 1090
                }[b];
                if ("undefined" == typeof d) {
                  throw Error("Unknown file open mode: ".concat(b));
                }
                b = d;
              }
              c = b & 64 ? ("undefined" == typeof c ? 438 : c) & 4095 | 32768 : 0;
              if ("object" == _typeof(a)) {
                var e = a;
              } else {
                a = db(a);
                try {
                  e = _Ib(a, {
                    fb: !(b & 131072)
                  }).node;
                } catch (f) {}
              }
              d = !1;
              if (b & 64) {
                if (e) {
                  if (b & 128) {
                    throw new O(20);
                  }
                } else {
                  e = S(a, c, 0), d = !0;
                }
              }
              if (!e) {
                throw new O(44);
              }
              8192 === (e.mode & 61440) && (b &= -513);
              if (b & 65536 && 16384 !== (e.mode & 61440)) {
                throw new O(54);
              }
              if (!d && (c = e ? 40960 === (e.mode & 61440) ? 32 : 16384 === (e.mode & 61440) && ("r" !== Nb(b) || b & 512) ? 31 : Lb(e, Nb(b)) : 44)) {
                throw new O(c);
              }
              if (b & 512 && !d) {
                c = e;
                c = "string" == typeof c ? _Ib(c, {
                  fb: !0
                }).node : c;
                if (!c.l.P) {
                  throw new O(63);
                }
                if (16384 === (c.mode & 61440)) {
                  throw new O(31);
                }
                if (32768 !== (c.mode & 61440)) {
                  throw new O(28);
                }
                if (d = Lb(c, "w")) {
                  throw new O(d);
                }
                c.l.P(c, {
                  size: 0,
                  timestamp: Date.now()
                });
              }
              b &= -131713;
              e = Sb({
                node: e,
                path: Jb(e),
                flags: b,
                seekable: !0,
                position: 0,
                m: e.m,
                zc: [],
                error: !1
              });
              e.m.open && e.m.open(e);
              !m.logReadFiles || b & 1 || (Wb || (Wb = {}), a in Wb || (Wb[a] = 1));
              return e;
            },
            cc = function cc(a, b, c) {
              if (null === a.X) {
                throw new O(8);
              }
              if (!a.seekable || !a.m.ba) {
                throw new O(70);
              }
              if (0 != c && 1 != c && 2 != c) {
                throw new O(28);
              }
              a.position = a.m.ba(a, b, c);
              a.zc = [];
            },
            dc = function dc() {
              O || (O = function O(a, b) {
                this.name = "ErrnoError";
                this.node = b;
                this.pc = function (c) {
                  this.aa = c;
                };
                this.pc(a);
                this.message = "FS error";
              }, O.prototype = Error(), O.prototype.constructor = O, [44].forEach(function (a) {
                yb[a] = new O(a);
                yb[a].stack = "<generic error, no stack>";
              }));
            },
            ec,
            gc = function gc(a, b, c) {
              a = db("/dev/" + a);
              var d = Ab(!!b, !!c);
              fc || (fc = 64);
              var e = fc++ << 8 | 0;
              rb(e, {
                open: function open(f) {
                  f.seekable = !1;
                },
                close: function close() {
                  c && c.buffer && c.buffer.length && c(10);
                },
                read: function read(f, g, n, p) {
                  for (var l = 0, u = 0; u < p; u++) {
                    try {
                      var v = b();
                    } catch (x) {
                      throw new O(29);
                    }
                    if (void 0 === v && 0 === l) {
                      throw new O(6);
                    }
                    if (null === v || void 0 === v) {
                      break;
                    }
                    l++;
                    g[n + u] = v;
                  }
                  l && (f.node.timestamp = Date.now());
                  return l;
                },
                write: function write(f, g, n, p) {
                  for (var l = 0; l < p; l++) {
                    try {
                      c(g[n + l]);
                    } catch (u) {
                      throw new O(29);
                    }
                  }
                  p && (f.node.timestamp = Date.now());
                  return l;
                }
              });
              Ub(a, d, e);
            },
            fc,
            hc = {},
            Rb,
            Wb,
            ic = void 0;
          function jc() {
            ic += 4;
            return L[ic - 4 >> 2];
          }
          function kc(a) {
            if (void 0 === a) {
              return "_unknown";
            }
            a = a.replace(/[^a-zA-Z0-9_]/g, "$");
            var b = a.charCodeAt(0);
            return 48 <= b && 57 >= b ? "_".concat(a) : a;
          }
          function lc(a, b) {
            a = kc(a);
            return _defineProperty({}, a, function () {
              return b.apply(this, arguments);
            })[a];
          }
          function mc() {
            this.M = [void 0];
            this.hb = [];
          }
          var U = new mc(),
            nc = void 0;
          function V(a) {
            throw new nc(a);
          }
          var oc = function oc(a) {
              a || V("Cannot use deleted val. handle = " + a);
              return U.get(a).value;
            },
            pc = function pc(a) {
              switch (a) {
                case void 0:
                  return 1;
                case null:
                  return 2;
                case !0:
                  return 3;
                case !1:
                  return 4;
                default:
                  return U.pa({
                    tb: 1,
                    value: a
                  });
              }
            };
          function qc(a) {
            var b = Error,
              c = lc(a, function (d) {
                this.name = a;
                this.message = d;
                d = Error(d).stack;
                void 0 !== d && (this.stack = this.toString() + "\n" + d.replace(/^Error(:[^\n]*)?\n/, ""));
              });
            c.prototype = Object.create(b.prototype);
            c.prototype.constructor = c;
            c.prototype.toString = function () {
              return void 0 === this.message ? this.name : "".concat(this.name, ": ").concat(this.message);
            };
            return c;
          }
          var rc = void 0,
            sc = void 0;
          function W(a) {
            for (var b = ""; E[a];) {
              b += sc[E[a++]];
            }
            return b;
          }
          var tc = [];
          function uc() {
            for (; tc.length;) {
              var a = tc.pop();
              a.g.fa = !1;
              a["delete"]();
            }
          }
          var vc = void 0,
            wc = {};
          function xc(a, b) {
            for (void 0 === b && V("ptr should not be undefined"); a.A;) {
              b = a.na(b), a = a.A;
            }
            return b;
          }
          var yc = {};
          function zc(a) {
            a = _Ac(a);
            var b = W(a);
            _Bc(a);
            return b;
          }
          function Cc(a, b) {
            var c = yc[a];
            void 0 === c && V(b + " has unknown type " + zc(a));
            return c;
          }
          function Dc() {}
          var Ec = !1;
          function Fc(a) {
            --a.count.value;
            0 === a.count.value && (a.G ? a.L.W(a.G) : a.u.i.W(a.o));
          }
          function Gc(a, b, c) {
            if (b === c) {
              return a;
            }
            if (void 0 === c.A) {
              return null;
            }
            a = Gc(a, b, c.A);
            return null === a ? null : c.Pb(a);
          }
          var Hc = {};
          function Ic(a, b) {
            b = xc(a, b);
            return wc[b];
          }
          var Jc = void 0;
          function Kc(a) {
            throw new Jc(a);
          }
          function Lc(a, b) {
            b.u && b.o || Kc("makeClassHandle requires ptr and ptrType");
            !!b.L !== !!b.G && Kc("Both smartPtrType and smartPtr must be specified");
            b.count = {
              value: 1
            };
            return Mc(Object.create(a, {
              g: {
                value: b
              }
            }));
          }
          function Mc(a) {
            if ("undefined" === typeof FinalizationRegistry) {
              return Mc = function Mc(b) {
                return b;
              }, a;
            }
            Ec = new FinalizationRegistry(function (b) {
              Fc(b.g);
            });
            Mc = function Mc(b) {
              var c = b.g;
              c.G && Ec.register(b, {
                g: c
              }, b);
              return b;
            };
            Dc = function Dc(b) {
              Ec.unregister(b);
            };
            return Mc(a);
          }
          var Nc = {};
          function Oc(a) {
            for (; a.length;) {
              var b = a.pop();
              a.pop()(b);
            }
          }
          function Pc(a) {
            return this.fromWireType(L[a >> 2]);
          }
          var Qc = {},
            Rc = {};
          function Y(a, b, c) {
            function d(n) {
              n = c(n);
              n.length !== a.length && Kc("Mismatched type converter count");
              for (var p = 0; p < a.length; ++p) {
                Sc(a[p], n[p]);
              }
            }
            a.forEach(function (n) {
              Rc[n] = b;
            });
            var e = Array(b.length),
              f = [],
              g = 0;
            b.forEach(function (n, p) {
              yc.hasOwnProperty(n) ? e[p] = yc[n] : (f.push(n), Qc.hasOwnProperty(n) || (Qc[n] = []), Qc[n].push(function () {
                e[p] = yc[n];
                ++g;
                g === f.length && d(e);
              }));
            });
            0 === f.length && d(e);
          }
          function Tc(a) {
            switch (a) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: ".concat(a));
            }
          }
          function Uc(a, b) {
            var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var d = b.name;
            a || V("type \"".concat(d, "\" must have a positive integer typeid pointer"));
            if (yc.hasOwnProperty(a)) {
              if (c.$b) {
                return;
              }
              V("Cannot register type '".concat(d, "' twice"));
            }
            yc[a] = b;
            delete Rc[a];
            Qc.hasOwnProperty(a) && (b = Qc[a], delete Qc[a], b.forEach(function (e) {
              return e();
            }));
          }
          function Sc(a, b) {
            var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            if (!("argPackAdvance" in b)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            Uc(a, b, c);
          }
          function Vc(a) {
            V(a.g.u.i.name + " instance already deleted");
          }
          function Wc() {}
          function Xc(a, b, c) {
            if (void 0 === a[b].B) {
              var d = a[b];
              a[b] = function () {
                a[b].B.hasOwnProperty(arguments.length) || V("Function '".concat(c, "' called with an invalid number of arguments (").concat(arguments.length, ") - expects one of (").concat(a[b].B, ")!"));
                return a[b].B[arguments.length].apply(this, arguments);
              };
              a[b].B = [];
              a[b].B[d.ea] = d;
            }
          }
          function Yc(a, b, c) {
            m.hasOwnProperty(a) ? ((void 0 === c || void 0 !== m[a].B && void 0 !== m[a].B[c]) && V("Cannot register public name '".concat(a, "' twice")), Xc(m, a, a), m.hasOwnProperty(c) && V("Cannot register multiple overloads of a function with the same number of arguments (".concat(c, ")!")), m[a].B[c] = b) : (m[a] = b, void 0 !== c && (m[a].Pc = c));
          }
          function Zc(a, b, c, d, e, f, g, n) {
            this.name = a;
            this.constructor = b;
            this.N = c;
            this.W = d;
            this.A = e;
            this.Ub = f;
            this.na = g;
            this.Pb = n;
            this.qb = [];
          }
          function $c(a, b, c) {
            for (; b !== c;) {
              b.na || V("Expected null or instance of ".concat(c.name, ", got an instance of ").concat(b.name)), a = b.na(a), b = b.A;
            }
            return a;
          }
          function ad(a, b) {
            if (null === b) {
              return this.Na && V("null is not a valid ".concat(this.name)), 0;
            }
            b.g || V("Cannot pass \"".concat(bd(b), "\" as a ").concat(this.name));
            b.g.o || V("Cannot pass deleted object as a pointer of type ".concat(this.name));
            return $c(b.g.o, b.g.u.i, this.i);
          }
          function cd(a, b) {
            if (null === b) {
              this.Na && V("null is not a valid ".concat(this.name));
              if (this.ua) {
                var c = this.Pa();
                null !== a && a.push(this.W, c);
                return c;
              }
              return 0;
            }
            b.g || V("Cannot pass \"".concat(bd(b), "\" as a ").concat(this.name));
            b.g.o || V("Cannot pass deleted object as a pointer of type ".concat(this.name));
            !this.ta && b.g.u.ta && V("Cannot convert argument of type ".concat(b.g.L ? b.g.L.name : b.g.u.name, " to parameter type ").concat(this.name));
            c = $c(b.g.o, b.g.u.i, this.i);
            if (this.ua) {
              switch (void 0 === b.g.G && V("Passing raw pointer to smart pointer is illegal"), this.tc) {
                case 0:
                  b.g.L === this ? c = b.g.G : V("Cannot convert argument of type ".concat(b.g.L ? b.g.L.name : b.g.u.name, " to parameter type ").concat(this.name));
                  break;
                case 1:
                  c = b.g.G;
                  break;
                case 2:
                  if (b.g.L === this) {
                    c = b.g.G;
                  } else {
                    var d = b.clone();
                    c = this.oc(c, pc(function () {
                      d["delete"]();
                    }));
                    null !== a && a.push(this.W, c);
                  }
                  break;
                default:
                  V("Unsupporting sharing policy");
              }
            }
            return c;
          }
          function dd(a, b) {
            if (null === b) {
              return this.Na && V("null is not a valid ".concat(this.name)), 0;
            }
            b.g || V("Cannot pass \"".concat(bd(b), "\" as a ").concat(this.name));
            b.g.o || V("Cannot pass deleted object as a pointer of type ".concat(this.name));
            b.g.u.ta && V("Cannot convert argument of type ".concat(b.g.u.name, " to parameter type ").concat(this.name));
            return $c(b.g.o, b.g.u.i, this.i);
          }
          function ed(a, b, c, d) {
            this.name = a;
            this.i = b;
            this.Na = c;
            this.ta = d;
            this.ua = !1;
            this.W = this.oc = this.Pa = this.rb = this.tc = this.nc = void 0;
            void 0 !== b.A ? this.toWireType = cd : (this.toWireType = d ? ad : dd, this.K = null);
          }
          function fd(a, b, c) {
            m.hasOwnProperty(a) || Kc("Replacing nonexistant public symbol");
            void 0 !== m[a].B && void 0 !== c ? m[a].B[c] = b : (m[a] = b, m[a].ea = c);
          }
          var gd = [],
            hd = function hd(a) {
              var b = gd[a];
              b || (a >= gd.length && (gd.length = a + 1), gd[a] = b = Ia.get(a));
              return b;
            },
            jd = function jd(a, b) {
              var c = [];
              return function () {
                c.length = 0;
                Object.assign(c, arguments);
                if (a.includes("j")) {
                  var d = m["dynCall_" + a];
                  d = c && c.length ? d.apply(null, [b].concat(c)) : d.call(null, b);
                } else {
                  d = hd(b).apply(null, c);
                }
                return d;
              };
            };
          function Z(a, b) {
            a = W(a);
            var c = a.includes("j") ? jd(a, b) : hd(b);
            "function" != typeof c && V("unknown function pointer with signature ".concat(a, ": ").concat(b));
            return c;
          }
          var kd = void 0;
          function ld(a, b) {
            function c(f) {
              e[f] || yc[f] || (Rc[f] ? Rc[f].forEach(c) : (d.push(f), e[f] = !0));
            }
            var d = [],
              e = {};
            b.forEach(c);
            throw new kd("".concat(a, ": ") + d.map(zc).join([", "]));
          }
          function od(a, b, c, d, e) {
            var f = b.length;
            2 > f && V("argTypes array size mismatch! Must at least get return value and 'this' types!");
            var g = null !== b[1] && null !== c,
              n = !1;
            for (c = 1; c < b.length; ++c) {
              if (null !== b[c] && void 0 === b[c].K) {
                n = !0;
                break;
              }
            }
            var p = "void" !== b[0].name,
              l = f - 2,
              u = Array(l),
              v = [],
              x = [];
            return function () {
              arguments.length !== l && V("function ".concat(a, " called with ").concat(arguments.length, " arguments, expected ").concat(l, " args!"));
              x.length = 0;
              v.length = g ? 2 : 1;
              v[0] = e;
              if (g) {
                var k = b[1].toWireType(x, this);
                v[1] = k;
              }
              for (var t = 0; t < l; ++t) {
                u[t] = b[t + 2].toWireType(x, arguments[t]), v.push(u[t]);
              }
              t = d.apply(null, v);
              if (n) {
                Oc(x);
              } else {
                for (var r = g ? 1 : 2; r < b.length; r++) {
                  var B = 1 === r ? k : u[r - 2];
                  null !== b[r].K && b[r].K(B);
                }
              }
              k = p ? b[0].fromWireType(t) : void 0;
              return k;
            };
          }
          function pd(a, b) {
            for (var c = [], d = 0; d < a; d++) {
              c.push(N[b + 4 * d >> 2]);
            }
            return c;
          }
          function qd(a, b, c) {
            a instanceof Object || V("".concat(c, " with invalid \"this\": ").concat(a));
            a instanceof b.i.constructor || V("".concat(c, " incompatible with \"this\" of type ").concat(a.constructor.name));
            a.g.o || V("cannot call emscripten binding method ".concat(c, " on deleted object"));
            return $c(a.g.o, a.g.u.i, b.i);
          }
          function rd(a) {
            a >= U.h && 0 === --U.get(a).tb && U.Zb(a);
          }
          function sd(a, b, c) {
            switch (b) {
              case 0:
                return function (d) {
                  return this.fromWireType((c ? C : E)[d]);
                };
              case 1:
                return function (d) {
                  return this.fromWireType((c ? Ba : Ca)[d >> 1]);
                };
              case 2:
                return function (d) {
                  return this.fromWireType((c ? L : N)[d >> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + a);
            }
          }
          function bd(a) {
            if (null === a) {
              return "null";
            }
            var b = _typeof(a);
            return "object" === b || "array" === b || "function" === b ? a.toString() : "" + a;
          }
          function td(a, b) {
            switch (b) {
              case 2:
                return function (c) {
                  return this.fromWireType(Da[c >> 2]);
                };
              case 3:
                return function (c) {
                  return this.fromWireType(Ea[c >> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + a);
            }
          }
          function ud(a, b, c) {
            switch (b) {
              case 0:
                return c ? function (d) {
                  return C[d];
                } : function (d) {
                  return E[d];
                };
              case 1:
                return c ? function (d) {
                  return Ba[d >> 1];
                } : function (d) {
                  return Ca[d >> 1];
                };
              case 2:
                return c ? function (d) {
                  return L[d >> 2];
                } : function (d) {
                  return N[d >> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + a);
            }
          }
          var vd = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0,
            wd = function wd(a, b) {
              var c = a >> 1;
              for (var d = c + b / 2; !(c >= d) && Ca[c];) {
                ++c;
              }
              c <<= 1;
              if (32 < c - a && vd) {
                return vd.decode(E.subarray(a, c));
              }
              c = "";
              for (d = 0; !(d >= b / 2); ++d) {
                var e = Ba[a + 2 * d >> 1];
                if (0 == e) {
                  break;
                }
                c += String.fromCharCode(e);
              }
              return c;
            },
            xd = function xd(a, b, c) {
              void 0 === c && (c = 2147483647);
              if (2 > c) {
                return 0;
              }
              c -= 2;
              var d = b;
              c = c < 2 * a.length ? c / 2 : a.length;
              for (var e = 0; e < c; ++e) {
                Ba[b >> 1] = a.charCodeAt(e), b += 2;
              }
              Ba[b >> 1] = 0;
              return b - d;
            },
            yd = function yd(a) {
              return 2 * a.length;
            },
            zd = function zd(a, b) {
              for (var c = 0, d = ""; !(c >= b / 4);) {
                var e = L[a + 4 * c >> 2];
                if (0 == e) {
                  break;
                }
                ++c;
                65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);
              }
              return d;
            },
            Ad = function Ad(a, b, c) {
              void 0 === c && (c = 2147483647);
              if (4 > c) {
                return 0;
              }
              var d = b;
              c = d + c - 4;
              for (var e = 0; e < a.length; ++e) {
                var f = a.charCodeAt(e);
                if (55296 <= f && 57343 >= f) {
                  var g = a.charCodeAt(++e);
                  f = 65536 + ((f & 1023) << 10) | g & 1023;
                }
                L[b >> 2] = f;
                b += 4;
                if (b + 4 > c) {
                  break;
                }
              }
              L[b >> 2] = 0;
              return b - d;
            },
            Bd = function Bd(a) {
              for (var b = 0, c = 0; c < a.length; ++c) {
                var d = a.charCodeAt(c);
                55296 <= d && 57343 >= d && ++c;
                b += 4;
              }
              return b;
            },
            Cd = {};
          function Dd(a) {
            var b = Cd[a];
            return void 0 === b ? W(a) : b;
          }
          var Ed = [];
          function Fd(a) {
            var b = Ed.length;
            Ed.push(a);
            return b;
          }
          function Gd(a, b) {
            for (var c = Array(a), d = 0; d < a; ++d) {
              c[d] = Cc(N[b + 4 * d >> 2], "parameter " + d);
            }
            return c;
          }
          var Hd = [],
            Id = [],
            Jd = {},
            Ld = function Ld() {
              if (!Kd) {
                var a = {
                    USER: "web_user",
                    LOGNAME: "web_user",
                    PATH: "/",
                    PWD: "/",
                    HOME: "/home/web_user",
                    LANG: ("object" == (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                    _: na || "./this.program"
                  },
                  b;
                for (b in Jd) {
                  void 0 === Jd[b] ? delete a[b] : a[b] = Jd[b];
                }
                var c = [];
                for (b in a) {
                  c.push("".concat(b, "=").concat(a[b]));
                }
                Kd = c;
              }
              return Kd;
            },
            Kd,
            Md = function Md(a) {
              return 0 === a % 4 && (0 !== a % 100 || 0 === a % 400);
            },
            Nd = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            Od = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            Pd = function Pd(a, b, c, d) {
              function _e2(k, t, r) {
                for (k = "number" == typeof k ? k.toString() : k || ""; k.length < t;) {
                  k = r[0] + k;
                }
                return k;
              }
              function f(k, t) {
                return _e2(k, t, "0");
              }
              function g(k, t) {
                function r(D) {
                  return 0 > D ? -1 : 0 < D ? 1 : 0;
                }
                var B;
                0 === (B = r(k.getFullYear() - t.getFullYear())) && 0 === (B = r(k.getMonth() - t.getMonth())) && (B = r(k.getDate() - t.getDate()));
                return B;
              }
              function n(k) {
                switch (k.getDay()) {
                  case 0:
                    return new Date(k.getFullYear() - 1, 11, 29);
                  case 1:
                    return k;
                  case 2:
                    return new Date(k.getFullYear(), 0, 3);
                  case 3:
                    return new Date(k.getFullYear(), 0, 2);
                  case 4:
                    return new Date(k.getFullYear(), 0, 1);
                  case 5:
                    return new Date(k.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(k.getFullYear() - 1, 11, 30);
                }
              }
              function p(k) {
                var t = k.ca;
                for (k = new Date(new Date(k.da + 1900, 0, 1).getTime()); 0 < t;) {
                  var r = k.getMonth(),
                    B = (Md(k.getFullYear()) ? Nd : Od)[r];
                  if (t > B - k.getDate()) {
                    t -= B - k.getDate() + 1, k.setDate(1), 11 > r ? k.setMonth(r + 1) : (k.setMonth(0), k.setFullYear(k.getFullYear() + 1));
                  } else {
                    k.setDate(k.getDate() + t);
                    break;
                  }
                }
                r = new Date(k.getFullYear() + 1, 0, 4);
                t = n(new Date(k.getFullYear(), 0, 4));
                r = n(r);
                return 0 >= g(t, k) ? 0 >= g(r, k) ? k.getFullYear() + 1 : k.getFullYear() : k.getFullYear() - 1;
              }
              var l = L[d + 40 >> 2];
              d = {
                wc: L[d >> 2],
                vc: L[d + 4 >> 2],
                Fa: L[d + 8 >> 2],
                Sa: L[d + 12 >> 2],
                Ga: L[d + 16 >> 2],
                da: L[d + 20 >> 2],
                R: L[d + 24 >> 2],
                ca: L[d + 28 >> 2],
                Rc: L[d + 32 >> 2],
                uc: L[d + 36 >> 2],
                xc: l ? l ? kb(E, l) : "" : ""
              };
              c = c ? kb(E, c) : "";
              l = {
                "%c": "%a %b %d %H:%M:%S %Y",
                "%D": "%m/%d/%y",
                "%F": "%Y-%m-%d",
                "%h": "%b",
                "%r": "%I:%M:%S %p",
                "%R": "%H:%M",
                "%T": "%H:%M:%S",
                "%x": "%m/%d/%y",
                "%X": "%H:%M:%S",
                "%Ec": "%c",
                "%EC": "%C",
                "%Ex": "%m/%d/%y",
                "%EX": "%H:%M:%S",
                "%Ey": "%y",
                "%EY": "%Y",
                "%Od": "%d",
                "%Oe": "%e",
                "%OH": "%H",
                "%OI": "%I",
                "%Om": "%m",
                "%OM": "%M",
                "%OS": "%S",
                "%Ou": "%u",
                "%OU": "%U",
                "%OV": "%V",
                "%Ow": "%w",
                "%OW": "%W",
                "%Oy": "%y"
              };
              for (var u in l) {
                c = c.replace(new RegExp(u, "g"), l[u]);
              }
              var v = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                x = "January February March April May June July August September October November December".split(" ");
              l = {
                "%a": function a(k) {
                  return v[k.R].substring(0, 3);
                },
                "%A": function A(k) {
                  return v[k.R];
                },
                "%b": function b(k) {
                  return x[k.Ga].substring(0, 3);
                },
                "%B": function B(k) {
                  return x[k.Ga];
                },
                "%C": function C(k) {
                  return f((k.da + 1900) / 100 | 0, 2);
                },
                "%d": function d(k) {
                  return f(k.Sa, 2);
                },
                "%e": function e(k) {
                  return _e2(k.Sa, 2, " ");
                },
                "%g": function g(k) {
                  return p(k).toString().substring(2);
                },
                "%G": function G(k) {
                  return p(k);
                },
                "%H": function H(k) {
                  return f(k.Fa, 2);
                },
                "%I": function I(k) {
                  k = k.Fa;
                  0 == k ? k = 12 : 12 < k && (k -= 12);
                  return f(k, 2);
                },
                "%j": function j(k) {
                  for (var t = 0, r = 0; r <= k.Ga - 1; t += (Md(k.da + 1900) ? Nd : Od)[r++]) {}
                  return f(k.Sa + t, 3);
                },
                "%m": function m(k) {
                  return f(k.Ga + 1, 2);
                },
                "%M": function M(k) {
                  return f(k.vc, 2);
                },
                "%n": function n() {
                  return "\n";
                },
                "%p": function p(k) {
                  return 0 <= k.Fa && 12 > k.Fa ? "AM" : "PM";
                },
                "%S": function S(k) {
                  return f(k.wc, 2);
                },
                "%t": function t() {
                  return "\t";
                },
                "%u": function u(k) {
                  return k.R || 7;
                },
                "%U": function U(k) {
                  return f(Math.floor((k.ca + 7 - k.R) / 7), 2);
                },
                "%V": function V(k) {
                  var t = Math.floor((k.ca + 7 - (k.R + 6) % 7) / 7);
                  2 >= (k.R + 371 - k.ca - 2) % 7 && t++;
                  if (t) {
                    53 == t && (r = (k.R + 371 - k.ca) % 7, 4 == r || 3 == r && Md(k.da) || (t = 1));
                  } else {
                    t = 52;
                    var r = (k.R + 7 - k.ca - 1) % 7;
                    (4 == r || 5 == r && Md(k.da % 400 - 1)) && t++;
                  }
                  return f(t, 2);
                },
                "%w": function w(k) {
                  return k.R;
                },
                "%W": function W(k) {
                  return f(Math.floor((k.ca + 7 - (k.R + 6) % 7) / 7), 2);
                },
                "%y": function y(k) {
                  return (k.da + 1900).toString().substring(2);
                },
                "%Y": function Y(k) {
                  return k.da + 1900;
                },
                "%z": function z(k) {
                  k = k.uc;
                  var t = 0 <= k;
                  k = Math.abs(k) / 60;
                  return (t ? "+" : "-") + String("0000" + (k / 60 * 100 + k % 60)).slice(-4);
                },
                "%Z": function Z(k) {
                  return k.xc;
                },
                "%%": function _() {
                  return "%";
                }
              };
              c = c.replace(/%%/g, "\x00\x00");
              for (u in l) {
                c.includes(u) && (c = c.replace(new RegExp(u, "g"), l[u](d)));
              }
              c = c.replace(/\0\0/g, "%");
              u = ob(c, !1);
              if (u.length > b) {
                return 0;
              }
              C.set(u, a);
              return u.length - 1;
            };
          function Mb(a, b, c, d) {
            a || (a = this);
            this.parent = a;
            this.U = a.U;
            this.wa = null;
            this.id = Eb++;
            this.name = b;
            this.mode = c;
            this.l = {};
            this.m = {};
            this.za = d;
          }
          Object.defineProperties(Mb.prototype, {
            read: {
              get: function get() {
                return 365 === (this.mode & 365);
              },
              set: function set(a) {
                a ? this.mode |= 365 : this.mode &= -366;
              }
            },
            write: {
              get: function get() {
                return 146 === (this.mode & 146);
              },
              set: function set(a) {
                a ? this.mode |= 146 : this.mode &= -147;
              }
            }
          });
          dc();
          Fb = Array(4096);
          Tb(P, "/");
          S("/tmp", 16895, 0);
          S("/home", 16895, 0);
          S("/home/web_user", 16895, 0);
          (function () {
            S("/dev", 16895, 0);
            rb(259, {
              read: function read() {
                return 0;
              },
              write: function write(d, e, f, g) {
                return g;
              }
            });
            Ub("/dev/null", 259);
            qb(1280, tb);
            qb(1536, ub);
            Ub("/dev/tty", 1280);
            Ub("/dev/tty1", 1536);
            var a = new Uint8Array(1024),
              b = 0,
              c = function c() {
                0 === b && (b = _hb(a).byteLength);
                return a[--b];
              };
            gc("random", c);
            gc("urandom", c);
            S("/dev/shm", 16895, 0);
            S("/dev/shm/tmp", 16895, 0);
          })();
          (function () {
            S("/proc", 16895, 0);
            var a = S("/proc/self", 16895, 0);
            S("/proc/self/fd", 16895, 0);
            Tb({
              U: function U() {
                var b = xb(a, "fd", 16895, 73);
                b.l = {
                  ka: function ka(c, d) {
                    var e = Qb(+d);
                    c = {
                      parent: null,
                      U: {
                        mb: "fake"
                      },
                      l: {
                        ma: function ma() {
                          return e.path;
                        }
                      }
                    };
                    return c.parent = c;
                  }
                };
                return b;
              }
            }, "/proc/self/fd");
          })();
          Object.assign(mc.prototype, {
            get: function get(a) {
              return this.M[a];
            },
            has: function has(a) {
              return void 0 !== this.M[a];
            },
            pa: function pa(a) {
              var b = this.hb.pop() || this.M.length;
              this.M[b] = a;
              return b;
            },
            Zb: function Zb(a) {
              this.M[a] = void 0;
              this.hb.push(a);
            }
          });
          nc = m.BindingError = /*#__PURE__*/function (_Error) {
            function _class(a) {
              var _this2;
              _classCallCheck(this, _class);
              _this2 = _callSuper(this, _class, [a]);
              _this2.name = "BindingError";
              return _this2;
            }
            _inherits(_class, _Error);
            return _createClass(_class);
          }(/*#__PURE__*/_wrapNativeSuper(Error));
          U.M.push({
            value: void 0
          }, {
            value: null
          }, {
            value: !0
          }, {
            value: !1
          });
          U.h = U.M.length;
          m.count_emval_handles = function () {
            for (var a = 0, b = U.h; b < U.M.length; ++b) {
              void 0 !== U.M[b] && ++a;
            }
            return a;
          };
          rc = m.PureVirtualError = qc("PureVirtualError");
          for (var Qd = Array(256), Rd = 0; 256 > Rd; ++Rd) {
            Qd[Rd] = String.fromCharCode(Rd);
          }
          sc = Qd;
          m.getInheritedInstanceCount = function () {
            return Object.keys(wc).length;
          };
          m.getLiveInheritedInstances = function () {
            var a = [],
              b;
            for (b in wc) {
              wc.hasOwnProperty(b) && a.push(wc[b]);
            }
            return a;
          };
          m.flushPendingDeletes = uc;
          m.setDelayFunction = function (a) {
            vc = a;
            tc.length && vc && vc(uc);
          };
          Jc = m.InternalError = /*#__PURE__*/function (_Error2) {
            function _class2(a) {
              var _this3;
              _classCallCheck(this, _class2);
              _this3 = _callSuper(this, _class2, [a]);
              _this3.name = "InternalError";
              return _this3;
            }
            _inherits(_class2, _Error2);
            return _createClass(_class2);
          }(/*#__PURE__*/_wrapNativeSuper(Error));
          Wc.prototype.isAliasOf = function (a) {
            if (!(this instanceof Wc && a instanceof Wc)) {
              return !1;
            }
            var b = this.g.u.i,
              c = this.g.o,
              d = a.g.u.i;
            for (a = a.g.o; b.A;) {
              c = b.na(c), b = b.A;
            }
            for (; d.A;) {
              a = d.na(a), d = d.A;
            }
            return b === d && c === a;
          };
          Wc.prototype.clone = function () {
            this.g.o || Vc(this);
            if (this.g.ia) {
              return this.g.count.value += 1, this;
            }
            var a = Mc,
              b = Object,
              c = b.create,
              d = Object.getPrototypeOf(this),
              e = this.g;
            a = a(c.call(b, d, {
              g: {
                value: {
                  count: e.count,
                  fa: e.fa,
                  ia: e.ia,
                  o: e.o,
                  u: e.u,
                  G: e.G,
                  L: e.L
                }
              }
            }));
            a.g.count.value += 1;
            a.g.fa = !1;
            return a;
          };
          Wc.prototype["delete"] = function () {
            this.g.o || Vc(this);
            this.g.fa && !this.g.ia && V("Object already scheduled for deletion");
            Dc(this);
            Fc(this.g);
            this.g.ia || (this.g.G = void 0, this.g.o = void 0);
          };
          Wc.prototype.isDeleted = function () {
            return !this.g.o;
          };
          Wc.prototype.deleteLater = function () {
            this.g.o || Vc(this);
            this.g.fa && !this.g.ia && V("Object already scheduled for deletion");
            tc.push(this);
            1 === tc.length && vc && vc(uc);
            this.g.fa = !0;
            return this;
          };
          ed.prototype.Vb = function (a) {
            this.rb && (a = this.rb(a));
            return a;
          };
          ed.prototype.ab = function (a) {
            this.W && this.W(a);
          };
          ed.prototype.argPackAdvance = 8;
          ed.prototype.readValueFromPointer = Pc;
          ed.prototype.deleteObject = function (a) {
            if (null !== a) {
              a["delete"]();
            }
          };
          ed.prototype.fromWireType = function (a) {
            function b() {
              return this.ua ? Lc(this.i.N, {
                u: this.nc,
                o: c,
                L: this,
                G: a
              }) : Lc(this.i.N, {
                u: this,
                o: a
              });
            }
            var c = this.Vb(a);
            if (!c) {
              return this.ab(a), null;
            }
            var d = Ic(this.i, c);
            if (void 0 !== d) {
              if (0 === d.g.count.value) {
                return d.g.o = c, d.g.G = a, d.clone();
              }
              d = d.clone();
              this.ab(a);
              return d;
            }
            d = this.i.Ub(c);
            d = Hc[d];
            if (!d) {
              return b.call(this);
            }
            d = this.ta ? d.Kb : d.pointerType;
            var e = Gc(c, this.i, d.i);
            return null === e ? b.call(this) : this.ua ? Lc(d.i.N, {
              u: d,
              o: e,
              L: this,
              G: a
            }) : Lc(d.i.N, {
              u: d,
              o: e
            });
          };
          kd = m.UnboundTypeError = qc("UnboundTypeError");
          var Ud = {
            __syscall_fcntl64: function __syscall_fcntl64(a, b, c) {
              ic = c;
              try {
                var d = Qb(a);
                switch (b) {
                  case 0:
                    var e = jc();
                    return 0 > e ? -28 : Sb(d, e).X;
                  case 1:
                  case 2:
                    return 0;
                  case 3:
                    return d.flags;
                  case 4:
                    return e = jc(), d.flags |= e, 0;
                  case 5:
                    return e = jc(), Ba[e + 0 >> 1] = 2, 0;
                  case 6:
                  case 7:
                    return 0;
                  case 16:
                  case 8:
                    return -28;
                  case 9:
                    return L[_Sd() >> 2] = 28, -1;
                  default:
                    return -28;
                }
              } catch (f) {
                if ("undefined" == typeof hc || "ErrnoError" !== f.name) {
                  throw f;
                }
                return -f.aa;
              }
            },
            __syscall_ioctl: function __syscall_ioctl(a, b, c) {
              ic = c;
              try {
                var d = Qb(a);
                switch (b) {
                  case 21509:
                    return d.s ? 0 : -59;
                  case 21505:
                    if (!d.s) {
                      return -59;
                    }
                    if (d.s.V.bc) {
                      b = [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                      var e = jc();
                      L[e >> 2] = 25856;
                      L[e + 4 >> 2] = 5;
                      L[e + 8 >> 2] = 191;
                      L[e + 12 >> 2] = 35387;
                      for (var f = 0; 32 > f; f++) {
                        C[e + f + 17 >> 0] = b[f] || 0;
                      }
                    }
                    return 0;
                  case 21510:
                  case 21511:
                  case 21512:
                    return d.s ? 0 : -59;
                  case 21506:
                  case 21507:
                  case 21508:
                    if (!d.s) {
                      return -59;
                    }
                    if (d.s.V.cc) {
                      for (e = jc(), b = [], f = 0; 32 > f; f++) {
                        b.push(C[e + f + 17 >> 0]);
                      }
                    }
                    return 0;
                  case 21519:
                    if (!d.s) {
                      return -59;
                    }
                    e = jc();
                    return L[e >> 2] = 0;
                  case 21520:
                    return d.s ? -28 : -59;
                  case 21531:
                    e = jc();
                    if (!d.m.ac) {
                      throw new O(59);
                    }
                    return d.m.ac(d, b, e);
                  case 21523:
                    if (!d.s) {
                      return -59;
                    }
                    d.s.V.dc && (f = [24, 80], e = jc(), Ba[e >> 1] = f[0], Ba[e + 2 >> 1] = f[1]);
                    return 0;
                  case 21524:
                    return d.s ? 0 : -59;
                  case 21515:
                    return d.s ? 0 : -59;
                  default:
                    return -28;
                }
              } catch (g) {
                if ("undefined" == typeof hc || "ErrnoError" !== g.name) {
                  throw g;
                }
                return -g.aa;
              }
            },
            __syscall_openat: function __syscall_openat(a, b, c, d) {
              ic = d;
              try {
                b = b ? kb(E, b) : "";
                var e = b;
                if ("/" === e.charAt(0)) {
                  b = e;
                } else {
                  var f = -100 === a ? "/" : Qb(a).path;
                  if (0 == e.length) {
                    throw new O(44);
                  }
                  b = db(f + "/" + e);
                }
                var g = d ? jc() : 0;
                return bc(b, c, g).X;
              } catch (n) {
                if ("undefined" == typeof hc || "ErrnoError" !== n.name) {
                  throw n;
                }
                return -n.aa;
              }
            },
            _embind_create_inheriting_constructor: function _embind_create_inheriting_constructor(a, b, c) {
              a = W(a);
              b = Cc(b, "wrapper");
              c = oc(c);
              var d = [].slice,
                e = b.i,
                f = e.N,
                g = e.A.N,
                n = e.A.constructor;
              a = lc(a, function () {
                e.A.qb.forEach(function (l) {
                  if (this[l] === g[l]) {
                    throw new rc("Pure virtual function ".concat(l, " must be implemented in JavaScript"));
                  }
                }.bind(this));
                Object.defineProperty(this, "__parent", {
                  value: f
                });
                this.__construct.apply(this, d.call(arguments));
              });
              f.__construct = function () {
                this === f && V("Pass correct 'this' to __construct");
                var l = n.implement.apply(void 0, [this].concat(d.call(arguments)));
                Dc(l);
                var u = l.g;
                l.notifyOnDestruction();
                u.ia = !0;
                Object.defineProperties(this, {
                  g: {
                    value: u
                  }
                });
                Mc(this);
                l = u.o;
                l = xc(e, l);
                wc.hasOwnProperty(l) ? V("Tried to register registered instance: ".concat(l)) : wc[l] = this;
              };
              f.__destruct = function () {
                this === f && V("Pass correct 'this' to __destruct");
                Dc(this);
                var l = this.g.o;
                l = xc(e, l);
                wc.hasOwnProperty(l) ? delete wc[l] : V("Tried to unregister unregistered instance: ".concat(l));
              };
              a.prototype = Object.create(f);
              for (var p in c) {
                a.prototype[p] = c[p];
              }
              return pc(a);
            },
            _embind_finalize_value_object: function _embind_finalize_value_object(a) {
              var b = Nc[a];
              delete Nc[a];
              var c = b.Pa,
                d = b.W,
                e = b.eb,
                f = e.map(function (g) {
                  return g.Yb;
                }).concat(e.map(function (g) {
                  return g.rc;
                }));
              Y([a], f, function (g) {
                var n = {};
                e.forEach(function (p, l) {
                  var u = g[l],
                    v = p.Wb,
                    x = p.Xb,
                    k = g[l + e.length],
                    t = p.qc,
                    r = p.sc;
                  n[p.Sb] = {
                    read: function read(B) {
                      return u.fromWireType(v(x, B));
                    },
                    write: function write(B, D) {
                      var w = [];
                      t(r, B, k.toWireType(w, D));
                      Oc(w);
                    }
                  };
                });
                return [{
                  name: b.name,
                  fromWireType: function fromWireType(p) {
                    var l = {},
                      u;
                    for (u in n) {
                      l[u] = n[u].read(p);
                    }
                    d(p);
                    return l;
                  },
                  toWireType: function toWireType(p, l) {
                    for (var u in n) {
                      if (!(u in l)) {
                        throw new TypeError("Missing field: \"".concat(u, "\""));
                      }
                    }
                    var v = c();
                    for (u in n) {
                      n[u].write(v, l[u]);
                    }
                    null !== p && p.push(d, v);
                    return v;
                  },
                  argPackAdvance: 8,
                  readValueFromPointer: Pc,
                  K: d
                }];
              });
            },
            _embind_register_bigint: function _embind_register_bigint() {},
            _embind_register_bool: function _embind_register_bool(a, b, c, d, e) {
              var f = Tc(c);
              b = W(b);
              Sc(a, {
                name: b,
                fromWireType: function fromWireType(g) {
                  return !!g;
                },
                toWireType: function toWireType(g, n) {
                  return n ? d : e;
                },
                argPackAdvance: 8,
                readValueFromPointer: function readValueFromPointer(g) {
                  if (1 === c) {
                    var n = C;
                  } else if (2 === c) {
                    n = Ba;
                  } else if (4 === c) {
                    n = L;
                  } else {
                    throw new TypeError("Unknown boolean type size: " + b);
                  }
                  return this.fromWireType(n[g >> f]);
                },
                K: null
              });
            },
            _embind_register_class: function _embind_register_class(a, b, c, d, e, f, g, n, p, l, u, v, x) {
              u = W(u);
              f = Z(e, f);
              n && (n = Z(g, n));
              l && (l = Z(p, l));
              x = Z(v, x);
              var k = kc(u);
              Yc(k, function () {
                ld("Cannot construct ".concat(u, " due to unbound types"), [d]);
              });
              Y([a, b, c], d ? [d] : [], function (t) {
                t = t[0];
                if (d) {
                  var r = t.i;
                  var B = r.N;
                } else {
                  B = Wc.prototype;
                }
                t = lc(k, function () {
                  if (Object.getPrototypeOf(this) !== D) {
                    throw new nc("Use 'new' to construct " + u);
                  }
                  if (void 0 === w.$) {
                    throw new nc(u + " has no accessible constructor");
                  }
                  var T = w.$[arguments.length];
                  if (void 0 === T) {
                    throw new nc("Tried to invoke ctor of ".concat(u, " with invalid number of parameters (").concat(arguments.length, ") - expected (").concat(Object.keys(w.$).toString(), ") parameters instead!"));
                  }
                  return T.apply(this, arguments);
                });
                var D = Object.create(B, {
                  constructor: {
                    value: t
                  }
                });
                t.prototype = D;
                var w = new Zc(u, t, D, x, r, f, n, l);
                w.A && (void 0 === w.A.oa && (w.A.oa = []), w.A.oa.push(w));
                r = new ed(u, w, !0, !1);
                B = new ed(u + "*", w, !1, !1);
                var M = new ed(u + " const*", w, !1, !0);
                Hc[a] = {
                  pointerType: B,
                  Kb: M
                };
                fd(k, t);
                return [r, B, M];
              });
            },
            _embind_register_class_class_function: function _embind_register_class_class_function(a, b, c, d, e, f, g) {
              var n = pd(c, d);
              b = W(b);
              f = Z(e, f);
              Y([], [a], function (p) {
                function l() {
                  ld("Cannot call ".concat(u, " due to unbound types"), n);
                }
                p = p[0];
                var u = "".concat(p.name, ".").concat(b);
                b.startsWith("@@") && (b = Symbol[b.substring(2)]);
                var v = p.i.constructor;
                void 0 === v[b] ? (l.ea = c - 1, v[b] = l) : (Xc(v, b, u), v[b].B[c - 1] = l);
                Y([], n, function (x) {
                  x = od(u, [x[0], null].concat(x.slice(1)), null, f, g);
                  void 0 === v[b].B ? (x.ea = c - 1, v[b] = x) : v[b].B[c - 1] = x;
                  if (p.i.oa) {
                    var _iterator8 = _createForOfIteratorHelper(p.i.oa),
                      _step8;
                    try {
                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                        var k = _step8.value;
                        k.constructor.hasOwnProperty(b) || (k.constructor[b] = x);
                      }
                    } catch (err) {
                      _iterator8.e(err);
                    } finally {
                      _iterator8.f();
                    }
                  }
                  return [];
                });
                return [];
              });
            },
            _embind_register_class_class_property: function _embind_register_class_class_property(a, b, c, d, e, f, g, n) {
              b = W(b);
              f = Z(e, f);
              Y([], [a], function (p) {
                p = p[0];
                var l = "".concat(p.name, ".").concat(b),
                  u = {
                    get: function get() {
                      ld("Cannot access ".concat(l, " due to unbound types"), [c]);
                    },
                    enumerable: !0,
                    configurable: !0
                  };
                u.set = n ? function () {
                  ld("Cannot access ".concat(l, " due to unbound types"), [c]);
                } : function () {
                  V("".concat(l, " is a read-only property"));
                };
                Object.defineProperty(p.i.constructor, b, u);
                Y([], [c], function (v) {
                  v = v[0];
                  var x = {
                    get: function get() {
                      return v.fromWireType(f(d));
                    },
                    enumerable: !0
                  };
                  n && (n = Z(g, n), x.set = function (k) {
                    var t = [];
                    n(d, v.toWireType(t, k));
                    Oc(t);
                  });
                  Object.defineProperty(p.i.constructor, b, x);
                  return [];
                });
                return [];
              });
            },
            _embind_register_class_constructor: function _embind_register_class_constructor(a, b, c, d, e, f) {
              var g = pd(b, c);
              e = Z(d, e);
              Y([], [a], function (n) {
                n = n[0];
                var p = "constructor ".concat(n.name);
                void 0 === n.i.$ && (n.i.$ = []);
                if (void 0 !== n.i.$[b - 1]) {
                  throw new nc("Cannot register multiple constructors with identical number of parameters (".concat(b - 1, ") for class '").concat(n.name, "'! Overload resolution is currently only performed using the parameter count, not actual type info!"));
                }
                n.i.$[b - 1] = function () {
                  ld("Cannot construct ".concat(n.name, " due to unbound types"), g);
                };
                Y([], g, function (l) {
                  l.splice(1, 0, null);
                  n.i.$[b - 1] = od(p, l, null, e, f);
                  return [];
                });
                return [];
              });
            },
            _embind_register_class_function: function _embind_register_class_function(a, b, c, d, e, f, g, n) {
              var p = pd(c, d);
              b = W(b);
              f = Z(e, f);
              Y([], [a], function (l) {
                function u() {
                  ld("Cannot call ".concat(v, " due to unbound types"), p);
                }
                l = l[0];
                var v = "".concat(l.name, ".").concat(b);
                b.startsWith("@@") && (b = Symbol[b.substring(2)]);
                n && l.i.qb.push(b);
                var x = l.i.N,
                  k = x[b];
                void 0 === k || void 0 === k.B && k.className !== l.name && k.ea === c - 2 ? (u.ea = c - 2, u.className = l.name, x[b] = u) : (Xc(x, b, v), x[b].B[c - 2] = u);
                Y([], p, function (t) {
                  t = od(v, t, l, f, g);
                  void 0 === x[b].B ? (t.ea = c - 2, x[b] = t) : x[b].B[c - 2] = t;
                  return [];
                });
                return [];
              });
            },
            _embind_register_class_property: function _embind_register_class_property(a, b, c, d, e, f, g, n, p, l) {
              b = W(b);
              e = Z(d, e);
              Y([], [a], function (u) {
                u = u[0];
                var v = "".concat(u.name, ".").concat(b),
                  x = {
                    get: function get() {
                      ld("Cannot access ".concat(v, " due to unbound types"), [c, g]);
                    },
                    enumerable: !0,
                    configurable: !0
                  };
                x.set = p ? function () {
                  ld("Cannot access ".concat(v, " due to unbound types"), [c, g]);
                } : function () {
                  V(v + " is a read-only property");
                };
                Object.defineProperty(u.i.N, b, x);
                Y([], p ? [c, g] : [c], function (k) {
                  var t = k[0],
                    r = {
                      get: function get() {
                        var D = qd(this, u, v + " getter");
                        return t.fromWireType(e(f, D));
                      },
                      enumerable: !0
                    };
                  if (p) {
                    p = Z(n, p);
                    var B = k[1];
                    r.set = function (D) {
                      var w = qd(this, u, v + " setter"),
                        M = [];
                      p(l, w, B.toWireType(M, D));
                      Oc(M);
                    };
                  }
                  Object.defineProperty(u.i.N, b, r);
                  return [];
                });
                return [];
              });
            },
            _embind_register_emval: function _embind_register_emval(a, b) {
              b = W(b);
              Sc(a, {
                name: b,
                fromWireType: function fromWireType(c) {
                  var d = oc(c);
                  rd(c);
                  return d;
                },
                toWireType: function toWireType(c, d) {
                  return pc(d);
                },
                argPackAdvance: 8,
                readValueFromPointer: Pc,
                K: null
              });
            },
            _embind_register_enum: function _embind_register_enum(a, b, c, d) {
              function e() {}
              c = Tc(c);
              b = W(b);
              e.values = {};
              Sc(a, {
                name: b,
                constructor: e,
                fromWireType: function fromWireType(f) {
                  return this.constructor.values[f];
                },
                toWireType: function toWireType(f, g) {
                  return g.value;
                },
                argPackAdvance: 8,
                readValueFromPointer: sd(b, c, d),
                K: null
              });
              Yc(b, e);
            },
            _embind_register_enum_value: function _embind_register_enum_value(a, b, c) {
              var d = Cc(a, "enum");
              b = W(b);
              a = d.constructor;
              d = Object.create(d.constructor.prototype, {
                value: {
                  value: c
                },
                constructor: {
                  value: lc("".concat(d.name, "_").concat(b), function () {})
                }
              });
              a.values[c] = d;
              a[b] = d;
            },
            _embind_register_float: function _embind_register_float(a, b, c) {
              c = Tc(c);
              b = W(b);
              Sc(a, {
                name: b,
                fromWireType: function fromWireType(d) {
                  return d;
                },
                toWireType: function toWireType(d, e) {
                  return e;
                },
                argPackAdvance: 8,
                readValueFromPointer: td(b, c),
                K: null
              });
            },
            _embind_register_function: function _embind_register_function(a, b, c, d, e, f) {
              var g = pd(b, c);
              a = W(a);
              e = Z(d, e);
              Yc(a, function () {
                ld("Cannot call ".concat(a, " due to unbound types"), g);
              }, b - 1);
              Y([], g, function (n) {
                fd(a, od(a, [n[0], null].concat(n.slice(1)), null, e, f), b - 1);
                return [];
              });
            },
            _embind_register_integer: function _embind_register_integer(a, b, c, d, e) {
              b = W(b);
              -1 === e && (e = 4294967295);
              e = Tc(c);
              var f = function f(n) {
                return n;
              };
              if (0 === d) {
                var g = 32 - 8 * c;
                f = function f(n) {
                  return n << g >>> g;
                };
              }
              c = b.includes("unsigned") ? function (n, p) {
                return p >>> 0;
              } : function (n, p) {
                return p;
              };
              Sc(a, {
                name: b,
                fromWireType: f,
                toWireType: c,
                argPackAdvance: 8,
                readValueFromPointer: ud(b, e, 0 !== d),
                K: null
              });
            },
            _embind_register_memory_view: function _embind_register_memory_view(a, b, c) {
              function d(f) {
                f >>= 2;
                var g = N;
                return new e(g.buffer, g[f + 1], g[f]);
              }
              var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
              c = W(c);
              Sc(a, {
                name: c,
                fromWireType: d,
                argPackAdvance: 8,
                readValueFromPointer: d
              }, {
                $b: !0
              });
            },
            _embind_register_std_string: function _embind_register_std_string(a, b) {
              b = W(b);
              var c = "std::string" === b;
              Sc(a, {
                name: b,
                fromWireType: function fromWireType(d) {
                  var e = N[d >> 2],
                    f = d + 4;
                  if (c) {
                    for (var g = f, n = 0; n <= e; ++n) {
                      var p = f + n;
                      if (n == e || 0 == E[p]) {
                        g = g ? kb(E, g, p - g) : "";
                        if (void 0 === l) {
                          var l = g;
                        } else {
                          l += String.fromCharCode(0), l += g;
                        }
                        g = p + 1;
                      }
                    }
                  } else {
                    l = Array(e);
                    for (n = 0; n < e; ++n) {
                      l[n] = String.fromCharCode(E[f + n]);
                    }
                    l = l.join("");
                  }
                  _Bc(d);
                  return l;
                },
                toWireType: function toWireType(d, e) {
                  e instanceof ArrayBuffer && (e = new Uint8Array(e));
                  var f = "string" == typeof e;
                  f || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || V("Cannot pass non-string to std::string");
                  var g = c && f ? mb(e) : e.length;
                  var n = _Td(4 + g + 1),
                    p = n + 4;
                  N[n >> 2] = g;
                  if (c && f) {
                    nb(e, E, p, g + 1);
                  } else {
                    if (f) {
                      for (f = 0; f < g; ++f) {
                        var l = e.charCodeAt(f);
                        255 < l && (_Bc(p), V("String has UTF-16 code units that do not fit in 8 bits"));
                        E[p + f] = l;
                      }
                    } else {
                      for (f = 0; f < g; ++f) {
                        E[p + f] = e[f];
                      }
                    }
                  }
                  null !== d && d.push(_Bc, n);
                  return n;
                },
                argPackAdvance: 8,
                readValueFromPointer: Pc,
                K: function K(d) {
                  _Bc(d);
                }
              });
            },
            _embind_register_std_wstring: function _embind_register_std_wstring(a, b, c) {
              c = W(c);
              if (2 === b) {
                var d = wd;
                var e = xd;
                var f = yd;
                var g = function g() {
                  return Ca;
                };
                var n = 1;
              } else {
                4 === b && (d = zd, e = Ad, f = Bd, g = function g() {
                  return N;
                }, n = 2);
              }
              Sc(a, {
                name: c,
                fromWireType: function fromWireType(p) {
                  for (var l = N[p >> 2], u = g(), v, x = p + 4, k = 0; k <= l; ++k) {
                    var t = p + 4 + k * b;
                    if (k == l || 0 == u[t >> n]) {
                      x = d(x, t - x), void 0 === v ? v = x : (v += String.fromCharCode(0), v += x), x = t + b;
                    }
                  }
                  _Bc(p);
                  return v;
                },
                toWireType: function toWireType(p, l) {
                  "string" != typeof l && V("Cannot pass non-string to C++ string type ".concat(c));
                  var u = f(l),
                    v = _Td(4 + u + b);
                  N[v >> 2] = u >> n;
                  e(l, v + 4, u + b);
                  null !== p && p.push(_Bc, v);
                  return v;
                },
                argPackAdvance: 8,
                readValueFromPointer: Pc,
                K: function K(p) {
                  _Bc(p);
                }
              });
            },
            _embind_register_value_object: function _embind_register_value_object(a, b, c, d, e, f) {
              Nc[a] = {
                name: W(b),
                Pa: Z(c, d),
                W: Z(e, f),
                eb: []
              };
            },
            _embind_register_value_object_field: function _embind_register_value_object_field(a, b, c, d, e, f, g, n, p, l) {
              Nc[a].eb.push({
                Sb: W(b),
                Yb: c,
                Wb: Z(d, e),
                Xb: f,
                rc: g,
                qc: Z(n, p),
                sc: l
              });
            },
            _embind_register_void: function _embind_register_void(a, b) {
              b = W(b);
              Sc(a, {
                fc: !0,
                name: b,
                argPackAdvance: 0,
                fromWireType: function fromWireType() {},
                toWireType: function toWireType() {}
              });
            },
            _emscripten_get_now_is_monotonic: function _emscripten_get_now_is_monotonic() {
              return !0;
            },
            _emval_as: function _emval_as(a, b, c) {
              a = oc(a);
              b = Cc(b, "emval::as");
              var d = [],
                e = pc(d);
              N[c >> 2] = e;
              return b.toWireType(d, a);
            },
            _emval_call_method: function _emval_call_method(a, b, c, d, e) {
              a = Ed[a];
              b = oc(b);
              c = Dd(c);
              var f = [];
              N[d >> 2] = pc(f);
              return a(b, c, f, e);
            },
            _emval_call_void_method: function _emval_call_void_method(a, b, c, d) {
              a = Ed[a];
              b = oc(b);
              c = Dd(c);
              a(b, c, null, d);
            },
            _emval_decref: rd,
            _emval_get_method_caller: function _emval_get_method_caller(a, b) {
              var c = Gd(a, b),
                d = c[0];
              b = d.name + "_$" + c.slice(1).map(function (g) {
                return g.name;
              }).join("_") + "$";
              var e = Hd[b];
              if (void 0 !== e) {
                return e;
              }
              var f = Array(a - 1);
              e = Fd(function (g, n, p, l) {
                for (var u = 0, v = 0; v < a - 1; ++v) {
                  f[v] = c[v + 1].readValueFromPointer(l + u), u += c[v + 1].argPackAdvance;
                }
                g = g[n].apply(g, f);
                for (v = 0; v < a - 1; ++v) {
                  c[v + 1].Nb && c[v + 1].Nb(f[v]);
                }
                if (!d.fc) {
                  return d.toWireType(p, g);
                }
              });
              return Hd[b] = e;
            },
            _emval_get_module_property: function _emval_get_module_property(a) {
              a = Dd(a);
              return pc(m[a]);
            },
            _emval_get_property: function _emval_get_property(a, b) {
              a = oc(a);
              b = oc(b);
              return pc(a[b]);
            },
            _emval_incref: function _emval_incref(a) {
              4 < a && (U.get(a).tb += 1);
            },
            _emval_new_array: function _emval_new_array() {
              return pc([]);
            },
            _emval_new_cstring: function _emval_new_cstring(a) {
              return pc(Dd(a));
            },
            _emval_new_object: function _emval_new_object() {
              return pc({});
            },
            _emval_run_destructors: function _emval_run_destructors(a) {
              var b = oc(a);
              Oc(b);
              rd(a);
            },
            _emval_set_property: function _emval_set_property(a, b, c) {
              a = oc(a);
              b = oc(b);
              c = oc(c);
              a[b] = c;
            },
            _emval_take_value: function _emval_take_value(a, b) {
              a = Cc(a, "_emval_take_value");
              a = a.readValueFromPointer(b);
              return pc(a);
            },
            abort: function abort() {
              xa("");
            },
            emscripten_asm_const_int: function emscripten_asm_const_int(a, b, c) {
              Id.length = 0;
              var d;
              for (c >>= 2; d = E[b++];) {
                c += 105 != d & c, Id.push(105 == d ? L[c] : Ea[c++ >> 1]), ++c;
              }
              return ab[a].apply(null, Id);
            },
            emscripten_date_now: function emscripten_date_now() {
              return Date.now();
            },
            emscripten_get_now: function emscripten_get_now() {
              return performance.now();
            },
            emscripten_memcpy_big: function emscripten_memcpy_big(a, b, c) {
              return E.copyWithin(a, b, b + c);
            },
            emscripten_resize_heap: function emscripten_resize_heap(a) {
              var b = E.length;
              a >>>= 0;
              if (2147483648 < a) {
                return !1;
              }
              for (var c = 1; 4 >= c; c *= 2) {
                var d = b * (1 + 0.2 / c);
                d = Math.min(d, a + 100663296);
                var e = Math;
                d = Math.max(a, d);
                a: {
                  e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536) - za.buffer.byteLength + 65535 >>> 16;
                  try {
                    za.grow(e);
                    Ha();
                    var f = 1;
                    break a;
                  } catch (g) {}
                  f = void 0;
                }
                if (f) {
                  return !0;
                }
              }
              return !1;
            },
            environ_get: function environ_get(a, b) {
              var c = 0;
              Ld().forEach(function (d, e) {
                var f = b + c;
                e = N[a + 4 * e >> 2] = f;
                for (f = 0; f < d.length; ++f) {
                  C[e++ >> 0] = d.charCodeAt(f);
                }
                C[e >> 0] = 0;
                c += d.length + 1;
              });
              return 0;
            },
            environ_sizes_get: function environ_sizes_get(a, b) {
              var c = Ld();
              N[a >> 2] = c.length;
              var d = 0;
              c.forEach(function (e) {
                d += e.length + 1;
              });
              N[b >> 2] = d;
              return 0;
            },
            fd_close: function fd_close(a) {
              try {
                var b = Qb(a);
                if (null === b.X) {
                  throw new O(8);
                }
                b.Ma && (b.Ma = null);
                try {
                  b.m.close && b.m.close(b);
                } catch (c) {
                  throw c;
                } finally {
                  Db[b.X] = null;
                }
                b.X = null;
                return 0;
              } catch (c) {
                if ("undefined" == typeof hc || "ErrnoError" !== c.name) {
                  throw c;
                }
                return c.aa;
              }
            },
            fd_read: function fd_read(a, b, c, d) {
              try {
                a: {
                  var e = Qb(a);
                  a = b;
                  for (var f, g = b = 0; g < c; g++) {
                    var n = N[a >> 2],
                      p = N[a + 4 >> 2];
                    a += 8;
                    var l = e,
                      u = n,
                      v = p,
                      x = f,
                      k = C;
                    if (0 > v || 0 > x) {
                      throw new O(28);
                    }
                    if (null === l.X) {
                      throw new O(8);
                    }
                    if (1 === (l.flags & 2097155)) {
                      throw new O(8);
                    }
                    if (16384 === (l.node.mode & 61440)) {
                      throw new O(31);
                    }
                    if (!l.m.read) {
                      throw new O(28);
                    }
                    var t = "undefined" != typeof x;
                    if (!t) {
                      x = l.position;
                    } else if (!l.seekable) {
                      throw new O(70);
                    }
                    var r = l.m.read(l, k, u, v, x);
                    t || (l.position += r);
                    var B = r;
                    if (0 > B) {
                      var D = -1;
                      break a;
                    }
                    b += B;
                    if (B < p) {
                      break;
                    }
                    "undefined" !== typeof f && (f += B);
                  }
                  D = b;
                }
                N[d >> 2] = D;
                return 0;
              } catch (w) {
                if ("undefined" == typeof hc || "ErrnoError" !== w.name) {
                  throw w;
                }
                return w.aa;
              }
            },
            fd_seek: function fd_seek(a, b, c, d, e) {
              b = c + 2097152 >>> 0 < 4194305 - !!b ? (b >>> 0) + 4294967296 * c : NaN;
              try {
                if (isNaN(b)) {
                  return 61;
                }
                var f = Qb(a);
                cc(f, b, d);
                Xa = [f.position >>> 0, (Wa = f.position, 1.0 <= +Math.abs(Wa) ? 0.0 < Wa ? +Math.floor(Wa / 4294967296.0) >>> 0 : ~~+Math.ceil((Wa - +(~~Wa >>> 0)) / 4294967296.0) >>> 0 : 0)];
                L[e >> 2] = Xa[0];
                L[e + 4 >> 2] = Xa[1];
                f.Ma && 0 === b && 0 === d && (f.Ma = null);
                return 0;
              } catch (g) {
                if ("undefined" == typeof hc || "ErrnoError" !== g.name) {
                  throw g;
                }
                return g.aa;
              }
            },
            fd_write: function fd_write(a, b, c, d) {
              try {
                a: {
                  var e = Qb(a);
                  a = b;
                  for (var f, g = b = 0; g < c; g++) {
                    var n = N[a >> 2],
                      p = N[a + 4 >> 2];
                    a += 8;
                    var l = e,
                      u = n,
                      v = p,
                      x = f,
                      k = C;
                    if (0 > v || 0 > x) {
                      throw new O(28);
                    }
                    if (null === l.X) {
                      throw new O(8);
                    }
                    if (0 === (l.flags & 2097155)) {
                      throw new O(8);
                    }
                    if (16384 === (l.node.mode & 61440)) {
                      throw new O(31);
                    }
                    if (!l.m.write) {
                      throw new O(28);
                    }
                    l.seekable && l.flags & 1024 && cc(l, 0, 2);
                    var t = "undefined" != typeof x;
                    if (!t) {
                      x = l.position;
                    } else if (!l.seekable) {
                      throw new O(70);
                    }
                    var r = l.m.write(l, k, u, v, x, void 0);
                    t || (l.position += r);
                    var B = r;
                    if (0 > B) {
                      var D = -1;
                      break a;
                    }
                    b += B;
                    "undefined" !== typeof f && (f += B);
                  }
                  D = b;
                }
                N[d >> 2] = D;
                return 0;
              } catch (w) {
                if ("undefined" == typeof hc || "ErrnoError" !== w.name) {
                  throw w;
                }
                return w.aa;
              }
            },
            strftime_l: function strftime_l(a, b, c, d) {
              return Pd(a, b, c, d);
            }
          };
          (function () {
            function a(c) {
              z = c = c.exports;
              za = z.memory;
              Ha();
              Ia = z.__indirect_function_table;
              Ka.unshift(z.__wasm_call_ctors);
              Na--;
              m.monitorRunDependencies && m.monitorRunDependencies(Na);
              if (0 == Na && (null !== Oa && (clearInterval(Oa), Oa = null), Pa)) {
                var d = Pa;
                Pa = null;
                d();
              }
              return c;
            }
            var b = {
              env: Ud,
              wasi_snapshot_preview1: Ud
            };
            Na++;
            m.monitorRunDependencies && m.monitorRunDependencies(Na);
            if (m.instantiateWasm) {
              try {
                return m.instantiateWasm(b, a);
              } catch (c) {
                va("Module.instantiateWasm callback failed with error: " + c), ba(c);
              }
            }
            Va(b, function (c) {
              a(c.instance);
            }).catch(ba);
            return {};
          })();
          var _Bc = function Bc(a) {
              return (_Bc = z.free)(a);
            },
            _Td = function Td(a) {
              return (_Td = z.malloc)(a);
            },
            Ya = m._ma_device__on_notification_unlocked = function (a) {
              return (Ya = m._ma_device__on_notification_unlocked = z.ma_device__on_notification_unlocked)(a);
            };
          m._ma_malloc_emscripten = function (a, b) {
            return (m._ma_malloc_emscripten = z.ma_malloc_emscripten)(a, b);
          };
          m._ma_free_emscripten = function (a, b) {
            return (m._ma_free_emscripten = z.ma_free_emscripten)(a, b);
          };
          var Za = m._ma_device_process_pcm_frames_capture__webaudio = function (a, b, c) {
              return (Za = m._ma_device_process_pcm_frames_capture__webaudio = z.ma_device_process_pcm_frames_capture__webaudio)(a, b, c);
            },
            $a = m._ma_device_process_pcm_frames_playback__webaudio = function (a, b, c) {
              return ($a = m._ma_device_process_pcm_frames_playback__webaudio = z.ma_device_process_pcm_frames_playback__webaudio)(a, b, c);
            },
            _Sd = function Sd() {
              return (_Sd = z.__errno_location)();
            },
            _Ac = function Ac(a) {
              return (_Ac = z.__getTypeName)(a);
            };
          m.__embind_initialize_bindings = function () {
            return (m.__embind_initialize_bindings = z._embind_initialize_bindings)();
          };
          m.dynCall_iiji = function (a, b, c, d, e) {
            return (m.dynCall_iiji = z.dynCall_iiji)(a, b, c, d, e);
          };
          m.dynCall_jiji = function (a, b, c, d, e) {
            return (m.dynCall_jiji = z.dynCall_jiji)(a, b, c, d, e);
          };
          m.dynCall_iiiji = function (a, b, c, d, e, f) {
            return (m.dynCall_iiiji = z.dynCall_iiiji)(a, b, c, d, e, f);
          };
          m.dynCall_iij = function (a, b, c, d) {
            return (m.dynCall_iij = z.dynCall_iij)(a, b, c, d);
          };
          m.dynCall_jii = function (a, b, c) {
            return (m.dynCall_jii = z.dynCall_jii)(a, b, c);
          };
          m.dynCall_viijii = function (a, b, c, d, e, f, g) {
            return (m.dynCall_viijii = z.dynCall_viijii)(a, b, c, d, e, f, g);
          };
          m.dynCall_iiiiij = function (a, b, c, d, e, f, g) {
            return (m.dynCall_iiiiij = z.dynCall_iiiiij)(a, b, c, d, e, f, g);
          };
          m.dynCall_iiiiijj = function (a, b, c, d, e, f, g, n, p) {
            return (m.dynCall_iiiiijj = z.dynCall_iiiiijj)(a, b, c, d, e, f, g, n, p);
          };
          m.dynCall_iiiiiijj = function (a, b, c, d, e, f, g, n, p, l) {
            return (m.dynCall_iiiiiijj = z.dynCall_iiiiiijj)(a, b, c, d, e, f, g, n, p, l);
          };
          var Vd;
          Pa = function Wd() {
            Vd || Xd();
            Vd || (Pa = Wd);
          };
          function Xd() {
            function a() {
              if (!Vd && (Vd = !0, m.calledRun = !0, !Aa)) {
                m.noFSInit || ec || (ec = !0, dc(), m.stdin = m.stdin, m.stdout = m.stdout, m.stderr = m.stderr, m.stdin ? gc("stdin", m.stdin) : Vb("/dev/tty", "/dev/stdin"), m.stdout ? gc("stdout", null, m.stdout) : Vb("/dev/tty", "/dev/stdout"), m.stderr ? gc("stderr", null, m.stderr) : Vb("/dev/tty1", "/dev/stderr"), bc("/dev/stdin", 0), bc("/dev/stdout", 1), bc("/dev/stderr", 1));
                Gb = !1;
                bb(Ka);
                aa(m);
                if (m.onRuntimeInitialized) {
                  m.onRuntimeInitialized();
                }
                if (m.postRun) {
                  for ("function" == typeof m.postRun && (m.postRun = [m.postRun]); m.postRun.length;) {
                    var b = m.postRun.shift();
                    La.unshift(b);
                  }
                }
                bb(La);
              }
            }
            if (!(0 < Na)) {
              if (m.preRun) {
                for ("function" == typeof m.preRun && (m.preRun = [m.preRun]); m.preRun.length;) {
                  Ma();
                }
              }
              bb(Ja);
              0 < Na || (m.setStatus ? (m.setStatus("Running..."), setTimeout(function () {
                setTimeout(function () {
                  m.setStatus("");
                }, 1);
                a();
              }, 1)) : a());
            }
          }
          if (m.preInit) {
            for ("function" == typeof m.preInit && (m.preInit = [m.preInit]); 0 < m.preInit.length;) {
              m.preInit.pop()();
            }
          }
          Xd();
          return moduleArg.ready;
        };
      }();
      /* harmony default export */
      var __WEBPACK_DEFAULT_EXPORT__ = Rive;

      /***/
    }), (/* 2 */
    /***/function (module) {
      module.exports = /*#__PURE__*/JSON.parse('{"name":"@rive-app/canvas-single","version":"2.6.0","description":"Rive\'s high-level canvas based web api all in one js file.","main":"rive.js","homepage":"https://rive.app","repository":{"type":"git","url":"https://github.com/rive-app/rive-wasm/tree/master/js"},"keywords":["rive","animation"],"author":"Rive","contributors":["Luigi Rosso <luigi@rive.app> (https://rive.app)","Maxwell Talbot <max@rive.app> (https://rive.app)","Arthur Vivian <arthur@rive.app> (https://rive.app)","Umberto Sonnino <umberto@rive.app> (https://rive.app)","Matthew Sullivan <matt.j.sullivan@gmail.com> (mailto:matt.j.sullivan@gmail.com)"],"license":"MIT","files":["rive.js","rive.js.map","rive.d.ts","rive_advanced.mjs.d.ts"],"typings":"rive.d.ts","dependencies":{},"browser":{"fs":false,"path":false}}');

      /***/
    }), (/* 3 */
    /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Animation: function Animation() {
          return /* reexport safe */_Animation__WEBPACK_IMPORTED_MODULE_0__.Animation;
        }
        /* harmony export */
      });
      /* harmony import */
      var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

      /***/
    }), (/* 4 */
    /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Animation: function Animation() {
          return /* binding */_Animation;
        }
        /* harmony export */
      });
      /**
       * Represents an animation that can be played on an Artboard.
       * Wraps animations and instances from the runtime and keeps track of playback state.
       *
       * The `Animation` class manages the state and behavior of a single animation instance,
       * including its current time, loop count, and ability to scrub to a specific time.
       *
       * The class provides methods to advance the animation, apply its interpolated keyframe
       * values to the Artboard, and clean up the underlying animation instance when the
       * animation is no longer needed.
       */
      var _Animation = /** @class */function () {
        /**
         * Constructs a new animation
         * @constructor
         * @param {any} animation: runtime animation object
         * @param {any} instance: runtime animation instance object
         */
        function Animation(animation, artboard, runtime, playing) {
          this.animation = animation;
          this.artboard = artboard;
          this.playing = playing;
          this.loopCount = 0;
          /**
           * The time to which the animation should move to on the next render.
           * If not null, the animation will scrub to this time instead of advancing by the given time.
           */
          this.scrubTo = null;
          this.instance = new runtime.LinearAnimationInstance(animation, artboard);
        }
        Object.defineProperty(Animation.prototype, "name", {
          /**
           * Returns the animation's name
           */
          get: function get() {
            return this.animation.name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "time", {
          /**
           * Returns the animation's name
           */
          get: function get() {
            return this.instance.time;
          },
          /**
           * Sets the animation's current time
           */
          set: function set(value) {
            this.instance.time = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "loopValue", {
          /**
           * Returns the animation's loop type
           */
          get: function get() {
            return this.animation.loopValue;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "needsScrub", {
          /**
           * Indicates whether the animation needs to be scrubbed.
           * @returns `true` if the animation needs to be scrubbed, `false` otherwise.
           */
          get: function get() {
            return this.scrubTo !== null;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Advances the animation by the give time. If the animation needs scrubbing,
         * time is ignored and the stored scrub value is used.
         * @param time the time to advance the animation by if no scrubbing required
         */
        Animation.prototype.advance = function (time) {
          if (this.scrubTo === null) {
            this.instance.advance(time);
          } else {
            this.instance.time = 0;
            this.instance.advance(this.scrubTo);
            this.scrubTo = null;
          }
        };
        /**
         * Apply interpolated keyframe values to the artboard. This should be called after calling
         * .advance() on an animation instance so that new values are applied to properties.
         *
         * Note: This does not advance the artboard, which updates all objects on the artboard
         * @param mix - Mix value for the animation from 0 to 1
         */
        Animation.prototype.apply = function (mix) {
          this.instance.apply(mix);
        };
        /**
         * Deletes the backing Wasm animation instance; once this is called, this
         * animation is no more.
         */
        Animation.prototype.cleanup = function () {
          this.instance.delete();
        };
        return Animation;
      }();

      /***/
    }), (/* 5 */
    /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */BLANK_URL: function BLANK_URL() {
          return /* reexport safe */_sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__.BLANK_URL;
        },
        /* harmony export */registerTouchInteractions: function registerTouchInteractions() {
          return /* reexport safe */_registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__.registerTouchInteractions;
        },
        /* harmony export */sanitizeUrl: function sanitizeUrl() {
          return /* reexport safe */_sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__.sanitizeUrl;
        }
        /* harmony export */
      });
      /* harmony import */
      var _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
      /* harmony import */
      var _sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);

      /***/
    }), (/* 6 */
    /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */registerTouchInteractions: function registerTouchInteractions() {
          return /* binding */_registerTouchInteractions;
        }
        /* harmony export */
      });
      var _this = undefined;
      /**
       * Returns the clientX and clientY properties from touch or mouse events. Also
       * calls preventDefault() on the event if it is a touchstart or touchmove to prevent
       * scrolling the page on mobile devices
       * @param event - Either a TouchEvent or a MouseEvent
       * @returns - Coordinates of the clientX and clientY properties from the touch/mouse event
       */
      var getClientCoordinates = function getClientCoordinates(event, isTouchScrollEnabled) {
        var _a, _b;
        if (["touchstart", "touchmove"].indexOf(event.type) > -1 && ((_a = event.touches) === null || _a === void 0 ? void 0 : _a.length)) {
          // This flag, if false, prevents touch events on the canvas default behavior
          // which may prevent scrolling if a drag motion on the canvas is performed
          if (!isTouchScrollEnabled) {
            event.preventDefault();
          }
          return {
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY
          };
        } else if (event.type === "touchend" && ((_b = event.changedTouches) === null || _b === void 0 ? void 0 : _b.length)) {
          return {
            clientX: event.changedTouches[0].clientX,
            clientY: event.changedTouches[0].clientY
          };
        } else {
          return {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }
      };
      /**
       * Registers mouse move/up/down callback handlers on the canvas to send meaningful coordinates to
       * the state machine pointer move/up/down functions based on cursor interaction
       */
      var _registerTouchInteractions = function _registerTouchInteractions(_a) {
        var canvas = _a.canvas,
          artboard = _a.artboard,
          _b = _a.stateMachines,
          stateMachines = _b === void 0 ? [] : _b,
          renderer = _a.renderer,
          rive = _a.rive,
          fit = _a.fit,
          alignment = _a.alignment,
          _c = _a.isTouchScrollEnabled,
          isTouchScrollEnabled = _c === void 0 ? false : _c,
          _d = _a.layoutScaleFactor,
          layoutScaleFactor = _d === void 0 ? 1.0 : _d;
        if (!canvas || !stateMachines.length || !renderer || !rive || !artboard || typeof window === "undefined") {
          return null;
        }
        /**
         * After a touchend event, some browsers may fire synthetic mouse events
         * (mouseover, mousedown, mousemove, mouseup) if the touch interaction did not cause
         * any default action (such as scrolling).
         *
         * This is done to simulate the behavior of a mouse for applications that do not support
         * touch events.
         *
         * We're keeping track of the previous event to not send the synthetic mouse events if the
         * touch event was a click (touchstart -> touchend).
         *
         * This is only needed when `isTouchScrollEnabled` is false
         * When true, `preventDefault()` is called which prevents this behaviour.
         **/
        var _prevEventType = null;
        var _syntheticEventsActive = false;
        var processEventCallback = function processEventCallback(event) {
          // Exit early out of all synthetic mouse events
          // https://stackoverflow.com/questions/9656990/how-to-prevent-simulated-mouse-events-in-mobile-browsers
          // https://stackoverflow.com/questions/25572070/javascript-touchend-versus-click-dilemma
          if (_syntheticEventsActive && event instanceof MouseEvent) {
            // Synthetic event finished
            if (event.type == "mouseup") {
              _syntheticEventsActive = false;
            }
            return;
          }
          // Test if it's a "touch click". This could cause the browser to send
          // synthetic mouse events.
          _syntheticEventsActive = isTouchScrollEnabled && event.type === "touchend" && _prevEventType === "touchstart";
          _prevEventType = event.type;
          var boundingRect = event.currentTarget.getBoundingClientRect();
          var _a = getClientCoordinates(event, isTouchScrollEnabled),
            clientX = _a.clientX,
            clientY = _a.clientY;
          if (!clientX && !clientY) {
            return;
          }
          var canvasX = clientX - boundingRect.left;
          var canvasY = clientY - boundingRect.top;
          var forwardMatrix = rive.computeAlignment(fit, alignment, {
            minX: 0,
            minY: 0,
            maxX: boundingRect.width,
            maxY: boundingRect.height
          }, artboard.bounds, layoutScaleFactor);
          var invertedMatrix = new rive.Mat2D();
          forwardMatrix.invert(invertedMatrix);
          var canvasCoordinatesVector = new rive.Vec2D(canvasX, canvasY);
          var transformedVector = rive.mapXY(invertedMatrix, canvasCoordinatesVector);
          var transformedX = transformedVector.x();
          var transformedY = transformedVector.y();
          transformedVector.delete();
          invertedMatrix.delete();
          canvasCoordinatesVector.delete();
          forwardMatrix.delete();
          switch (event.type) {
            /**
             * There's a 2px buffer for a hitRadius when translating the pointer coordinates
             * down to the state machine. In cases where the hitbox is about that much away
             * from the Artboard border, we don't have exact precision on determining pointer
             * exit. We're therefore adding to the translated coordinates on mouseout of a canvas
             * to ensure that we report the mouse has truly exited the hitarea.
             * https://github.com/rive-app/rive-cpp/blob/master/src/animation/state_machine_instance.cpp#L336
             *
             * We add/subtract 10000 to account for when the graphic goes beyond the canvas bound
             * due to for example, a fit: 'cover'. Not perfect, but helps reliably (for now) ensure
             * we report going out of bounds when the mouse is out of the canvas
             */
            case "mouseout":
              for (var _i = 0, stateMachines_1 = stateMachines; _i < stateMachines_1.length; _i++) {
                var stateMachine = stateMachines_1[_i];
                stateMachine.pointerMove(transformedX, transformedY);
              }
              break;
            // Pointer moving/hovering on the canvas
            case "touchmove":
            case "mouseover":
            case "mousemove":
              {
                for (var _b = 0, stateMachines_2 = stateMachines; _b < stateMachines_2.length; _b++) {
                  var stateMachine = stateMachines_2[_b];
                  stateMachine.pointerMove(transformedX, transformedY);
                }
                break;
              }
            // Pointer click initiated but not released yet on the canvas
            case "touchstart":
            case "mousedown":
              {
                for (var _c = 0, stateMachines_3 = stateMachines; _c < stateMachines_3.length; _c++) {
                  var stateMachine = stateMachines_3[_c];
                  stateMachine.pointerDown(transformedX, transformedY);
                }
                break;
              }
            // Pointer click released on the canvas
            case "touchend":
            case "mouseup":
              {
                for (var _d = 0, stateMachines_4 = stateMachines; _d < stateMachines_4.length; _d++) {
                  var stateMachine = stateMachines_4[_d];
                  stateMachine.pointerUp(transformedX, transformedY);
                }
                break;
              }
            default:
          }
        };
        var callback = processEventCallback.bind(_this);
        canvas.addEventListener("mouseover", callback);
        canvas.addEventListener("mouseout", callback);
        canvas.addEventListener("mousemove", callback);
        canvas.addEventListener("mousedown", callback);
        canvas.addEventListener("mouseup", callback);
        canvas.addEventListener("touchmove", callback, {
          passive: isTouchScrollEnabled
        });
        canvas.addEventListener("touchstart", callback, {
          passive: isTouchScrollEnabled
        });
        canvas.addEventListener("touchend", callback);
        return function () {
          canvas.removeEventListener("mouseover", callback);
          canvas.removeEventListener("mouseout", callback);
          canvas.removeEventListener("mousemove", callback);
          canvas.removeEventListener("mousedown", callback);
          canvas.removeEventListener("mouseup", callback);
          canvas.removeEventListener("touchmove", callback);
          canvas.removeEventListener("touchstart", callback);
          canvas.removeEventListener("touchend", callback);
        };
      };

      /***/
    }), (/* 7 */
    /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */BLANK_URL: function BLANK_URL() {
          return /* binding */_BLANK_URL;
        },
        /* harmony export */sanitizeUrl: function sanitizeUrl() {
          return /* binding */_sanitizeUrl;
        }
        /* harmony export */
      });
      // Reference: https://github.com/braintree/sanitize-url/tree/main
      var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
      var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
      var htmlCtrlEntityRegex = /&(newline|tab);/gi;
      var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
      var urlSchemeRegex = /^.+(:|&colon;)/gim;
      var relativeFirstCharacters = [".", "/"];
      var _BLANK_URL = "about:blank";
      function isRelativeUrlWithoutProtocol(url) {
        return relativeFirstCharacters.indexOf(url[0]) > -1;
      }
      // adapted from https://stackoverflow.com/a/29824550/2601552
      function decodeHtmlCharacters(str) {
        var removedNullByte = str.replace(ctrlCharactersRegex, "");
        return removedNullByte.replace(htmlEntitiesRegex, function (match, dec) {
          return String.fromCharCode(dec);
        });
      }
      function _sanitizeUrl(url) {
        if (!url) {
          return _BLANK_URL;
        }
        var sanitizedUrl = decodeHtmlCharacters(url).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
        if (!sanitizedUrl) {
          return _BLANK_URL;
        }
        if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
          return sanitizedUrl;
        }
        var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
        if (!urlSchemeParseResults) {
          return sanitizedUrl;
        }
        var urlScheme = urlSchemeParseResults[0];
        if (invalidProtocolRegex.test(urlScheme)) {
          return _BLANK_URL;
        }
        return sanitizedUrl;
      }

      /***/
    }
    /******/)];
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
      /******/ // Check if module is in cache
      /******/var cachedModule = __webpack_module_cache__[moduleId];
      /******/
      if (cachedModule !== undefined) {
        /******/return cachedModule.exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/define property getters */
    /******/
    (function () {
      /******/ // define getter functions for harmony exports
      /******/__webpack_require__.d = function (exports, definition) {
        /******/for (var key in definition) {
          /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            /******/Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key]
            });
            /******/
          }
          /******/
        }
        /******/
      };
      /******/
    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    (function () {
      /******/__webpack_require__.o = function (obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      /******/
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/
    (function () {
      /******/ // define __esModule on exports
      /******/__webpack_require__.r = function (exports) {
        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/
    })();
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
    (function () {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Alignment: function Alignment() {
          return /* binding */_Alignment;
        },
        /* harmony export */DataEnum: function DataEnum() {
          return /* binding */_DataEnum;
        },
        /* harmony export */EventType: function EventType() {
          return /* binding */_EventType;
        },
        /* harmony export */Fit: function Fit() {
          return /* binding */_Fit;
        },
        /* harmony export */Layout: function Layout() {
          return /* binding */_Layout;
        },
        /* harmony export */LoopType: function LoopType() {
          return /* binding */_LoopType;
        },
        /* harmony export */Rive: function Rive() {
          return /* binding */_Rive;
        },
        /* harmony export */RiveEventType: function RiveEventType() {
          return /* binding */_RiveEventType;
        },
        /* harmony export */RiveFile: function RiveFile() {
          return /* binding */_RiveFile;
        },
        /* harmony export */RuntimeLoader: function RuntimeLoader() {
          return /* binding */_RuntimeLoader;
        },
        /* harmony export */StateMachineInput: function StateMachineInput() {
          return /* binding */_StateMachineInput;
        },
        /* harmony export */StateMachineInputType: function StateMachineInputType() {
          return /* binding */_StateMachineInputType;
        },
        /* harmony export */Testing: function Testing() {
          return /* binding */_Testing;
        },
        /* harmony export */ViewModel: function ViewModel() {
          return /* binding */_ViewModel;
        },
        /* harmony export */ViewModelInstance: function ViewModelInstance() {
          return /* binding */_ViewModelInstance;
        },
        /* harmony export */ViewModelInstanceBoolean: function ViewModelInstanceBoolean() {
          return /* binding */_ViewModelInstanceBoolean;
        },
        /* harmony export */ViewModelInstanceColor: function ViewModelInstanceColor() {
          return /* binding */_ViewModelInstanceColor;
        },
        /* harmony export */ViewModelInstanceEnum: function ViewModelInstanceEnum() {
          return /* binding */_ViewModelInstanceEnum;
        },
        /* harmony export */ViewModelInstanceNumber: function ViewModelInstanceNumber() {
          return /* binding */_ViewModelInstanceNumber;
        },
        /* harmony export */ViewModelInstanceString: function ViewModelInstanceString() {
          return /* binding */_ViewModelInstanceString;
        },
        /* harmony export */ViewModelInstanceTrigger: function ViewModelInstanceTrigger() {
          return /* binding */_ViewModelInstanceTrigger;
        },
        /* harmony export */ViewModelInstanceValue: function ViewModelInstanceValue() {
          return /* binding */_ViewModelInstanceValue;
        },
        /* harmony export */decodeAudio: function decodeAudio() {
          return /* binding */_decodeAudio;
        },
        /* harmony export */decodeFont: function decodeFont() {
          return /* binding */_decodeFont;
        },
        /* harmony export */decodeImage: function decodeImage() {
          return /* binding */_decodeImage;
        }
        /* harmony export */
      });
      /* harmony import */
      var _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
      /* harmony import */
      var package_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
      /* harmony import */
      var _animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
      /* harmony import */
      var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
      var __extends = undefined && undefined.__extends || function () {
        var _extendStatics = function extendStatics(d, b) {
          _extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          };
          return _extendStatics(d, b);
        };
        return function (d, b) {
          if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          _extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign = undefined && undefined.__assign || function () {
        __assign = Object.assign || function (t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = undefined && undefined.__generator || function (thisArg, body) {
        var _ = {
            label: 0,
            sent: function sent() {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      };
      var RiveError = /** @class */function (_super) {
        __extends(RiveError, _super);
        function RiveError() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.isHandledError = true;
          return _this;
        }
        return RiveError;
      }(Error);
      // #regions helpers
      var resolveErrorMessage = function resolveErrorMessage(error) {
        return error && error.isHandledError ? error.message : "Problem loading file; may be corrupt!";
      };
      // #region layout
      // Fit options for the canvas
      var _Fit;
      (function (Fit) {
        Fit["Cover"] = "cover";
        Fit["Contain"] = "contain";
        Fit["Fill"] = "fill";
        Fit["FitWidth"] = "fitWidth";
        Fit["FitHeight"] = "fitHeight";
        Fit["None"] = "none";
        Fit["ScaleDown"] = "scaleDown";
        Fit["Layout"] = "layout";
      })(_Fit || (_Fit = {}));
      // Alignment options for the canvas
      var _Alignment;
      (function (Alignment) {
        Alignment["Center"] = "center";
        Alignment["TopLeft"] = "topLeft";
        Alignment["TopCenter"] = "topCenter";
        Alignment["TopRight"] = "topRight";
        Alignment["CenterLeft"] = "centerLeft";
        Alignment["CenterRight"] = "centerRight";
        Alignment["BottomLeft"] = "bottomLeft";
        Alignment["BottomCenter"] = "bottomCenter";
        Alignment["BottomRight"] = "bottomRight";
      })(_Alignment || (_Alignment = {}));
      // Alignment options for Rive animations in a HTML canvas
      var _Layout = /** @class */function () {
        function Layout(params) {
          var _a, _b, _c, _d, _e, _f, _g;
          this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : _Fit.Contain;
          this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : _Alignment.Center;
          this.layoutScaleFactor = (_c = params === null || params === void 0 ? void 0 : params.layoutScaleFactor) !== null && _c !== void 0 ? _c : 1;
          this.minX = (_d = params === null || params === void 0 ? void 0 : params.minX) !== null && _d !== void 0 ? _d : 0;
          this.minY = (_e = params === null || params === void 0 ? void 0 : params.minY) !== null && _e !== void 0 ? _e : 0;
          this.maxX = (_f = params === null || params === void 0 ? void 0 : params.maxX) !== null && _f !== void 0 ? _f : 0;
          this.maxY = (_g = params === null || params === void 0 ? void 0 : params.maxY) !== null && _g !== void 0 ? _g : 0;
        }
        // Alternative constructor to build a Layout from an interface/object
        Layout.new = function (_a) {
          var fit = _a.fit,
            alignment = _a.alignment,
            minX = _a.minX,
            minY = _a.minY,
            maxX = _a.maxX,
            maxY = _a.maxY;
          console.warn("This function is deprecated: please use `new Layout({})` instead");
          return new Layout({
            fit: fit,
            alignment: alignment,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY
          });
        };
        /**
         * Makes a copy of the layout, replacing any specified parameters
         */
        Layout.prototype.copyWith = function (_a) {
          var fit = _a.fit,
            alignment = _a.alignment,
            layoutScaleFactor = _a.layoutScaleFactor,
            minX = _a.minX,
            minY = _a.minY,
            maxX = _a.maxX,
            maxY = _a.maxY;
          return new Layout({
            fit: fit !== null && fit !== void 0 ? fit : this.fit,
            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,
            layoutScaleFactor: layoutScaleFactor !== null && layoutScaleFactor !== void 0 ? layoutScaleFactor : this.layoutScaleFactor,
            minX: minX !== null && minX !== void 0 ? minX : this.minX,
            minY: minY !== null && minY !== void 0 ? minY : this.minY,
            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,
            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY
          });
        };
        // Returns fit for the Wasm runtime format
        Layout.prototype.runtimeFit = function (rive) {
          if (this.cachedRuntimeFit) return this.cachedRuntimeFit;
          var fit;
          if (this.fit === _Fit.Cover) fit = rive.Fit.cover;else if (this.fit === _Fit.Contain) fit = rive.Fit.contain;else if (this.fit === _Fit.Fill) fit = rive.Fit.fill;else if (this.fit === _Fit.FitWidth) fit = rive.Fit.fitWidth;else if (this.fit === _Fit.FitHeight) fit = rive.Fit.fitHeight;else if (this.fit === _Fit.ScaleDown) fit = rive.Fit.scaleDown;else if (this.fit === _Fit.Layout) fit = rive.Fit.layout;else fit = rive.Fit.none;
          this.cachedRuntimeFit = fit;
          return fit;
        };
        // Returns alignment for the Wasm runtime format
        Layout.prototype.runtimeAlignment = function (rive) {
          if (this.cachedRuntimeAlignment) return this.cachedRuntimeAlignment;
          var alignment;
          if (this.alignment === _Alignment.TopLeft) alignment = rive.Alignment.topLeft;else if (this.alignment === _Alignment.TopCenter) alignment = rive.Alignment.topCenter;else if (this.alignment === _Alignment.TopRight) alignment = rive.Alignment.topRight;else if (this.alignment === _Alignment.CenterLeft) alignment = rive.Alignment.centerLeft;else if (this.alignment === _Alignment.CenterRight) alignment = rive.Alignment.centerRight;else if (this.alignment === _Alignment.BottomLeft) alignment = rive.Alignment.bottomLeft;else if (this.alignment === _Alignment.BottomCenter) alignment = rive.Alignment.bottomCenter;else if (this.alignment === _Alignment.BottomRight) alignment = rive.Alignment.bottomRight;else alignment = rive.Alignment.center;
          this.cachedRuntimeAlignment = alignment;
          return alignment;
        };
        return Layout;
      }();

      // Runtime singleton; use getInstance to provide a callback that returns the
      // Rive runtime
      var _RuntimeLoader = /** @class */function () {
        // Class is never instantiated
        function RuntimeLoader() {}
        // Loads the runtime
        RuntimeLoader.loadRuntime = function () {
          _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]({
            // Loads Wasm bundle
            locateFile: function locateFile() {
              return RuntimeLoader.wasmURL;
            }
          }).then(function (rive) {
            var _a;
            RuntimeLoader.runtime = rive;
            // Fire all the callbacks
            while (RuntimeLoader.callBackQueue.length > 0) {
              (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);
            }
          }).catch(function (error) {
            // Capture specific error details
            var errorDetails = {
              message: (error === null || error === void 0 ? void 0 : error.message) || "Unknown error",
              type: (error === null || error === void 0 ? void 0 : error.name) || "Error",
              // Some browsers may provide additional WebAssembly-specific details
              wasmError: error instanceof WebAssembly.CompileError || error instanceof WebAssembly.RuntimeError,
              originalError: error
            };
            // Log detailed error for debugging
            console.debug("Rive WASM load error details:", errorDetails);
            // In case unpkg fails, or the wasm was not supported, we try to load the fallback module from jsdelivr.
            // This `rive_fallback.wasm` is compiled to support older architecture.
            // TODO: (Gordon): preemptively test browser support and load the correct wasm file. Then use jsdelvr only if unpkg fails.
            var backupJsdelivrUrl = "https://cdn.jsdelivr.net/npm/".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, "@").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, "/rive_fallback.wasm");
            if (RuntimeLoader.wasmURL.toLowerCase() !== backupJsdelivrUrl) {
              console.warn("Failed to load WASM from ".concat(RuntimeLoader.wasmURL, " (").concat(errorDetails.message, "), trying jsdelivr as a backup"));
              RuntimeLoader.setWasmUrl(backupJsdelivrUrl);
              RuntimeLoader.loadRuntime();
            } else {
              var errorMessage = ["Could not load Rive WASM file from ".concat(RuntimeLoader.wasmURL, " or ").concat(backupJsdelivrUrl, "."), "Possible reasons:", "- Network connection is down", "- WebAssembly is not supported in this environment", "- The WASM file is corrupted or incompatible", "\nError details:", "- Type: ".concat(errorDetails.type), "- Message: ".concat(errorDetails.message), "- WebAssembly-specific error: ".concat(errorDetails.wasmError), "\nTo resolve, you may need to:", "1. Check your network connection", "2. Set a new WASM source via RuntimeLoader.setWasmUrl()", "3. Call RuntimeLoader.loadRuntime() again"].join("\n");
              console.error(errorMessage);
            }
          });
        };
        // Provides a runtime instance via a callback
        RuntimeLoader.getInstance = function (callback) {
          // If it's not loading, start loading runtime
          if (!RuntimeLoader.isLoading) {
            RuntimeLoader.isLoading = true;
            RuntimeLoader.loadRuntime();
          }
          if (!RuntimeLoader.runtime) {
            RuntimeLoader.callBackQueue.push(callback);
          } else {
            callback(RuntimeLoader.runtime);
          }
        };
        // Provides a runtime instance via a promise
        RuntimeLoader.awaitInstance = function () {
          return new Promise(function (resolve) {
            return RuntimeLoader.getInstance(function (rive) {
              return resolve(rive);
            });
          });
        };
        // Manually sets the wasm url
        RuntimeLoader.setWasmUrl = function (url) {
          RuntimeLoader.wasmURL = url;
        };
        // Gets the current wasm url
        RuntimeLoader.getWasmUrl = function () {
          return RuntimeLoader.wasmURL;
        };
        // Flag to indicate that loading has started/completed
        RuntimeLoader.isLoading = false;
        // List of callbacks for the runtime that come in while loading
        RuntimeLoader.callBackQueue = [];
        // Path to the Wasm file; default path works for testing only;
        // if embedded wasm is used then this is never used.
        RuntimeLoader.wasmURL = "https://unpkg.com/".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, "@").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, "/rive.wasm");
        return RuntimeLoader;
      }();

      // #endregion
      // #region state machines
      var _StateMachineInputType;
      (function (StateMachineInputType) {
        StateMachineInputType[StateMachineInputType["Number"] = 56] = "Number";
        StateMachineInputType[StateMachineInputType["Trigger"] = 58] = "Trigger";
        StateMachineInputType[StateMachineInputType["Boolean"] = 59] = "Boolean";
      })(_StateMachineInputType || (_StateMachineInputType = {}));
      /**
       * An input for a state machine
       */
      var _StateMachineInput = /** @class */function () {
        function StateMachineInput(type, runtimeInput) {
          this.type = type;
          this.runtimeInput = runtimeInput;
        }
        Object.defineProperty(StateMachineInput.prototype, "name", {
          /**
           * Returns the name of the input
           */
          get: function get() {
            return this.runtimeInput.name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(StateMachineInput.prototype, "value", {
          /**
           * Returns the current value of the input
           */
          get: function get() {
            return this.runtimeInput.value;
          },
          /**
           * Sets the value of the input
           */
          set: function set(value) {
            this.runtimeInput.value = value;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Fires a trigger; does nothing on Number or Boolean input types
         */
        StateMachineInput.prototype.fire = function () {
          if (this.type === _StateMachineInputType.Trigger) {
            this.runtimeInput.fire();
          }
        };
        /**
         * Deletes the input
         */
        StateMachineInput.prototype.delete = function () {
          this.runtimeInput = null;
        };
        return StateMachineInput;
      }();
      var _RiveEventType;
      (function (RiveEventType) {
        RiveEventType[RiveEventType["General"] = 128] = "General";
        RiveEventType[RiveEventType["OpenUrl"] = 131] = "OpenUrl";
      })(_RiveEventType || (_RiveEventType = {}));
      var StateMachine = /** @class */function () {
        /**
         * @constructor
         * @param stateMachine runtime state machine object
         * @param instance runtime state machine instance object
         */
        function StateMachine(stateMachine, runtime, playing, artboard) {
          this.stateMachine = stateMachine;
          this.playing = playing;
          this.artboard = artboard;
          /**
           * Caches the inputs from the runtime
           */
          this.inputs = [];
          this.instance = new runtime.StateMachineInstance(stateMachine, artboard);
          this.initInputs(runtime);
        }
        Object.defineProperty(StateMachine.prototype, "name", {
          get: function get() {
            return this.stateMachine.name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(StateMachine.prototype, "statesChanged", {
          /**
           * Returns a list of state names that have changed on this frame
           */
          get: function get() {
            var names = [];
            for (var i = 0; i < this.instance.stateChangedCount(); i++) {
              names.push(this.instance.stateChangedNameByIndex(i));
            }
            return names;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Advances the state machine instance by a given time.
         * @param time - the time to advance the animation by in seconds
         */
        StateMachine.prototype.advance = function (time) {
          this.instance.advance(time);
        };
        /**
         * Advances the state machine instance by a given time and apply changes to artboard.
         * @param time - the time to advance the animation by in seconds
         */
        StateMachine.prototype.advanceAndApply = function (time) {
          this.instance.advanceAndApply(time);
        };
        /**
         * Returns the number of events reported from the last advance call
         * @returns Number of events reported
         */
        StateMachine.prototype.reportedEventCount = function () {
          return this.instance.reportedEventCount();
        };
        /**
         * Returns a RiveEvent object emitted from the last advance call at the given index
         * of a list of potentially multiple events. If an event at the index is not found,
         * undefined is returned.
         * @param i index of the event reported in a list of potentially multiple events
         * @returns RiveEvent or extended RiveEvent object returned, or undefined
         */
        StateMachine.prototype.reportedEventAt = function (i) {
          return this.instance.reportedEventAt(i);
        };
        /**
         * Fetches references to the state machine's inputs and caches them
         * @param runtime an instance of the runtime; needed for the SMIInput types
         */
        StateMachine.prototype.initInputs = function (runtime) {
          // Fetch the inputs from the runtime if we don't have them
          for (var i = 0; i < this.instance.inputCount(); i++) {
            var input = this.instance.input(i);
            this.inputs.push(this.mapRuntimeInput(input, runtime));
          }
        };
        /**
         * Maps a runtime input to it's appropriate type
         * @param input
         */
        StateMachine.prototype.mapRuntimeInput = function (input, runtime) {
          if (input.type === runtime.SMIInput.bool) {
            return new _StateMachineInput(_StateMachineInputType.Boolean, input.asBool());
          } else if (input.type === runtime.SMIInput.number) {
            return new _StateMachineInput(_StateMachineInputType.Number, input.asNumber());
          } else if (input.type === runtime.SMIInput.trigger) {
            return new _StateMachineInput(_StateMachineInputType.Trigger, input.asTrigger());
          }
        };
        /**
         * Deletes the backing Wasm state machine instance; once this is called, this
         * state machine is no more.
         */
        StateMachine.prototype.cleanup = function () {
          this.inputs.forEach(function (input) {
            input.delete();
          });
          this.inputs.length = 0;
          this.instance.delete();
        };
        StateMachine.prototype.setDataContextFromInstance = function (viewModelInstance) {
          this.instance.setDataContextFromInstance(viewModelInstance.runtimeInstance);
        };
        return StateMachine;
      }();
      // #endregion
      // #region animator
      /**
       * Manages animation
       */
      var Animator = /** @class */function () {
        /**
         * Constructs a new animator
         * @constructor
         * @param runtime Rive runtime; needed to instance animations & state machines
         * @param artboard the artboard that holds all animations and state machines
         * @param animations optional list of animations
         * @param stateMachines optional list of state machines
         */
        function Animator(runtime, artboard, eventManager, animations, stateMachines) {
          if (animations === void 0) {
            animations = [];
          }
          if (stateMachines === void 0) {
            stateMachines = [];
          }
          this.runtime = runtime;
          this.artboard = artboard;
          this.eventManager = eventManager;
          this.animations = animations;
          this.stateMachines = stateMachines;
        }
        /**
         * Adds animations and state machines by their names. If names are shared
         * between animations & state machines, then the first one found will be
         * created. Best not to use the same names for these in your Rive file.
         * @param animatable the name(s) of animations and state machines to add
         * @returns a list of names of the playing animations and state machines
         */
        Animator.prototype.add = function (animatables, playing, fireEvent) {
          if (fireEvent === void 0) {
            fireEvent = true;
          }
          animatables = mapToStringArray(animatables);
          // If animatables is empty, play or pause everything
          if (animatables.length === 0) {
            this.animations.forEach(function (a) {
              return a.playing = playing;
            });
            this.stateMachines.forEach(function (m) {
              return m.playing = playing;
            });
          } else {
            // Play/pause already instanced items, or create new instances
            var instancedAnimationNames = this.animations.map(function (a) {
              return a.name;
            });
            var instancedMachineNames = this.stateMachines.map(function (m) {
              return m.name;
            });
            for (var i = 0; i < animatables.length; i++) {
              var aIndex = instancedAnimationNames.indexOf(animatables[i]);
              var mIndex = instancedMachineNames.indexOf(animatables[i]);
              if (aIndex >= 0 || mIndex >= 0) {
                if (aIndex >= 0) {
                  // Animation is instanced, play/pause it
                  this.animations[aIndex].playing = playing;
                } else {
                  // State machine is instanced, play/pause it
                  this.stateMachines[mIndex].playing = playing;
                }
              } else {
                // Try to create a new animation instance
                var anim = this.artboard.animationByName(animatables[i]);
                if (anim) {
                  var newAnimation = new _animation__WEBPACK_IMPORTED_MODULE_2__.Animation(anim, this.artboard, this.runtime, playing);
                  // Display the first frame of the specified animation
                  newAnimation.advance(0);
                  newAnimation.apply(1.0);
                  this.animations.push(newAnimation);
                } else {
                  // Try to create a new state machine instance
                  var sm = this.artboard.stateMachineByName(animatables[i]);
                  if (sm) {
                    var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);
                    this.stateMachines.push(newStateMachine);
                  }
                }
              }
            }
          }
          // Fire play/paused events for animations
          if (fireEvent) {
            if (playing) {
              this.eventManager.fire({
                type: _EventType.Play,
                data: this.playing
              });
            } else {
              this.eventManager.fire({
                type: _EventType.Pause,
                data: this.paused
              });
            }
          }
          return playing ? this.playing : this.paused;
        };
        /**
         * Adds linear animations by their names.
         * @param animatables the name(s) of animations to add
         * @param playing whether animations should play on instantiation
         */
        Animator.prototype.initLinearAnimations = function (animatables, playing) {
          // Play/pause already instanced items, or create new instances
          // This validation is kept to maintain compatibility with current behavior.
          // But given that it this is called during artboard initialization
          // it should probably be safe to remove.
          var instancedAnimationNames = this.animations.map(function (a) {
            return a.name;
          });
          for (var i = 0; i < animatables.length; i++) {
            var aIndex = instancedAnimationNames.indexOf(animatables[i]);
            if (aIndex >= 0) {
              this.animations[aIndex].playing = playing;
            } else {
              // Try to create a new animation instance
              var anim = this.artboard.animationByName(animatables[i]);
              if (anim) {
                var newAnimation = new _animation__WEBPACK_IMPORTED_MODULE_2__.Animation(anim, this.artboard, this.runtime, playing);
                // Display the first frame of the specified animation
                newAnimation.advance(0);
                newAnimation.apply(1.0);
                this.animations.push(newAnimation);
              }
            }
          }
        };
        /**
         * Adds state machines by their names.
         * @param animatables the name(s) of state machines to add
         * @param playing whether state machines should play on instantiation
         */
        Animator.prototype.initStateMachines = function (animatables, playing) {
          // Play/pause already instanced items, or create new instances
          // This validation is kept to maintain compatibility with current behavior.
          // But given that it this is called during artboard initialization
          // it should probably be safe to remove.
          var instancedStateMachineNames = this.stateMachines.map(function (a) {
            return a.name;
          });
          for (var i = 0; i < animatables.length; i++) {
            var aIndex = instancedStateMachineNames.indexOf(animatables[i]);
            if (aIndex >= 0) {
              this.stateMachines[aIndex].playing = playing;
            } else {
              // Try to create a new state machine instance
              var sm = this.artboard.stateMachineByName(animatables[i]);
              if (sm) {
                var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);
                this.stateMachines.push(newStateMachine);
              } else {
                // In order to maintain compatibility with current behavior, if a state machine is not found
                // we look for an animation with the same name
                this.initLinearAnimations([animatables[i]], playing);
              }
            }
          }
        };
        /**
         * Play the named animations/state machines
         * @param animatables the names of the animations/machines to play; plays all if empty
         * @returns a list of the playing items
         */
        Animator.prototype.play = function (animatables) {
          return this.add(animatables, true);
        };
        /**
         * Pauses named animations and state machines, or everything if nothing is
         * specified
         * @param animatables names of the animations and state machines to pause
         * @returns a list of names of the animations and state machines paused
         */
        Animator.prototype.pause = function (animatables) {
          return this.add(animatables, false);
        };
        /**
         * Set time of named animations
         * @param animations names of the animations to scrub
         * @param value time scrub value, a floating point number to which the playhead is jumped
         * @returns a list of names of the animations that were scrubbed
         */
        Animator.prototype.scrub = function (animatables, value) {
          var forScrubbing = this.animations.filter(function (a) {
            return animatables.includes(a.name);
          });
          forScrubbing.forEach(function (a) {
            return a.scrubTo = value;
          });
          return forScrubbing.map(function (a) {
            return a.name;
          });
        };
        Object.defineProperty(Animator.prototype, "playing", {
          /**
           * Returns a list of names of all animations and state machines currently
           * playing
           */
          get: function get() {
            return this.animations.filter(function (a) {
              return a.playing;
            }).map(function (a) {
              return a.name;
            }).concat(this.stateMachines.filter(function (m) {
              return m.playing;
            }).map(function (m) {
              return m.name;
            }));
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animator.prototype, "paused", {
          /**
           * Returns a list of names of all animations and state machines currently
           * paused
           */
          get: function get() {
            return this.animations.filter(function (a) {
              return !a.playing;
            }).map(function (a) {
              return a.name;
            }).concat(this.stateMachines.filter(function (m) {
              return !m.playing;
            }).map(function (m) {
              return m.name;
            }));
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Stops and removes all named animations and state machines
         * @param animatables animations and state machines to remove
         * @returns a list of names of removed items
         */
        Animator.prototype.stop = function (animatables) {
          var _this = this;
          animatables = mapToStringArray(animatables);
          // If nothing's specified, wipe them out, all of them
          var removedNames = [];
          // Stop everything
          if (animatables.length === 0) {
            removedNames = this.animations.map(function (a) {
              return a.name;
            }).concat(this.stateMachines.map(function (m) {
              return m.name;
            }));
            // Clean up before emptying the arrays
            this.animations.forEach(function (a) {
              return a.cleanup();
            });
            this.stateMachines.forEach(function (m) {
              return m.cleanup();
            });
            // Empty out the arrays
            this.animations.splice(0, this.animations.length);
            this.stateMachines.splice(0, this.stateMachines.length);
          } else {
            // Remove only the named animations/state machines
            var animationsToRemove = this.animations.filter(function (a) {
              return animatables.includes(a.name);
            });
            animationsToRemove.forEach(function (a) {
              a.cleanup();
              _this.animations.splice(_this.animations.indexOf(a), 1);
            });
            var machinesToRemove = this.stateMachines.filter(function (m) {
              return animatables.includes(m.name);
            });
            machinesToRemove.forEach(function (m) {
              m.cleanup();
              _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);
            });
            removedNames = animationsToRemove.map(function (a) {
              return a.name;
            }).concat(machinesToRemove.map(function (m) {
              return m.name;
            }));
          }
          this.eventManager.fire({
            type: _EventType.Stop,
            data: removedNames
          });
          // Return the list of animations removed
          return removedNames;
        };
        Object.defineProperty(Animator.prototype, "isPlaying", {
          /**
           * Returns true if at least one animation is active
           */
          get: function get() {
            return this.animations.reduce(function (acc, curr) {
              return acc || curr.playing;
            }, false) || this.stateMachines.reduce(function (acc, curr) {
              return acc || curr.playing;
            }, false);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animator.prototype, "isPaused", {
          /**
           * Returns true if all animations are paused and there's at least one animation
           */
          get: function get() {
            return !this.isPlaying && (this.animations.length > 0 || this.stateMachines.length > 0);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Animator.prototype, "isStopped", {
          /**
           * Returns true if there are no playing or paused animations/state machines
           */
          get: function get() {
            return this.animations.length === 0 && this.stateMachines.length === 0;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * If there are no animations or state machines, add the first one found
         * @returns the name of the animation or state machine instanced
         */
        Animator.prototype.atLeastOne = function (playing, fireEvent) {
          if (fireEvent === void 0) {
            fireEvent = true;
          }
          var instancedName;
          if (this.animations.length === 0 && this.stateMachines.length === 0) {
            if (this.artboard.animationCount() > 0) {
              // Add the first animation
              this.add([instancedName = this.artboard.animationByIndex(0).name], playing, fireEvent);
            } else if (this.artboard.stateMachineCount() > 0) {
              // Add the first state machine
              this.add([instancedName = this.artboard.stateMachineByIndex(0).name], playing, fireEvent);
            }
          }
          return instancedName;
        };
        /**
         * Checks if any animations have looped and if so, fire the appropriate event
         */
        Animator.prototype.handleLooping = function () {
          for (var _i = 0, _a = this.animations.filter(function (a) {
              return a.playing;
            }); _i < _a.length; _i++) {
            var animation = _a[_i];
            // Emit if the animation looped
            if (animation.loopValue === 0 && animation.loopCount) {
              animation.loopCount = 0;
              // This is a one-shot; if it has ended, delete the instance
              this.stop(animation.name);
            } else if (animation.loopValue === 1 && animation.loopCount) {
              this.eventManager.fire({
                type: _EventType.Loop,
                data: {
                  animation: animation.name,
                  type: _LoopType.Loop
                }
              });
              animation.loopCount = 0;
            }
            // Wasm indicates a loop at each time the animation
            // changes direction, so a full loop/lap occurs every
            // two loop counts
            else if (animation.loopValue === 2 && animation.loopCount > 1) {
              this.eventManager.fire({
                type: _EventType.Loop,
                data: {
                  animation: animation.name,
                  type: _LoopType.PingPong
                }
              });
              animation.loopCount = 0;
            }
          }
        };
        /**
         * Checks if states have changed in state machines and fires a statechange
         * event
         */
        Animator.prototype.handleStateChanges = function () {
          var statesChanged = [];
          for (var _i = 0, _a = this.stateMachines.filter(function (sm) {
              return sm.playing;
            }); _i < _a.length; _i++) {
            var stateMachine = _a[_i];
            statesChanged.push.apply(statesChanged, stateMachine.statesChanged);
          }
          if (statesChanged.length > 0) {
            this.eventManager.fire({
              type: _EventType.StateChange,
              data: statesChanged
            });
          }
        };
        Animator.prototype.handleAdvancing = function (time) {
          this.eventManager.fire({
            type: _EventType.Advance,
            data: time
          });
        };
        return Animator;
      }();
      // #endregion
      // #region events
      /**
       * Supported event types triggered in Rive
       */
      var _EventType;
      (function (EventType) {
        EventType["Load"] = "load";
        EventType["LoadError"] = "loaderror";
        EventType["Play"] = "play";
        EventType["Pause"] = "pause";
        EventType["Stop"] = "stop";
        EventType["Loop"] = "loop";
        EventType["Draw"] = "draw";
        EventType["Advance"] = "advance";
        EventType["StateChange"] = "statechange";
        EventType["RiveEvent"] = "riveevent";
        EventType["AudioStatusChange"] = "audiostatuschange";
      })(_EventType || (_EventType = {}));
      /**
       * Looping types: one-shot, loop, and ping-pong
       */
      var _LoopType;
      (function (LoopType) {
        LoopType["OneShot"] = "oneshot";
        LoopType["Loop"] = "loop";
        LoopType["PingPong"] = "pingpong";
      })(_LoopType || (_LoopType = {}));
      // Manages Rive events and listeners
      var EventManager = /** @class */function () {
        function EventManager(listeners) {
          if (listeners === void 0) {
            listeners = [];
          }
          this.listeners = listeners;
        }
        // Gets listeners of specified type
        EventManager.prototype.getListeners = function (type) {
          return this.listeners.filter(function (e) {
            return e.type === type;
          });
        };
        // Adds a listener
        EventManager.prototype.add = function (listener) {
          if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
          }
        };
        /**
         * Removes a listener
         * @param listener the listener with the callback to be removed
         */
        EventManager.prototype.remove = function (listener) {
          // We can't simply look for the listener as it'll be a different instance to
          // one originally subscribed. Find all the listeners of the right type and
          // then check their callbacks which should match.
          for (var i = 0; i < this.listeners.length; i++) {
            var currentListener = this.listeners[i];
            if (currentListener.type === listener.type) {
              if (currentListener.callback === listener.callback) {
                this.listeners.splice(i, 1);
                break;
              }
            }
          }
        };
        /**
         * Clears all listeners of specified type, or every listener if no type is
         * specified
         * @param type the type of listeners to clear, or all listeners if not
         * specified
         */
        EventManager.prototype.removeAll = function (type) {
          var _this = this;
          if (!type) {
            this.listeners.splice(0, this.listeners.length);
          } else {
            this.listeners.filter(function (l) {
              return l.type === type;
            }).forEach(function (l) {
              return _this.remove(l);
            });
          }
        };
        // Fires an event
        EventManager.prototype.fire = function (event) {
          var eventListeners = this.getListeners(event.type);
          eventListeners.forEach(function (listener) {
            return listener.callback(event);
          });
        };
        return EventManager;
      }();
      // Manages a queue of tasks
      var TaskQueueManager = /** @class */function () {
        function TaskQueueManager(eventManager) {
          this.eventManager = eventManager;
          this.queue = [];
        }
        // Adds a task top the queue
        TaskQueueManager.prototype.add = function (task) {
          this.queue.push(task);
        };
        // Processes all tasks in the queue
        TaskQueueManager.prototype.process = function () {
          while (this.queue.length > 0) {
            var task = this.queue.shift();
            if (task === null || task === void 0 ? void 0 : task.action) {
              task.action();
            }
            if (task === null || task === void 0 ? void 0 : task.event) {
              this.eventManager.fire(task.event);
            }
          }
        };
        return TaskQueueManager;
      }();
      // #endregion
      // #region Audio
      var SystemAudioStatus;
      (function (SystemAudioStatus) {
        SystemAudioStatus[SystemAudioStatus["AVAILABLE"] = 0] = "AVAILABLE";
        SystemAudioStatus[SystemAudioStatus["UNAVAILABLE"] = 1] = "UNAVAILABLE";
      })(SystemAudioStatus || (SystemAudioStatus = {}));
      // Class to handle audio context availability and status changes
      var AudioManager = /** @class */function (_super) {
        __extends(AudioManager, _super);
        function AudioManager() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._started = false;
          _this._enabled = false;
          _this._status = SystemAudioStatus.UNAVAILABLE;
          return _this;
        }
        AudioManager.prototype.delay = function (time) {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              return [2 /*return*/, new Promise(function (resolve) {
                return setTimeout(resolve, time);
              })];
            });
          });
        };
        AudioManager.prototype.timeout = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              return [2 /*return*/, new Promise(function (_, reject) {
                return setTimeout(reject, 50);
              })];
            });
          });
        };
        // Alerts animations on status changes and removes the listeners to avoid alerting twice.
        AudioManager.prototype.reportToListeners = function () {
          this.fire({
            type: _EventType.AudioStatusChange
          });
          this.removeAll();
        };
        /**
         * The audio context has been resolved.
         * Alert any listeners that we can now play audio.
         * Rive will now play audio at the configured volume.
         */
        AudioManager.prototype.enableAudio = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              if (!this._enabled) {
                this._enabled = true;
                this._status = SystemAudioStatus.AVAILABLE;
                this.reportToListeners();
              }
              return [2 /*return*/];
            });
          });
        };
        /**
         * Check if we are able to play audio.
         *
         * We currently check the audio context, when resume() returns before a timeout we know that the
         * audio context is running and we can enable audio.
         */
        AudioManager.prototype.testAudio = function () {
          return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
              switch (_b.label) {
                case 0:
                  if (!(this._status === SystemAudioStatus.UNAVAILABLE && this._audioContext !== null)) return [3 /*break*/, 4];
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 3,, 4]);
                  return [4 /*yield*/, Promise.race([this._audioContext.resume(), this.timeout()])];
                case 2:
                  _b.sent();
                  this.enableAudio();
                  return [3 /*break*/, 4];
                case 3:
                  _a = _b.sent();
                  return [3 /*break*/, 4];
                case 4:
                  return [2 /*return*/];
              }
            });
          });
        };
        /**
         * Establish audio for use with rive.
         * We both test if we can use audio intermittently and listen for user interaction.
         * The aim is to enable audio playback as soon as the browser allows this.
         */
        AudioManager.prototype._establishAudio = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  if (!!this._started) return [3 /*break*/, 5];
                  this._started = true;
                  if (!(typeof window == "undefined")) return [3 /*break*/, 1];
                  this.enableAudio();
                  return [3 /*break*/, 5];
                case 1:
                  this._audioContext = new AudioContext();
                  this.listenForUserAction();
                  _a.label = 2;
                case 2:
                  if (!(this._status === SystemAudioStatus.UNAVAILABLE)) return [3 /*break*/, 5];
                  return [4 /*yield*/, this.testAudio()];
                case 3:
                  _a.sent();
                  return [4 /*yield*/, this.delay(1000)];
                case 4:
                  _a.sent();
                  return [3 /*break*/, 2];
                case 5:
                  return [2 /*return*/];
              }
            });
          });
        };
        AudioManager.prototype.listenForUserAction = function () {
          var _this = this;
          // NOTE: AudioContexts are ready immediately if requested in a ui callback
          // we *could* re request one in this listener.
          var _clickListener = function _clickListener() {
            return __awaiter(_this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                // note this has "better" results than calling `await this.testAudio()`
                // as we force audio to be enabled in the current thread, rather than chancing
                // the thread to be passed over for some other async context
                this.enableAudio();
                return [2 /*return*/];
              });
            });
          };
          // NOTE: we should test this on mobile/pads
          document.addEventListener("pointerdown", _clickListener, {
            once: true
          });
        };
        /**
         * Establish the audio context for rive, this lets rive know that we can play audio.
         */
        AudioManager.prototype.establishAudio = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              this._establishAudio();
              return [2 /*return*/];
            });
          });
        };
        Object.defineProperty(AudioManager.prototype, "systemVolume", {
          get: function get() {
            if (this._status === SystemAudioStatus.UNAVAILABLE) {
              // We do an immediate test to avoid depending on the delay of the running test
              this.testAudio();
              return 0;
            }
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(AudioManager.prototype, "status", {
          get: function get() {
            return this._status;
          },
          enumerable: false,
          configurable: true
        });
        return AudioManager;
      }(EventManager);
      var audioManager = new AudioManager();
      var FakeResizeObserver = /** @class */function () {
        function FakeResizeObserver() {}
        FakeResizeObserver.prototype.observe = function () {};
        FakeResizeObserver.prototype.unobserve = function () {};
        FakeResizeObserver.prototype.disconnect = function () {};
        return FakeResizeObserver;
      }();
      var MyResizeObserver = globalThis.ResizeObserver || FakeResizeObserver;
      /**
       * This class takes care of any observers that will be attached to an animation.
       * It should be treated as a singleton because observers are much more performant
       * when used for observing multiple elements by a single instance.
       */
      var ObjectObservers = /** @class */function () {
        function ObjectObservers() {
          var _this = this;
          this._elementsMap = new Map();
          /**
           * Resize observers trigger both when the element changes its size and also when the
           * element is added or removed from the document.
           */
          this._onObservedEntry = function (entry) {
            var observed = _this._elementsMap.get(entry.target);
            if (observed !== null) {
              observed.onResize(entry.target.clientWidth == 0 || entry.target.clientHeight == 0);
            } else {
              _this._resizeObserver.unobserve(entry.target);
            }
          };
          this._onObserved = function (entries) {
            entries.forEach(_this._onObservedEntry);
          };
          this._resizeObserver = new MyResizeObserver(this._onObserved);
        }
        // Adds an observable element
        ObjectObservers.prototype.add = function (element, onResize) {
          var observed = {
            onResize: onResize,
            element: element
          };
          this._elementsMap.set(element, observed);
          this._resizeObserver.observe(element);
          return observed;
        };
        // Removes an observable element
        ObjectObservers.prototype.remove = function (observed) {
          this._resizeObserver.unobserve(observed.element);
          this._elementsMap.delete(observed.element);
        };
        return ObjectObservers;
      }();
      var observers = new ObjectObservers();
      var _RiveFile = /** @class */function () {
        function RiveFile(params) {
          // Allow the runtime to automatically load assets hosted in Rive's runtime.
          this.enableRiveAssetCDN = true;
          this.referenceCount = 0;
          this.destroyed = false;
          this.src = params.src;
          this.buffer = params.buffer;
          if (params.assetLoader) this.assetLoader = params.assetLoader;
          this.enableRiveAssetCDN = typeof params.enableRiveAssetCDN == "boolean" ? params.enableRiveAssetCDN : true;
          // New event management system
          this.eventManager = new EventManager();
          if (params.onLoad) this.on(_EventType.Load, params.onLoad);
          if (params.onLoadError) this.on(_EventType.LoadError, params.onLoadError);
        }
        RiveFile.prototype.initData = function () {
          return __awaiter(this, void 0, void 0, function () {
            var _a, loader, _b;
            var _c;
            return __generator(this, function (_d) {
              switch (_d.label) {
                case 0:
                  if (!this.src) return [3 /*break*/, 2];
                  _a = this;
                  return [4 /*yield*/, loadRiveFile(this.src)];
                case 1:
                  _a.buffer = _d.sent();
                  _d.label = 2;
                case 2:
                  if (this.destroyed) {
                    return [2 /*return*/];
                  }
                  if (this.assetLoader) {
                    loader = new this.runtime.CustomFileAssetLoader({
                      loadContents: this.assetLoader
                    });
                  }
                  // Load the Rive file
                  _b = this;
                  return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer), loader, this.enableRiveAssetCDN)];
                case 3:
                  // Load the Rive file
                  _b.file = _d.sent();
                  if (this.destroyed) {
                    (_c = this.file) === null || _c === void 0 ? void 0 : _c.delete();
                    this.file = null;
                    return [2 /*return*/];
                  }
                  if (this.file !== null) {
                    this.eventManager.fire({
                      type: _EventType.Load,
                      data: this
                    });
                  } else {
                    this.eventManager.fire({
                      type: _EventType.LoadError,
                      data: null
                    });
                    throw new Error(RiveFile.fileLoadErrorMessage);
                  }
                  return [2 /*return*/];
              }
            });
          });
        };
        RiveFile.prototype.init = function () {
          return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
              switch (_b.label) {
                case 0:
                  // If no source file url specified, it's a bust
                  if (!this.src && !this.buffer) {
                    throw new Error(RiveFile.missingErrorMessage);
                  }
                  _a = this;
                  return [4 /*yield*/, _RuntimeLoader.awaitInstance()];
                case 1:
                  _a.runtime = _b.sent();
                  if (this.destroyed) {
                    return [2 /*return*/];
                  }
                  return [4 /*yield*/, this.initData()];
                case 2:
                  _b.sent();
                  return [2 /*return*/];
              }
            });
          });
        };
        /**
         * Subscribe to Rive-generated events
         * @param type the type of event to subscribe to
         * @param callback callback to fire when the event occurs
         */
        RiveFile.prototype.on = function (type, callback) {
          this.eventManager.add({
            type: type,
            callback: callback
          });
        };
        /**
         * Unsubscribes from a Rive-generated event
         * @param type the type of event to unsubscribe from
         * @param callback the callback to unsubscribe
         */
        RiveFile.prototype.off = function (type, callback) {
          this.eventManager.remove({
            type: type,
            callback: callback
          });
        };
        RiveFile.prototype.cleanup = function () {
          var _a;
          this.referenceCount -= 1;
          if (this.referenceCount <= 0) {
            this.removeAllRiveEventListeners();
            (_a = this.file) === null || _a === void 0 ? void 0 : _a.delete();
            this.file = null;
            this.destroyed = true;
          }
        };
        /**
         * Unsubscribes all Rive listeners from an event type, or everything if no type is
         * given
         * @param type the type of event to unsubscribe from, or all types if
         * undefined
         */
        RiveFile.prototype.removeAllRiveEventListeners = function (type) {
          this.eventManager.removeAll(type);
        };
        RiveFile.prototype.getInstance = function () {
          if (this.file !== null) {
            this.referenceCount += 1;
            return this.file;
          }
        };
        // Error message for missing source or buffer
        RiveFile.missingErrorMessage = "Rive source file or data buffer required";
        // Error message for file load error
        RiveFile.fileLoadErrorMessage = "The file failed to load";
        return RiveFile;
      }();
      var _Rive = /** @class */function () {
        function Rive(params) {
          var _this = this;
          var _a;
          // Tracks if a Rive file is loaded
          this.loaded = false;
          // Reference of an object that handles any observers for the animation
          this._observed = null;
          // Stores a custom device pixel ratio set by the user
          this._customDevicePixelRatio = 0;
          /**
           * Tracks if a Rive file is loaded; we need this in addition to loaded as some
           * commands (e.g. contents) can be called as soon as the file is loaded.
           * However, playback commands need to be queued and run in order once initial
           * animations and autoplay has been sorted out. This applies to play, pause,
           * and start.
           */
          this.readyForPlaying = false;
          // Runtime artboard
          this.artboard = null;
          // place to clear up event listeners
          this.eventCleanup = null;
          this.shouldDisableRiveListeners = false;
          this.automaticallyHandleEvents = false;
          // Allow the runtime to automatically load assets hosted in Rive's runtime.
          this.enableRiveAssetCDN = true;
          // Keep a local value of the set volume to update it asynchronously
          this._volume = 1;
          // Keep a local value of the set width to update it asynchronously
          this._artboardWidth = undefined;
          // Keep a local value of the set height to update it asynchronously
          this._artboardHeight = undefined;
          // Keep a local value of the device pixel ratio used in rendering and canvas/artboard resizing
          this._devicePixelRatioUsed = 1;
          // Whether the canvas element's size is 0
          this._hasZeroSize = false;
          // Audio event listener
          this._audioEventListener = null;
          // draw method bound to the class
          this._boundDraw = null;
          this._viewModelInstance = null;
          this._dataEnums = null;
          // Durations to generate a frame for the last second. Used for performance profiling.
          this.durations = [];
          this.frameTimes = [];
          this.frameCount = 0;
          this.isTouchScrollEnabled = false;
          this.onCanvasResize = function (hasZeroSize) {
            _this._hasZeroSize = hasZeroSize;
            if (!hasZeroSize) {
              _this.resizeDrawingSurfaceToCanvas();
            } else if (!_this._layout.maxX || !_this._layout.maxY) {
              _this.resizeToCanvas();
            }
          };
          /**
           * Used be draw to track when a second of active rendering time has passed.
           * Used for debugging purposes
           */
          this.renderSecondTimer = 0;
          this._boundDraw = this.draw.bind(this);
          this.canvas = params.canvas;
          if (params.canvas.constructor === HTMLCanvasElement) {
            this._observed = observers.add(this.canvas, this.onCanvasResize);
          }
          this.src = params.src;
          this.buffer = params.buffer;
          this.riveFile = params.riveFile;
          this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new _Layout();
          this.shouldDisableRiveListeners = !!params.shouldDisableRiveListeners;
          this.isTouchScrollEnabled = !!params.isTouchScrollEnabled;
          this.automaticallyHandleEvents = !!params.automaticallyHandleEvents;
          this.enableRiveAssetCDN = params.enableRiveAssetCDN === undefined ? true : params.enableRiveAssetCDN;
          // New event management system
          this.eventManager = new EventManager();
          if (params.onLoad) this.on(_EventType.Load, params.onLoad);
          if (params.onLoadError) this.on(_EventType.LoadError, params.onLoadError);
          if (params.onPlay) this.on(_EventType.Play, params.onPlay);
          if (params.onPause) this.on(_EventType.Pause, params.onPause);
          if (params.onStop) this.on(_EventType.Stop, params.onStop);
          if (params.onLoop) this.on(_EventType.Loop, params.onLoop);
          if (params.onStateChange) this.on(_EventType.StateChange, params.onStateChange);
          if (params.onAdvance) this.on(_EventType.Advance, params.onAdvance);
          /**
           * @deprecated Use camelCase'd versions instead.
           */
          if (params.onload && !params.onLoad) this.on(_EventType.Load, params.onload);
          if (params.onloaderror && !params.onLoadError) this.on(_EventType.LoadError, params.onloaderror);
          if (params.onplay && !params.onPlay) this.on(_EventType.Play, params.onplay);
          if (params.onpause && !params.onPause) this.on(_EventType.Pause, params.onpause);
          if (params.onstop && !params.onStop) this.on(_EventType.Stop, params.onstop);
          if (params.onloop && !params.onLoop) this.on(_EventType.Loop, params.onloop);
          if (params.onstatechange && !params.onStateChange) this.on(_EventType.StateChange, params.onstatechange);
          /**
           * Asset loading
           */
          if (params.assetLoader) this.assetLoader = params.assetLoader;
          // Hook up the task queue
          this.taskQueue = new TaskQueueManager(this.eventManager);
          this.init({
            src: this.src,
            buffer: this.buffer,
            riveFile: this.riveFile,
            autoplay: params.autoplay,
            autoBind: params.autoBind,
            animations: params.animations,
            stateMachines: params.stateMachines,
            artboard: params.artboard,
            useOffscreenRenderer: params.useOffscreenRenderer
          });
        }
        // Alternative constructor to build a Rive instance from an interface/object
        Rive.new = function (params) {
          console.warn("This function is deprecated: please use `new Rive({})` instead");
          return new Rive(params);
        };
        // Event handler for when audio context becomes available
        Rive.prototype.onSystemAudioChanged = function () {
          this.volume = this._volume;
        };
        // Initializes the Rive object either from constructor or load()
        Rive.prototype.init = function (_a) {
          var _this = this;
          var src = _a.src,
            buffer = _a.buffer,
            riveFile = _a.riveFile,
            animations = _a.animations,
            stateMachines = _a.stateMachines,
            artboard = _a.artboard,
            _b = _a.autoplay,
            autoplay = _b === void 0 ? false : _b,
            _c = _a.useOffscreenRenderer,
            useOffscreenRenderer = _c === void 0 ? false : _c,
            _d = _a.autoBind,
            autoBind = _d === void 0 ? false : _d;
          this.src = src;
          this.buffer = buffer;
          this.riveFile = riveFile;
          // If no source file url specified, it's a bust
          if (!this.src && !this.buffer && !this.riveFile) {
            throw new Error(Rive.missingErrorMessage);
          }
          // List of animations that should be initialized.
          var startingAnimationNames = mapToStringArray(animations);
          // List of state machines that should be initialized
          var startingStateMachineNames = mapToStringArray(stateMachines);
          // Ensure loaded is marked as false if loading new file
          this.loaded = false;
          this.readyForPlaying = false;
          // Ensure the runtime is loaded
          _RuntimeLoader.awaitInstance().then(function (runtime) {
            _this.runtime = runtime;
            _this.removeRiveListeners();
            _this.deleteRiveRenderer();
            // Get the canvas where you want to render the animation and create a renderer
            _this.renderer = _this.runtime.makeRenderer(_this.canvas, useOffscreenRenderer);
            // Initial size adjustment based on devicePixelRatio if no width/height are
            // specified explicitly
            if (!(_this.canvas.width || _this.canvas.height)) {
              _this.resizeDrawingSurfaceToCanvas();
            }
            // Load Rive data from a source uri or a data buffer
            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay, autoBind).then(function () {
              return _this.setupRiveListeners();
            }).catch(function (e) {
              console.error(e);
            });
          }).catch(function (e) {
            console.error(e);
          });
        };
        /**
         * Setup Rive Listeners on the canvas
         * @param riveListenerOptions - Enables TouchEvent events on the canvas. Set to true to allow
         * touch scrolling on the canvas element on touch-enabled devices
         * i.e. { isTouchScrollEnabled: true }
         */
        Rive.prototype.setupRiveListeners = function (riveListenerOptions) {
          var _this = this;
          if (this.eventCleanup) {
            this.eventCleanup();
          }
          if (!this.shouldDisableRiveListeners) {
            var activeStateMachines = (this.animator.stateMachines || []).filter(function (sm) {
              return sm.playing && _this.runtime.hasListeners(sm.instance);
            }).map(function (sm) {
              return sm.instance;
            });
            var touchScrollEnabledOption = this.isTouchScrollEnabled;
            if (riveListenerOptions && "isTouchScrollEnabled" in riveListenerOptions) {
              touchScrollEnabledOption = riveListenerOptions.isTouchScrollEnabled;
            }
            this.eventCleanup = (0, _utils__WEBPACK_IMPORTED_MODULE_3__.registerTouchInteractions)({
              canvas: this.canvas,
              artboard: this.artboard,
              stateMachines: activeStateMachines,
              renderer: this.renderer,
              rive: this.runtime,
              fit: this._layout.runtimeFit(this.runtime),
              alignment: this._layout.runtimeAlignment(this.runtime),
              isTouchScrollEnabled: touchScrollEnabledOption,
              layoutScaleFactor: this._layout.layoutScaleFactor
            });
          }
        };
        /**
         * Remove Rive Listeners setup on the canvas
         */
        Rive.prototype.removeRiveListeners = function () {
          if (this.eventCleanup) {
            this.eventCleanup();
            this.eventCleanup = null;
          }
        };
        /**
         * If the instance has audio and the system audio is not ready
         * we hook the instance to the audio manager
         */
        Rive.prototype.initializeAudio = function () {
          var _this = this;
          var _a;
          // Initialize audio if needed
          if (audioManager.status == SystemAudioStatus.UNAVAILABLE) {
            if (((_a = this.artboard) === null || _a === void 0 ? void 0 : _a.hasAudio) && this._audioEventListener === null) {
              this._audioEventListener = {
                type: _EventType.AudioStatusChange,
                callback: function callback() {
                  return _this.onSystemAudioChanged();
                }
              };
              audioManager.add(this._audioEventListener);
              audioManager.establishAudio();
            }
          }
        };
        Rive.prototype.initArtboardSize = function () {
          if (!this.artboard) return;
          // Use preset values if they are not undefined
          this._artboardWidth = this.artboard.width = this._artboardWidth || this.artboard.width;
          this._artboardHeight = this.artboard.height = this._artboardHeight || this.artboard.height;
        };
        // Initializes runtime with Rive data and preps for playing
        Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay, autoBind) {
          return __awaiter(this, void 0, void 0, function () {
            var error_1, msg;
            var _a;
            return __generator(this, function (_b) {
              switch (_b.label) {
                case 0:
                  _b.trys.push([0, 3,, 4]);
                  if (!(this.riveFile == null)) return [3 /*break*/, 2];
                  this.riveFile = new _RiveFile({
                    src: this.src,
                    buffer: this.buffer,
                    enableRiveAssetCDN: this.enableRiveAssetCDN,
                    assetLoader: this.assetLoader
                  });
                  return [4 /*yield*/, this.riveFile.init()];
                case 1:
                  _b.sent();
                  _b.label = 2;
                case 2:
                  // Check for riveFile in case it has been cleaned up while initializing;
                  if (!this.riveFile) {
                    throw new RiveError(Rive.cleanupErrorMessage);
                  }
                  this.file = this.riveFile.getInstance();
                  // Initialize and draw frame
                  this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay, autoBind);
                  // Initialize the artboard size
                  this.initArtboardSize();
                  // Check for audio
                  this.initializeAudio();
                  // Everything's set up, emit a load event
                  this.loaded = true;
                  this.eventManager.fire({
                    type: _EventType.Load,
                    data: (_a = this.src) !== null && _a !== void 0 ? _a : "buffer"
                  });
                  // Flag ready for playback commands and clear the task queue; this order
                  // is important or it may infinitely recurse
                  this.readyForPlaying = true;
                  this.taskQueue.process();
                  this.drawFrame();
                  return [2 /*return*/, Promise.resolve()];
                case 3:
                  error_1 = _b.sent();
                  msg = resolveErrorMessage(error_1);
                  console.warn(msg);
                  this.eventManager.fire({
                    type: _EventType.LoadError,
                    data: msg
                  });
                  return [2 /*return*/, Promise.reject(msg)];
                case 4:
                  return [2 /*return*/];
              }
            });
          });
        };
        // Initialize for playback
        Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay, autoBind) {
          if (!this.file) {
            return;
          }
          // Fetch the artboard
          var rootArtboard = artboardName ? this.file.artboardByName(artboardName) : this.file.defaultArtboard();
          // Check we have a working artboard
          if (!rootArtboard) {
            var msg = "Invalid artboard name or no default artboard";
            console.warn(msg);
            this.eventManager.fire({
              type: _EventType.LoadError,
              data: msg
            });
            return;
          }
          this.artboard = rootArtboard;
          rootArtboard.volume = this._volume * audioManager.systemVolume;
          // Check that the artboard has at least 1 animation
          if (this.artboard.animationCount() < 1) {
            var msg = "Artboard has no animations";
            this.eventManager.fire({
              type: _EventType.LoadError,
              data: msg
            });
            throw msg;
          }
          // Initialize the animator
          this.animator = new Animator(this.runtime, this.artboard, this.eventManager);
          // Initialize the animations; as loaded hasn't happened yet, we need to
          // suppress firing the play/pause events until the load event has fired. To
          // do this we tell the animator to suppress firing events, and add event
          // firing to the task queue.
          var instanceNames;
          if (animationNames.length > 0 || stateMachineNames.length > 0) {
            instanceNames = animationNames.concat(stateMachineNames);
            this.animator.initLinearAnimations(animationNames, autoplay);
            this.animator.initStateMachines(stateMachineNames, autoplay);
          } else {
            instanceNames = [this.animator.atLeastOne(autoplay, false)];
          }
          // Queue up firing the playback events
          this.taskQueue.add({
            event: {
              type: autoplay ? _EventType.Play : _EventType.Pause,
              data: instanceNames
            }
          });
          if (autoBind) {
            var viewModel = this.file.defaultArtboardViewModel(rootArtboard);
            if (viewModel !== null) {
              var runtimeInstance = viewModel.defaultInstance();
              if (runtimeInstance !== null) {
                var viewModelInstance = new _ViewModelInstance(runtimeInstance, null);
                this.setDataContextFromInstance(viewModelInstance);
              }
            }
          }
        };
        // Draws the current artboard frame
        Rive.prototype.drawFrame = function () {
          var _a;
          if ((_a = document === null || document === void 0 ? void 0 : document.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) {
            if (this.loaded && this.artboard && !this.frameRequestId) {
              this._boundDraw(document.timeline.currentTime);
            }
          } else {
            this.startRendering();
          }
        };
        /**
         * Draw rendering loop; renders animation frames at the correct time interval.
         * @param time the time at which to render a frame
         */
        Rive.prototype.draw = function (time, onSecond) {
          var _a;
          // Clear the frameRequestId, as we're now rendering a fresh frame
          this.frameRequestId = null;
          var before = performance.now();
          // On the first pass, make sure lastTime has a valid value
          if (!this.lastRenderTime) {
            this.lastRenderTime = time;
          }
          // Handle the onSecond callback
          this.renderSecondTimer += time - this.lastRenderTime;
          if (this.renderSecondTimer > 5000) {
            this.renderSecondTimer = 0;
            onSecond === null || onSecond === void 0 ? void 0 : onSecond();
          }
          // Calculate the elapsed time between frames in seconds
          var elapsedTime = (time - this.lastRenderTime) / 1000;
          this.lastRenderTime = time;
          // - Advance non-paused animations by the elapsed number of seconds
          // - Advance any animations that require scrubbing
          // - Advance to the first frame even when autoplay is false
          var activeAnimations = this.animator.animations.filter(function (a) {
            return a.playing || a.needsScrub;
          })
          // The scrubbed animations must be applied first to prevent weird artifacts
          // if the playing animations conflict with the scrubbed animating attribuates.
          .sort(function (first) {
            return first.needsScrub ? -1 : 1;
          });
          for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {
            var animation = activeAnimations_1[_i];
            animation.advance(elapsedTime);
            if (animation.instance.didLoop) {
              animation.loopCount += 1;
            }
            animation.apply(1.0);
          }
          // - Advance non-paused state machines by the elapsed number of seconds
          // - Advance to the first frame even when autoplay is false
          var activeStateMachines = this.animator.stateMachines.filter(function (a) {
            return a.playing;
          });
          for (var _b = 0, activeStateMachines_1 = activeStateMachines; _b < activeStateMachines_1.length; _b++) {
            var stateMachine = activeStateMachines_1[_b];
            // Check for events before the current frame's state machine advance
            var numEventsReported = stateMachine.reportedEventCount();
            if (numEventsReported) {
              for (var i = 0; i < numEventsReported; i++) {
                var event_1 = stateMachine.reportedEventAt(i);
                if (event_1) {
                  if (event_1.type === _RiveEventType.OpenUrl) {
                    this.eventManager.fire({
                      type: _EventType.RiveEvent,
                      data: event_1
                    });
                    // Handle the event side effect if explicitly enabled
                    if (this.automaticallyHandleEvents) {
                      var newAnchorTag = document.createElement("a");
                      var _c = event_1,
                        url = _c.url,
                        target = _c.target;
                      var sanitizedUrl = (0, _utils__WEBPACK_IMPORTED_MODULE_3__.sanitizeUrl)(url);
                      url && newAnchorTag.setAttribute("href", sanitizedUrl);
                      target && newAnchorTag.setAttribute("target", target);
                      if (sanitizedUrl && sanitizedUrl !== _utils__WEBPACK_IMPORTED_MODULE_3__.BLANK_URL) {
                        newAnchorTag.click();
                      }
                    }
                  } else {
                    this.eventManager.fire({
                      type: _EventType.RiveEvent,
                      data: event_1
                    });
                  }
                }
              }
            }
            stateMachine.advanceAndApply(elapsedTime);
            // stateMachine.instance.apply(this.artboard);
          }
          // Once the animations have been applied to the artboard, advance it
          // by the elapsed time.
          if (this.animator.stateMachines.length == 0) {
            this.artboard.advance(elapsedTime);
          }
          var renderer = this.renderer;
          // Canvas must be wiped to prevent artifacts
          renderer.clear();
          renderer.save();
          // Update the renderer alignment if necessary
          this.alignRenderer();
          // Do not draw on 0 canvas size
          if (!this._hasZeroSize) {
            this.artboard.draw(renderer);
          }
          renderer.restore();
          renderer.flush();
          // Check for any animations that looped
          this.animator.handleLooping();
          // Check for any state machines that had a state change
          this.animator.handleStateChanges();
          // Report advanced time
          this.animator.handleAdvancing(elapsedTime);
          // Add duration to create frame to durations array
          this.frameCount++;
          var after = performance.now();
          this.frameTimes.push(after);
          this.durations.push(after - before);
          while (this.frameTimes[0] <= after - 1000) {
            this.frameTimes.shift();
            this.durations.shift();
          }
          (_a = this._viewModelInstance) === null || _a === void 0 ? void 0 : _a.handleCallbacks();
          // Calling requestAnimationFrame will rerun draw() at the correct rate:
          // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations
          if (this.animator.isPlaying) {
            // Request a new rendering frame
            this.startRendering();
          } else if (this.animator.isPaused) {
            // Reset the end time so on playback it starts at the correct frame
            this.lastRenderTime = 0;
          } else if (this.animator.isStopped) {
            // Reset animation instances, artboard and time
            // TODO: implement this properly when we have instancing
            // this.initArtboard();
            // this.drawFrame();
            this.lastRenderTime = 0;
          }
        };
        /**
         * Align the renderer
         */
        Rive.prototype.alignRenderer = function () {
          var _a = this,
            renderer = _a.renderer,
            runtime = _a.runtime,
            _layout = _a._layout,
            artboard = _a.artboard;
          // Align things up safe in the knowledge we can restore if changed
          renderer.align(_layout.runtimeFit(runtime), _layout.runtimeAlignment(runtime), {
            minX: _layout.minX,
            minY: _layout.minY,
            maxX: _layout.maxX,
            maxY: _layout.maxY
          }, artboard.bounds, this._devicePixelRatioUsed * _layout.layoutScaleFactor);
        };
        Object.defineProperty(Rive.prototype, "fps", {
          get: function get() {
            return this.durations.length;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "frameTime", {
          get: function get() {
            if (this.durations.length === 0) {
              return 0;
            }
            return (this.durations.reduce(function (a, b) {
              return a + b;
            }, 0) / this.durations.length).toFixed(4);
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Cleans up all Wasm-generated objects that need to be manually destroyed:
         * artboard instances, animation instances, state machine instances,
         * renderer instance, file and runtime.
         *
         * Once this is called, you will need to initialise a new instance of the
         * Rive class
         */
        Rive.prototype.cleanup = function () {
          var _a, _b;
          // Stop the renderer if it hasn't already been stopped.
          this.stopRendering();
          // Clean up any artboard, animation or state machine instances.
          this.cleanupInstances();
          // Remove from observer
          if (this._observed !== null) {
            observers.remove(this._observed);
          }
          this.removeRiveListeners();
          (_a = this.riveFile) === null || _a === void 0 ? void 0 : _a.cleanup();
          this.riveFile = null;
          this.file = null;
          this.deleteRiveRenderer();
          if (this._audioEventListener !== null) {
            audioManager.remove(this._audioEventListener);
            this._audioEventListener = null;
          }
          (_b = this._viewModelInstance) === null || _b === void 0 ? void 0 : _b.cleanup();
          this._viewModelInstance = null;
          if (this._dataEnums != null) {
            this._dataEnums = null;
          }
        };
        /**
         * Cleans up the Renderer object. Only call this API if you no longer
         * need to render Rive content in your session.
         */
        Rive.prototype.deleteRiveRenderer = function () {
          var _a;
          (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.delete();
          this.renderer = null;
        };
        /**
         * Cleans up any Wasm-generated objects that need to be manually destroyed:
         * artboard instances, animation instances, state machine instances.
         *
         * Once this is called, things will need to be reinitialized or bad things
         * might happen.
         */
        Rive.prototype.cleanupInstances = function () {
          if (this.eventCleanup !== null) {
            this.eventCleanup();
          }
          // Delete all animation and state machine instances
          this.stop();
          if (this.artboard) {
            this.artboard.delete();
            this.artboard = null;
          }
        };
        /**
         * Tries to query the setup Artboard for a text run node with the given name.
         *
         * @param textRunName - Name of the text run node associated with a text object
         * @returns - TextValueRun node or undefined if the text run cannot be queried
         */
        Rive.prototype.retrieveTextRun = function (textRunName) {
          var _a;
          if (!textRunName) {
            console.warn("No text run name provided");
            return;
          }
          if (!this.artboard) {
            console.warn("Tried to access text run, but the Artboard is null");
            return;
          }
          var textRun = this.artboard.textRun(textRunName);
          if (!textRun) {
            console.warn("Could not access a text run with name '".concat(textRunName, "' in the '").concat((_a = this.artboard) === null || _a === void 0 ? void 0 : _a.name, "' Artboard. Note that you must rename a text run node in the Rive editor to make it queryable at runtime."));
            return;
          }
          return textRun;
        };
        /**
         * Returns a string from a given text run node name, or undefined if the text run
         * cannot be queried.
         *
         * @param textRunName - Name of the text run node associated with a text object
         * @returns - String value of the text run node or undefined
         */
        Rive.prototype.getTextRunValue = function (textRunName) {
          var textRun = this.retrieveTextRun(textRunName);
          return textRun ? textRun.text : undefined;
        };
        /**
         * Sets a text value for a given text run node name if possible
         *
         * @param textRunName - Name of the text run node associated with a text object
         * @param textRunValue - String value to set on the text run node
         */
        Rive.prototype.setTextRunValue = function (textRunName, textRunValue) {
          var textRun = this.retrieveTextRun(textRunName);
          if (textRun) {
            textRun.text = textRunValue;
          }
        };
        // Plays specified animations; if none specified, it unpauses everything.
        Rive.prototype.play = function (animationNames, autoplay) {
          var _this = this;
          animationNames = mapToStringArray(animationNames);
          // If the file's not loaded, queue up the play
          if (!this.readyForPlaying) {
            this.taskQueue.add({
              action: function action() {
                return _this.play(animationNames, autoplay);
              }
            });
            return;
          }
          this.animator.play(animationNames);
          if (this.eventCleanup) {
            this.eventCleanup();
          }
          this.setupRiveListeners();
          this.startRendering();
        };
        // Pauses specified animations; if none specified, pauses all.
        Rive.prototype.pause = function (animationNames) {
          var _this = this;
          animationNames = mapToStringArray(animationNames);
          // If the file's not loaded, early out, nothing to pause
          if (!this.readyForPlaying) {
            this.taskQueue.add({
              action: function action() {
                return _this.pause(animationNames);
              }
            });
            return;
          }
          if (this.eventCleanup) {
            this.eventCleanup();
          }
          this.animator.pause(animationNames);
        };
        Rive.prototype.scrub = function (animationNames, value) {
          var _this = this;
          animationNames = mapToStringArray(animationNames);
          // If the file's not loaded, early out, nothing to pause
          if (!this.readyForPlaying) {
            this.taskQueue.add({
              action: function action() {
                return _this.scrub(animationNames, value);
              }
            });
            return;
          }
          // Scrub the animation time; we draw a single frame here so that if
          // nothing's currently playing, the scrubbed animation is still rendered/
          this.animator.scrub(animationNames, value || 0);
          this.drawFrame();
        };
        // Stops specified animations; if none specifies, stops them all.
        Rive.prototype.stop = function (animationNames) {
          var _this = this;
          animationNames = mapToStringArray(animationNames);
          // If the file's not loaded, early out, nothing to pause
          if (!this.readyForPlaying) {
            this.taskQueue.add({
              action: function action() {
                return _this.stop(animationNames);
              }
            });
            return;
          }
          this.animator.stop(animationNames);
          if (this.eventCleanup) {
            this.eventCleanup();
          }
        };
        /**
         * Resets the animation
         * @param artboard the name of the artboard, or default if none given
         * @param animations the names of animations for playback
         * @param stateMachines the names of state machines for playback
         * @param autoplay whether to autoplay when reset, defaults to false
         *
         */
        Rive.prototype.reset = function (params) {
          var _a, _b;
          // Get the current artboard, animations, state machines, and playback states
          var artBoardName = params === null || params === void 0 ? void 0 : params.artboard;
          var animationNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.animations);
          var stateMachineNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.stateMachines);
          var autoplay = (_a = params === null || params === void 0 ? void 0 : params.autoplay) !== null && _a !== void 0 ? _a : false;
          var autoBind = (_b = params === null || params === void 0 ? void 0 : params.autoBind) !== null && _b !== void 0 ? _b : false;
          // Stop everything and clean up
          this.cleanupInstances();
          // Reinitialize an artboard instance with the state
          this.initArtboard(artBoardName, animationNames, stateMachineNames, autoplay, autoBind);
          this.taskQueue.process();
        };
        // Loads a new Rive file, keeping listeners in place
        Rive.prototype.load = function (params) {
          this.file = null;
          // Stop all animations
          this.stop();
          // Reinitialize
          this.init(params);
        };
        Object.defineProperty(Rive.prototype, "layout", {
          /**
           * Returns the current layout. Note that layout should be treated as
           * immutable. If you want to change the layout, create a new one use the
           * layout setter
           */
          get: function get() {
            return this._layout;
          },
          // Sets a new layout
          set: function set(layout) {
            this._layout = layout;
            // If the maxX or maxY are 0, then set them to the canvas width and height
            if (!layout.maxX || !layout.maxY) {
              this.resizeToCanvas();
            }
            if (this.loaded && !this.animator.isPlaying) {
              this.drawFrame();
            }
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Sets the layout bounds to the current canvas size; this is typically called
         * when the canvas is resized
         */
        Rive.prototype.resizeToCanvas = function () {
          this._layout = this.layout.copyWith({
            minX: 0,
            minY: 0,
            maxX: this.canvas.width,
            maxY: this.canvas.height
          });
        };
        /**
         * Accounts for devicePixelRatio as a multiplier to render the size of the canvas drawing surface.
         * Uses the size of the backing canvas to set new width/height attributes. Need to re-render
         * and resize the layout to match the new drawing surface afterwards.
         * Useful function for consumers to include in a window resize listener.
         *
         * This method will set the {@link devicePixelRatioUsed} property.
         *
         * Optionally, you can provide a {@link customDevicePixelRatio} to provide a
         * custom value.
         */
        Rive.prototype.resizeDrawingSurfaceToCanvas = function (customDevicePixelRatio) {
          if (this.canvas instanceof HTMLCanvasElement && !!window) {
            if (!isNaN(customDevicePixelRatio)) {
              this._customDevicePixelRatio = customDevicePixelRatio;
            }
            var _a = this.canvas.getBoundingClientRect(),
              width = _a.width,
              height = _a.height;
            var dpr = this._customDevicePixelRatio || window.devicePixelRatio || 1;
            this.devicePixelRatioUsed = dpr;
            this.canvas.width = dpr * width;
            this.canvas.height = dpr * height;
            this.resizeToCanvas();
            this.drawFrame();
            if (this.layout.fit === _Fit.Layout) {
              var scaleFactor = this._layout.layoutScaleFactor;
              this.artboard.width = width / scaleFactor;
              this.artboard.height = height / scaleFactor;
            }
          }
        };
        Object.defineProperty(Rive.prototype, "source", {
          // Returns the animation source, which may be undefined
          get: function get() {
            return this.src;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "activeArtboard", {
          /**
           * Returns the name of the active artboard
           */
          get: function get() {
            return this.artboard ? this.artboard.name : "";
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "animationNames", {
          // Returns a list of animation names on the chosen artboard
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded || !this.artboard) {
              return [];
            }
            var animationNames = [];
            for (var i = 0; i < this.artboard.animationCount(); i++) {
              animationNames.push(this.artboard.animationByIndex(i).name);
            }
            return animationNames;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "stateMachineNames", {
          /**
           * Returns a list of state machine names from the current artboard
           */
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded || !this.artboard) {
              return [];
            }
            var stateMachineNames = [];
            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {
              stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);
            }
            return stateMachineNames;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Returns the inputs for the specified instanced state machine, or an empty
         * list if the name is invalid or the state machine is not instanced
         * @param name the state machine name
         * @returns the inputs for the named state machine
         */
        Rive.prototype.stateMachineInputs = function (name) {
          // If the file's not loaded, early out, nothing to pause
          if (!this.loaded) {
            return;
          }
          var stateMachine = this.animator.stateMachines.find(function (m) {
            return m.name === name;
          });
          return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;
        };
        // Returns the input with the provided name at the given path
        Rive.prototype.retrieveInputAtPath = function (name, path) {
          if (!name) {
            console.warn("No input name provided for path '".concat(path, "'"));
            return;
          }
          if (!this.artboard) {
            console.warn("Tried to access input: '".concat(name, "', at path: '").concat(path, "', but the Artboard is null"));
            return;
          }
          var input = this.artboard.inputByPath(name, path);
          if (!input) {
            console.warn("Could not access an input with name: '".concat(name, "', at path:'").concat(path, "'"));
            return;
          }
          return input;
        };
        /**
         * Set the boolean input with the provided name at the given path with value
         * @param input the state machine input name
         * @param value the value to set the input to
         * @param path the path the input is located at an artboard level
         */
        Rive.prototype.setBooleanStateAtPath = function (inputName, value, path) {
          var input = this.retrieveInputAtPath(inputName, path);
          if (!input) return;
          if (input.type === _StateMachineInputType.Boolean) {
            input.asBool().value = value;
          } else {
            console.warn("Input with name: '".concat(inputName, "', at path:'").concat(path, "' is not a boolean"));
          }
        };
        /**
         * Set the number input with the provided name at the given path with value
         * @param input the state machine input name
         * @param value the value to set the input to
         * @param path the path the input is located at an artboard level
         */
        Rive.prototype.setNumberStateAtPath = function (inputName, value, path) {
          var input = this.retrieveInputAtPath(inputName, path);
          if (!input) return;
          if (input.type === _StateMachineInputType.Number) {
            input.asNumber().value = value;
          } else {
            console.warn("Input with name: '".concat(inputName, "', at path:'").concat(path, "' is not a number"));
          }
        };
        /**
         * Fire the trigger with the provided name at the given path
         * @param input the state machine input name
         * @param path the path the input is located at an artboard level
         */
        Rive.prototype.fireStateAtPath = function (inputName, path) {
          var input = this.retrieveInputAtPath(inputName, path);
          if (!input) return;
          if (input.type === _StateMachineInputType.Trigger) {
            input.asTrigger().fire();
          } else {
            console.warn("Input with name: '".concat(inputName, "', at path:'").concat(path, "' is not a trigger"));
          }
        };
        // Returns the TextValueRun object for the provided name at the given path
        Rive.prototype.retrieveTextAtPath = function (name, path) {
          if (!name) {
            console.warn("No text name provided for path '".concat(path, "'"));
            return;
          }
          if (!path) {
            console.warn("No path provided for text '".concat(name, "'"));
            return;
          }
          if (!this.artboard) {
            console.warn("Tried to access text: '".concat(name, "', at path: '").concat(path, "', but the Artboard is null"));
            return;
          }
          var text = this.artboard.textByPath(name, path);
          if (!text) {
            console.warn("Could not access text with name: '".concat(name, "', at path:'").concat(path, "'"));
            return;
          }
          return text;
        };
        /**
         * Retrieves the text value for a specified text run at a given path
         * @param textName The name of the text run
         * @param path The path to the text run within the artboard
         * @returns The text value of the text run, or undefined if not found
         *
         * @example
         * // Get the text value for a text run named "title" at one nested artboard deep
         * const titleText = riveInstance.getTextRunValueAtPath("title", "artboard1");
         *
         * @example
         * // Get the text value for a text run named "subtitle" within a nested group two artboards deep
         * const subtitleText = riveInstance.getTextRunValueAtPath("subtitle", "group/nestedGroup");
         *
         * @remarks
         * If the text run cannot be found at the specified path, a warning will be logged to the console.
         */
        Rive.prototype.getTextRunValueAtPath = function (textName, path) {
          var run = this.retrieveTextAtPath(textName, path);
          if (!run) {
            console.warn("Could not get text with name: '".concat(textName, "', at path:'").concat(path, "'"));
            return;
          }
          return run.text;
        };
        /**
         * Sets the text value for a specified text run at a given path
         * @param textName The name of the text run
         * @param value The new text value to set
         * @param path The path to the text run within the artboard
         * @returns void
         *
         * @example
         * // Set the text value for a text run named "title" at one nested artboard deep
         * riveInstance.setTextRunValueAtPath("title", "New Title", "artboard1");
         *
         * @example
         * // Set the text value for a text run named "subtitle" within a nested group two artboards deep
         * riveInstance.setTextRunValueAtPath("subtitle", "New Subtitle", "group/nestedGroup");
         *
         * @remarks
         * If the text run cannot be found at the specified path, a warning will be logged to the console.
         */
        Rive.prototype.setTextRunValueAtPath = function (textName, value, path) {
          var run = this.retrieveTextAtPath(textName, path);
          if (!run) {
            console.warn("Could not set text with name: '".concat(textName, "', at path:'").concat(path, "'"));
            return;
          }
          run.text = value;
        };
        Object.defineProperty(Rive.prototype, "playingStateMachineNames", {
          // Returns a list of playing machine names
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
              return [];
            }
            return this.animator.stateMachines.filter(function (m) {
              return m.playing;
            }).map(function (m) {
              return m.name;
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "playingAnimationNames", {
          // Returns a list of playing animation names
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
              return [];
            }
            return this.animator.animations.filter(function (a) {
              return a.playing;
            }).map(function (a) {
              return a.name;
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "pausedAnimationNames", {
          // Returns a list of paused animation names
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
              return [];
            }
            return this.animator.animations.filter(function (a) {
              return !a.playing;
            }).map(function (a) {
              return a.name;
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "pausedStateMachineNames", {
          /**
           *  Returns a list of paused machine names
           * @returns a list of state machine names that are paused
           */
          get: function get() {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
              return [];
            }
            return this.animator.stateMachines.filter(function (m) {
              return !m.playing;
            }).map(function (m) {
              return m.name;
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "isPlaying", {
          /**
           * @returns true if any animation is playing
           */
          get: function get() {
            return this.animator.isPlaying;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "isPaused", {
          /**
           * @returns true if all instanced animations are paused
           */
          get: function get() {
            return this.animator.isPaused;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "isStopped", {
          /**
           * @returns true if no animations are playing or paused
           */
          get: function get() {
            return this.animator.isStopped;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "bounds", {
          /**
           * @returns the bounds of the current artboard, or undefined if the artboard
           * isn't loaded yet.
           */
          get: function get() {
            return this.artboard ? this.artboard.bounds : undefined;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Subscribe to Rive-generated events
         * @param type the type of event to subscribe to
         * @param callback callback to fire when the event occurs
         */
        Rive.prototype.on = function (type, callback) {
          this.eventManager.add({
            type: type,
            callback: callback
          });
        };
        /**
         * Unsubscribes from a Rive-generated event
         * @param type the type of event to unsubscribe from
         * @param callback the callback to unsubscribe
         */
        Rive.prototype.off = function (type, callback) {
          this.eventManager.remove({
            type: type,
            callback: callback
          });
        };
        /**
         * Unsubscribes from a Rive-generated event
         * @deprecated
         * @param callback the callback to unsubscribe from
         */
        Rive.prototype.unsubscribe = function (type, callback) {
          console.warn("This function is deprecated: please use `off()` instead.");
          this.off(type, callback);
        };
        /**
         * Unsubscribes all Rive listeners from an event type, or everything if no type is
         * given
         * @param type the type of event to unsubscribe from, or all types if
         * undefined
         */
        Rive.prototype.removeAllRiveEventListeners = function (type) {
          this.eventManager.removeAll(type);
        };
        /**
         * Unsubscribes all listeners from an event type, or everything if no type is
         * given
         * @deprecated
         * @param type the type of event to unsubscribe from, or all types if
         * undefined
         */
        Rive.prototype.unsubscribeAll = function (type) {
          console.warn("This function is deprecated: please use `removeAllRiveEventListeners()` instead.");
          this.removeAllRiveEventListeners(type);
        };
        /**
         * Stops the rendering loop; this is different from pausing in that it doesn't
         * change the state of any animation. It stops rendering from occurring. This
         * is designed for situations such as when Rive isn't visible.
         *
         * The only way to start rendering again is to call `startRendering`.
         * Animations that are marked as playing will start from the position that
         * they would have been at if rendering had not been stopped.
         */
        Rive.prototype.stopRendering = function () {
          if (this.loaded && this.frameRequestId) {
            if (this.runtime.cancelAnimationFrame) {
              this.runtime.cancelAnimationFrame(this.frameRequestId);
            } else {
              cancelAnimationFrame(this.frameRequestId);
            }
            this.frameRequestId = null;
          }
        };
        /**
         * Starts the rendering loop if it has been previously stopped. If the
         * renderer is already active, then this will have zero effect.
         */
        Rive.prototype.startRendering = function () {
          if (this.loaded && this.artboard && !this.frameRequestId) {
            if (this.runtime.requestAnimationFrame) {
              this.frameRequestId = this.runtime.requestAnimationFrame(this._boundDraw);
            } else {
              this.frameRequestId = requestAnimationFrame(this._boundDraw);
            }
          }
        };
        /**
         * Enables frames-per-second (FPS) reporting for the runtime
         * If no callback is provided, Rive will append a fixed-position div at the top-right corner of
         * the page with the FPS reading
         * @param fpsCallback - Callback from the runtime during the RAF loop that supplies the FPS value
         */
        Rive.prototype.enableFPSCounter = function (fpsCallback) {
          this.runtime.enableFPSCounter(fpsCallback);
        };
        /**
         * Disables frames-per-second (FPS) reporting for the runtime
         */
        Rive.prototype.disableFPSCounter = function () {
          this.runtime.disableFPSCounter();
        };
        Object.defineProperty(Rive.prototype, "contents", {
          /**
           * Returns the contents of a Rive file: the artboards, animations, and state machines
           */
          get: function get() {
            if (!this.loaded) {
              return undefined;
            }
            var riveContents = {
              artboards: []
            };
            for (var i = 0; i < this.file.artboardCount(); i++) {
              var artboard = this.file.artboardByIndex(i);
              var artboardContents = {
                name: artboard.name,
                animations: [],
                stateMachines: []
              };
              for (var j = 0; j < artboard.animationCount(); j++) {
                var animation = artboard.animationByIndex(j);
                artboardContents.animations.push(animation.name);
              }
              for (var k = 0; k < artboard.stateMachineCount(); k++) {
                var stateMachine = artboard.stateMachineByIndex(k);
                var name_1 = stateMachine.name;
                var instance = new this.runtime.StateMachineInstance(stateMachine, artboard);
                var inputContents = [];
                for (var l = 0; l < instance.inputCount(); l++) {
                  var input = instance.input(l);
                  inputContents.push({
                    name: input.name,
                    type: input.type
                  });
                }
                artboardContents.stateMachines.push({
                  name: name_1,
                  inputs: inputContents
                });
              }
              riveContents.artboards.push(artboardContents);
            }
            return riveContents;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "volume", {
          /**
           * Getter / Setter for the volume of the artboard
           */
          get: function get() {
            if (this.artboard && this.artboard.volume !== this._volume) {
              this._volume = this.artboard.volume;
            }
            return this._volume;
          },
          set: function set(value) {
            this._volume = value;
            if (this.artboard) {
              this.artboard.volume = value * audioManager.systemVolume;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "artboardWidth", {
          /**
           * The width of the artboard.
           *
           * This will return 0 if the artboard is not loaded yet and a custom
           * width has not been set.
           *
           * Do not set this value manually when using {@link resizeDrawingSurfaceToCanvas}
           * with a {@link Layout.fit} of {@link Fit.Layout}, as the artboard width is
           * automatically set.
           */
          get: function get() {
            var _a;
            if (this.artboard) {
              return this.artboard.width;
            }
            return (_a = this._artboardWidth) !== null && _a !== void 0 ? _a : 0;
          },
          set: function set(value) {
            this._artboardWidth = value;
            if (this.artboard) {
              this.artboard.width = value;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rive.prototype, "artboardHeight", {
          /**
           * The height of the artboard.
           *
           * This will return 0 if the artboard is not loaded yet and a custom
           * height has not been set.
           *
           * Do not set this value manually when using {@link resizeDrawingSurfaceToCanvas}
           * with a {@link Layout.fit} of {@link Fit.Layout}, as the artboard height is
           * automatically set.
           */
          get: function get() {
            var _a;
            if (this.artboard) {
              return this.artboard.height;
            }
            return (_a = this._artboardHeight) !== null && _a !== void 0 ? _a : 0;
          },
          set: function set(value) {
            this._artboardHeight = value;
            if (this.artboard) {
              this.artboard.height = value;
            }
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Reset the artboard size to its original values.
         */
        Rive.prototype.resetArtboardSize = function () {
          if (this.artboard) {
            this.artboard.resetArtboardSize();
            this._artboardWidth = this.artboard.width;
            this._artboardHeight = this.artboard.height;
          } else {
            // If the artboard isn't loaded, we need to reset the custom width and height
            this._artboardWidth = undefined;
            this._artboardHeight = undefined;
          }
        };
        Object.defineProperty(Rive.prototype, "devicePixelRatioUsed", {
          /**
           * The device pixel ratio used in rendering and canvas/artboard resizing.
           *
           * This value will be overidden by the device pixel ratio used in
           * {@link resizeDrawingSurfaceToCanvas}. If you use that method, do not set this value.
           */
          get: function get() {
            return this._devicePixelRatioUsed;
          },
          set: function set(value) {
            this._devicePixelRatioUsed = value;
          },
          enumerable: false,
          configurable: true
        });
        /**
         * Initialize the data context with the view model instance.
         */
        Rive.prototype.setDataContextFromInstance = function (viewModelInstance) {
          var _a;
          if (this.artboard) {
            (_a = this._viewModelInstance) === null || _a === void 0 ? void 0 : _a.cleanup();
            if (viewModelInstance) {
              this._viewModelInstance = viewModelInstance;
              this.artboard.setDataContextFromInstance(viewModelInstance.runtimeInstance);
              this.animator.stateMachines.forEach(function (stateMachine) {
                return stateMachine.setDataContextFromInstance(viewModelInstance);
              });
              viewModelInstance.incrementReferenceCount();
            }
          }
        };
        Object.defineProperty(Rive.prototype, "viewModelInstance", {
          get: function get() {
            return this._viewModelInstance;
          },
          enumerable: false,
          configurable: true
        });
        Rive.prototype.viewModelByIndex = function (index) {
          var viewModel = this.file.viewModelByIndex(index);
          if (viewModel !== null) {
            return new _ViewModel(viewModel);
          }
          return null;
        };
        Rive.prototype.viewModelByName = function (name) {
          var viewModel = this.file.viewModelByName(name);
          if (viewModel !== null) {
            return new _ViewModel(viewModel);
          }
          return null;
        };
        Rive.prototype.enums = function () {
          if (this._dataEnums === null) {
            var dataEnums = this.file.enums();
            this._dataEnums = dataEnums.map(function (dataEnum) {
              return new _DataEnum(dataEnum);
            });
          }
          return this._dataEnums;
        };
        Rive.prototype.defaultViewModel = function () {
          if (this.artboard) {
            var viewModel = this.file.defaultArtboardViewModel(this.artboard);
            if (viewModel) {
              return new _ViewModel(viewModel);
            }
          }
          return null;
        };
        // Error message for missing source or buffer
        Rive.missingErrorMessage = "Rive source file or data buffer required";
        // Error message for removed rive file
        Rive.cleanupErrorMessage = "Attempt to use file after calling cleanup.";
        return Rive;
      }();
      var _ViewModel = /** @class */function () {
        function ViewModel(viewModel) {
          this._viewModel = viewModel;
        }
        Object.defineProperty(ViewModel.prototype, "instanceCount", {
          get: function get() {
            return this._viewModel.instanceCount;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ViewModel.prototype, "name", {
          get: function get() {
            return this._viewModel.name;
          },
          enumerable: false,
          configurable: true
        });
        ViewModel.prototype.instanceByIndex = function (index) {
          var instance = this._viewModel.instanceByIndex(index);
          if (instance !== null) {
            return new _ViewModelInstance(instance, null);
          }
          return null;
        };
        ViewModel.prototype.instanceByName = function (name) {
          var instance = this._viewModel.instanceByName(name);
          if (instance !== null) {
            return new _ViewModelInstance(instance, null);
          }
          return null;
        };
        ViewModel.prototype.defaultInstance = function () {
          var runtimeInstance = this._viewModel.defaultInstance();
          if (runtimeInstance !== null) {
            return new _ViewModelInstance(runtimeInstance, null);
          }
          return null;
        };
        ViewModel.prototype.instance = function () {
          var runtimeInstance = this._viewModel.instance();
          if (runtimeInstance !== null) {
            return new _ViewModelInstance(runtimeInstance, null);
          }
          return null;
        };
        Object.defineProperty(ViewModel.prototype, "properties", {
          get: function get() {
            return this._viewModel.getProperties();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ViewModel.prototype, "instanceNames", {
          get: function get() {
            return this._viewModel.getInstanceNames();
          },
          enumerable: false,
          configurable: true
        });
        return ViewModel;
      }();
      var _DataEnum = /** @class */function () {
        function DataEnum(dataEnum) {
          this._dataEnum = dataEnum;
        }
        Object.defineProperty(DataEnum.prototype, "name", {
          get: function get() {
            return this._dataEnum.name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(DataEnum.prototype, "values", {
          get: function get() {
            return this._dataEnum.values;
          },
          enumerable: false,
          configurable: true
        });
        return DataEnum;
      }();
      var _ViewModelInstance = /** @class */function () {
        function ViewModelInstance(runtimeInstance, root) {
          this._propertiesWithCallbacks = [];
          this._referenceCount = 0;
          this._runtimeInstance = runtimeInstance;
          this._root = root || this;
        }
        Object.defineProperty(ViewModelInstance.prototype, "runtimeInstance", {
          get: function get() {
            return this._runtimeInstance;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstance.prototype.handleCallbacks = function () {
          if (this._propertiesWithCallbacks.length !== 0) {
            this._propertiesWithCallbacks.forEach(function (property) {
              property.handleCallbacks();
            });
          }
        };
        ViewModelInstance.prototype.clearCallbacks = function () {
          this._propertiesWithCallbacks.forEach(function (property) {
            property.clearCallbacks();
          });
        };
        /**
         * method to access a property instance of type number belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.number = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.number(path);
          if (instance) {
            return new _ViewModelInstanceNumber(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a property instance of type string belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.string = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.string(path);
          if (instance) {
            return new _ViewModelInstanceString(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a property instance of type boolean belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.boolean = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.boolean(path);
          if (instance) {
            return new _ViewModelInstanceBoolean(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a property instance of type color belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.color = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.color(path);
          if (instance) {
            return new _ViewModelInstanceColor(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a property instance of type trigger belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.trigger = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.trigger(path);
          if (instance) {
            return new _ViewModelInstanceTrigger(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a property instance of type enum belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.enum = function (path) {
          var _a;
          var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.enum(path);
          if (instance) {
            return new _ViewModelInstanceEnum(instance, this._root);
          }
          return null;
        };
        /**
         * method to access a view model property instance belonging
         * to the view model instance or to a nested view model instance
         * @param path - path to the number property
         */
        ViewModelInstance.prototype.viewModel = function (path) {
          var _a;
          var viewModelInstance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.viewModel(path);
          if (viewModelInstance) {
            return new ViewModelInstance(viewModelInstance, this._root);
          }
          return null;
        };
        ViewModelInstance.prototype.property = function (path) {
          var _a;
          var viewModelInstance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.property(path);
          if (viewModelInstance) {
            return new _ViewModelInstanceValue(viewModelInstance, this._root);
          }
          return null;
        };
        ViewModelInstance.prototype.addToCallbacks = function (property) {
          if (!this._propertiesWithCallbacks.includes(property)) {
            this._propertiesWithCallbacks.push(property);
          }
        };
        ViewModelInstance.prototype.removeFromCallbacks = function (property) {
          if (this._propertiesWithCallbacks.includes(property)) {
            this._propertiesWithCallbacks = this._propertiesWithCallbacks.filter(function (prop) {
              return prop !== property;
            });
          }
        };
        Object.defineProperty(ViewModelInstance.prototype, "properties", {
          get: function get() {
            var _a;
            return ((_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.getProperties().map(function (prop) {
              return __assign({}, prop);
            })) || [];
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstance.prototype.incrementReferenceCount = function () {
          this._referenceCount++;
        };
        ViewModelInstance.prototype.cleanup = function () {
          var _a;
          this._referenceCount--;
          if (this._referenceCount == 0) {
            this._runtimeInstance.deleteInstance();
            (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.delete();
            this._runtimeInstance = null;
            this._propertiesWithCallbacks = [];
            this.clearCallbacks();
          }
        };
        return ViewModelInstance;
      }();
      var _ViewModelInstanceValue = /** @class */function () {
        function ViewModelInstanceValue(instance, root) {
          this.callbacks = [];
          this._viewModelInstanceValue = instance;
          this._rootViewModel = root;
        }
        ViewModelInstanceValue.prototype.on = function (callback) {
          // Since we don't clean the changed flag for properties that don't have listeners,
          // we clean it the first time we add a listener to it
          if (this.callbacks.length === 0) {
            this._viewModelInstanceValue.clearChanges();
          }
          if (!this.callbacks.includes(callback)) {
            this.callbacks.push(callback);
            this._rootViewModel.addToCallbacks(this);
          }
        };
        ViewModelInstanceValue.prototype.off = function (callback) {
          if (!callback) {
            this.callbacks.length = 0;
          } else {
            this.callbacks = this.callbacks.filter(function (cb) {
              return cb !== callback;
            });
          }
          if (this.callbacks.length === 0) {
            this._rootViewModel.removeFromCallbacks(this);
          }
        };
        ViewModelInstanceValue.prototype.internalHandleCallback = function (callback) {};
        ViewModelInstanceValue.prototype.handleCallbacks = function () {
          var _this = this;
          if (this._viewModelInstanceValue.hasChanged) {
            this._viewModelInstanceValue.clearChanges();
            this.callbacks.forEach(function (callback) {
              _this.internalHandleCallback(callback);
            });
          }
        };
        ViewModelInstanceValue.prototype.clearCallbacks = function () {
          this.callbacks.length = 0;
        };
        return ViewModelInstanceValue;
      }();
      var _ViewModelInstanceString = /** @class */function (_super) {
        __extends(ViewModelInstanceString, _super);
        function ViewModelInstanceString(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        Object.defineProperty(ViewModelInstanceString.prototype, "value", {
          get: function get() {
            return this._viewModelInstanceValue.value;
          },
          set: function set(val) {
            this._viewModelInstanceValue.value = val;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstanceString.prototype.internalHandleCallback = function (callback) {
          callback(this.value);
        };
        return ViewModelInstanceString;
      }(_ViewModelInstanceValue);
      var _ViewModelInstanceNumber = /** @class */function (_super) {
        __extends(ViewModelInstanceNumber, _super);
        function ViewModelInstanceNumber(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        Object.defineProperty(ViewModelInstanceNumber.prototype, "value", {
          get: function get() {
            return this._viewModelInstanceValue.value;
          },
          set: function set(val) {
            this._viewModelInstanceValue.value = val;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstanceNumber.prototype.internalHandleCallback = function (callback) {
          callback(this.value);
        };
        return ViewModelInstanceNumber;
      }(_ViewModelInstanceValue);
      var _ViewModelInstanceBoolean = /** @class */function (_super) {
        __extends(ViewModelInstanceBoolean, _super);
        function ViewModelInstanceBoolean(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        Object.defineProperty(ViewModelInstanceBoolean.prototype, "value", {
          get: function get() {
            return this._viewModelInstanceValue.value;
          },
          set: function set(val) {
            this._viewModelInstanceValue.value = val;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstanceBoolean.prototype.internalHandleCallback = function (callback) {
          callback(this.value);
        };
        return ViewModelInstanceBoolean;
      }(_ViewModelInstanceValue);
      var _ViewModelInstanceTrigger = /** @class */function (_super) {
        __extends(ViewModelInstanceTrigger, _super);
        function ViewModelInstanceTrigger(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        ViewModelInstanceTrigger.prototype.trigger = function () {
          return this._viewModelInstanceValue.trigger();
        };
        ViewModelInstanceTrigger.prototype.internalHandleCallback = function (callback) {
          callback();
        };
        return ViewModelInstanceTrigger;
      }(_ViewModelInstanceValue);
      var _ViewModelInstanceEnum = /** @class */function (_super) {
        __extends(ViewModelInstanceEnum, _super);
        function ViewModelInstanceEnum(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        Object.defineProperty(ViewModelInstanceEnum.prototype, "value", {
          get: function get() {
            return this._viewModelInstanceValue.value;
          },
          set: function set(val) {
            this._viewModelInstanceValue.value = val;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ViewModelInstanceEnum.prototype, "valueIndex", {
          get: function get() {
            return this._viewModelInstanceValue.valueIndex;
          },
          set: function set(val) {
            this._viewModelInstanceValue.valueIndex = val;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ViewModelInstanceEnum.prototype, "values", {
          get: function get() {
            return this._viewModelInstanceValue.values;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstanceEnum.prototype.internalHandleCallback = function (callback) {
          callback(this.value);
        };
        return ViewModelInstanceEnum;
      }(_ViewModelInstanceValue);
      var _ViewModelInstanceColor = /** @class */function (_super) {
        __extends(ViewModelInstanceColor, _super);
        function ViewModelInstanceColor(instance, root) {
          return _super.call(this, instance, root) || this;
        }
        Object.defineProperty(ViewModelInstanceColor.prototype, "value", {
          get: function get() {
            return this._viewModelInstanceValue.value;
          },
          set: function set(val) {
            this._viewModelInstanceValue.value = val;
          },
          enumerable: false,
          configurable: true
        });
        ViewModelInstanceColor.prototype.rgb = function (r, g, b) {
          this._viewModelInstanceValue.rgb(r, g, b);
        };
        ViewModelInstanceColor.prototype.rgba = function (r, g, b, a) {
          this._viewModelInstanceValue.argb(a, r, g, b);
        };
        ViewModelInstanceColor.prototype.argb = function (a, r, g, b) {
          this._viewModelInstanceValue.argb(a, r, g, b);
        };
        // Value 0 to 255
        ViewModelInstanceColor.prototype.alpha = function (a) {
          this._viewModelInstanceValue.alpha(a);
        };
        // Value 0 to 100
        ViewModelInstanceColor.prototype.opacity = function (o) {
          this._viewModelInstanceValue.alpha(Math.round(Math.max(0, Math.min(100, o)) / 100 * 255));
        };
        ViewModelInstanceColor.prototype.internalHandleCallback = function (callback) {
          callback(this.value);
        };
        return ViewModelInstanceColor;
      }(_ViewModelInstanceValue);

      // Loads Rive data from a URI via fetch.
      var loadRiveFile = function loadRiveFile(src) {
        return __awaiter(void 0, void 0, void 0, function () {
          var req, res, buffer;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                req = new Request(src);
                return [4 /*yield*/, fetch(req)];
              case 1:
                res = _a.sent();
                return [4 /*yield*/, res.arrayBuffer()];
              case 2:
                buffer = _a.sent();
                return [2 /*return*/, buffer];
            }
          });
        });
      };
      // #endregion
      // #region utility functions
      /*
       * Utility function to ensure an object is a string array
       */
      var mapToStringArray = function mapToStringArray(obj) {
        if (typeof obj === "string") {
          return [obj];
        } else if (obj instanceof Array) {
          return obj;
        }
        // If obj is undefined, return empty array
        return [];
      };
      // #endregion
      // #region testing utilities
      // Exports to only be used for tests
      var _Testing = {
        EventManager: EventManager,
        TaskQueueManager: TaskQueueManager
      };
      // #endregion
      // #region asset loaders
      /**
       * Decodes bytes into an audio asset.
       *
       * Be sure to call `.unref()` on the audio once it is no longer needed. This
       * allows the engine to clean it up when it is not used by any more animations.
       */
      var _decodeAudio = function _decodeAudio(bytes) {
        return new Promise(function (resolve) {
          return _RuntimeLoader.getInstance(function (rive) {
            rive.decodeAudio(bytes, resolve);
          });
        });
      };
      /**
       * Decodes bytes into an image.
       *
       * Be sure to call `.unref()` on the image once it is no longer needed. This
       * allows the engine to clean it up when it is not used by any more animations.
       */
      var _decodeImage = function _decodeImage(bytes) {
        return new Promise(function (resolve) {
          return _RuntimeLoader.getInstance(function (rive) {
            rive.decodeImage(bytes, resolve);
          });
        });
      };
      /**
       * Decodes bytes into a font.
       *
       * Be sure to call `.unref()` on the font once it is no longer needed. This
       * allows the engine to clean it up when it is not used by any more animations.
       */
      var _decodeFont = function _decodeFont(bytes) {
        return new Promise(function (resolve) {
          return _RuntimeLoader.getInstance(function (rive) {
            rive.decodeFont(bytes, resolve);
          });
        });
      };
      // #endregion
    })();

    /******/
    return __webpack_exports__;
    /******/
  }();
});
},{}],"node_modules/planck/dist/planck-with-testbed.js":[function(require,module,exports) {
var define;
var global = arguments[3];
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.planck = {}));
})(this, function (exports2) {
  "use strict";

  /**
  * Planck.js v1.3.0
  * @license The MIT license
  * @copyright Copyright (c) 2024 Erin Catto, Ali Shakiba
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */

  /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
  var _extendStatics$ = function extendStatics$1(d2, b2) {
    _extendStatics$ = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d3, b3) {
      d3.__proto__ = b3;
    } || function (d3, b3) {
      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];
    };
    return _extendStatics$(d2, b2);
  };
  function __extends$1(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics$(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var _assign$ = function __assign$1() {
    _assign$ = Object.assign || function __assign2(t) {
      for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
        s2 = arguments[i];
        for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t[p] = s2[p];
      }
      return t;
    };
    return _assign$.apply(this, arguments);
  };
  var options = function options(input2, defaults) {
    if (input2 === null || typeof input2 === "undefined") {
      input2 = {};
    }
    var output2 = _assign$({}, input2);
    for (var key in defaults) {
      if (defaults.hasOwnProperty(key) && typeof input2[key] === "undefined") {
        output2[key] = defaults[key];
      }
    }
    if (typeof Object.getOwnPropertySymbols === "function") {
      var symbols = Object.getOwnPropertySymbols(defaults);
      for (var i = 0; i < symbols.length; i++) {
        var symbol = symbols[i];
        if (defaults.propertyIsEnumerable(symbol) && typeof input2[symbol] === "undefined") {
          output2[symbol] = defaults[symbol];
        }
      }
    }
    return output2;
  };
  var math_random$1 = Math.random;
  var EPSILON = 1e-9;
  var isFinite = Number.isFinite;
  function nextPowerOfTwo(x2) {
    x2 |= x2 >> 1;
    x2 |= x2 >> 2;
    x2 |= x2 >> 4;
    x2 |= x2 >> 8;
    x2 |= x2 >> 16;
    return x2 + 1;
  }
  function isPowerOfTwo(x2) {
    return x2 > 0 && (x2 & x2 - 1) === 0;
  }
  function mod(num, min, max) {
    if (typeof min === "undefined") {
      max = 1;
      min = 0;
    } else if (typeof max === "undefined") {
      max = min;
      min = 0;
    }
    if (max > min) {
      num = (num - min) % (max - min);
      return num + (num < 0 ? max : min);
    } else {
      num = (num - max) % (min - max);
      return num + (num <= 0 ? min : max);
    }
  }
  function clamp$1(num, min, max) {
    if (num < min) {
      return min;
    } else if (num > max) {
      return max;
    } else {
      return num;
    }
  }
  function random$1(min, max) {
    if (typeof min === "undefined") {
      max = 1;
      min = 0;
    } else if (typeof max === "undefined") {
      max = min;
      min = 0;
    }
    return min === max ? min : math_random$1() * (max - min) + min;
  }
  var math$1 = Object.create(Math);
  math$1.EPSILON = EPSILON;
  math$1.isFinite = isFinite;
  math$1.nextPowerOfTwo = nextPowerOfTwo;
  math$1.isPowerOfTwo = isPowerOfTwo;
  math$1.mod = mod;
  math$1.clamp = clamp$1;
  math$1.random = random$1;
  var math_abs$a = Math.abs;
  var math_sqrt$8 = Math.sqrt;
  var math_max$b = Math.max;
  var math_min$d = Math.min;
  var Vec2 = /** @class */
  function () {
    function Vec22(x2, y) {
      if (!(this instanceof Vec22)) {
        return new Vec22(x2, y);
      }
      if (typeof x2 === "undefined") {
        this.x = 0;
        this.y = 0;
      } else if (_typeof(x2) === "object") {
        this.x = x2.x;
        this.y = x2.y;
      } else {
        this.x = x2;
        this.y = y;
      }
    }
    Vec22.prototype._serialize = function () {
      return {
        x: this.x,
        y: this.y
      };
    };
    Vec22._deserialize = function (data) {
      var obj = Object.create(Vec22.prototype);
      obj.x = data.x;
      obj.y = data.y;
      return obj;
    };
    Vec22.zero = function () {
      var obj = Object.create(Vec22.prototype);
      obj.x = 0;
      obj.y = 0;
      return obj;
    };
    Vec22.neo = function (x2, y) {
      var obj = Object.create(Vec22.prototype);
      obj.x = x2;
      obj.y = y;
      return obj;
    };
    Vec22.clone = function (v3) {
      return Vec22.neo(v3.x, v3.y);
    };
    Vec22.prototype.toString = function () {
      return JSON.stringify(this);
    };
    Vec22.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Number.isFinite(obj.x) && Number.isFinite(obj.y);
    };
    Vec22.assert = function (o) {};
    Vec22.prototype.clone = function () {
      return Vec22.clone(this);
    };
    Vec22.prototype.setZero = function () {
      this.x = 0;
      this.y = 0;
      return this;
    };
    Vec22.prototype.set = function (x2, y) {
      if (_typeof(x2) === "object") {
        this.x = x2.x;
        this.y = x2.y;
      } else {
        this.x = x2;
        this.y = y;
      }
      return this;
    };
    Vec22.prototype.setNum = function (x2, y) {
      this.x = x2;
      this.y = y;
      return this;
    };
    Vec22.prototype.setVec2 = function (value) {
      this.x = value.x;
      this.y = value.y;
      return this;
    };
    Vec22.prototype.wSet = function (a2, v3, b2, w) {
      if (typeof b2 !== "undefined" || typeof w !== "undefined") {
        return this.setCombine(a2, v3, b2, w);
      } else {
        return this.setMul(a2, v3);
      }
    };
    Vec22.prototype.setCombine = function (a2, v3, b2, w) {
      var x2 = a2 * v3.x + b2 * w.x;
      var y = a2 * v3.y + b2 * w.y;
      this.x = x2;
      this.y = y;
      return this;
    };
    Vec22.prototype.setMul = function (a2, v3) {
      var x2 = a2 * v3.x;
      var y = a2 * v3.y;
      this.x = x2;
      this.y = y;
      return this;
    };
    Vec22.prototype.add = function (w) {
      this.x += w.x;
      this.y += w.y;
      return this;
    };
    Vec22.prototype.wAdd = function (a2, v3, b2, w) {
      if (typeof b2 !== "undefined" || typeof w !== "undefined") {
        return this.addCombine(a2, v3, b2, w);
      } else {
        return this.addMul(a2, v3);
      }
    };
    Vec22.prototype.addCombine = function (a2, v3, b2, w) {
      var x2 = a2 * v3.x + b2 * w.x;
      var y = a2 * v3.y + b2 * w.y;
      this.x += x2;
      this.y += y;
      return this;
    };
    Vec22.prototype.addMul = function (a2, v3) {
      var x2 = a2 * v3.x;
      var y = a2 * v3.y;
      this.x += x2;
      this.y += y;
      return this;
    };
    Vec22.prototype.wSub = function (a2, v3, b2, w) {
      if (typeof b2 !== "undefined" || typeof w !== "undefined") {
        return this.subCombine(a2, v3, b2, w);
      } else {
        return this.subMul(a2, v3);
      }
    };
    Vec22.prototype.subCombine = function (a2, v3, b2, w) {
      var x2 = a2 * v3.x + b2 * w.x;
      var y = a2 * v3.y + b2 * w.y;
      this.x -= x2;
      this.y -= y;
      return this;
    };
    Vec22.prototype.subMul = function (a2, v3) {
      var x2 = a2 * v3.x;
      var y = a2 * v3.y;
      this.x -= x2;
      this.y -= y;
      return this;
    };
    Vec22.prototype.sub = function (w) {
      this.x -= w.x;
      this.y -= w.y;
      return this;
    };
    Vec22.prototype.mul = function (m) {
      this.x *= m;
      this.y *= m;
      return this;
    };
    Vec22.prototype.length = function () {
      return Vec22.lengthOf(this);
    };
    Vec22.prototype.lengthSquared = function () {
      return Vec22.lengthSquared(this);
    };
    Vec22.prototype.normalize = function () {
      var length2 = this.length();
      if (length2 < EPSILON) {
        return 0;
      }
      var invLength = 1 / length2;
      this.x *= invLength;
      this.y *= invLength;
      return length2;
    };
    Vec22.normalize = function (v3) {
      var length2 = Vec22.lengthOf(v3);
      if (length2 < EPSILON) {
        return Vec22.zero();
      }
      var invLength = 1 / length2;
      return Vec22.neo(v3.x * invLength, v3.y * invLength);
    };
    Vec22.lengthOf = function (v3) {
      return math_sqrt$8(v3.x * v3.x + v3.y * v3.y);
    };
    Vec22.lengthSquared = function (v3) {
      return v3.x * v3.x + v3.y * v3.y;
    };
    Vec22.distance = function (v3, w) {
      var dx = v3.x - w.x;
      var dy = v3.y - w.y;
      return math_sqrt$8(dx * dx + dy * dy);
    };
    Vec22.distanceSquared = function (v3, w) {
      var dx = v3.x - w.x;
      var dy = v3.y - w.y;
      return dx * dx + dy * dy;
    };
    Vec22.areEqual = function (v3, w) {
      return v3 === w || _typeof(w) === "object" && w !== null && v3.x === w.x && v3.y === w.y;
    };
    Vec22.skew = function (v3) {
      return Vec22.neo(-v3.y, v3.x);
    };
    Vec22.dot = function (v3, w) {
      return v3.x * w.x + v3.y * w.y;
    };
    Vec22.cross = function (v3, w) {
      if (typeof w === "number") {
        return Vec22.neo(w * v3.y, -w * v3.x);
      } else if (typeof v3 === "number") {
        return Vec22.neo(-v3 * w.y, v3 * w.x);
      } else {
        return v3.x * w.y - v3.y * w.x;
      }
    };
    Vec22.crossVec2Vec2 = function (v3, w) {
      return v3.x * w.y - v3.y * w.x;
    };
    Vec22.crossVec2Num = function (v3, w) {
      return Vec22.neo(w * v3.y, -w * v3.x);
    };
    Vec22.crossNumVec2 = function (v3, w) {
      return Vec22.neo(-v3 * w.y, v3 * w.x);
    };
    Vec22.addCross = function (a2, v3, w) {
      if (typeof w === "number") {
        return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);
      } else if (typeof v3 === "number") {
        return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);
      }
    };
    Vec22.addCrossVec2Num = function (a2, v3, w) {
      return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);
    };
    Vec22.addCrossNumVec2 = function (a2, v3, w) {
      return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);
    };
    Vec22.add = function (v3, w) {
      return Vec22.neo(v3.x + w.x, v3.y + w.y);
    };
    Vec22.wAdd = function (a2, v3, b2, w) {
      if (typeof b2 !== "undefined" || typeof w !== "undefined") {
        return Vec22.combine(a2, v3, b2, w);
      } else {
        return Vec22.mulNumVec2(a2, v3);
      }
    };
    Vec22.combine = function (a2, v3, b2, w) {
      return Vec22.zero().setCombine(a2, v3, b2, w);
    };
    Vec22.sub = function (v3, w) {
      return Vec22.neo(v3.x - w.x, v3.y - w.y);
    };
    Vec22.mul = function (a2, b2) {
      if (_typeof(a2) === "object") {
        return Vec22.neo(a2.x * b2, a2.y * b2);
      } else if (_typeof(b2) === "object") {
        return Vec22.neo(a2 * b2.x, a2 * b2.y);
      }
    };
    Vec22.mulVec2Num = function (a2, b2) {
      return Vec22.neo(a2.x * b2, a2.y * b2);
    };
    Vec22.mulNumVec2 = function (a2, b2) {
      return Vec22.neo(a2 * b2.x, a2 * b2.y);
    };
    Vec22.prototype.neg = function () {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    Vec22.neg = function (v3) {
      return Vec22.neo(-v3.x, -v3.y);
    };
    Vec22.abs = function (v3) {
      return Vec22.neo(math_abs$a(v3.x), math_abs$a(v3.y));
    };
    Vec22.mid = function (v3, w) {
      return Vec22.neo((v3.x + w.x) * 0.5, (v3.y + w.y) * 0.5);
    };
    Vec22.upper = function (v3, w) {
      return Vec22.neo(math_max$b(v3.x, w.x), math_max$b(v3.y, w.y));
    };
    Vec22.lower = function (v3, w) {
      return Vec22.neo(math_min$d(v3.x, w.x), math_min$d(v3.y, w.y));
    };
    Vec22.prototype.clamp = function (max) {
      var lengthSqr = this.x * this.x + this.y * this.y;
      if (lengthSqr > max * max) {
        var scale = max / math_sqrt$8(lengthSqr);
        this.x *= scale;
        this.y *= scale;
      }
      return this;
    };
    Vec22.clamp = function (v3, max) {
      var r = Vec22.neo(v3.x, v3.y);
      r.clamp(max);
      return r;
    };
    Vec22.clampVec2 = function (v3, min, max) {
      return {
        x: clamp$1(v3.x, min === null || min === void 0 ? void 0 : min.x, max === null || max === void 0 ? void 0 : max.x),
        y: clamp$1(v3.y, min === null || min === void 0 ? void 0 : min.y, max === null || max === void 0 ? void 0 : max.y)
      };
    };
    Vec22.scaleFn = function (x2, y) {
      return function (v3) {
        return Vec22.neo(v3.x * x2, v3.y * y);
      };
    };
    Vec22.translateFn = function (x2, y) {
      return function (v3) {
        return Vec22.neo(v3.x + x2, v3.y + y);
      };
    };
    return Vec22;
  }();
  var math_max$a = Math.max;
  var math_min$c = Math.min;
  var AABB = /** @class */
  function () {
    function AABB2(lower, upper) {
      if (!(this instanceof AABB2)) {
        return new AABB2(lower, upper);
      }
      this.lowerBound = Vec2.zero();
      this.upperBound = Vec2.zero();
      if (_typeof(lower) === "object") {
        this.lowerBound.setVec2(lower);
      }
      if (_typeof(upper) === "object") {
        this.upperBound.setVec2(upper);
      } else if (_typeof(lower) === "object") {
        this.upperBound.setVec2(lower);
      }
    }
    AABB2.prototype.isValid = function () {
      return AABB2.isValid(this);
    };
    AABB2.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;
    };
    AABB2.assert = function (o) {};
    AABB2.prototype.getCenter = function () {
      return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);
    };
    AABB2.prototype.getExtents = function () {
      return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);
    };
    AABB2.prototype.getPerimeter = function () {
      return 2 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
    };
    AABB2.prototype.combine = function (a2, b2) {
      b2 = b2 || this;
      var lowerA = a2.lowerBound;
      var upperA = a2.upperBound;
      var lowerB = b2.lowerBound;
      var upperB = b2.upperBound;
      var lowerX = math_min$c(lowerA.x, lowerB.x);
      var lowerY = math_min$c(lowerA.y, lowerB.y);
      var upperX = math_max$a(upperB.x, upperA.x);
      var upperY = math_max$a(upperB.y, upperA.y);
      this.lowerBound.setNum(lowerX, lowerY);
      this.upperBound.setNum(upperX, upperY);
    };
    AABB2.prototype.combinePoints = function (a2, b2) {
      this.lowerBound.setNum(math_min$c(a2.x, b2.x), math_min$c(a2.y, b2.y));
      this.upperBound.setNum(math_max$a(a2.x, b2.x), math_max$a(a2.y, b2.y));
    };
    AABB2.prototype.set = function (aabb) {
      this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);
      this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);
    };
    AABB2.prototype.contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
    };
    AABB2.prototype.extend = function (value) {
      AABB2.extend(this, value);
      return this;
    };
    AABB2.extend = function (out, value) {
      out.lowerBound.x -= value;
      out.lowerBound.y -= value;
      out.upperBound.x += value;
      out.upperBound.y += value;
      return out;
    };
    AABB2.testOverlap = function (a2, b2) {
      var d1x = b2.lowerBound.x - a2.upperBound.x;
      var d2x = a2.lowerBound.x - b2.upperBound.x;
      var d1y = b2.lowerBound.y - a2.upperBound.y;
      var d2y = a2.lowerBound.y - b2.upperBound.y;
      if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
        return false;
      }
      return true;
    };
    AABB2.areEqual = function (a2, b2) {
      return Vec2.areEqual(a2.lowerBound, b2.lowerBound) && Vec2.areEqual(a2.upperBound, b2.upperBound);
    };
    AABB2.diff = function (a2, b2) {
      var wD = math_max$a(0, math_min$c(a2.upperBound.x, b2.upperBound.x) - math_max$a(b2.lowerBound.x, a2.lowerBound.x));
      var hD = math_max$a(0, math_min$c(a2.upperBound.y, b2.upperBound.y) - math_max$a(b2.lowerBound.y, a2.lowerBound.y));
      var wA = a2.upperBound.x - a2.lowerBound.x;
      var hA = a2.upperBound.y - a2.lowerBound.y;
      var wB = b2.upperBound.x - b2.lowerBound.x;
      var hB = b2.upperBound.y - b2.lowerBound.y;
      return wA * hA + wB * hB - wD * hD;
    };
    AABB2.prototype.rayCast = function (output2, input2) {
      var tmin = -Infinity;
      var tmax = Infinity;
      var p = input2.p1;
      var d2 = Vec2.sub(input2.p2, input2.p1);
      var absD = Vec2.abs(d2);
      var normal3 = Vec2.zero();
      for (var f = "x"; f !== null; f = f === "x" ? "y" : null) {
        if (absD.x < EPSILON) {
          if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
            return false;
          }
        } else {
          var inv_d = 1 / d2[f];
          var t1 = (this.lowerBound[f] - p[f]) * inv_d;
          var t2 = (this.upperBound[f] - p[f]) * inv_d;
          var s2 = -1;
          if (t1 > t2) {
            var temp3 = t1;
            t1 = t2;
            t2 = temp3;
            s2 = 1;
          }
          if (t1 > tmin) {
            normal3.setZero();
            normal3[f] = s2;
            tmin = t1;
          }
          tmax = math_min$c(tmax, t2);
          if (tmin > tmax) {
            return false;
          }
        }
      }
      if (tmin < 0 || input2.maxFraction < tmin) {
        return false;
      }
      output2.fraction = tmin;
      output2.normal = normal3;
      return true;
    };
    AABB2.prototype.toString = function () {
      return JSON.stringify(this);
    };
    AABB2.combinePoints = function (out, a2, b2) {
      out.lowerBound.x = math_min$c(a2.x, b2.x);
      out.lowerBound.y = math_min$c(a2.y, b2.y);
      out.upperBound.x = math_max$a(a2.x, b2.x);
      out.upperBound.y = math_max$a(a2.y, b2.y);
      return out;
    };
    AABB2.combinedPerimeter = function (a2, b2) {
      var lx = math_min$c(a2.lowerBound.x, b2.lowerBound.x);
      var ly = math_min$c(a2.lowerBound.y, b2.lowerBound.y);
      var ux = math_max$a(a2.upperBound.x, b2.upperBound.x);
      var uy = math_max$a(a2.upperBound.y, b2.upperBound.y);
      return 2 * (ux - lx + uy - ly);
    };
    return AABB2;
  }();
  var math_PI$8 = Math.PI;
  var Settings = /** @class */
  function () {
    function Settings2() {}
    Object.defineProperty(Settings2, "polygonRadius", {
      /**
       * The radius of the polygon/edge shape skin. This should not be modified.
       * Making this smaller means polygons will have an insufficient buffer for
       * continuous collision. Making it larger may create artifacts for vertex
       * collision.
       */
      get: function get() {
        return 2 * Settings2.linearSlop;
      },
      enumerable: false,
      configurable: true
    });
    Settings2.lengthUnitsPerMeter = 1;
    Settings2.maxManifoldPoints = 2;
    Settings2.maxPolygonVertices = 12;
    Settings2.aabbExtension = 0.1;
    Settings2.aabbMultiplier = 2;
    Settings2.linearSlop = 5e-3;
    Settings2.angularSlop = 2 / 180 * math_PI$8;
    Settings2.maxSubSteps = 8;
    Settings2.maxTOIContacts = 32;
    Settings2.maxTOIIterations = 20;
    Settings2.maxDistanceIterations = 20;
    Settings2.velocityThreshold = 1;
    Settings2.maxLinearCorrection = 0.2;
    Settings2.maxAngularCorrection = 8 / 180 * math_PI$8;
    Settings2.maxTranslation = 2;
    Settings2.maxRotation = 0.5 * math_PI$8;
    Settings2.baumgarte = 0.2;
    Settings2.toiBaugarte = 0.75;
    Settings2.timeToSleep = 0.5;
    Settings2.linearSleepTolerance = 0.01;
    Settings2.angularSleepTolerance = 2 / 180 * math_PI$8;
    return Settings2;
  }();
  var SettingsInternal = /** @class */
  function () {
    function SettingsInternal2() {}
    Object.defineProperty(SettingsInternal2, "maxManifoldPoints", {
      get: function get() {
        return Settings.maxManifoldPoints;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxPolygonVertices", {
      get: function get() {
        return Settings.maxPolygonVertices;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "aabbExtension", {
      get: function get() {
        return Settings.aabbExtension * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "aabbMultiplier", {
      get: function get() {
        return Settings.aabbMultiplier;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "linearSlop", {
      get: function get() {
        return Settings.linearSlop * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "linearSlopSquared", {
      get: function get() {
        return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "angularSlop", {
      get: function get() {
        return Settings.angularSlop;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "polygonRadius", {
      get: function get() {
        return 2 * Settings.linearSlop;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxSubSteps", {
      get: function get() {
        return Settings.maxSubSteps;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxTOIContacts", {
      get: function get() {
        return Settings.maxTOIContacts;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxTOIIterations", {
      get: function get() {
        return Settings.maxTOIIterations;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxDistanceIterations", {
      get: function get() {
        return Settings.maxDistanceIterations;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "velocityThreshold", {
      get: function get() {
        return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxLinearCorrection", {
      get: function get() {
        return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxAngularCorrection", {
      get: function get() {
        return Settings.maxAngularCorrection;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxTranslation", {
      get: function get() {
        return Settings.maxTranslation * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxTranslationSquared", {
      get: function get() {
        return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxRotation", {
      get: function get() {
        return Settings.maxRotation;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "maxRotationSquared", {
      get: function get() {
        return Settings.maxRotation * Settings.maxRotation;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "baumgarte", {
      get: function get() {
        return Settings.baumgarte;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "toiBaugarte", {
      get: function get() {
        return Settings.toiBaugarte;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "timeToSleep", {
      get: function get() {
        return Settings.timeToSleep;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "linearSleepTolerance", {
      get: function get() {
        return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "linearSleepToleranceSqr", {
      get: function get() {
        return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "angularSleepTolerance", {
      get: function get() {
        return Settings.angularSleepTolerance;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SettingsInternal2, "angularSleepToleranceSqr", {
      get: function get() {
        return Settings.angularSleepTolerance * Settings.angularSleepTolerance;
      },
      enumerable: false,
      configurable: true
    });
    return SettingsInternal2;
  }();
  var Pool = /** @class */
  function () {
    function Pool2(opts) {
      this._list = [];
      this._max = Infinity;
      this._hasCreateFn = false;
      this._createCount = 0;
      this._hasAllocateFn = false;
      this._allocateCount = 0;
      this._hasReleaseFn = false;
      this._releaseCount = 0;
      this._hasDisposeFn = false;
      this._disposeCount = 0;
      this._list = [];
      this._max = opts.max || this._max;
      this._createFn = opts.create;
      this._hasCreateFn = typeof this._createFn === "function";
      this._allocateFn = opts.allocate;
      this._hasAllocateFn = typeof this._allocateFn === "function";
      this._releaseFn = opts.release;
      this._hasReleaseFn = typeof this._releaseFn === "function";
      this._disposeFn = opts.dispose;
      this._hasDisposeFn = typeof this._disposeFn === "function";
    }
    Pool2.prototype.max = function (n2) {
      if (typeof n2 === "number") {
        this._max = n2;
        return this;
      }
      return this._max;
    };
    Pool2.prototype.size = function () {
      return this._list.length;
    };
    Pool2.prototype.allocate = function () {
      var item;
      if (this._list.length > 0) {
        item = this._list.shift();
      } else {
        this._createCount++;
        if (this._hasCreateFn) {
          item = this._createFn();
        } else {
          item = {};
        }
      }
      this._allocateCount++;
      if (this._hasAllocateFn) {
        this._allocateFn(item);
      }
      return item;
    };
    Pool2.prototype.release = function (item) {
      if (this._list.length < this._max) {
        this._releaseCount++;
        if (this._hasReleaseFn) {
          this._releaseFn(item);
        }
        this._list.push(item);
      } else {
        this._disposeCount++;
        if (this._hasDisposeFn) {
          item = this._disposeFn(item);
        }
      }
    };
    Pool2.prototype.toString = function () {
      return " +" + this._createCount + " >" + this._allocateCount + " <" + this._releaseCount + " -" + this._disposeCount + " =" + this._list.length + "/" + this._max;
    };
    return Pool2;
  }();
  var math_abs$9 = Math.abs;
  var math_max$9 = Math.max;
  var TreeNode = /** @class */
  function () {
    function TreeNode2(id) {
      this.aabb = new AABB();
      this.userData = null;
      this.parent = null;
      this.child1 = null;
      this.child2 = null;
      this.height = -1;
      this.id = id;
    }
    TreeNode2.prototype.toString = function () {
      return this.id + ": " + this.userData;
    };
    TreeNode2.prototype.isLeaf = function () {
      return this.child1 == null;
    };
    return TreeNode2;
  }();
  var poolTreeNode = new Pool({
    create: function create() {
      return new TreeNode();
    },
    release: function release(node) {
      node.userData = null;
      node.parent = null;
      node.child1 = null;
      node.child2 = null;
      node.height = -1;
      node.id = void 0;
    }
  });
  var DynamicTree = /** @class */
  function () {
    function DynamicTree2() {
      this.inputPool = new Pool({
        create: function create() {
          return {};
        },
        release: function release(stack) {}
      });
      this.stackPool = new Pool({
        create: function create() {
          return [];
        },
        release: function release(stack) {
          stack.length = 0;
        }
      });
      this.iteratorPool = new Pool({
        create: function create() {
          return new Iterator();
        },
        release: function release(iterator) {
          iterator.close();
        }
      });
      this.m_root = null;
      this.m_nodes = {};
      this.m_lastProxyId = 0;
    }
    DynamicTree2.prototype.getUserData = function (id) {
      var node = this.m_nodes[id];
      return node.userData;
    };
    DynamicTree2.prototype.getFatAABB = function (id) {
      var node = this.m_nodes[id];
      return node.aabb;
    };
    DynamicTree2.prototype.allocateNode = function () {
      var node = poolTreeNode.allocate();
      node.id = ++this.m_lastProxyId;
      this.m_nodes[node.id] = node;
      return node;
    };
    DynamicTree2.prototype.freeNode = function (node) {
      delete this.m_nodes[node.id];
      poolTreeNode.release(node);
    };
    DynamicTree2.prototype.createProxy = function (aabb, userData) {
      var node = this.allocateNode();
      node.aabb.set(aabb);
      AABB.extend(node.aabb, SettingsInternal.aabbExtension);
      node.userData = userData;
      node.height = 0;
      this.insertLeaf(node);
      return node.id;
    };
    DynamicTree2.prototype.destroyProxy = function (id) {
      var node = this.m_nodes[id];
      this.removeLeaf(node);
      this.freeNode(node);
    };
    DynamicTree2.prototype.moveProxy = function (id, aabb, d2) {
      var node = this.m_nodes[id];
      if (node.aabb.contains(aabb)) {
        return false;
      }
      this.removeLeaf(node);
      node.aabb.set(aabb);
      aabb = node.aabb;
      AABB.extend(aabb, SettingsInternal.aabbExtension);
      if (d2.x < 0) {
        aabb.lowerBound.x += d2.x * SettingsInternal.aabbMultiplier;
      } else {
        aabb.upperBound.x += d2.x * SettingsInternal.aabbMultiplier;
      }
      if (d2.y < 0) {
        aabb.lowerBound.y += d2.y * SettingsInternal.aabbMultiplier;
      } else {
        aabb.upperBound.y += d2.y * SettingsInternal.aabbMultiplier;
      }
      this.insertLeaf(node);
      return true;
    };
    DynamicTree2.prototype.insertLeaf = function (leaf) {
      if (this.m_root == null) {
        this.m_root = leaf;
        this.m_root.parent = null;
        return;
      }
      var leafAABB = leaf.aabb;
      var index = this.m_root;
      while (!index.isLeaf()) {
        var child1 = index.child1;
        var child2 = index.child2;
        var area = index.aabb.getPerimeter();
        var combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);
        var cost = 2 * combinedArea;
        var inheritanceCost = 2 * (combinedArea - area);
        var newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);
        var cost1 = newArea1 + inheritanceCost;
        if (!child1.isLeaf()) {
          var oldArea = child1.aabb.getPerimeter();
          cost1 -= oldArea;
        }
        var newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);
        var cost2 = newArea2 + inheritanceCost;
        if (!child2.isLeaf()) {
          var oldArea = child2.aabb.getPerimeter();
          cost2 -= oldArea;
        }
        if (cost < cost1 && cost < cost2) {
          break;
        }
        if (cost1 < cost2) {
          index = child1;
        } else {
          index = child2;
        }
      }
      var sibling = index;
      var oldParent = sibling.parent;
      var newParent = this.allocateNode();
      newParent.parent = oldParent;
      newParent.userData = null;
      newParent.aabb.combine(leafAABB, sibling.aabb);
      newParent.height = sibling.height + 1;
      if (oldParent != null) {
        if (oldParent.child1 === sibling) {
          oldParent.child1 = newParent;
        } else {
          oldParent.child2 = newParent;
        }
        newParent.child1 = sibling;
        newParent.child2 = leaf;
        sibling.parent = newParent;
        leaf.parent = newParent;
      } else {
        newParent.child1 = sibling;
        newParent.child2 = leaf;
        sibling.parent = newParent;
        leaf.parent = newParent;
        this.m_root = newParent;
      }
      index = leaf.parent;
      while (index != null) {
        index = this.balance(index);
        var child1 = index.child1;
        var child2 = index.child2;
        index.height = 1 + math_max$9(child1.height, child2.height);
        index.aabb.combine(child1.aabb, child2.aabb);
        index = index.parent;
      }
    };
    DynamicTree2.prototype.removeLeaf = function (leaf) {
      if (leaf === this.m_root) {
        this.m_root = null;
        return;
      }
      var parent = leaf.parent;
      var grandParent = parent.parent;
      var sibling;
      if (parent.child1 === leaf) {
        sibling = parent.child2;
      } else {
        sibling = parent.child1;
      }
      if (grandParent != null) {
        if (grandParent.child1 === parent) {
          grandParent.child1 = sibling;
        } else {
          grandParent.child2 = sibling;
        }
        sibling.parent = grandParent;
        this.freeNode(parent);
        var index = grandParent;
        while (index != null) {
          index = this.balance(index);
          var child1 = index.child1;
          var child2 = index.child2;
          index.aabb.combine(child1.aabb, child2.aabb);
          index.height = 1 + math_max$9(child1.height, child2.height);
          index = index.parent;
        }
      } else {
        this.m_root = sibling;
        sibling.parent = null;
        this.freeNode(parent);
      }
    };
    DynamicTree2.prototype.balance = function (iA) {
      var A = iA;
      if (A.isLeaf() || A.height < 2) {
        return iA;
      }
      var B = A.child1;
      var C = A.child2;
      var balance = C.height - B.height;
      if (balance > 1) {
        var F = C.child1;
        var G = C.child2;
        C.child1 = A;
        C.parent = A.parent;
        A.parent = C;
        if (C.parent != null) {
          if (C.parent.child1 === iA) {
            C.parent.child1 = C;
          } else {
            C.parent.child2 = C;
          }
        } else {
          this.m_root = C;
        }
        if (F.height > G.height) {
          C.child2 = F;
          A.child2 = G;
          G.parent = A;
          A.aabb.combine(B.aabb, G.aabb);
          C.aabb.combine(A.aabb, F.aabb);
          A.height = 1 + math_max$9(B.height, G.height);
          C.height = 1 + math_max$9(A.height, F.height);
        } else {
          C.child2 = G;
          A.child2 = F;
          F.parent = A;
          A.aabb.combine(B.aabb, F.aabb);
          C.aabb.combine(A.aabb, G.aabb);
          A.height = 1 + math_max$9(B.height, F.height);
          C.height = 1 + math_max$9(A.height, G.height);
        }
        return C;
      }
      if (balance < -1) {
        var D = B.child1;
        var E = B.child2;
        B.child1 = A;
        B.parent = A.parent;
        A.parent = B;
        if (B.parent != null) {
          if (B.parent.child1 === A) {
            B.parent.child1 = B;
          } else {
            B.parent.child2 = B;
          }
        } else {
          this.m_root = B;
        }
        if (D.height > E.height) {
          B.child2 = D;
          A.child1 = E;
          E.parent = A;
          A.aabb.combine(C.aabb, E.aabb);
          B.aabb.combine(A.aabb, D.aabb);
          A.height = 1 + math_max$9(C.height, E.height);
          B.height = 1 + math_max$9(A.height, D.height);
        } else {
          B.child2 = E;
          A.child1 = D;
          D.parent = A;
          A.aabb.combine(C.aabb, D.aabb);
          B.aabb.combine(A.aabb, E.aabb);
          A.height = 1 + math_max$9(C.height, D.height);
          B.height = 1 + math_max$9(A.height, E.height);
        }
        return B;
      }
      return A;
    };
    DynamicTree2.prototype.getHeight = function () {
      if (this.m_root == null) {
        return 0;
      }
      return this.m_root.height;
    };
    DynamicTree2.prototype.getAreaRatio = function () {
      if (this.m_root == null) {
        return 0;
      }
      var root = this.m_root;
      var rootArea = root.aabb.getPerimeter();
      var totalArea = 0;
      var node;
      var it = this.iteratorPool.allocate().preorder(this.m_root);
      while (node = it.next()) {
        if (node.height < 0) {
          continue;
        }
        totalArea += node.aabb.getPerimeter();
      }
      this.iteratorPool.release(it);
      return totalArea / rootArea;
    };
    DynamicTree2.prototype.computeHeight = function (id) {
      var node;
      if (typeof id !== "undefined") {
        node = this.m_nodes[id];
      } else {
        node = this.m_root;
      }
      if (node.isLeaf()) {
        return 0;
      }
      var height1 = this.computeHeight(node.child1.id);
      var height2 = this.computeHeight(node.child2.id);
      return 1 + math_max$9(height1, height2);
    };
    DynamicTree2.prototype.validateStructure = function (node) {
      if (node == null) {
        return;
      }
      if (node === this.m_root) ;
      var child1 = node.child1;
      var child2 = node.child2;
      if (node.isLeaf()) {
        return;
      }
      this.validateStructure(child1);
      this.validateStructure(child2);
    };
    DynamicTree2.prototype.validateMetrics = function (node) {
      if (node == null) {
        return;
      }
      var child1 = node.child1;
      var child2 = node.child2;
      if (node.isLeaf()) {
        return;
      }
      child1.height;
      child2.height;
      var aabb = new AABB();
      aabb.combine(child1.aabb, child2.aabb);
      this.validateMetrics(child1);
      this.validateMetrics(child2);
    };
    DynamicTree2.prototype.validate = function () {
      return;
    };
    DynamicTree2.prototype.getMaxBalance = function () {
      var maxBalance = 0;
      var node;
      var it = this.iteratorPool.allocate().preorder(this.m_root);
      while (node = it.next()) {
        if (node.height <= 1) {
          continue;
        }
        var balance = math_abs$9(node.child2.height - node.child1.height);
        maxBalance = math_max$9(maxBalance, balance);
      }
      this.iteratorPool.release(it);
      return maxBalance;
    };
    DynamicTree2.prototype.rebuildBottomUp = function () {
      var nodes = [];
      var count = 0;
      var node;
      var it = this.iteratorPool.allocate().preorder(this.m_root);
      while (node = it.next()) {
        if (node.height < 0) {
          continue;
        }
        if (node.isLeaf()) {
          node.parent = null;
          nodes[count] = node;
          ++count;
        } else {
          this.freeNode(node);
        }
      }
      this.iteratorPool.release(it);
      while (count > 1) {
        var minCost = Infinity;
        var iMin = -1;
        var jMin = -1;
        for (var i = 0; i < count; ++i) {
          var aabbi = nodes[i].aabb;
          for (var j = i + 1; j < count; ++j) {
            var aabbj = nodes[j].aabb;
            var cost = AABB.combinedPerimeter(aabbi, aabbj);
            if (cost < minCost) {
              iMin = i;
              jMin = j;
              minCost = cost;
            }
          }
        }
        var child1 = nodes[iMin];
        var child2 = nodes[jMin];
        var parent_1 = this.allocateNode();
        parent_1.child1 = child1;
        parent_1.child2 = child2;
        parent_1.height = 1 + math_max$9(child1.height, child2.height);
        parent_1.aabb.combine(child1.aabb, child2.aabb);
        parent_1.parent = null;
        child1.parent = parent_1;
        child2.parent = parent_1;
        nodes[jMin] = nodes[count - 1];
        nodes[iMin] = parent_1;
        --count;
      }
      this.m_root = nodes[0];
    };
    DynamicTree2.prototype.shiftOrigin = function (newOrigin) {
      var node;
      var it = this.iteratorPool.allocate().preorder(this.m_root);
      while (node = it.next()) {
        var aabb = node.aabb;
        aabb.lowerBound.x -= newOrigin.x;
        aabb.lowerBound.y -= newOrigin.y;
        aabb.upperBound.x -= newOrigin.x;
        aabb.upperBound.y -= newOrigin.y;
      }
      this.iteratorPool.release(it);
    };
    DynamicTree2.prototype.query = function (aabb, queryCallback) {
      var stack = this.stackPool.allocate();
      stack.push(this.m_root);
      while (stack.length > 0) {
        var node = stack.pop();
        if (node == null) {
          continue;
        }
        if (AABB.testOverlap(node.aabb, aabb)) {
          if (node.isLeaf()) {
            var proceed = queryCallback(node.id);
            if (proceed === false) {
              return;
            }
          } else {
            stack.push(node.child1);
            stack.push(node.child2);
          }
        }
      }
      this.stackPool.release(stack);
    };
    DynamicTree2.prototype.rayCast = function (input2, rayCastCallback) {
      var p1 = input2.p1;
      var p2 = input2.p2;
      var r = Vec2.sub(p2, p1);
      r.normalize();
      var v3 = Vec2.crossNumVec2(1, r);
      var abs_v = Vec2.abs(v3);
      var maxFraction = input2.maxFraction;
      var segmentAABB = new AABB();
      var t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);
      segmentAABB.combinePoints(p1, t);
      var stack = this.stackPool.allocate();
      var subInput = this.inputPool.allocate();
      stack.push(this.m_root);
      while (stack.length > 0) {
        var node = stack.pop();
        if (node == null) {
          continue;
        }
        if (AABB.testOverlap(node.aabb, segmentAABB) === false) {
          continue;
        }
        var c2 = node.aabb.getCenter();
        var h = node.aabb.getExtents();
        var separation = math_abs$9(Vec2.dot(v3, Vec2.sub(p1, c2))) - Vec2.dot(abs_v, h);
        if (separation > 0) {
          continue;
        }
        if (node.isLeaf()) {
          subInput.p1 = Vec2.clone(input2.p1);
          subInput.p2 = Vec2.clone(input2.p2);
          subInput.maxFraction = maxFraction;
          var value = rayCastCallback(subInput, node.id);
          if (value === 0) {
            break;
          } else if (value > 0) {
            maxFraction = value;
            t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);
            segmentAABB.combinePoints(p1, t);
          }
        } else {
          stack.push(node.child1);
          stack.push(node.child2);
        }
      }
      this.stackPool.release(stack);
      this.inputPool.release(subInput);
    };
    return DynamicTree2;
  }();
  var Iterator = /** @class */
  function () {
    function Iterator2() {
      this.parents = [];
      this.states = [];
    }
    Iterator2.prototype.preorder = function (root) {
      this.parents.length = 0;
      this.parents.push(root);
      this.states.length = 0;
      this.states.push(0);
      return this;
    };
    Iterator2.prototype.next = function () {
      while (this.parents.length > 0) {
        var i = this.parents.length - 1;
        var node = this.parents[i];
        if (this.states[i] === 0) {
          this.states[i] = 1;
          return node;
        }
        if (this.states[i] === 1) {
          this.states[i] = 2;
          if (node.child1) {
            this.parents.push(node.child1);
            this.states.push(1);
            return node.child1;
          }
        }
        if (this.states[i] === 2) {
          this.states[i] = 3;
          if (node.child2) {
            this.parents.push(node.child2);
            this.states.push(1);
            return node.child2;
          }
        }
        this.parents.pop();
        this.states.pop();
      }
    };
    Iterator2.prototype.close = function () {
      this.parents.length = 0;
    };
    return Iterator2;
  }();
  var math_max$8 = Math.max;
  var math_min$b = Math.min;
  var BroadPhase = /** @class */
  function () {
    function BroadPhase2() {
      var _this = this;
      this.m_tree = new DynamicTree();
      this.m_moveBuffer = [];
      this.query = function (aabb, queryCallback) {
        _this.m_tree.query(aabb, queryCallback);
      };
      this.queryCallback = function (proxyId) {
        if (proxyId === _this.m_queryProxyId) {
          return true;
        }
        var proxyIdA = math_min$b(proxyId, _this.m_queryProxyId);
        var proxyIdB = math_max$8(proxyId, _this.m_queryProxyId);
        var userDataA = _this.m_tree.getUserData(proxyIdA);
        var userDataB = _this.m_tree.getUserData(proxyIdB);
        _this.m_callback(userDataA, userDataB);
        return true;
      };
    }
    BroadPhase2.prototype.getUserData = function (proxyId) {
      return this.m_tree.getUserData(proxyId);
    };
    BroadPhase2.prototype.testOverlap = function (proxyIdA, proxyIdB) {
      var aabbA = this.m_tree.getFatAABB(proxyIdA);
      var aabbB = this.m_tree.getFatAABB(proxyIdB);
      return AABB.testOverlap(aabbA, aabbB);
    };
    BroadPhase2.prototype.getFatAABB = function (proxyId) {
      return this.m_tree.getFatAABB(proxyId);
    };
    BroadPhase2.prototype.getProxyCount = function () {
      return this.m_moveBuffer.length;
    };
    BroadPhase2.prototype.getTreeHeight = function () {
      return this.m_tree.getHeight();
    };
    BroadPhase2.prototype.getTreeBalance = function () {
      return this.m_tree.getMaxBalance();
    };
    BroadPhase2.prototype.getTreeQuality = function () {
      return this.m_tree.getAreaRatio();
    };
    BroadPhase2.prototype.rayCast = function (input2, rayCastCallback) {
      this.m_tree.rayCast(input2, rayCastCallback);
    };
    BroadPhase2.prototype.shiftOrigin = function (newOrigin) {
      this.m_tree.shiftOrigin(newOrigin);
    };
    BroadPhase2.prototype.createProxy = function (aabb, userData) {
      var proxyId = this.m_tree.createProxy(aabb, userData);
      this.bufferMove(proxyId);
      return proxyId;
    };
    BroadPhase2.prototype.destroyProxy = function (proxyId) {
      this.unbufferMove(proxyId);
      this.m_tree.destroyProxy(proxyId);
    };
    BroadPhase2.prototype.moveProxy = function (proxyId, aabb, displacement2) {
      var changed = this.m_tree.moveProxy(proxyId, aabb, displacement2);
      if (changed) {
        this.bufferMove(proxyId);
      }
    };
    BroadPhase2.prototype.touchProxy = function (proxyId) {
      this.bufferMove(proxyId);
    };
    BroadPhase2.prototype.bufferMove = function (proxyId) {
      this.m_moveBuffer.push(proxyId);
    };
    BroadPhase2.prototype.unbufferMove = function (proxyId) {
      for (var i = 0; i < this.m_moveBuffer.length; ++i) {
        if (this.m_moveBuffer[i] === proxyId) {
          this.m_moveBuffer[i] = null;
        }
      }
    };
    BroadPhase2.prototype.updatePairs = function (addPairCallback) {
      this.m_callback = addPairCallback;
      while (this.m_moveBuffer.length > 0) {
        this.m_queryProxyId = this.m_moveBuffer.pop();
        if (this.m_queryProxyId === null) {
          continue;
        }
        var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);
        this.m_tree.query(fatAABB, this.queryCallback);
      }
    };
    return BroadPhase2;
  }();
  var math_sin$2 = Math.sin;
  var math_cos$2 = Math.cos;
  var math_sqrt$7 = Math.sqrt;
  function vec2(x2, y) {
    return {
      x: x2,
      y: y
    };
  }
  function rotation(angle) {
    return {
      s: math_sin$2(angle),
      c: math_cos$2(angle)
    };
  }
  function setVec2(out, x2, y) {
    out.x = x2;
    out.y = y;
    return out;
  }
  function copyVec2(out, w) {
    out.x = w.x;
    out.y = w.y;
    return out;
  }
  function zeroVec2(out) {
    out.x = 0;
    out.y = 0;
    return out;
  }
  function negVec2(out) {
    out.x = -out.x;
    out.y = -out.y;
    return out;
  }
  function plusVec2(out, w) {
    out.x += w.x;
    out.y += w.y;
    return out;
  }
  function addVec2(out, v3, w) {
    out.x = v3.x + w.x;
    out.y = v3.x + w.y;
    return out;
  }
  function minusVec2(out, w) {
    out.x -= w.x;
    out.y -= w.y;
    return out;
  }
  function subVec2(out, v3, w) {
    out.x = v3.x - w.x;
    out.y = v3.y - w.y;
    return out;
  }
  function mulVec2(out, m) {
    out.x *= m;
    out.y *= m;
    return out;
  }
  function scaleVec2(out, m, w) {
    out.x = m * w.x;
    out.y = m * w.y;
    return out;
  }
  function plusScaleVec2(out, m, w) {
    out.x += m * w.x;
    out.y += m * w.y;
    return out;
  }
  function minusScaleVec2(out, m, w) {
    out.x -= m * w.x;
    out.y -= m * w.y;
    return out;
  }
  function combine2Vec2(out, am, a2, bm, b2) {
    out.x = am * a2.x + bm * b2.x;
    out.y = am * a2.y + bm * b2.y;
    return out;
  }
  function combine3Vec2(out, am, a2, bm, b2, cm, c2) {
    out.x = am * a2.x + bm * b2.x + cm * c2.x;
    out.y = am * a2.y + bm * b2.y + cm * c2.y;
    return out;
  }
  function normalizeVec2Length(out) {
    var length2 = math_sqrt$7(out.x * out.x + out.y * out.y);
    if (length2 !== 0) {
      var invLength = 1 / length2;
      out.x *= invLength;
      out.y *= invLength;
    }
    return length2;
  }
  function normalizeVec2(out) {
    var length2 = math_sqrt$7(out.x * out.x + out.y * out.y);
    if (length2 > 0) {
      var invLength = 1 / length2;
      out.x *= invLength;
      out.y *= invLength;
    }
    return out;
  }
  function crossVec2Num(out, v3, w) {
    var x2 = w * v3.y;
    var y = -w * v3.x;
    out.x = x2;
    out.y = y;
    return out;
  }
  function crossNumVec2(out, w, v3) {
    var x2 = -w * v3.y;
    var y = w * v3.x;
    out.x = x2;
    out.y = y;
    return out;
  }
  function crossVec2Vec2(a2, b2) {
    return a2.x * b2.y - a2.y * b2.x;
  }
  function dotVec2(a2, b2) {
    return a2.x * b2.x + a2.y * b2.y;
  }
  function lengthSqrVec2(a2) {
    return a2.x * a2.x + a2.y * a2.y;
  }
  function distVec2(a2, b2) {
    var dx = a2.x - b2.x;
    var dy = a2.y - b2.y;
    return math_sqrt$7(dx * dx + dy * dy);
  }
  function distSqrVec2(a2, b2) {
    var dx = a2.x - b2.x;
    var dy = a2.y - b2.y;
    return dx * dx + dy * dy;
  }
  function setRotAngle(out, a2) {
    out.c = math_cos$2(a2);
    out.s = math_sin$2(a2);
    return out;
  }
  function rotVec2(out, q, v3) {
    out.x = q.c * v3.x - q.s * v3.y;
    out.y = q.s * v3.x + q.c * v3.y;
    return out;
  }
  function derotVec2(out, q, v3) {
    var x2 = q.c * v3.x + q.s * v3.y;
    var y = -q.s * v3.x + q.c * v3.y;
    out.x = x2;
    out.y = y;
    return out;
  }
  function rerotVec2(out, before, after, v3) {
    var x0 = before.c * v3.x + before.s * v3.y;
    var y0 = -before.s * v3.x + before.c * v3.y;
    var x2 = after.c * x0 - after.s * y0;
    var y = after.s * x0 + after.c * y0;
    out.x = x2;
    out.y = y;
    return out;
  }
  function transform(x2, y, a2) {
    return {
      p: vec2(x2, y),
      q: rotation(a2)
    };
  }
  function copyTransform(out, transform2) {
    out.p.x = transform2.p.x;
    out.p.y = transform2.p.y;
    out.q.s = transform2.q.s;
    out.q.c = transform2.q.c;
    return out;
  }
  function transformVec2(out, xf2, v3) {
    var x2 = xf2.q.c * v3.x - xf2.q.s * v3.y + xf2.p.x;
    var y = xf2.q.s * v3.x + xf2.q.c * v3.y + xf2.p.y;
    out.x = x2;
    out.y = y;
    return out;
  }
  function detransformVec2(out, xf2, v3) {
    var px = v3.x - xf2.p.x;
    var py = v3.y - xf2.p.y;
    var x2 = xf2.q.c * px + xf2.q.s * py;
    var y = -xf2.q.s * px + xf2.q.c * py;
    out.x = x2;
    out.y = y;
    return out;
  }
  function retransformVec2(out, from, to, v3) {
    var x0 = from.q.c * v3.x - from.q.s * v3.y + from.p.x;
    var y0 = from.q.s * v3.x + from.q.c * v3.y + from.p.y;
    var px = x0 - to.p.x;
    var py = y0 - to.p.y;
    var x2 = to.q.c * px + to.q.s * py;
    var y = -to.q.s * px + to.q.c * py;
    out.x = x2;
    out.y = y;
    return out;
  }
  function detransformTransform(out, a2, b2) {
    var c2 = a2.q.c * b2.q.c + a2.q.s * b2.q.s;
    var s2 = a2.q.c * b2.q.s - a2.q.s * b2.q.c;
    var x2 = a2.q.c * (b2.p.x - a2.p.x) + a2.q.s * (b2.p.y - a2.p.y);
    var y = -a2.q.s * (b2.p.x - a2.p.x) + a2.q.c * (b2.p.y - a2.p.y);
    out.q.c = c2;
    out.q.s = s2;
    out.p.x = x2;
    out.p.y = y;
    return out;
  }
  var math_sin$1 = Math.sin;
  var math_cos$1 = Math.cos;
  var math_atan2$3 = Math.atan2;
  var Rot = /** @class */
  function () {
    function Rot2(angle) {
      if (!(this instanceof Rot2)) {
        return new Rot2(angle);
      }
      if (typeof angle === "number") {
        this.setAngle(angle);
      } else if (_typeof(angle) === "object") {
        this.setRot(angle);
      } else {
        this.setIdentity();
      }
    }
    Rot2.neo = function (angle) {
      var obj = Object.create(Rot2.prototype);
      obj.setAngle(angle);
      return obj;
    };
    Rot2.clone = function (rot) {
      var obj = Object.create(Rot2.prototype);
      obj.s = rot.s;
      obj.c = rot.c;
      return obj;
    };
    Rot2.identity = function () {
      var obj = Object.create(Rot2.prototype);
      obj.s = 0;
      obj.c = 1;
      return obj;
    };
    Rot2.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Number.isFinite(obj.s) && Number.isFinite(obj.c);
    };
    Rot2.assert = function (o) {};
    Rot2.prototype.setIdentity = function () {
      this.s = 0;
      this.c = 1;
    };
    Rot2.prototype.set = function (angle) {
      if (_typeof(angle) === "object") {
        this.s = angle.s;
        this.c = angle.c;
      } else {
        this.s = math_sin$1(angle);
        this.c = math_cos$1(angle);
      }
    };
    Rot2.prototype.setRot = function (angle) {
      this.s = angle.s;
      this.c = angle.c;
    };
    Rot2.prototype.setAngle = function (angle) {
      this.s = math_sin$1(angle);
      this.c = math_cos$1(angle);
    };
    Rot2.prototype.getAngle = function () {
      return math_atan2$3(this.s, this.c);
    };
    Rot2.prototype.getXAxis = function () {
      return Vec2.neo(this.c, this.s);
    };
    Rot2.prototype.getYAxis = function () {
      return Vec2.neo(-this.s, this.c);
    };
    Rot2.mul = function (rot, m) {
      if ("c" in m && "s" in m) {
        var qr = Rot2.identity();
        qr.s = rot.s * m.c + rot.c * m.s;
        qr.c = rot.c * m.c - rot.s * m.s;
        return qr;
      } else if ("x" in m && "y" in m) {
        return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
      }
    };
    Rot2.mulRot = function (rot, m) {
      var qr = Rot2.identity();
      qr.s = rot.s * m.c + rot.c * m.s;
      qr.c = rot.c * m.c - rot.s * m.s;
      return qr;
    };
    Rot2.mulVec2 = function (rot, m) {
      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
    };
    Rot2.mulSub = function (rot, v3, w) {
      var x2 = rot.c * (v3.x - w.x) - rot.s * (v3.y - w.y);
      var y = rot.s * (v3.x - w.x) + rot.c * (v3.y - w.y);
      return Vec2.neo(x2, y);
    };
    Rot2.mulT = function (rot, m) {
      if ("c" in m && "s" in m) {
        var qr = Rot2.identity();
        qr.s = rot.c * m.s - rot.s * m.c;
        qr.c = rot.c * m.c + rot.s * m.s;
        return qr;
      } else if ("x" in m && "y" in m) {
        return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
      }
    };
    Rot2.mulTRot = function (rot, m) {
      var qr = Rot2.identity();
      qr.s = rot.c * m.s - rot.s * m.c;
      qr.c = rot.c * m.c + rot.s * m.s;
      return qr;
    };
    Rot2.mulTVec2 = function (rot, m) {
      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
    };
    return Rot2;
  }();
  var math_atan2$2 = Math.atan2;
  var math_PI$7 = Math.PI;
  var temp$7 = vec2(0, 0);
  var Sweep = /** @class */
  function () {
    function Sweep2() {
      this.localCenter = Vec2.zero();
      this.c = Vec2.zero();
      this.a = 0;
      this.alpha0 = 0;
      this.c0 = Vec2.zero();
      this.a0 = 0;
    }
    Sweep2.prototype.recycle = function () {
      zeroVec2(this.localCenter);
      zeroVec2(this.c);
      this.a = 0;
      this.alpha0 = 0;
      zeroVec2(this.c0);
      this.a0 = 0;
    };
    Sweep2.prototype.setTransform = function (xf2) {
      transformVec2(temp$7, xf2, this.localCenter);
      copyVec2(this.c, temp$7);
      copyVec2(this.c0, temp$7);
      this.a = this.a0 = math_atan2$2(xf2.q.s, xf2.q.c);
    };
    Sweep2.prototype.setLocalCenter = function (localCenter2, xf2) {
      copyVec2(this.localCenter, localCenter2);
      transformVec2(temp$7, xf2, this.localCenter);
      copyVec2(this.c, temp$7);
      copyVec2(this.c0, temp$7);
    };
    Sweep2.prototype.getTransform = function (xf2, beta) {
      if (beta === void 0) {
        beta = 0;
      }
      setRotAngle(xf2.q, (1 - beta) * this.a0 + beta * this.a);
      combine2Vec2(xf2.p, 1 - beta, this.c0, beta, this.c);
      minusVec2(xf2.p, rotVec2(temp$7, xf2.q, this.localCenter));
    };
    Sweep2.prototype.advance = function (alpha) {
      var beta = (alpha - this.alpha0) / (1 - this.alpha0);
      combine2Vec2(this.c0, beta, this.c, 1 - beta, this.c0);
      this.a0 = beta * this.a + (1 - beta) * this.a0;
      this.alpha0 = alpha;
    };
    Sweep2.prototype.forward = function () {
      this.a0 = this.a;
      copyVec2(this.c0, this.c);
    };
    Sweep2.prototype.normalize = function () {
      var a0 = mod(this.a0, -math_PI$7, +math_PI$7);
      this.a -= this.a0 - a0;
      this.a0 = a0;
    };
    Sweep2.prototype.set = function (that) {
      copyVec2(this.localCenter, that.localCenter);
      copyVec2(this.c, that.c);
      this.a = that.a;
      this.alpha0 = that.alpha0;
      copyVec2(this.c0, that.c0);
      this.a0 = that.a0;
    };
    return Sweep2;
  }();
  var Transform = /** @class */
  function () {
    function Transform2(position, rotation2) {
      if (!(this instanceof Transform2)) {
        return new Transform2(position, rotation2);
      }
      this.p = Vec2.zero();
      this.q = Rot.identity();
      if (typeof position !== "undefined") {
        this.p.setVec2(position);
      }
      if (typeof rotation2 !== "undefined") {
        this.q.setAngle(rotation2);
      }
    }
    Transform2.clone = function (xf2) {
      var obj = Object.create(Transform2.prototype);
      obj.p = Vec2.clone(xf2.p);
      obj.q = Rot.clone(xf2.q);
      return obj;
    };
    Transform2.neo = function (position, rotation2) {
      var obj = Object.create(Transform2.prototype);
      obj.p = Vec2.clone(position);
      obj.q = Rot.clone(rotation2);
      return obj;
    };
    Transform2.identity = function () {
      var obj = Object.create(Transform2.prototype);
      obj.p = Vec2.zero();
      obj.q = Rot.identity();
      return obj;
    };
    Transform2.prototype.setIdentity = function () {
      this.p.setZero();
      this.q.setIdentity();
    };
    Transform2.prototype.set = function (a2, b2) {
      if (typeof b2 === "undefined") {
        this.p.set(a2.p);
        this.q.set(a2.q);
      } else {
        this.p.set(a2);
        this.q.set(b2);
      }
    };
    Transform2.prototype.setNum = function (position, rotation2) {
      this.p.setVec2(position);
      this.q.setAngle(rotation2);
    };
    Transform2.prototype.setTransform = function (xf2) {
      this.p.setVec2(xf2.p);
      this.q.setRot(xf2.q);
    };
    Transform2.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Vec2.isValid(obj.p) && Rot.isValid(obj.q);
    };
    Transform2.assert = function (o) {};
    Transform2.mul = function (a2, b2) {
      if (Array.isArray(b2)) {
        var arr = [];
        for (var i = 0; i < b2.length; i++) {
          arr[i] = Transform2.mul(a2, b2[i]);
        }
        return arr;
      } else if ("x" in b2 && "y" in b2) {
        return Transform2.mulVec2(a2, b2);
      } else if ("p" in b2 && "q" in b2) {
        return Transform2.mulXf(a2, b2);
      }
    };
    Transform2.mulAll = function (a2, b2) {
      var arr = [];
      for (var i = 0; i < b2.length; i++) {
        arr[i] = Transform2.mul(a2, b2[i]);
      }
      return arr;
    };
    Transform2.mulFn = function (a2) {
      return function (b2) {
        return Transform2.mul(a2, b2);
      };
    };
    Transform2.mulVec2 = function (a2, b2) {
      var x2 = a2.q.c * b2.x - a2.q.s * b2.y + a2.p.x;
      var y = a2.q.s * b2.x + a2.q.c * b2.y + a2.p.y;
      return Vec2.neo(x2, y);
    };
    Transform2.mulXf = function (a2, b2) {
      var xf2 = Transform2.identity();
      xf2.q = Rot.mulRot(a2.q, b2.q);
      xf2.p = Vec2.add(Rot.mulVec2(a2.q, b2.p), a2.p);
      return xf2;
    };
    Transform2.mulT = function (a2, b2) {
      if ("x" in b2 && "y" in b2) {
        return Transform2.mulTVec2(a2, b2);
      } else if ("p" in b2 && "q" in b2) {
        return Transform2.mulTXf(a2, b2);
      }
    };
    Transform2.mulTVec2 = function (a2, b2) {
      var px = b2.x - a2.p.x;
      var py = b2.y - a2.p.y;
      var x2 = a2.q.c * px + a2.q.s * py;
      var y = -a2.q.s * px + a2.q.c * py;
      return Vec2.neo(x2, y);
    };
    Transform2.mulTXf = function (a2, b2) {
      var xf2 = Transform2.identity();
      xf2.q.setRot(Rot.mulTRot(a2.q, b2.q));
      xf2.p.setVec2(Rot.mulTVec2(a2.q, Vec2.sub(b2.p, a2.p)));
      return xf2;
    };
    return Transform2;
  }();
  var Velocity = /** @class */
  /* @__PURE__ */function () {
    function Velocity2() {
      this.v = Vec2.zero();
      this.w = 0;
    }
    return Velocity2;
  }();
  var math_sin = Math.sin;
  var math_cos = Math.cos;
  var Position = /** @class */
  function () {
    function Position2() {
      this.c = Vec2.zero();
      this.a = 0;
    }
    Position2.prototype.getTransform = function (xf2, p) {
      xf2.q.c = math_cos(this.a);
      xf2.q.s = math_sin(this.a);
      xf2.p.x = this.c.x - (xf2.q.c * p.x - xf2.q.s * p.y);
      xf2.p.y = this.c.y - (xf2.q.s * p.x + xf2.q.c * p.y);
      return xf2;
    };
    return Position2;
  }();
  function getTransform(xf2, p, c2, a2) {
    xf2.q.c = math_cos(a2);
    xf2.q.s = math_sin(a2);
    xf2.p.x = c2.x - (xf2.q.c * p.x - xf2.q.s * p.y);
    xf2.p.y = c2.y - (xf2.q.s * p.x + xf2.q.c * p.y);
    return xf2;
  }
  var Shape = /** @class */
  function () {
    function Shape2() {
      this.style = {};
      this.appData = {};
    }
    Shape2.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return typeof obj.m_type === "string" && typeof obj.m_radius === "number";
    };
    return Shape2;
  }();
  var synchronize_aabb1 = new AABB();
  var synchronize_aabb2 = new AABB();
  var displacement = vec2(0, 0);
  var FixtureDefDefault = {
    userData: null,
    friction: 0.2,
    restitution: 0,
    density: 0,
    isSensor: false,
    filterGroupIndex: 0,
    filterCategoryBits: 1,
    filterMaskBits: 65535
  };
  var FixtureProxy = /** @class */
  /* @__PURE__ */function () {
    function FixtureProxy2(fixture, childIndex) {
      this.aabb = new AABB();
      this.fixture = fixture;
      this.childIndex = childIndex;
    }
    return FixtureProxy2;
  }();
  var Fixture = /** @class */
  function () {
    function Fixture2(body, shape, def) {
      this.style = {};
      this.appData = {};
      if (shape.shape) {
        def = shape;
        shape = shape.shape;
      } else if (typeof def === "number") {
        def = {
          density: def
        };
      }
      def = options(def, FixtureDefDefault);
      this.m_body = body;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_density = def.density;
      this.m_isSensor = def.isSensor;
      this.m_filterGroupIndex = def.filterGroupIndex;
      this.m_filterCategoryBits = def.filterCategoryBits;
      this.m_filterMaskBits = def.filterMaskBits;
      this.m_shape = shape;
      this.m_next = null;
      this.m_proxies = [];
      this.m_proxyCount = 0;
      var childCount = this.m_shape.getChildCount();
      for (var i = 0; i < childCount; ++i) {
        this.m_proxies[i] = new FixtureProxy(this, i);
      }
      this.m_userData = def.userData;
      if (_typeof(def.style) === "object" && def.style !== null) {
        this.style = def.style;
      }
    }
    Fixture2.prototype._reset = function () {
      var body = this.getBody();
      var broadPhase = body.m_world.m_broadPhase;
      this.destroyProxies(broadPhase);
      if (this.m_shape._reset) {
        this.m_shape._reset();
      }
      var childCount = this.m_shape.getChildCount();
      for (var i = 0; i < childCount; ++i) {
        this.m_proxies[i] = new FixtureProxy(this, i);
      }
      this.createProxies(broadPhase, body.m_xf);
      body.resetMassData();
    };
    Fixture2.prototype._serialize = function () {
      return {
        friction: this.m_friction,
        restitution: this.m_restitution,
        density: this.m_density,
        isSensor: this.m_isSensor,
        filterGroupIndex: this.m_filterGroupIndex,
        filterCategoryBits: this.m_filterCategoryBits,
        filterMaskBits: this.m_filterMaskBits,
        shape: this.m_shape
      };
    };
    Fixture2._deserialize = function (data, body, restore) {
      var shape = restore(Shape, data.shape);
      var fixture = shape && new Fixture2(body, shape, data);
      return fixture;
    };
    Fixture2.prototype.getType = function () {
      return this.m_shape.m_type;
    };
    Fixture2.prototype.getShape = function () {
      return this.m_shape;
    };
    Fixture2.prototype.isSensor = function () {
      return this.m_isSensor;
    };
    Fixture2.prototype.setSensor = function (sensor) {
      if (sensor != this.m_isSensor) {
        this.m_body.setAwake(true);
        this.m_isSensor = sensor;
      }
    };
    Fixture2.prototype.getUserData = function () {
      return this.m_userData;
    };
    Fixture2.prototype.setUserData = function (data) {
      this.m_userData = data;
    };
    Fixture2.prototype.getBody = function () {
      return this.m_body;
    };
    Fixture2.prototype.getNext = function () {
      return this.m_next;
    };
    Fixture2.prototype.getDensity = function () {
      return this.m_density;
    };
    Fixture2.prototype.setDensity = function (density) {
      this.m_density = density;
    };
    Fixture2.prototype.getFriction = function () {
      return this.m_friction;
    };
    Fixture2.prototype.setFriction = function (friction) {
      this.m_friction = friction;
    };
    Fixture2.prototype.getRestitution = function () {
      return this.m_restitution;
    };
    Fixture2.prototype.setRestitution = function (restitution) {
      this.m_restitution = restitution;
    };
    Fixture2.prototype.testPoint = function (p) {
      return this.m_shape.testPoint(this.m_body.getTransform(), p);
    };
    Fixture2.prototype.rayCast = function (output2, input2, childIndex) {
      return this.m_shape.rayCast(output2, input2, this.m_body.getTransform(), childIndex);
    };
    Fixture2.prototype.getMassData = function (massData) {
      this.m_shape.computeMass(massData, this.m_density);
    };
    Fixture2.prototype.getAABB = function (childIndex) {
      return this.m_proxies[childIndex].aabb;
    };
    Fixture2.prototype.createProxies = function (broadPhase, xf2) {
      this.m_proxyCount = this.m_shape.getChildCount();
      for (var i = 0; i < this.m_proxyCount; ++i) {
        var proxy = this.m_proxies[i];
        this.m_shape.computeAABB(proxy.aabb, xf2, i);
        proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
      }
    };
    Fixture2.prototype.destroyProxies = function (broadPhase) {
      for (var i = 0; i < this.m_proxyCount; ++i) {
        var proxy = this.m_proxies[i];
        broadPhase.destroyProxy(proxy.proxyId);
        proxy.proxyId = null;
      }
      this.m_proxyCount = 0;
    };
    Fixture2.prototype.synchronize = function (broadPhase, xf1, xf2) {
      for (var i = 0; i < this.m_proxyCount; ++i) {
        var proxy = this.m_proxies[i];
        this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);
        this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);
        proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);
        subVec2(displacement, xf2.p, xf1.p);
        broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
      }
    };
    Fixture2.prototype.setFilterData = function (filter) {
      this.m_filterGroupIndex = filter.groupIndex;
      this.m_filterCategoryBits = filter.categoryBits;
      this.m_filterMaskBits = filter.maskBits;
      this.refilter();
    };
    Fixture2.prototype.getFilterGroupIndex = function () {
      return this.m_filterGroupIndex;
    };
    Fixture2.prototype.setFilterGroupIndex = function (groupIndex) {
      this.m_filterGroupIndex = groupIndex;
      this.refilter();
    };
    Fixture2.prototype.getFilterCategoryBits = function () {
      return this.m_filterCategoryBits;
    };
    Fixture2.prototype.setFilterCategoryBits = function (categoryBits) {
      this.m_filterCategoryBits = categoryBits;
      this.refilter();
    };
    Fixture2.prototype.getFilterMaskBits = function () {
      return this.m_filterMaskBits;
    };
    Fixture2.prototype.setFilterMaskBits = function (maskBits) {
      this.m_filterMaskBits = maskBits;
      this.refilter();
    };
    Fixture2.prototype.refilter = function () {
      if (this.m_body == null) {
        return;
      }
      var edge = this.m_body.getContactList();
      while (edge) {
        var contact = edge.contact;
        var fixtureA = contact.getFixtureA();
        var fixtureB = contact.getFixtureB();
        if (fixtureA == this || fixtureB == this) {
          contact.flagForFiltering();
        }
        edge = edge.next;
      }
      var world = this.m_body.getWorld();
      if (world == null) {
        return;
      }
      var broadPhase = world.m_broadPhase;
      for (var i = 0; i < this.m_proxyCount; ++i) {
        broadPhase.touchProxy(this.m_proxies[i].proxyId);
      }
    };
    Fixture2.prototype.shouldCollide = function (that) {
      if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {
        return that.m_filterGroupIndex > 0;
      }
      var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;
      var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;
      var collide = collideA && collideB;
      return collide;
    };
    return Fixture2;
  }();
  var STATIC = "static";
  var KINEMATIC = "kinematic";
  var DYNAMIC = "dynamic";
  var oldCenter = vec2(0, 0);
  var localCenter = vec2(0, 0);
  var shift = vec2(0, 0);
  var temp$6 = vec2(0, 0);
  var xf$2 = transform(0, 0, 0);
  var BodyDefDefault = {
    type: STATIC,
    position: Vec2.zero(),
    angle: 0,
    linearVelocity: Vec2.zero(),
    angularVelocity: 0,
    linearDamping: 0,
    angularDamping: 0,
    fixedRotation: false,
    bullet: false,
    gravityScale: 1,
    allowSleep: true,
    awake: true,
    active: true,
    userData: null
  };
  var Body = /** @class */
  function () {
    function Body2(world, def) {
      this.style = {};
      this.appData = {};
      def = options(def, BodyDefDefault);
      this.m_world = world;
      this.m_awakeFlag = def.awake;
      this.m_autoSleepFlag = def.allowSleep;
      this.m_bulletFlag = def.bullet;
      this.m_fixedRotationFlag = def.fixedRotation;
      this.m_activeFlag = def.active;
      this.m_islandFlag = false;
      this.m_toiFlag = false;
      this.m_userData = def.userData;
      this.m_type = def.type;
      if (this.m_type == DYNAMIC) {
        this.m_mass = 1;
        this.m_invMass = 1;
      } else {
        this.m_mass = 0;
        this.m_invMass = 0;
      }
      this.m_I = 0;
      this.m_invI = 0;
      this.m_xf = Transform.identity();
      this.m_xf.p.setVec2(def.position);
      this.m_xf.q.setAngle(def.angle);
      this.m_sweep = new Sweep();
      this.m_sweep.setTransform(this.m_xf);
      this.c_velocity = new Velocity();
      this.c_position = new Position();
      this.m_force = Vec2.zero();
      this.m_torque = 0;
      this.m_linearVelocity = Vec2.clone(def.linearVelocity);
      this.m_angularVelocity = def.angularVelocity;
      this.m_linearDamping = def.linearDamping;
      this.m_angularDamping = def.angularDamping;
      this.m_gravityScale = def.gravityScale;
      this.m_sleepTime = 0;
      this.m_jointList = null;
      this.m_contactList = null;
      this.m_fixtureList = null;
      this.m_prev = null;
      this.m_next = null;
      this.m_destroyed = false;
      if (_typeof(def.style) === "object" && def.style !== null) {
        this.style = def.style;
      }
    }
    Body2.prototype._serialize = function () {
      var fixtures = [];
      for (var f = this.m_fixtureList; f; f = f.m_next) {
        fixtures.push(f);
      }
      return {
        type: this.m_type,
        bullet: this.m_bulletFlag,
        position: this.m_xf.p,
        angle: this.m_xf.q.getAngle(),
        linearVelocity: this.m_linearVelocity,
        angularVelocity: this.m_angularVelocity,
        fixtures: fixtures
      };
    };
    Body2._deserialize = function (data, world, restore) {
      var body = new Body2(world, data);
      if (data.fixtures) {
        for (var i = data.fixtures.length - 1; i >= 0; i--) {
          var fixture = restore(Fixture, data.fixtures[i], body);
          body._addFixture(fixture);
        }
      }
      return body;
    };
    Body2.prototype.isWorldLocked = function () {
      return this.m_world && this.m_world.isLocked() ? true : false;
    };
    Body2.prototype.getWorld = function () {
      return this.m_world;
    };
    Body2.prototype.getNext = function () {
      return this.m_next;
    };
    Body2.prototype.setUserData = function (data) {
      this.m_userData = data;
    };
    Body2.prototype.getUserData = function () {
      return this.m_userData;
    };
    Body2.prototype.getFixtureList = function () {
      return this.m_fixtureList;
    };
    Body2.prototype.getJointList = function () {
      return this.m_jointList;
    };
    Body2.prototype.getContactList = function () {
      return this.m_contactList;
    };
    Body2.prototype.isStatic = function () {
      return this.m_type == STATIC;
    };
    Body2.prototype.isDynamic = function () {
      return this.m_type == DYNAMIC;
    };
    Body2.prototype.isKinematic = function () {
      return this.m_type == KINEMATIC;
    };
    Body2.prototype.setStatic = function () {
      this.setType(STATIC);
      return this;
    };
    Body2.prototype.setDynamic = function () {
      this.setType(DYNAMIC);
      return this;
    };
    Body2.prototype.setKinematic = function () {
      this.setType(KINEMATIC);
      return this;
    };
    Body2.prototype.getType = function () {
      return this.m_type;
    };
    Body2.prototype.setType = function (type) {
      if (this.isWorldLocked() == true) {
        return;
      }
      if (this.m_type == type) {
        return;
      }
      this.m_type = type;
      this.resetMassData();
      if (this.m_type == STATIC) {
        this.m_linearVelocity.setZero();
        this.m_angularVelocity = 0;
        this.m_sweep.forward();
        this.synchronizeFixtures();
      }
      this.setAwake(true);
      this.m_force.setZero();
      this.m_torque = 0;
      var ce = this.m_contactList;
      while (ce) {
        var ce0 = ce;
        ce = ce.next;
        this.m_world.destroyContact(ce0.contact);
      }
      this.m_contactList = null;
      var broadPhase = this.m_world.m_broadPhase;
      for (var f = this.m_fixtureList; f; f = f.m_next) {
        for (var i = 0; i < f.m_proxyCount; ++i) {
          broadPhase.touchProxy(f.m_proxies[i].proxyId);
        }
      }
    };
    Body2.prototype.isBullet = function () {
      return this.m_bulletFlag;
    };
    Body2.prototype.setBullet = function (flag) {
      this.m_bulletFlag = !!flag;
    };
    Body2.prototype.isSleepingAllowed = function () {
      return this.m_autoSleepFlag;
    };
    Body2.prototype.setSleepingAllowed = function (flag) {
      this.m_autoSleepFlag = !!flag;
      if (this.m_autoSleepFlag == false) {
        this.setAwake(true);
      }
    };
    Body2.prototype.isAwake = function () {
      return this.m_awakeFlag;
    };
    Body2.prototype.setAwake = function (flag) {
      if (flag) {
        this.m_awakeFlag = true;
        this.m_sleepTime = 0;
      } else {
        this.m_awakeFlag = false;
        this.m_sleepTime = 0;
        this.m_linearVelocity.setZero();
        this.m_angularVelocity = 0;
        this.m_force.setZero();
        this.m_torque = 0;
      }
    };
    Body2.prototype.isActive = function () {
      return this.m_activeFlag;
    };
    Body2.prototype.setActive = function (flag) {
      if (flag == this.m_activeFlag) {
        return;
      }
      this.m_activeFlag = !!flag;
      if (this.m_activeFlag) {
        var broadPhase = this.m_world.m_broadPhase;
        for (var f = this.m_fixtureList; f; f = f.m_next) {
          f.createProxies(broadPhase, this.m_xf);
        }
        this.m_world.m_newFixture = true;
      } else {
        var broadPhase = this.m_world.m_broadPhase;
        for (var f = this.m_fixtureList; f; f = f.m_next) {
          f.destroyProxies(broadPhase);
        }
        var ce = this.m_contactList;
        while (ce) {
          var ce0 = ce;
          ce = ce.next;
          this.m_world.destroyContact(ce0.contact);
        }
        this.m_contactList = null;
      }
    };
    Body2.prototype.isFixedRotation = function () {
      return this.m_fixedRotationFlag;
    };
    Body2.prototype.setFixedRotation = function (flag) {
      if (this.m_fixedRotationFlag == flag) {
        return;
      }
      this.m_fixedRotationFlag = !!flag;
      this.m_angularVelocity = 0;
      this.resetMassData();
    };
    Body2.prototype.getTransform = function () {
      return this.m_xf;
    };
    Body2.prototype.setTransform = function (a2, b2) {
      if (this.isWorldLocked() == true) {
        return;
      }
      if (typeof b2 === "number") {
        this.m_xf.setNum(a2, b2);
      } else {
        this.m_xf.setTransform(a2);
      }
      this.m_sweep.setTransform(this.m_xf);
      var broadPhase = this.m_world.m_broadPhase;
      for (var f = this.m_fixtureList; f; f = f.m_next) {
        f.synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.setAwake(true);
    };
    Body2.prototype.synchronizeTransform = function () {
      this.m_sweep.getTransform(this.m_xf, 1);
    };
    Body2.prototype.synchronizeFixtures = function () {
      this.m_sweep.getTransform(xf$2, 0);
      var broadPhase = this.m_world.m_broadPhase;
      for (var f = this.m_fixtureList; f; f = f.m_next) {
        f.synchronize(broadPhase, xf$2, this.m_xf);
      }
    };
    Body2.prototype.advance = function (alpha) {
      this.m_sweep.advance(alpha);
      copyVec2(this.m_sweep.c, this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.m_sweep.getTransform(this.m_xf, 1);
    };
    Body2.prototype.getPosition = function () {
      return this.m_xf.p;
    };
    Body2.prototype.setPosition = function (p) {
      this.setTransform(p, this.m_sweep.a);
    };
    Body2.prototype.getAngle = function () {
      return this.m_sweep.a;
    };
    Body2.prototype.setAngle = function (angle) {
      this.setTransform(this.m_xf.p, angle);
    };
    Body2.prototype.getWorldCenter = function () {
      return this.m_sweep.c;
    };
    Body2.prototype.getLocalCenter = function () {
      return this.m_sweep.localCenter;
    };
    Body2.prototype.getLinearVelocity = function () {
      return this.m_linearVelocity;
    };
    Body2.prototype.getLinearVelocityFromWorldPoint = function (worldPoint) {
      var localCenter2 = Vec2.sub(worldPoint, this.m_sweep.c);
      return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter2));
    };
    Body2.prototype.getLinearVelocityFromLocalPoint = function (localPoint) {
      return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
    };
    Body2.prototype.setLinearVelocity = function (v3) {
      if (this.m_type == STATIC) {
        return;
      }
      if (Vec2.dot(v3, v3) > 0) {
        this.setAwake(true);
      }
      this.m_linearVelocity.setVec2(v3);
    };
    Body2.prototype.getAngularVelocity = function () {
      return this.m_angularVelocity;
    };
    Body2.prototype.setAngularVelocity = function (w) {
      if (this.m_type == STATIC) {
        return;
      }
      if (w * w > 0) {
        this.setAwake(true);
      }
      this.m_angularVelocity = w;
    };
    Body2.prototype.getLinearDamping = function () {
      return this.m_linearDamping;
    };
    Body2.prototype.setLinearDamping = function (linearDamping) {
      this.m_linearDamping = linearDamping;
    };
    Body2.prototype.getAngularDamping = function () {
      return this.m_angularDamping;
    };
    Body2.prototype.setAngularDamping = function (angularDamping) {
      this.m_angularDamping = angularDamping;
    };
    Body2.prototype.getGravityScale = function () {
      return this.m_gravityScale;
    };
    Body2.prototype.setGravityScale = function (scale) {
      this.m_gravityScale = scale;
    };
    Body2.prototype.getMass = function () {
      return this.m_mass;
    };
    Body2.prototype.getInertia = function () {
      return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
    };
    Body2.prototype.getMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.getInertia();
      copyVec2(data.center, this.m_sweep.localCenter);
    };
    Body2.prototype.resetMassData = function () {
      this.m_mass = 0;
      this.m_invMass = 0;
      this.m_I = 0;
      this.m_invI = 0;
      zeroVec2(this.m_sweep.localCenter);
      if (this.isStatic() || this.isKinematic()) {
        copyVec2(this.m_sweep.c0, this.m_xf.p);
        copyVec2(this.m_sweep.c, this.m_xf.p);
        this.m_sweep.a0 = this.m_sweep.a;
        return;
      }
      zeroVec2(localCenter);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
        if (f.m_density == 0) {
          continue;
        }
        var massData = {
          mass: 0,
          center: vec2(0, 0),
          I: 0
        };
        f.getMassData(massData);
        this.m_mass += massData.mass;
        plusScaleVec2(localCenter, massData.mass, massData.center);
        this.m_I += massData.I;
      }
      if (this.m_mass > 0) {
        this.m_invMass = 1 / this.m_mass;
        scaleVec2(localCenter, this.m_invMass, localCenter);
      } else {
        this.m_mass = 1;
        this.m_invMass = 1;
      }
      if (this.m_I > 0 && this.m_fixedRotationFlag == false) {
        this.m_I -= this.m_mass * dotVec2(localCenter, localCenter);
        this.m_invI = 1 / this.m_I;
      } else {
        this.m_I = 0;
        this.m_invI = 0;
      }
      copyVec2(oldCenter, this.m_sweep.c);
      this.m_sweep.setLocalCenter(localCenter, this.m_xf);
      subVec2(shift, this.m_sweep.c, oldCenter);
      crossNumVec2(temp$6, this.m_angularVelocity, shift);
      plusVec2(this.m_linearVelocity, temp$6);
    };
    Body2.prototype.setMassData = function (massData) {
      if (this.isWorldLocked() == true) {
        return;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      this.m_invMass = 0;
      this.m_I = 0;
      this.m_invI = 0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0) {
        this.m_mass = 1;
      }
      this.m_invMass = 1 / this.m_mass;
      if (massData.I > 0 && this.m_fixedRotationFlag == false) {
        this.m_I = massData.I - this.m_mass * dotVec2(massData.center, massData.center);
        this.m_invI = 1 / this.m_I;
      }
      copyVec2(oldCenter, this.m_sweep.c);
      this.m_sweep.setLocalCenter(massData.center, this.m_xf);
      subVec2(shift, this.m_sweep.c, oldCenter);
      crossNumVec2(temp$6, this.m_angularVelocity, shift);
      plusVec2(this.m_linearVelocity, temp$6);
    };
    Body2.prototype.applyForce = function (force, point2, wake) {
      if (wake === void 0) {
        wake = true;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      if (wake && this.m_awakeFlag == false) {
        this.setAwake(true);
      }
      if (this.m_awakeFlag) {
        this.m_force.add(force);
        this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), force);
      }
    };
    Body2.prototype.applyForceToCenter = function (force, wake) {
      if (wake === void 0) {
        wake = true;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      if (wake && this.m_awakeFlag == false) {
        this.setAwake(true);
      }
      if (this.m_awakeFlag) {
        this.m_force.add(force);
      }
    };
    Body2.prototype.applyTorque = function (torque, wake) {
      if (wake === void 0) {
        wake = true;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      if (wake && this.m_awakeFlag == false) {
        this.setAwake(true);
      }
      if (this.m_awakeFlag) {
        this.m_torque += torque;
      }
    };
    Body2.prototype.applyLinearImpulse = function (impulse, point2, wake) {
      if (wake === void 0) {
        wake = true;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      if (wake && this.m_awakeFlag == false) {
        this.setAwake(true);
      }
      if (this.m_awakeFlag) {
        this.m_linearVelocity.addMul(this.m_invMass, impulse);
        this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), impulse);
      }
    };
    Body2.prototype.applyAngularImpulse = function (impulse, wake) {
      if (wake === void 0) {
        wake = true;
      }
      if (this.m_type != DYNAMIC) {
        return;
      }
      if (wake && this.m_awakeFlag == false) {
        this.setAwake(true);
      }
      if (this.m_awakeFlag) {
        this.m_angularVelocity += this.m_invI * impulse;
      }
    };
    Body2.prototype.shouldCollide = function (that) {
      if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {
        return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
        if (jn.other == that) {
          if (jn.joint.m_collideConnected == false) {
            return false;
          }
        }
      }
      return true;
    };
    Body2.prototype._addFixture = function (fixture) {
      if (this.isWorldLocked() == true) {
        return null;
      }
      if (this.m_activeFlag) {
        var broadPhase = this.m_world.m_broadPhase;
        fixture.createProxies(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      if (fixture.m_density > 0) {
        this.resetMassData();
      }
      this.m_world.m_newFixture = true;
      return fixture;
    };
    Body2.prototype.createFixture = function (shape, fixdef) {
      if (this.isWorldLocked() == true) {
        return null;
      }
      var fixture = new Fixture(this, shape, fixdef);
      this._addFixture(fixture);
      return fixture;
    };
    Body2.prototype.destroyFixture = function (fixture) {
      if (this.isWorldLocked() == true) {
        return;
      }
      if (this.m_fixtureList === fixture) {
        this.m_fixtureList = fixture.m_next;
      } else {
        var node = this.m_fixtureList;
        while (node != null) {
          if (node.m_next === fixture) {
            node.m_next = fixture.m_next;
            break;
          }
          node = node.m_next;
        }
      }
      var edge = this.m_contactList;
      while (edge) {
        var c2 = edge.contact;
        edge = edge.next;
        var fixtureA = c2.getFixtureA();
        var fixtureB = c2.getFixtureB();
        if (fixture == fixtureA || fixture == fixtureB) {
          this.m_world.destroyContact(c2);
        }
      }
      if (this.m_activeFlag) {
        var broadPhase = this.m_world.m_broadPhase;
        fixture.destroyProxies(broadPhase);
      }
      fixture.m_body = null;
      fixture.m_next = null;
      this.m_world.publish("remove-fixture", fixture);
      this.resetMassData();
    };
    Body2.prototype.getWorldPoint = function (localPoint) {
      return Transform.mulVec2(this.m_xf, localPoint);
    };
    Body2.prototype.getWorldVector = function (localVector) {
      return Rot.mulVec2(this.m_xf.q, localVector);
    };
    Body2.prototype.getLocalPoint = function (worldPoint) {
      return Transform.mulTVec2(this.m_xf, worldPoint);
    };
    Body2.prototype.getLocalVector = function (worldVector) {
      return Rot.mulTVec2(this.m_xf.q, worldVector);
    };
    Body2.STATIC = "static";
    Body2.KINEMATIC = "kinematic";
    Body2.DYNAMIC = "dynamic";
    return Body2;
  }();
  var JointEdge = /** @class */
  /* @__PURE__ */function () {
    function JointEdge2() {
      this.other = null;
      this.joint = null;
      this.prev = null;
      this.next = null;
    }
    return JointEdge2;
  }();
  var Joint = /** @class */
  function () {
    function Joint2(def, bodyA, bodyB) {
      this.m_type = "unknown-joint";
      this.m_prev = null;
      this.m_next = null;
      this.m_edgeA = new JointEdge();
      this.m_edgeB = new JointEdge();
      this.m_islandFlag = false;
      this.style = {};
      this.appData = {};
      bodyA = "bodyA" in def ? def.bodyA : bodyA;
      bodyB = "bodyB" in def ? def.bodyB : bodyB;
      this.m_bodyA = bodyA;
      this.m_bodyB = bodyB;
      this.m_collideConnected = !!def.collideConnected;
      this.m_userData = def.userData;
      if (_typeof(def.style) === "object" && def.style !== null) {
        this.style = def.style;
      }
    }
    Joint2.prototype.isActive = function () {
      return this.m_bodyA.isActive() && this.m_bodyB.isActive();
    };
    Joint2.prototype.getType = function () {
      return this.m_type;
    };
    Joint2.prototype.getBodyA = function () {
      return this.m_bodyA;
    };
    Joint2.prototype.getBodyB = function () {
      return this.m_bodyB;
    };
    Joint2.prototype.getNext = function () {
      return this.m_next;
    };
    Joint2.prototype.getUserData = function () {
      return this.m_userData;
    };
    Joint2.prototype.setUserData = function (data) {
      this.m_userData = data;
    };
    Joint2.prototype.getCollideConnected = function () {
      return this.m_collideConnected;
    };
    Joint2.prototype.shiftOrigin = function (newOrigin) {};
    Joint2.prototype._resetAnchors = function (def) {
      return this._reset(def);
    };
    return Joint2;
  }();
  var stats$1 = {
    gjkCalls: 0,
    gjkIters: 0,
    gjkMaxIters: 0,
    toiTime: 0,
    toiMaxTime: 0,
    toiCalls: 0,
    toiIters: 0,
    toiMaxIters: 0,
    toiRootIters: 0,
    toiMaxRootIters: 0,
    toString: function toString(newline) {
      newline = typeof newline === "string" ? newline : "\n";
      var string = "";
      for (var name_1 in this) {
        if (typeof this[name_1] !== "function" && _typeof(this[name_1]) !== "object") {
          string += name_1 + ": " + this[name_1] + newline;
        }
      }
      return string;
    }
  };
  var now = function now() {
    return Date.now();
  };
  var diff = function diff(time) {
    return Date.now() - time;
  };
  var Timer = {
    now: now,
    diff: diff
  };
  var math_max$7 = Math.max;
  var temp$5 = vec2(0, 0);
  var normal$4 = vec2(0, 0);
  var e12 = vec2(0, 0);
  var e13 = vec2(0, 0);
  var e23 = vec2(0, 0);
  var temp1 = vec2(0, 0);
  var temp2 = vec2(0, 0);
  stats$1.gjkCalls = 0;
  stats$1.gjkIters = 0;
  stats$1.gjkMaxIters = 0;
  var DistanceInput = /** @class */
  function () {
    function DistanceInput2() {
      this.proxyA = new DistanceProxy();
      this.proxyB = new DistanceProxy();
      this.transformA = Transform.identity();
      this.transformB = Transform.identity();
      this.useRadii = false;
    }
    DistanceInput2.prototype.recycle = function () {
      this.proxyA.recycle();
      this.proxyB.recycle();
      this.transformA.setIdentity();
      this.transformB.setIdentity();
      this.useRadii = false;
    };
    return DistanceInput2;
  }();
  var DistanceOutput = /** @class */
  function () {
    function DistanceOutput2() {
      this.pointA = vec2(0, 0);
      this.pointB = vec2(0, 0);
      this.distance = 0;
      this.iterations = 0;
    }
    DistanceOutput2.prototype.recycle = function () {
      zeroVec2(this.pointA);
      zeroVec2(this.pointB);
      this.distance = 0;
      this.iterations = 0;
    };
    return DistanceOutput2;
  }();
  var SimplexCache = /** @class */
  function () {
    function SimplexCache2() {
      this.metric = 0;
      this.indexA = [];
      this.indexB = [];
      this.count = 0;
    }
    SimplexCache2.prototype.recycle = function () {
      this.metric = 0;
      this.indexA.length = 0;
      this.indexB.length = 0;
      this.count = 0;
    };
    return SimplexCache2;
  }();
  var Distance = function Distance(output2, cache2, input2) {
    ++stats$1.gjkCalls;
    var proxyA = input2.proxyA;
    var proxyB = input2.proxyB;
    var xfA2 = input2.transformA;
    var xfB2 = input2.transformB;
    simplex.recycle();
    simplex.readCache(cache2, proxyA, xfA2, proxyB, xfB2);
    var vertices = simplex.m_v;
    var k_maxIters = SettingsInternal.maxDistanceIterations;
    var saveA = [];
    var saveB = [];
    var saveCount = 0;
    var iter = 0;
    while (iter < k_maxIters) {
      saveCount = simplex.m_count;
      for (var i = 0; i < saveCount; ++i) {
        saveA[i] = vertices[i].indexA;
        saveB[i] = vertices[i].indexB;
      }
      simplex.solve();
      if (simplex.m_count === 3) {
        break;
      }
      var d2 = simplex.getSearchDirection();
      if (lengthSqrVec2(d2) < EPSILON * EPSILON) {
        break;
      }
      var vertex = vertices[simplex.m_count];
      vertex.indexA = proxyA.getSupport(derotVec2(temp$5, xfA2.q, scaleVec2(temp$5, -1, d2)));
      transformVec2(vertex.wA, xfA2, proxyA.getVertex(vertex.indexA));
      vertex.indexB = proxyB.getSupport(derotVec2(temp$5, xfB2.q, d2));
      transformVec2(vertex.wB, xfB2, proxyB.getVertex(vertex.indexB));
      subVec2(vertex.w, vertex.wB, vertex.wA);
      ++iter;
      ++stats$1.gjkIters;
      var duplicate = false;
      for (var i = 0; i < saveCount; ++i) {
        if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {
          duplicate = true;
          break;
        }
      }
      if (duplicate) {
        break;
      }
      ++simplex.m_count;
    }
    stats$1.gjkMaxIters = math_max$7(stats$1.gjkMaxIters, iter);
    simplex.getWitnessPoints(output2.pointA, output2.pointB);
    output2.distance = distVec2(output2.pointA, output2.pointB);
    output2.iterations = iter;
    simplex.writeCache(cache2);
    if (input2.useRadii) {
      var rA2 = proxyA.m_radius;
      var rB2 = proxyB.m_radius;
      if (output2.distance > rA2 + rB2 && output2.distance > EPSILON) {
        output2.distance -= rA2 + rB2;
        subVec2(normal$4, output2.pointB, output2.pointA);
        normalizeVec2(normal$4);
        plusScaleVec2(output2.pointA, rA2, normal$4);
        minusScaleVec2(output2.pointB, rB2, normal$4);
      } else {
        var p = subVec2(temp$5, output2.pointA, output2.pointB);
        copyVec2(output2.pointA, p);
        copyVec2(output2.pointB, p);
        output2.distance = 0;
      }
    }
  };
  var DistanceProxy = /** @class */
  function () {
    function DistanceProxy2() {
      this.m_vertices = [];
      this.m_count = 0;
      this.m_radius = 0;
    }
    DistanceProxy2.prototype.recycle = function () {
      this.m_vertices.length = 0;
      this.m_count = 0;
      this.m_radius = 0;
    };
    DistanceProxy2.prototype.getVertexCount = function () {
      return this.m_count;
    };
    DistanceProxy2.prototype.getVertex = function (index) {
      return this.m_vertices[index];
    };
    DistanceProxy2.prototype.getSupport = function (d2) {
      var bestIndex = -1;
      var bestValue = -Infinity;
      for (var i = 0; i < this.m_count; ++i) {
        var value = dotVec2(this.m_vertices[i], d2);
        if (value > bestValue) {
          bestIndex = i;
          bestValue = value;
        }
      }
      return bestIndex;
    };
    DistanceProxy2.prototype.getSupportVertex = function (d2) {
      return this.m_vertices[this.getSupport(d2)];
    };
    DistanceProxy2.prototype.set = function (shape, index) {
      shape.computeDistanceProxy(this, index);
    };
    DistanceProxy2.prototype.setVertices = function (vertices, count, radius) {
      this.m_vertices = vertices;
      this.m_count = count;
      this.m_radius = radius;
    };
    return DistanceProxy2;
  }();
  var SimplexVertex = /** @class */
  function () {
    function SimplexVertex2() {
      this.wA = vec2(0, 0);
      this.indexA = 0;
      this.wB = vec2(0, 0);
      this.indexB = 0;
      this.w = vec2(0, 0);
      this.a = 0;
    }
    SimplexVertex2.prototype.recycle = function () {
      this.indexA = 0;
      this.indexB = 0;
      zeroVec2(this.wA);
      zeroVec2(this.wB);
      zeroVec2(this.w);
      this.a = 0;
    };
    SimplexVertex2.prototype.set = function (v3) {
      this.indexA = v3.indexA;
      this.indexB = v3.indexB;
      copyVec2(this.wA, v3.wA);
      copyVec2(this.wB, v3.wB);
      copyVec2(this.w, v3.w);
      this.a = v3.a;
    };
    return SimplexVertex2;
  }();
  var searchDirection_reuse = vec2(0, 0);
  var closestPoint_reuse = vec2(0, 0);
  var Simplex = /** @class */
  function () {
    function Simplex2() {
      this.m_v1 = new SimplexVertex();
      this.m_v2 = new SimplexVertex();
      this.m_v3 = new SimplexVertex();
      this.m_v = [this.m_v1, this.m_v2, this.m_v3];
    }
    Simplex2.prototype.recycle = function () {
      this.m_v1.recycle();
      this.m_v2.recycle();
      this.m_v3.recycle();
      this.m_count = 0;
    };
    Simplex2.prototype.toString = function () {
      if (this.m_count === 3) {
        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y, this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y, this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y].toString();
      } else if (this.m_count === 2) {
        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y, this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y].toString();
      } else if (this.m_count === 1) {
        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y].toString();
      } else {
        return "+" + this.m_count;
      }
    };
    Simplex2.prototype.readCache = function (cache2, proxyA, transformA, proxyB, transformB) {
      this.m_count = cache2.count;
      for (var i = 0; i < this.m_count; ++i) {
        var v3 = this.m_v[i];
        v3.indexA = cache2.indexA[i];
        v3.indexB = cache2.indexB[i];
        var wALocal = proxyA.getVertex(v3.indexA);
        var wBLocal = proxyB.getVertex(v3.indexB);
        transformVec2(v3.wA, transformA, wALocal);
        transformVec2(v3.wB, transformB, wBLocal);
        subVec2(v3.w, v3.wB, v3.wA);
        v3.a = 0;
      }
      if (this.m_count > 1) {
        var metric1 = cache2.metric;
        var metric2 = this.getMetric();
        if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < EPSILON) {
          this.m_count = 0;
        }
      }
      if (this.m_count === 0) {
        var v3 = this.m_v[0];
        v3.indexA = 0;
        v3.indexB = 0;
        var wALocal = proxyA.getVertex(0);
        var wBLocal = proxyB.getVertex(0);
        transformVec2(v3.wA, transformA, wALocal);
        transformVec2(v3.wB, transformB, wBLocal);
        subVec2(v3.w, v3.wB, v3.wA);
        v3.a = 1;
        this.m_count = 1;
      }
    };
    Simplex2.prototype.writeCache = function (cache2) {
      cache2.metric = this.getMetric();
      cache2.count = this.m_count;
      for (var i = 0; i < this.m_count; ++i) {
        cache2.indexA[i] = this.m_v[i].indexA;
        cache2.indexB[i] = this.m_v[i].indexB;
      }
    };
    Simplex2.prototype.getSearchDirection = function () {
      var v13 = this.m_v1;
      var v22 = this.m_v2;
      this.m_v3;
      switch (this.m_count) {
        case 1:
          return setVec2(searchDirection_reuse, -v13.w.x, -v13.w.y);
        case 2:
          {
            subVec2(e12, v22.w, v13.w);
            var sgn = -crossVec2Vec2(e12, v13.w);
            if (sgn > 0) {
              return setVec2(searchDirection_reuse, -e12.y, e12.x);
            } else {
              return setVec2(searchDirection_reuse, e12.y, -e12.x);
            }
          }
        default:
          return zeroVec2(searchDirection_reuse);
      }
    };
    Simplex2.prototype.getClosestPoint = function () {
      var v13 = this.m_v1;
      var v22 = this.m_v2;
      this.m_v3;
      switch (this.m_count) {
        case 0:
          return zeroVec2(closestPoint_reuse);
        case 1:
          return copyVec2(closestPoint_reuse, v13.w);
        case 2:
          return combine2Vec2(closestPoint_reuse, v13.a, v13.w, v22.a, v22.w);
        case 3:
          return zeroVec2(closestPoint_reuse);
        default:
          return zeroVec2(closestPoint_reuse);
      }
    };
    Simplex2.prototype.getWitnessPoints = function (pA2, pB2) {
      var v13 = this.m_v1;
      var v22 = this.m_v2;
      var v3 = this.m_v3;
      switch (this.m_count) {
        case 0:
          break;
        case 1:
          copyVec2(pA2, v13.wA);
          copyVec2(pB2, v13.wB);
          break;
        case 2:
          combine2Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA);
          combine2Vec2(pB2, v13.a, v13.wB, v22.a, v22.wB);
          break;
        case 3:
          combine3Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA, v3.a, v3.wA);
          copyVec2(pB2, pA2);
          break;
      }
    };
    Simplex2.prototype.getMetric = function () {
      switch (this.m_count) {
        case 0:
          return 0;
        case 1:
          return 0;
        case 2:
          return distVec2(this.m_v1.w, this.m_v2.w);
        case 3:
          return crossVec2Vec2(subVec2(temp1, this.m_v2.w, this.m_v1.w), subVec2(temp2, this.m_v3.w, this.m_v1.w));
        default:
          return 0;
      }
    };
    Simplex2.prototype.solve = function () {
      switch (this.m_count) {
        case 1:
          break;
        case 2:
          this.solve2();
          break;
        case 3:
          this.solve3();
          break;
      }
    };
    Simplex2.prototype.solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      subVec2(e12, w2, w1);
      var d12_2 = -dotVec2(w1, e12);
      if (d12_2 <= 0) {
        this.m_v1.a = 1;
        this.m_count = 1;
        return;
      }
      var d12_1 = dotVec2(w2, e12);
      if (d12_1 <= 0) {
        this.m_v2.a = 1;
        this.m_count = 1;
        this.m_v1.set(this.m_v2);
        return;
      }
      var inv_d12 = 1 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
    };
    Simplex2.prototype.solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      subVec2(e12, w2, w1);
      var w1e12 = dotVec2(w1, e12);
      var w2e12 = dotVec2(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = -w1e12;
      subVec2(e13, w3, w1);
      var w1e13 = dotVec2(w1, e13);
      var w3e13 = dotVec2(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = -w1e13;
      subVec2(e23, w3, w2);
      var w2e23 = dotVec2(w2, e23);
      var w3e23 = dotVec2(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = -w2e23;
      var n123 = crossVec2Vec2(e12, e13);
      var d123_1 = n123 * crossVec2Vec2(w2, w3);
      var d123_2 = n123 * crossVec2Vec2(w3, w1);
      var d123_3 = n123 * crossVec2Vec2(w1, w2);
      if (d12_2 <= 0 && d13_2 <= 0) {
        this.m_v1.a = 1;
        this.m_count = 1;
        return;
      }
      if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
        var inv_d12 = 1 / (d12_1 + d12_2);
        this.m_v1.a = d12_1 * inv_d12;
        this.m_v2.a = d12_2 * inv_d12;
        this.m_count = 2;
        return;
      }
      if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
        var inv_d13 = 1 / (d13_1 + d13_2);
        this.m_v1.a = d13_1 * inv_d13;
        this.m_v3.a = d13_2 * inv_d13;
        this.m_count = 2;
        this.m_v2.set(this.m_v3);
        return;
      }
      if (d12_1 <= 0 && d23_2 <= 0) {
        this.m_v2.a = 1;
        this.m_count = 1;
        this.m_v1.set(this.m_v2);
        return;
      }
      if (d13_1 <= 0 && d23_1 <= 0) {
        this.m_v3.a = 1;
        this.m_count = 1;
        this.m_v1.set(this.m_v3);
        return;
      }
      if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
        var inv_d23 = 1 / (d23_1 + d23_2);
        this.m_v2.a = d23_1 * inv_d23;
        this.m_v3.a = d23_2 * inv_d23;
        this.m_count = 2;
        this.m_v1.set(this.m_v3);
        return;
      }
      var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
    };
    return Simplex2;
  }();
  var simplex = new Simplex();
  var input$1 = new DistanceInput();
  var cache$1 = new SimplexCache();
  var output$1 = new DistanceOutput();
  var testOverlap = function testOverlap(shapeA, indexA, shapeB, indexB, xfA2, xfB2) {
    input$1.recycle();
    input$1.proxyA.set(shapeA, indexA);
    input$1.proxyB.set(shapeB, indexB);
    copyTransform(input$1.transformA, xfA2);
    copyTransform(input$1.transformB, xfB2);
    input$1.useRadii = true;
    output$1.recycle();
    cache$1.recycle();
    Distance(output$1, cache$1, input$1);
    return output$1.distance < 10 * EPSILON;
  };
  Distance.testOverlap = testOverlap;
  Distance.Input = DistanceInput;
  Distance.Output = DistanceOutput;
  Distance.Proxy = DistanceProxy;
  Distance.Cache = SimplexCache;
  var ShapeCastInput = /** @class */
  function () {
    function ShapeCastInput2() {
      this.proxyA = new DistanceProxy();
      this.proxyB = new DistanceProxy();
      this.transformA = Transform.identity();
      this.transformB = Transform.identity();
      this.translationB = Vec2.zero();
    }
    ShapeCastInput2.prototype.recycle = function () {
      this.proxyA.recycle();
      this.proxyB.recycle();
      this.transformA.setIdentity();
      this.transformB.setIdentity();
      zeroVec2(this.translationB);
    };
    return ShapeCastInput2;
  }();
  var ShapeCastOutput = /** @class */
  /* @__PURE__ */function () {
    function ShapeCastOutput2() {
      this.point = Vec2.zero();
      this.normal = Vec2.zero();
      this.lambda = 1;
      this.iterations = 0;
    }
    return ShapeCastOutput2;
  }();
  var ShapeCast = function ShapeCast(output2, input2) {
    output2.iterations = 0;
    output2.lambda = 1;
    output2.normal.setZero();
    output2.point.setZero();
    var proxyA = input2.proxyA;
    var proxyB = input2.proxyB;
    var radiusA = math_max$7(proxyA.m_radius, SettingsInternal.polygonRadius);
    var radiusB = math_max$7(proxyB.m_radius, SettingsInternal.polygonRadius);
    var radius = radiusA + radiusB;
    var xfA2 = input2.transformA;
    var xfB2 = input2.transformB;
    var r = input2.translationB;
    var n2 = Vec2.zero();
    var lambda = 0;
    var simplex2 = new Simplex();
    simplex2.m_count = 0;
    var vertices = simplex2.m_v;
    var indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(r)));
    var wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));
    var indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, r));
    var wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));
    var v3 = Vec2.sub(wA, wB);
    var sigma = math_max$7(SettingsInternal.polygonRadius, radius - SettingsInternal.polygonRadius);
    var tolerance = 0.5 * SettingsInternal.linearSlop;
    var k_maxIters = 20;
    var iter = 0;
    while (iter < k_maxIters && v3.length() - sigma > tolerance) {
      output2.iterations += 1;
      indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(v3)));
      wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));
      indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, v3));
      wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));
      var p = Vec2.sub(wA, wB);
      v3.normalize();
      var vp = Vec2.dot(v3, p);
      var vr = Vec2.dot(v3, r);
      if (vp - sigma > lambda * vr) {
        if (vr <= 0) {
          return false;
        }
        lambda = (vp - sigma) / vr;
        if (lambda > 1) {
          return false;
        }
        n2.setMul(-1, v3);
        simplex2.m_count = 0;
      }
      var vertex = vertices[simplex2.m_count];
      vertex.indexA = indexB;
      vertex.wA = Vec2.combine(1, wB, lambda, r);
      vertex.indexB = indexA;
      vertex.wB = wA;
      vertex.w = Vec2.sub(vertex.wB, vertex.wA);
      vertex.a = 1;
      simplex2.m_count += 1;
      switch (simplex2.m_count) {
        case 1:
          break;
        case 2:
          simplex2.solve2();
          break;
        case 3:
          simplex2.solve3();
          break;
      }
      if (simplex2.m_count == 3) {
        return false;
      }
      v3.setVec2(simplex2.getClosestPoint());
      ++iter;
    }
    if (iter == 0) {
      return false;
    }
    var pointA2 = Vec2.zero();
    var pointB2 = Vec2.zero();
    simplex2.getWitnessPoints(pointB2, pointA2);
    if (v3.lengthSquared() > 0) {
      n2.setMul(-1, v3);
      n2.normalize();
    }
    output2.point = Vec2.combine(1, pointA2, radiusA, n2);
    output2.normal = n2;
    output2.lambda = lambda;
    output2.iterations = iter;
    return true;
  };
  var math_abs$8 = Math.abs;
  var math_max$6 = Math.max;
  var TOIInput = /** @class */
  function () {
    function TOIInput2() {
      this.proxyA = new DistanceProxy();
      this.proxyB = new DistanceProxy();
      this.sweepA = new Sweep();
      this.sweepB = new Sweep();
    }
    TOIInput2.prototype.recycle = function () {
      this.proxyA.recycle();
      this.proxyB.recycle();
      this.sweepA.recycle();
      this.sweepB.recycle();
      this.tMax = -1;
    };
    return TOIInput2;
  }();
  exports2.TOIOutputState = void 0;
  (function (TOIOutputState2) {
    TOIOutputState2[TOIOutputState2["e_unset"] = -1] = "e_unset";
    TOIOutputState2[TOIOutputState2["e_unknown"] = 0] = "e_unknown";
    TOIOutputState2[TOIOutputState2["e_failed"] = 1] = "e_failed";
    TOIOutputState2[TOIOutputState2["e_overlapped"] = 2] = "e_overlapped";
    TOIOutputState2[TOIOutputState2["e_touching"] = 3] = "e_touching";
    TOIOutputState2[TOIOutputState2["e_separated"] = 4] = "e_separated";
  })(exports2.TOIOutputState || (exports2.TOIOutputState = {}));
  var TOIOutput = /** @class */
  function () {
    function TOIOutput2() {
      this.state = exports2.TOIOutputState.e_unset;
      this.t = -1;
    }
    TOIOutput2.prototype.recycle = function () {
      this.state = exports2.TOIOutputState.e_unset;
      this.t = -1;
    };
    return TOIOutput2;
  }();
  stats$1.toiTime = 0;
  stats$1.toiMaxTime = 0;
  stats$1.toiCalls = 0;
  stats$1.toiIters = 0;
  stats$1.toiMaxIters = 0;
  stats$1.toiRootIters = 0;
  stats$1.toiMaxRootIters = 0;
  var distanceInput = new DistanceInput();
  var distanceOutput = new DistanceOutput();
  var cache = new SimplexCache();
  var xfA$1 = transform(0, 0, 0);
  var xfB$1 = transform(0, 0, 0);
  var temp$4 = vec2(0, 0);
  var pointA$2 = vec2(0, 0);
  var pointB$2 = vec2(0, 0);
  var normal$3 = vec2(0, 0);
  var axisA = vec2(0, 0);
  var axisB = vec2(0, 0);
  var localPointA = vec2(0, 0);
  var localPointB = vec2(0, 0);
  var TimeOfImpact = function TimeOfImpact(output2, input2) {
    var timer = Timer.now();
    ++stats$1.toiCalls;
    output2.state = exports2.TOIOutputState.e_unknown;
    output2.t = input2.tMax;
    var proxyA = input2.proxyA;
    var proxyB = input2.proxyB;
    var sweepA = input2.sweepA;
    var sweepB = input2.sweepB;
    sweepA.normalize();
    sweepB.normalize();
    var tMax = input2.tMax;
    var totalRadius = proxyA.m_radius + proxyB.m_radius;
    var target = math_max$6(SettingsInternal.linearSlop, totalRadius - 3 * SettingsInternal.linearSlop);
    var tolerance = 0.25 * SettingsInternal.linearSlop;
    var t1 = 0;
    var k_maxIterations = SettingsInternal.maxTOIIterations;
    var iter = 0;
    cache.recycle();
    distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);
    distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);
    distanceInput.useRadii = false;
    while (true) {
      sweepA.getTransform(xfA$1, t1);
      sweepB.getTransform(xfB$1, t1);
      copyTransform(distanceInput.transformA, xfA$1);
      copyTransform(distanceInput.transformB, xfB$1);
      Distance(distanceOutput, cache, distanceInput);
      if (distanceOutput.distance <= 0) {
        output2.state = exports2.TOIOutputState.e_overlapped;
        output2.t = 0;
        break;
      }
      if (distanceOutput.distance < target + tolerance) {
        output2.state = exports2.TOIOutputState.e_touching;
        output2.t = t1;
        break;
      }
      separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
      var done = false;
      var t2 = tMax;
      var pushBackIter = 0;
      while (true) {
        var s2 = separationFunction.findMinSeparation(t2);
        if (s2 > target + tolerance) {
          output2.state = exports2.TOIOutputState.e_separated;
          output2.t = tMax;
          done = true;
          break;
        }
        if (s2 > target - tolerance) {
          t1 = t2;
          break;
        }
        var s1 = separationFunction.evaluate(t1);
        if (s1 < target - tolerance) {
          output2.state = exports2.TOIOutputState.e_failed;
          output2.t = t1;
          done = true;
          break;
        }
        if (s1 <= target + tolerance) {
          output2.state = exports2.TOIOutputState.e_touching;
          output2.t = t1;
          done = true;
          break;
        }
        var rootIterCount = 0;
        var a1 = t1;
        var a2 = t2;
        while (true) {
          var t = void 0;
          if (rootIterCount & 1) {
            t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
          } else {
            t = 0.5 * (a1 + a2);
          }
          ++rootIterCount;
          ++stats$1.toiRootIters;
          var s3 = separationFunction.evaluate(t);
          if (math_abs$8(s3 - target) < tolerance) {
            t2 = t;
            break;
          }
          if (s3 > target) {
            a1 = t;
            s1 = s3;
          } else {
            a2 = t;
            s2 = s3;
          }
          if (rootIterCount === 50) {
            break;
          }
        }
        stats$1.toiMaxRootIters = math_max$6(stats$1.toiMaxRootIters, rootIterCount);
        ++pushBackIter;
        if (pushBackIter === SettingsInternal.maxPolygonVertices) {
          break;
        }
      }
      ++iter;
      ++stats$1.toiIters;
      if (done) {
        break;
      }
      if (iter === k_maxIterations) {
        output2.state = exports2.TOIOutputState.e_failed;
        output2.t = t1;
        break;
      }
    }
    stats$1.toiMaxIters = math_max$6(stats$1.toiMaxIters, iter);
    var time = Timer.diff(timer);
    stats$1.toiMaxTime = math_max$6(stats$1.toiMaxTime, time);
    stats$1.toiTime += time;
    separationFunction.recycle();
  };
  var SeparationFunctionType;
  (function (SeparationFunctionType2) {
    SeparationFunctionType2[SeparationFunctionType2["e_unset"] = -1] = "e_unset";
    SeparationFunctionType2[SeparationFunctionType2["e_points"] = 1] = "e_points";
    SeparationFunctionType2[SeparationFunctionType2["e_faceA"] = 2] = "e_faceA";
    SeparationFunctionType2[SeparationFunctionType2["e_faceB"] = 3] = "e_faceB";
  })(SeparationFunctionType || (SeparationFunctionType = {}));
  var SeparationFunction = /** @class */
  function () {
    function SeparationFunction2() {
      this.m_proxyA = null;
      this.m_proxyB = null;
      this.m_sweepA = null;
      this.m_sweepB = null;
      this.m_type = SeparationFunctionType.e_unset;
      this.m_localPoint = vec2(0, 0);
      this.m_axis = vec2(0, 0);
      this.indexA = -1;
      this.indexB = -1;
    }
    SeparationFunction2.prototype.recycle = function () {
      this.m_proxyA = null;
      this.m_proxyB = null;
      this.m_sweepA = null;
      this.m_sweepB = null;
      this.m_type = SeparationFunctionType.e_unset;
      zeroVec2(this.m_localPoint);
      zeroVec2(this.m_axis);
      this.indexA = -1;
      this.indexB = -1;
    };
    SeparationFunction2.prototype.initialize = function (cache2, proxyA, sweepA, proxyB, sweepB, t1) {
      var count = cache2.count;
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      this.m_sweepA = sweepA;
      this.m_sweepB = sweepB;
      this.m_sweepA.getTransform(xfA$1, t1);
      this.m_sweepB.getTransform(xfB$1, t1);
      if (count === 1) {
        this.m_type = SeparationFunctionType.e_points;
        var localPointA_1 = this.m_proxyA.getVertex(cache2.indexA[0]);
        var localPointB_1 = this.m_proxyB.getVertex(cache2.indexB[0]);
        transformVec2(pointA$2, xfA$1, localPointA_1);
        transformVec2(pointB$2, xfB$1, localPointB_1);
        subVec2(this.m_axis, pointB$2, pointA$2);
        var s2 = normalizeVec2Length(this.m_axis);
        return s2;
      } else if (cache2.indexA[0] === cache2.indexA[1]) {
        this.m_type = SeparationFunctionType.e_faceB;
        var localPointB1 = proxyB.getVertex(cache2.indexB[0]);
        var localPointB2 = proxyB.getVertex(cache2.indexB[1]);
        crossVec2Num(this.m_axis, subVec2(temp$4, localPointB2, localPointB1), 1);
        normalizeVec2(this.m_axis);
        rotVec2(normal$3, xfB$1.q, this.m_axis);
        combine2Vec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);
        transformVec2(pointB$2, xfB$1, this.m_localPoint);
        var localPointA_2 = proxyA.getVertex(cache2.indexA[0]);
        var pointA_1 = Transform.mulVec2(xfA$1, localPointA_2);
        var s2 = dotVec2(pointA_1, normal$3) - dotVec2(pointB$2, normal$3);
        if (s2 < 0) {
          negVec2(this.m_axis);
          s2 = -s2;
        }
        return s2;
      } else {
        this.m_type = SeparationFunctionType.e_faceA;
        var localPointA1 = this.m_proxyA.getVertex(cache2.indexA[0]);
        var localPointA2 = this.m_proxyA.getVertex(cache2.indexA[1]);
        crossVec2Num(this.m_axis, subVec2(temp$4, localPointA2, localPointA1), 1);
        normalizeVec2(this.m_axis);
        rotVec2(normal$3, xfA$1.q, this.m_axis);
        combine2Vec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);
        transformVec2(pointA$2, xfA$1, this.m_localPoint);
        var localPointB_2 = this.m_proxyB.getVertex(cache2.indexB[0]);
        transformVec2(pointB$2, xfB$1, localPointB_2);
        var s2 = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);
        if (s2 < 0) {
          negVec2(this.m_axis);
          s2 = -s2;
        }
        return s2;
      }
    };
    SeparationFunction2.prototype.compute = function (find, t) {
      this.m_sweepA.getTransform(xfA$1, t);
      this.m_sweepB.getTransform(xfB$1, t);
      switch (this.m_type) {
        case SeparationFunctionType.e_points:
          {
            if (find) {
              derotVec2(axisA, xfA$1.q, this.m_axis);
              derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, this.m_axis));
              this.indexA = this.m_proxyA.getSupport(axisA);
              this.indexB = this.m_proxyB.getSupport(axisB);
            }
            copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));
            copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));
            transformVec2(pointA$2, xfA$1, localPointA);
            transformVec2(pointB$2, xfB$1, localPointB);
            var sep = dotVec2(pointB$2, this.m_axis) - dotVec2(pointA$2, this.m_axis);
            return sep;
          }
        case SeparationFunctionType.e_faceA:
          {
            rotVec2(normal$3, xfA$1.q, this.m_axis);
            transformVec2(pointA$2, xfA$1, this.m_localPoint);
            if (find) {
              derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, normal$3));
              this.indexA = -1;
              this.indexB = this.m_proxyB.getSupport(axisB);
            }
            copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));
            transformVec2(pointB$2, xfB$1, localPointB);
            var sep = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);
            return sep;
          }
        case SeparationFunctionType.e_faceB:
          {
            rotVec2(normal$3, xfB$1.q, this.m_axis);
            transformVec2(pointB$2, xfB$1, this.m_localPoint);
            if (find) {
              derotVec2(axisA, xfA$1.q, scaleVec2(temp$4, -1, normal$3));
              this.indexB = -1;
              this.indexA = this.m_proxyA.getSupport(axisA);
            }
            copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));
            transformVec2(pointA$2, xfA$1, localPointA);
            var sep = dotVec2(pointA$2, normal$3) - dotVec2(pointB$2, normal$3);
            return sep;
          }
        default:
          if (find) {
            this.indexA = -1;
            this.indexB = -1;
          }
          return 0;
      }
    };
    SeparationFunction2.prototype.findMinSeparation = function (t) {
      return this.compute(true, t);
    };
    SeparationFunction2.prototype.evaluate = function (t) {
      return this.compute(false, t);
    };
    return SeparationFunction2;
  }();
  var separationFunction = new SeparationFunction();
  TimeOfImpact.Input = TOIInput;
  TimeOfImpact.Output = TOIOutput;
  var math_abs$7 = Math.abs;
  var math_sqrt$6 = Math.sqrt;
  var math_min$a = Math.min;
  var TimeStep = /** @class */
  function () {
    function TimeStep2() {
      this.dt = 0;
      this.inv_dt = 0;
      this.velocityIterations = 0;
      this.positionIterations = 0;
      this.warmStarting = false;
      this.blockSolve = true;
      this.inv_dt0 = 0;
      this.dtRatio = 1;
    }
    TimeStep2.prototype.reset = function (dt) {
      if (this.dt > 0) {
        this.inv_dt0 = this.inv_dt;
      }
      this.dt = dt;
      this.inv_dt = dt == 0 ? 0 : 1 / dt;
      this.dtRatio = dt * this.inv_dt0;
    };
    return TimeStep2;
  }();
  var s_subStep = new TimeStep();
  var c = vec2(0, 0);
  var v = vec2(0, 0);
  var translation = vec2(0, 0);
  var input = new TOIInput();
  var output = new TOIOutput();
  var backup = new Sweep();
  var backup1 = new Sweep();
  var backup2 = new Sweep();
  var ContactImpulse = /** @class */
  function () {
    function ContactImpulse2(contact) {
      this.contact = contact;
      this.normals = [];
      this.tangents = [];
    }
    ContactImpulse2.prototype.recycle = function () {
      this.normals.length = 0;
      this.tangents.length = 0;
    };
    Object.defineProperty(ContactImpulse2.prototype, "normalImpulses", {
      get: function get() {
        var contact = this.contact;
        var normals = this.normals;
        normals.length = 0;
        for (var p = 0; p < contact.v_points.length; ++p) {
          normals.push(contact.v_points[p].normalImpulse);
        }
        return normals;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ContactImpulse2.prototype, "tangentImpulses", {
      get: function get() {
        var contact = this.contact;
        var tangents = this.tangents;
        tangents.length = 0;
        for (var p = 0; p < contact.v_points.length; ++p) {
          tangents.push(contact.v_points[p].tangentImpulse);
        }
        return tangents;
      },
      enumerable: false,
      configurable: true
    });
    return ContactImpulse2;
  }();
  var Solver = /** @class */
  function () {
    function Solver2(world) {
      this.m_world = world;
      this.m_stack = [];
      this.m_bodies = [];
      this.m_contacts = [];
      this.m_joints = [];
    }
    Solver2.prototype.clear = function () {
      this.m_stack.length = 0;
      this.m_bodies.length = 0;
      this.m_contacts.length = 0;
      this.m_joints.length = 0;
    };
    Solver2.prototype.addBody = function (body) {
      this.m_bodies.push(body);
    };
    Solver2.prototype.addContact = function (contact) {
      this.m_contacts.push(contact);
    };
    Solver2.prototype.addJoint = function (joint) {
      this.m_joints.push(joint);
    };
    Solver2.prototype.solveWorld = function (step) {
      var world = this.m_world;
      for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {
        b2.m_islandFlag = false;
      }
      for (var c_1 = world.m_contactList; c_1; c_1 = c_1.m_next) {
        c_1.m_islandFlag = false;
      }
      for (var j = world.m_jointList; j; j = j.m_next) {
        j.m_islandFlag = false;
      }
      var stack = this.m_stack;
      for (var seed = world.m_bodyList; seed; seed = seed.m_next) {
        if (seed.m_islandFlag) {
          continue;
        }
        if (seed.isAwake() == false || seed.isActive() == false) {
          continue;
        }
        if (seed.isStatic()) {
          continue;
        }
        this.clear();
        stack.push(seed);
        seed.m_islandFlag = true;
        while (stack.length > 0) {
          var b2 = stack.pop();
          this.addBody(b2);
          b2.m_awakeFlag = true;
          if (b2.isStatic()) {
            continue;
          }
          for (var ce = b2.m_contactList; ce; ce = ce.next) {
            var contact = ce.contact;
            if (contact.m_islandFlag) {
              continue;
            }
            if (contact.isEnabled() == false || contact.isTouching() == false) {
              continue;
            }
            var sensorA = contact.m_fixtureA.m_isSensor;
            var sensorB = contact.m_fixtureB.m_isSensor;
            if (sensorA || sensorB) {
              continue;
            }
            this.addContact(contact);
            contact.m_islandFlag = true;
            var other = ce.other;
            if (other.m_islandFlag) {
              continue;
            }
            stack.push(other);
            other.m_islandFlag = true;
          }
          for (var je = b2.m_jointList; je; je = je.next) {
            if (je.joint.m_islandFlag == true) {
              continue;
            }
            var other = je.other;
            if (other.isActive() == false) {
              continue;
            }
            this.addJoint(je.joint);
            je.joint.m_islandFlag = true;
            if (other.m_islandFlag) {
              continue;
            }
            stack.push(other);
            other.m_islandFlag = true;
          }
        }
        this.solveIsland(step);
        for (var i = 0; i < this.m_bodies.length; ++i) {
          var b2 = this.m_bodies[i];
          if (b2.isStatic()) {
            b2.m_islandFlag = false;
          }
        }
      }
    };
    Solver2.prototype.solveIsland = function (step) {
      var world = this.m_world;
      var gravity = world.m_gravity;
      var allowSleep = world.m_allowSleep;
      var h = step.dt;
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        copyVec2(c, body.m_sweep.c);
        var a2 = body.m_sweep.a;
        copyVec2(v, body.m_linearVelocity);
        var w = body.m_angularVelocity;
        copyVec2(body.m_sweep.c0, body.m_sweep.c);
        body.m_sweep.a0 = body.m_sweep.a;
        if (body.isDynamic()) {
          plusScaleVec2(v, h * body.m_gravityScale, gravity);
          plusScaleVec2(v, h * body.m_invMass, body.m_force);
          w += h * body.m_invI * body.m_torque;
          scaleVec2(v, 1 / (1 + h * body.m_linearDamping), v);
          w *= 1 / (1 + h * body.m_angularDamping);
        }
        copyVec2(body.c_position.c, c);
        body.c_position.a = a2;
        copyVec2(body.c_velocity.v, v);
        body.c_velocity.w = w;
      }
      for (var i = 0; i < this.m_contacts.length; ++i) {
        var contact = this.m_contacts[i];
        contact.initConstraint(step);
      }
      for (var i = 0; i < this.m_contacts.length; ++i) {
        var contact = this.m_contacts[i];
        contact.initVelocityConstraint(step);
      }
      if (step.warmStarting) {
        for (var i = 0; i < this.m_contacts.length; ++i) {
          var contact = this.m_contacts[i];
          contact.warmStartConstraint(step);
        }
      }
      for (var i = 0; i < this.m_joints.length; ++i) {
        var joint = this.m_joints[i];
        joint.initVelocityConstraints(step);
      }
      for (var i = 0; i < step.velocityIterations; ++i) {
        for (var j = 0; j < this.m_joints.length; ++j) {
          var joint = this.m_joints[j];
          joint.solveVelocityConstraints(step);
        }
        for (var j = 0; j < this.m_contacts.length; ++j) {
          var contact = this.m_contacts[j];
          contact.solveVelocityConstraint(step);
        }
      }
      for (var i = 0; i < this.m_contacts.length; ++i) {
        var contact = this.m_contacts[i];
        contact.storeConstraintImpulses(step);
      }
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        copyVec2(c, body.c_position.c);
        var a2 = body.c_position.a;
        copyVec2(v, body.c_velocity.v);
        var w = body.c_velocity.w;
        scaleVec2(translation, h, v);
        var translationLengthSqr = lengthSqrVec2(translation);
        if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {
          var ratio = SettingsInternal.maxTranslation / math_sqrt$6(translationLengthSqr);
          mulVec2(v, ratio);
        }
        var rotation2 = h * w;
        if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {
          var ratio = SettingsInternal.maxRotation / math_abs$7(rotation2);
          w *= ratio;
        }
        plusScaleVec2(c, h, v);
        a2 += h * w;
        copyVec2(body.c_position.c, c);
        body.c_position.a = a2;
        copyVec2(body.c_velocity.v, v);
        body.c_velocity.w = w;
      }
      var positionSolved = false;
      for (var i = 0; i < step.positionIterations; ++i) {
        var minSeparation = 0;
        for (var j = 0; j < this.m_contacts.length; ++j) {
          var contact = this.m_contacts[j];
          var separation = contact.solvePositionConstraint(step);
          minSeparation = math_min$a(minSeparation, separation);
        }
        var contactsOkay = minSeparation >= -3 * SettingsInternal.linearSlop;
        var jointsOkay = true;
        for (var j = 0; j < this.m_joints.length; ++j) {
          var joint = this.m_joints[j];
          var jointOkay = joint.solvePositionConstraints(step);
          jointsOkay = jointsOkay && jointOkay;
        }
        if (contactsOkay && jointsOkay) {
          positionSolved = true;
          break;
        }
      }
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        copyVec2(body.m_sweep.c, body.c_position.c);
        body.m_sweep.a = body.c_position.a;
        copyVec2(body.m_linearVelocity, body.c_velocity.v);
        body.m_angularVelocity = body.c_velocity.w;
        body.synchronizeTransform();
      }
      this.postSolveIsland();
      if (allowSleep) {
        var minSleepTime = Infinity;
        var linTolSqr = SettingsInternal.linearSleepToleranceSqr;
        var angTolSqr = SettingsInternal.angularSleepToleranceSqr;
        for (var i = 0; i < this.m_bodies.length; ++i) {
          var body = this.m_bodies[i];
          if (body.isStatic()) {
            continue;
          }
          if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || lengthSqrVec2(body.m_linearVelocity) > linTolSqr) {
            body.m_sleepTime = 0;
            minSleepTime = 0;
          } else {
            body.m_sleepTime += h;
            minSleepTime = math_min$a(minSleepTime, body.m_sleepTime);
          }
        }
        if (minSleepTime >= SettingsInternal.timeToSleep && positionSolved) {
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var body = this.m_bodies[i];
            body.setAwake(false);
          }
        }
      }
    };
    Solver2.prototype.solveWorldTOI = function (step) {
      var world = this.m_world;
      if (world.m_stepComplete) {
        for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {
          b2.m_islandFlag = false;
          b2.m_sweep.alpha0 = 0;
        }
        for (var c_2 = world.m_contactList; c_2; c_2 = c_2.m_next) {
          c_2.m_toiFlag = false;
          c_2.m_islandFlag = false;
          c_2.m_toiCount = 0;
          c_2.m_toi = 1;
        }
      }
      while (true) {
        var minContact = null;
        var minAlpha = 1;
        for (var c_3 = world.m_contactList; c_3; c_3 = c_3.m_next) {
          if (c_3.isEnabled() == false) {
            continue;
          }
          if (c_3.m_toiCount > SettingsInternal.maxSubSteps) {
            continue;
          }
          var alpha = 1;
          if (c_3.m_toiFlag) {
            alpha = c_3.m_toi;
          } else {
            var fA_1 = c_3.getFixtureA();
            var fB_1 = c_3.getFixtureB();
            if (fA_1.isSensor() || fB_1.isSensor()) {
              continue;
            }
            var bA_1 = fA_1.getBody();
            var bB_1 = fB_1.getBody();
            var activeA = bA_1.isAwake() && !bA_1.isStatic();
            var activeB = bB_1.isAwake() && !bB_1.isStatic();
            if (activeA == false && activeB == false) {
              continue;
            }
            var collideA = bA_1.isBullet() || !bA_1.isDynamic();
            var collideB = bB_1.isBullet() || !bB_1.isDynamic();
            if (collideA == false && collideB == false) {
              continue;
            }
            var alpha0 = bA_1.m_sweep.alpha0;
            if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {
              alpha0 = bB_1.m_sweep.alpha0;
              bA_1.m_sweep.advance(alpha0);
            } else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {
              alpha0 = bA_1.m_sweep.alpha0;
              bB_1.m_sweep.advance(alpha0);
            }
            var indexA = c_3.getChildIndexA();
            var indexB = c_3.getChildIndexB();
            bA_1.m_sweep;
            bB_1.m_sweep;
            input.proxyA.set(fA_1.getShape(), indexA);
            input.proxyB.set(fB_1.getShape(), indexB);
            input.sweepA.set(bA_1.m_sweep);
            input.sweepB.set(bB_1.m_sweep);
            input.tMax = 1;
            TimeOfImpact(output, input);
            var beta = output.t;
            if (output.state == exports2.TOIOutputState.e_touching) {
              alpha = math_min$a(alpha0 + (1 - alpha0) * beta, 1);
            } else {
              alpha = 1;
            }
            c_3.m_toi = alpha;
            c_3.m_toiFlag = true;
          }
          if (alpha < minAlpha) {
            minContact = c_3;
            minAlpha = alpha;
          }
        }
        if (minContact == null || 1 - 10 * EPSILON < minAlpha) {
          world.m_stepComplete = true;
          break;
        }
        var fA = minContact.getFixtureA();
        var fB = minContact.getFixtureB();
        var bA = fA.getBody();
        var bB = fB.getBody();
        backup1.set(bA.m_sweep);
        backup2.set(bB.m_sweep);
        bA.advance(minAlpha);
        bB.advance(minAlpha);
        minContact.update(world);
        minContact.m_toiFlag = false;
        ++minContact.m_toiCount;
        if (minContact.isEnabled() == false || minContact.isTouching() == false) {
          minContact.setEnabled(false);
          bA.m_sweep.set(backup1);
          bB.m_sweep.set(backup2);
          bA.synchronizeTransform();
          bB.synchronizeTransform();
          continue;
        }
        bA.setAwake(true);
        bB.setAwake(true);
        this.clear();
        this.addBody(bA);
        this.addBody(bB);
        this.addContact(minContact);
        bA.m_islandFlag = true;
        bB.m_islandFlag = true;
        minContact.m_islandFlag = true;
        var bodies = [bA, bB];
        for (var i = 0; i < bodies.length; ++i) {
          var body = bodies[i];
          if (body.isDynamic()) {
            for (var ce = body.m_contactList; ce; ce = ce.next) {
              var contact = ce.contact;
              if (contact.m_islandFlag) {
                continue;
              }
              var other = ce.other;
              if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
                continue;
              }
              var sensorA = contact.m_fixtureA.m_isSensor;
              var sensorB = contact.m_fixtureB.m_isSensor;
              if (sensorA || sensorB) {
                continue;
              }
              backup.set(other.m_sweep);
              if (other.m_islandFlag == false) {
                other.advance(minAlpha);
              }
              contact.update(world);
              if (contact.isEnabled() == false || contact.isTouching() == false) {
                other.m_sweep.set(backup);
                other.synchronizeTransform();
                continue;
              }
              contact.m_islandFlag = true;
              this.addContact(contact);
              if (other.m_islandFlag) {
                continue;
              }
              other.m_islandFlag = true;
              if (!other.isStatic()) {
                other.setAwake(true);
              }
              this.addBody(other);
            }
          }
        }
        s_subStep.reset((1 - minAlpha) * step.dt);
        s_subStep.dtRatio = 1;
        s_subStep.positionIterations = 20;
        s_subStep.velocityIterations = step.velocityIterations;
        s_subStep.warmStarting = false;
        this.solveIslandTOI(s_subStep, bA, bB);
        for (var i = 0; i < this.m_bodies.length; ++i) {
          var body = this.m_bodies[i];
          body.m_islandFlag = false;
          if (!body.isDynamic()) {
            continue;
          }
          body.synchronizeFixtures();
          for (var ce = body.m_contactList; ce; ce = ce.next) {
            ce.contact.m_toiFlag = false;
            ce.contact.m_islandFlag = false;
          }
        }
        world.findNewContacts();
        if (world.m_subStepping) {
          world.m_stepComplete = false;
          break;
        }
      }
    };
    Solver2.prototype.solveIslandTOI = function (subStep, toiA, toiB) {
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        copyVec2(body.c_position.c, body.m_sweep.c);
        body.c_position.a = body.m_sweep.a;
        copyVec2(body.c_velocity.v, body.m_linearVelocity);
        body.c_velocity.w = body.m_angularVelocity;
      }
      for (var i = 0; i < this.m_contacts.length; ++i) {
        var contact = this.m_contacts[i];
        contact.initConstraint(subStep);
      }
      for (var i = 0; i < subStep.positionIterations; ++i) {
        var minSeparation = 0;
        for (var j = 0; j < this.m_contacts.length; ++j) {
          var contact = this.m_contacts[j];
          var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
          minSeparation = math_min$a(minSeparation, separation);
        }
        var contactsOkay = minSeparation >= -1.5 * SettingsInternal.linearSlop;
        if (contactsOkay) {
          break;
        }
      }
      var i;
      copyVec2(toiA.m_sweep.c0, toiA.c_position.c);
      toiA.m_sweep.a0 = toiA.c_position.a;
      copyVec2(toiB.m_sweep.c0, toiB.c_position.c);
      toiB.m_sweep.a0 = toiB.c_position.a;
      for (var i = 0; i < this.m_contacts.length; ++i) {
        var contact = this.m_contacts[i];
        contact.initVelocityConstraint(subStep);
      }
      for (var i = 0; i < subStep.velocityIterations; ++i) {
        for (var j = 0; j < this.m_contacts.length; ++j) {
          var contact = this.m_contacts[j];
          contact.solveVelocityConstraint(subStep);
        }
      }
      var h = subStep.dt;
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        copyVec2(c, body.c_position.c);
        var a2 = body.c_position.a;
        copyVec2(v, body.c_velocity.v);
        var w = body.c_velocity.w;
        scaleVec2(translation, h, v);
        var translationLengthSqr = lengthSqrVec2(translation);
        if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {
          var ratio = SettingsInternal.maxTranslation / math_sqrt$6(translationLengthSqr);
          mulVec2(v, ratio);
        }
        var rotation2 = h * w;
        if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {
          var ratio = SettingsInternal.maxRotation / math_abs$7(rotation2);
          w *= ratio;
        }
        plusScaleVec2(c, h, v);
        a2 += h * w;
        copyVec2(body.c_position.c, c);
        body.c_position.a = a2;
        copyVec2(body.c_velocity.v, v);
        body.c_velocity.w = w;
        copyVec2(body.m_sweep.c, c);
        body.m_sweep.a = a2;
        copyVec2(body.m_linearVelocity, v);
        body.m_angularVelocity = w;
        body.synchronizeTransform();
      }
      this.postSolveIsland();
    };
    Solver2.prototype.postSolveIsland = function () {
      for (var c_5 = 0; c_5 < this.m_contacts.length; ++c_5) {
        var contact = this.m_contacts[c_5];
        this.m_world.postSolve(contact, contact.m_impulse);
      }
    };
    return Solver2;
  }();
  Solver.TimeStep = TimeStep;
  var Mat22 = /** @class */
  function () {
    function Mat222(a2, b2, c2, d2) {
      if (_typeof(a2) === "object" && a2 !== null) {
        this.ex = Vec2.clone(a2);
        this.ey = Vec2.clone(b2);
      } else if (typeof a2 === "number") {
        this.ex = Vec2.neo(a2, c2);
        this.ey = Vec2.neo(b2, d2);
      } else {
        this.ex = Vec2.zero();
        this.ey = Vec2.zero();
      }
    }
    Mat222.prototype.toString = function () {
      return JSON.stringify(this);
    };
    Mat222.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);
    };
    Mat222.assert = function (o) {};
    Mat222.prototype.set = function (a2, b2, c2, d2) {
      if (typeof a2 === "number" && typeof b2 === "number" && typeof c2 === "number" && typeof d2 === "number") {
        this.ex.setNum(a2, c2);
        this.ey.setNum(b2, d2);
      } else if (_typeof(a2) === "object" && _typeof(b2) === "object") {
        this.ex.setVec2(a2);
        this.ey.setVec2(b2);
      } else if (_typeof(a2) === "object") {
        this.ex.setVec2(a2.ex);
        this.ey.setVec2(a2.ey);
      } else ;
    };
    Mat222.prototype.setIdentity = function () {
      this.ex.x = 1;
      this.ey.x = 0;
      this.ex.y = 0;
      this.ey.y = 1;
    };
    Mat222.prototype.setZero = function () {
      this.ex.x = 0;
      this.ey.x = 0;
      this.ex.y = 0;
      this.ey.y = 0;
    };
    Mat222.prototype.getInverse = function () {
      var a2 = this.ex.x;
      var b2 = this.ey.x;
      var c2 = this.ex.y;
      var d2 = this.ey.y;
      var det = a2 * d2 - b2 * c2;
      if (det !== 0) {
        det = 1 / det;
      }
      var imx = new Mat222();
      imx.ex.x = det * d2;
      imx.ey.x = -det * b2;
      imx.ex.y = -det * c2;
      imx.ey.y = det * a2;
      return imx;
    };
    Mat222.prototype.solve = function (v3) {
      var a2 = this.ex.x;
      var b2 = this.ey.x;
      var c2 = this.ex.y;
      var d2 = this.ey.y;
      var det = a2 * d2 - b2 * c2;
      if (det !== 0) {
        det = 1 / det;
      }
      var w = Vec2.zero();
      w.x = det * (d2 * v3.x - b2 * v3.y);
      w.y = det * (a2 * v3.y - c2 * v3.x);
      return w;
    };
    Mat222.mul = function (mx, v3) {
      if (v3 && "x" in v3 && "y" in v3) {
        var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;
        var y = mx.ex.y * v3.x + mx.ey.y * v3.y;
        return Vec2.neo(x2, y);
      } else if (v3 && "ex" in v3 && "ey" in v3) {
        var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;
        var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;
        var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;
        var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;
        return new Mat222(a2, b2, c2, d2);
      }
    };
    Mat222.mulVec2 = function (mx, v3) {
      var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;
      var y = mx.ex.y * v3.x + mx.ey.y * v3.y;
      return Vec2.neo(x2, y);
    };
    Mat222.mulMat22 = function (mx, v3) {
      var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;
      var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;
      var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;
      var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;
      return new Mat222(a2, b2, c2, d2);
    };
    Mat222.mulT = function (mx, v3) {
      if (v3 && "x" in v3 && "y" in v3) {
        return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));
      } else if (v3 && "ex" in v3 && "ey" in v3) {
        var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));
        var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));
        return new Mat222(c1, c2);
      }
    };
    Mat222.mulTVec2 = function (mx, v3) {
      return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));
    };
    Mat222.mulTMat22 = function (mx, v3) {
      var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));
      var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));
      return new Mat222(c1, c2);
    };
    Mat222.abs = function (mx) {
      return new Mat222(Vec2.abs(mx.ex), Vec2.abs(mx.ey));
    };
    Mat222.add = function (mx1, mx2) {
      return new Mat222(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));
    };
    return Mat222;
  }();
  var math_sqrt$5 = Math.sqrt;
  var pointA$1 = vec2(0, 0);
  var pointB$1 = vec2(0, 0);
  var temp$3 = vec2(0, 0);
  var cA$1 = vec2(0, 0);
  var cB$1 = vec2(0, 0);
  var dist = vec2(0, 0);
  var planePoint$2 = vec2(0, 0);
  var clipPoint$1 = vec2(0, 0);
  exports2.ManifoldType = void 0;
  (function (ManifoldType2) {
    ManifoldType2[ManifoldType2["e_unset"] = -1] = "e_unset";
    ManifoldType2[ManifoldType2["e_circles"] = 0] = "e_circles";
    ManifoldType2[ManifoldType2["e_faceA"] = 1] = "e_faceA";
    ManifoldType2[ManifoldType2["e_faceB"] = 2] = "e_faceB";
  })(exports2.ManifoldType || (exports2.ManifoldType = {}));
  exports2.ContactFeatureType = void 0;
  (function (ContactFeatureType2) {
    ContactFeatureType2[ContactFeatureType2["e_unset"] = -1] = "e_unset";
    ContactFeatureType2[ContactFeatureType2["e_vertex"] = 0] = "e_vertex";
    ContactFeatureType2[ContactFeatureType2["e_face"] = 1] = "e_face";
  })(exports2.ContactFeatureType || (exports2.ContactFeatureType = {}));
  exports2.PointState = void 0;
  (function (PointState2) {
    PointState2[PointState2["nullState"] = 0] = "nullState";
    PointState2[PointState2["addState"] = 1] = "addState";
    PointState2[PointState2["persistState"] = 2] = "persistState";
    PointState2[PointState2["removeState"] = 3] = "removeState";
  })(exports2.PointState || (exports2.PointState = {}));
  var ClipVertex = /** @class */
  function () {
    function ClipVertex2() {
      this.v = vec2(0, 0);
      this.id = new ContactID();
    }
    ClipVertex2.prototype.set = function (o) {
      copyVec2(this.v, o.v);
      this.id.set(o.id);
    };
    ClipVertex2.prototype.recycle = function () {
      zeroVec2(this.v);
      this.id.recycle();
    };
    return ClipVertex2;
  }();
  var Manifold = /** @class */
  function () {
    function Manifold2() {
      this.localNormal = vec2(0, 0);
      this.localPoint = vec2(0, 0);
      this.points = [new ManifoldPoint(), new ManifoldPoint()];
      this.pointCount = 0;
    }
    Manifold2.prototype.set = function (that) {
      this.type = that.type;
      copyVec2(this.localNormal, that.localNormal);
      copyVec2(this.localPoint, that.localPoint);
      this.pointCount = that.pointCount;
      this.points[0].set(that.points[0]);
      this.points[1].set(that.points[1]);
    };
    Manifold2.prototype.recycle = function () {
      this.type = exports2.ManifoldType.e_unset;
      zeroVec2(this.localNormal);
      zeroVec2(this.localPoint);
      this.pointCount = 0;
      this.points[0].recycle();
      this.points[1].recycle();
    };
    Manifold2.prototype.getWorldManifold = function (wm, xfA2, radiusA, xfB2, radiusB) {
      if (this.pointCount == 0) {
        return wm;
      }
      wm = wm || new WorldManifold();
      wm.pointCount = this.pointCount;
      var normal3 = wm.normal;
      var points = wm.points;
      var separations = wm.separations;
      switch (this.type) {
        case exports2.ManifoldType.e_circles:
          {
            setVec2(normal3, 1, 0);
            var manifoldPoint = this.points[0];
            transformVec2(pointA$1, xfA2, this.localPoint);
            transformVec2(pointB$1, xfB2, manifoldPoint.localPoint);
            subVec2(dist, pointB$1, pointA$1);
            var lengthSqr = lengthSqrVec2(dist);
            if (lengthSqr > EPSILON * EPSILON) {
              var length_1 = math_sqrt$5(lengthSqr);
              scaleVec2(normal3, 1 / length_1, dist);
            }
            combine2Vec2(cA$1, 1, pointA$1, radiusA, normal3);
            combine2Vec2(cB$1, 1, pointB$1, -radiusB, normal3);
            combine2Vec2(points[0], 0.5, cA$1, 0.5, cB$1);
            separations[0] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);
            break;
          }
        case exports2.ManifoldType.e_faceA:
          {
            rotVec2(normal3, xfA2.q, this.localNormal);
            transformVec2(planePoint$2, xfA2, this.localPoint);
            for (var i = 0; i < this.pointCount; ++i) {
              var manifoldPoint = this.points[i];
              transformVec2(clipPoint$1, xfB2, manifoldPoint.localPoint);
              combine2Vec2(cA$1, 1, clipPoint$1, radiusA - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);
              combine2Vec2(cB$1, 1, clipPoint$1, -radiusB, normal3);
              combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);
              separations[i] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);
            }
            break;
          }
        case exports2.ManifoldType.e_faceB:
          {
            rotVec2(normal3, xfB2.q, this.localNormal);
            transformVec2(planePoint$2, xfB2, this.localPoint);
            for (var i = 0; i < this.pointCount; ++i) {
              var manifoldPoint = this.points[i];
              transformVec2(clipPoint$1, xfA2, manifoldPoint.localPoint);
              combine2Vec2(cB$1, 1, clipPoint$1, radiusB - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);
              combine2Vec2(cA$1, 1, clipPoint$1, -radiusA, normal3);
              combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);
              separations[i] = dotVec2(subVec2(temp$3, cA$1, cB$1), normal3);
            }
            negVec2(normal3);
            break;
          }
      }
      return wm;
    };
    Manifold2.clipSegmentToLine = clipSegmentToLine;
    Manifold2.ClipVertex = ClipVertex;
    Manifold2.getPointStates = getPointStates;
    Manifold2.PointState = exports2.PointState;
    return Manifold2;
  }();
  var ManifoldPoint = /** @class */
  function () {
    function ManifoldPoint2() {
      this.localPoint = vec2(0, 0);
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
      this.id = new ContactID();
    }
    ManifoldPoint2.prototype.set = function (that) {
      copyVec2(this.localPoint, that.localPoint);
      this.normalImpulse = that.normalImpulse;
      this.tangentImpulse = that.tangentImpulse;
      this.id.set(that.id);
    };
    ManifoldPoint2.prototype.recycle = function () {
      zeroVec2(this.localPoint);
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
      this.id.recycle();
    };
    return ManifoldPoint2;
  }();
  var ContactID = /** @class */
  function () {
    function ContactID2() {
      this.key = -1;
      this.indexA = -1;
      this.indexB = -1;
      this.typeA = exports2.ContactFeatureType.e_unset;
      this.typeB = exports2.ContactFeatureType.e_unset;
    }
    ContactID2.prototype.setFeatures = function (indexA, typeA, indexB, typeB) {
      this.indexA = indexA;
      this.indexB = indexB;
      this.typeA = typeA;
      this.typeB = typeB;
      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
    };
    ContactID2.prototype.set = function (that) {
      this.indexA = that.indexA;
      this.indexB = that.indexB;
      this.typeA = that.typeA;
      this.typeB = that.typeB;
      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
    };
    ContactID2.prototype.swapFeatures = function () {
      var indexA = this.indexA;
      var indexB = this.indexB;
      var typeA = this.typeA;
      var typeB = this.typeB;
      this.indexA = indexB;
      this.indexB = indexA;
      this.typeA = typeB;
      this.typeB = typeA;
      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
    };
    ContactID2.prototype.recycle = function () {
      this.indexA = 0;
      this.indexB = 0;
      this.typeA = exports2.ContactFeatureType.e_unset;
      this.typeB = exports2.ContactFeatureType.e_unset;
      this.key = -1;
    };
    return ContactID2;
  }();
  var WorldManifold = /** @class */
  function () {
    function WorldManifold2() {
      this.normal = vec2(0, 0);
      this.points = [vec2(0, 0), vec2(0, 0)];
      this.separations = [0, 0];
      this.pointCount = 0;
    }
    WorldManifold2.prototype.recycle = function () {
      zeroVec2(this.normal);
      zeroVec2(this.points[0]);
      zeroVec2(this.points[1]);
      this.separations[0] = 0;
      this.separations[1] = 0;
      this.pointCount = 0;
    };
    return WorldManifold2;
  }();
  function getPointStates(state1, state2, manifold1, manifold2) {
    for (var i = 0; i < manifold1.pointCount; ++i) {
      var id = manifold1.points[i].id;
      state1[i] = exports2.PointState.removeState;
      for (var j = 0; j < manifold2.pointCount; ++j) {
        if (manifold2.points[j].id.key === id.key) {
          state1[i] = exports2.PointState.persistState;
          break;
        }
      }
    }
    for (var i = 0; i < manifold2.pointCount; ++i) {
      var id = manifold2.points[i].id;
      state2[i] = exports2.PointState.addState;
      for (var j = 0; j < manifold1.pointCount; ++j) {
        if (manifold1.points[j].id.key === id.key) {
          state2[i] = exports2.PointState.persistState;
          break;
        }
      }
    }
  }
  function clipSegmentToLine(vOut, vIn, normal3, offset, vertexIndexA) {
    var numOut = 0;
    var distance0 = dotVec2(normal3, vIn[0].v) - offset;
    var distance1 = dotVec2(normal3, vIn[1].v) - offset;
    if (distance0 <= 0) vOut[numOut++].set(vIn[0]);
    if (distance1 <= 0) vOut[numOut++].set(vIn[1]);
    if (distance0 * distance1 < 0) {
      var interp = distance0 / (distance0 - distance1);
      combine2Vec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);
      vOut[numOut].id.setFeatures(vertexIndexA, exports2.ContactFeatureType.e_vertex, vIn[0].id.indexB, exports2.ContactFeatureType.e_face);
      ++numOut;
    }
    return numOut;
  }
  var math_sqrt$4 = Math.sqrt;
  var math_max$5 = Math.max;
  var math_min$9 = Math.min;
  var contactPool = new Pool({
    create: function create() {
      return new Contact();
    },
    release: function release(contact) {
      contact.recycle();
    }
  });
  var oldManifold = new Manifold();
  var worldManifold = new WorldManifold();
  var ContactEdge = /** @class */
  function () {
    function ContactEdge2(contact) {
      this.prev = null;
      this.next = null;
      this.other = null;
      this.contact = contact;
    }
    ContactEdge2.prototype.recycle = function () {
      this.prev = null;
      this.next = null;
      this.other = null;
    };
    return ContactEdge2;
  }();
  function mixFriction(friction1, friction2) {
    return math_sqrt$4(friction1 * friction2);
  }
  function mixRestitution(restitution1, restitution2) {
    return restitution1 > restitution2 ? restitution1 : restitution2;
  }
  var s_registers = [];
  var VelocityConstraintPoint = /** @class */
  function () {
    function VelocityConstraintPoint2() {
      this.rA = vec2(0, 0);
      this.rB = vec2(0, 0);
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
      this.normalMass = 0;
      this.tangentMass = 0;
      this.velocityBias = 0;
    }
    VelocityConstraintPoint2.prototype.recycle = function () {
      zeroVec2(this.rA);
      zeroVec2(this.rB);
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
      this.normalMass = 0;
      this.tangentMass = 0;
      this.velocityBias = 0;
    };
    return VelocityConstraintPoint2;
  }();
  var cA = vec2(0, 0);
  var vA = vec2(0, 0);
  var cB = vec2(0, 0);
  var vB = vec2(0, 0);
  var tangent$1 = vec2(0, 0);
  var xfA = transform(0, 0, 0);
  var xfB = transform(0, 0, 0);
  var pointA = vec2(0, 0);
  var pointB = vec2(0, 0);
  var clipPoint = vec2(0, 0);
  var planePoint$1 = vec2(0, 0);
  var rA = vec2(0, 0);
  var rB = vec2(0, 0);
  var P$1 = vec2(0, 0);
  var normal$2 = vec2(0, 0);
  var point = vec2(0, 0);
  var dv = vec2(0, 0);
  var dv1 = vec2(0, 0);
  var dv2 = vec2(0, 0);
  var b = vec2(0, 0);
  var a = vec2(0, 0);
  var x = vec2(0, 0);
  var d = vec2(0, 0);
  var P1 = vec2(0, 0);
  var P2 = vec2(0, 0);
  var temp$2 = vec2(0, 0);
  var Contact = /** @class */
  function () {
    function Contact2() {
      this.m_nodeA = new ContactEdge(this);
      this.m_nodeB = new ContactEdge(this);
      this.m_fixtureA = null;
      this.m_fixtureB = null;
      this.m_indexA = -1;
      this.m_indexB = -1;
      this.m_evaluateFcn = null;
      this.m_manifold = new Manifold();
      this.m_prev = null;
      this.m_next = null;
      this.m_toi = 1;
      this.m_toiCount = 0;
      this.m_toiFlag = false;
      this.m_friction = 0;
      this.m_restitution = 0;
      this.m_tangentSpeed = 0;
      this.m_enabledFlag = true;
      this.m_islandFlag = false;
      this.m_touchingFlag = false;
      this.m_filterFlag = false;
      this.m_bulletHitFlag = false;
      this.m_impulse = new ContactImpulse(this);
      this.v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()];
      this.v_normal = vec2(0, 0);
      this.v_normalMass = new Mat22();
      this.v_K = new Mat22();
      this.v_pointCount = 0;
      this.v_tangentSpeed = 0;
      this.v_friction = 0;
      this.v_restitution = 0;
      this.v_invMassA = 0;
      this.v_invMassB = 0;
      this.v_invIA = 0;
      this.v_invIB = 0;
      this.p_localPoints = [vec2(0, 0), vec2(0, 0)];
      this.p_localNormal = vec2(0, 0);
      this.p_localPoint = vec2(0, 0);
      this.p_localCenterA = vec2(0, 0);
      this.p_localCenterB = vec2(0, 0);
      this.p_type = exports2.ManifoldType.e_unset;
      this.p_radiusA = 0;
      this.p_radiusB = 0;
      this.p_pointCount = 0;
      this.p_invMassA = 0;
      this.p_invMassB = 0;
      this.p_invIA = 0;
      this.p_invIB = 0;
    }
    Contact2.prototype.initialize = function (fA, indexA, fB, indexB, evaluateFcn) {
      this.m_fixtureA = fA;
      this.m_fixtureB = fB;
      this.m_indexA = indexA;
      this.m_indexB = indexB;
      this.m_evaluateFcn = evaluateFcn;
      this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
      this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
    };
    Contact2.prototype.recycle = function () {
      this.m_nodeA.recycle();
      this.m_nodeB.recycle();
      this.m_fixtureA = null;
      this.m_fixtureB = null;
      this.m_indexA = -1;
      this.m_indexB = -1;
      this.m_evaluateFcn = null;
      this.m_manifold.recycle();
      this.m_prev = null;
      this.m_next = null;
      this.m_toi = 1;
      this.m_toiCount = 0;
      this.m_toiFlag = false;
      this.m_friction = 0;
      this.m_restitution = 0;
      this.m_tangentSpeed = 0;
      this.m_enabledFlag = true;
      this.m_islandFlag = false;
      this.m_touchingFlag = false;
      this.m_filterFlag = false;
      this.m_bulletHitFlag = false;
      this.m_impulse.recycle();
      for (var _i = 0, _a2 = this.v_points; _i < _a2.length; _i++) {
        var point_1 = _a2[_i];
        point_1.recycle();
      }
      zeroVec2(this.v_normal);
      this.v_normalMass.setZero();
      this.v_K.setZero();
      this.v_pointCount = 0;
      this.v_tangentSpeed = 0;
      this.v_friction = 0;
      this.v_restitution = 0;
      this.v_invMassA = 0;
      this.v_invMassB = 0;
      this.v_invIA = 0;
      this.v_invIB = 0;
      for (var _b = 0, _c = this.p_localPoints; _b < _c.length; _b++) {
        var point_2 = _c[_b];
        zeroVec2(point_2);
      }
      zeroVec2(this.p_localNormal);
      zeroVec2(this.p_localPoint);
      zeroVec2(this.p_localCenterA);
      zeroVec2(this.p_localCenterB);
      this.p_type = exports2.ManifoldType.e_unset;
      this.p_radiusA = 0;
      this.p_radiusB = 0;
      this.p_pointCount = 0;
      this.p_invMassA = 0;
      this.p_invMassB = 0;
      this.p_invIA = 0;
      this.p_invIB = 0;
    };
    Contact2.prototype.initConstraint = function (step) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var shapeA = fixtureA.m_shape;
      var shapeB = fixtureB.m_shape;
      if (shapeA === null || shapeB === null) return;
      var manifold = this.m_manifold;
      var pointCount = manifold.pointCount;
      this.v_invMassA = bodyA.m_invMass;
      this.v_invMassB = bodyB.m_invMass;
      this.v_invIA = bodyA.m_invI;
      this.v_invIB = bodyB.m_invI;
      this.v_friction = this.m_friction;
      this.v_restitution = this.m_restitution;
      this.v_tangentSpeed = this.m_tangentSpeed;
      this.v_pointCount = pointCount;
      this.v_K.setZero();
      this.v_normalMass.setZero();
      this.p_invMassA = bodyA.m_invMass;
      this.p_invMassB = bodyB.m_invMass;
      this.p_invIA = bodyA.m_invI;
      this.p_invIB = bodyB.m_invI;
      copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);
      copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);
      this.p_radiusA = shapeA.m_radius;
      this.p_radiusB = shapeB.m_radius;
      this.p_type = manifold.type;
      copyVec2(this.p_localNormal, manifold.localNormal);
      copyVec2(this.p_localPoint, manifold.localPoint);
      this.p_pointCount = pointCount;
      for (var j = 0; j < SettingsInternal.maxManifoldPoints; ++j) {
        this.v_points[j].recycle();
        zeroVec2(this.p_localPoints[j]);
      }
      for (var j = 0; j < pointCount; ++j) {
        var cp = manifold.points[j];
        var vcp = this.v_points[j];
        if (step.warmStarting) {
          vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
          vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
        }
        copyVec2(this.p_localPoints[j], cp.localPoint);
      }
    };
    Contact2.prototype.getManifold = function () {
      return this.m_manifold;
    };
    Contact2.prototype.getWorldManifold = function (worldManifold2) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var shapeA = fixtureA.m_shape;
      var shapeB = fixtureB.m_shape;
      if (shapeA === null || shapeB === null) return;
      return this.m_manifold.getWorldManifold(worldManifold2, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
    };
    Contact2.prototype.setEnabled = function (flag) {
      this.m_enabledFlag = !!flag;
    };
    Contact2.prototype.isEnabled = function () {
      return this.m_enabledFlag;
    };
    Contact2.prototype.isTouching = function () {
      return this.m_touchingFlag;
    };
    Contact2.prototype.getNext = function () {
      return this.m_next;
    };
    Contact2.prototype.getFixtureA = function () {
      return this.m_fixtureA;
    };
    Contact2.prototype.getFixtureB = function () {
      return this.m_fixtureB;
    };
    Contact2.prototype.getChildIndexA = function () {
      return this.m_indexA;
    };
    Contact2.prototype.getChildIndexB = function () {
      return this.m_indexB;
    };
    Contact2.prototype.flagForFiltering = function () {
      this.m_filterFlag = true;
    };
    Contact2.prototype.setFriction = function (friction) {
      this.m_friction = friction;
    };
    Contact2.prototype.getFriction = function () {
      return this.m_friction;
    };
    Contact2.prototype.resetFriction = function () {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);
    };
    Contact2.prototype.setRestitution = function (restitution) {
      this.m_restitution = restitution;
    };
    Contact2.prototype.getRestitution = function () {
      return this.m_restitution;
    };
    Contact2.prototype.resetRestitution = function () {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);
    };
    Contact2.prototype.setTangentSpeed = function (speed) {
      this.m_tangentSpeed = speed;
    };
    Contact2.prototype.getTangentSpeed = function () {
      return this.m_tangentSpeed;
    };
    Contact2.prototype.evaluate = function (manifold, xfA2, xfB2) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      this.m_evaluateFcn(manifold, xfA2, fixtureA, this.m_indexA, xfB2, fixtureB, this.m_indexB);
    };
    Contact2.prototype.update = function (listener) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var shapeA = fixtureA.m_shape;
      var shapeB = fixtureB.m_shape;
      if (shapeA === null || shapeB === null) return;
      this.m_enabledFlag = true;
      var touching = false;
      var wasTouching = this.m_touchingFlag;
      var sensorA = fixtureA.m_isSensor;
      var sensorB = fixtureB.m_isSensor;
      var sensor = sensorA || sensorB;
      var xfA2 = bodyA.m_xf;
      var xfB2 = bodyB.m_xf;
      if (sensor) {
        touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA2, xfB2);
        this.m_manifold.pointCount = 0;
      } else {
        oldManifold.recycle();
        oldManifold.set(this.m_manifold);
        this.m_manifold.recycle();
        this.evaluate(this.m_manifold, xfA2, xfB2);
        touching = this.m_manifold.pointCount > 0;
        for (var i = 0; i < this.m_manifold.pointCount; ++i) {
          var nmp = this.m_manifold.points[i];
          nmp.normalImpulse = 0;
          nmp.tangentImpulse = 0;
          for (var j = 0; j < oldManifold.pointCount; ++j) {
            var omp = oldManifold.points[j];
            if (omp.id.key === nmp.id.key) {
              nmp.normalImpulse = omp.normalImpulse;
              nmp.tangentImpulse = omp.tangentImpulse;
              break;
            }
          }
        }
        if (touching !== wasTouching) {
          bodyA.setAwake(true);
          bodyB.setAwake(true);
        }
      }
      this.m_touchingFlag = touching;
      var hasListener = _typeof(listener) === "object" && listener !== null;
      if (!wasTouching && touching && hasListener) {
        listener.beginContact(this);
      }
      if (wasTouching && !touching && hasListener) {
        listener.endContact(this);
      }
      if (!sensor && touching && hasListener && oldManifold) {
        listener.preSolve(this, oldManifold);
      }
    };
    Contact2.prototype.solvePositionConstraint = function (step) {
      return this._solvePositionConstraint(step, null, null);
    };
    Contact2.prototype.solvePositionConstraintTOI = function (step, toiA, toiB) {
      return this._solvePositionConstraint(step, toiA, toiB);
    };
    Contact2.prototype._solvePositionConstraint = function (step, toiA, toiB) {
      var toi = toiA !== null && toiB !== null ? true : false;
      var minSeparation = 0;
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return minSeparation;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return minSeparation;
      bodyA.c_velocity;
      bodyB.c_velocity;
      var positionA = bodyA.c_position;
      var positionB = bodyB.c_position;
      var localCenterA = this.p_localCenterA;
      var localCenterB = this.p_localCenterB;
      var mA = 0;
      var iA = 0;
      if (!toi || bodyA === toiA || bodyA === toiB) {
        mA = this.p_invMassA;
        iA = this.p_invIA;
      }
      var mB = 0;
      var iB = 0;
      if (!toi || bodyB === toiA || bodyB === toiB) {
        mB = this.p_invMassB;
        iB = this.p_invIB;
      }
      copyVec2(cA, positionA.c);
      var aA = positionA.a;
      copyVec2(cB, positionB.c);
      var aB = positionB.a;
      for (var j = 0; j < this.p_pointCount; ++j) {
        getTransform(xfA, localCenterA, cA, aA);
        getTransform(xfB, localCenterB, cB, aB);
        var separation = void 0;
        switch (this.p_type) {
          case exports2.ManifoldType.e_circles:
            {
              transformVec2(pointA, xfA, this.p_localPoint);
              transformVec2(pointB, xfB, this.p_localPoints[0]);
              subVec2(normal$2, pointB, pointA);
              normalizeVec2(normal$2);
              combine2Vec2(point, 0.5, pointA, 0.5, pointB);
              separation = dotVec2(pointB, normal$2) - dotVec2(pointA, normal$2) - this.p_radiusA - this.p_radiusB;
              break;
            }
          case exports2.ManifoldType.e_faceA:
            {
              rotVec2(normal$2, xfA.q, this.p_localNormal);
              transformVec2(planePoint$1, xfA, this.p_localPoint);
              transformVec2(clipPoint, xfB, this.p_localPoints[j]);
              separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;
              copyVec2(point, clipPoint);
              break;
            }
          case exports2.ManifoldType.e_faceB:
            {
              rotVec2(normal$2, xfB.q, this.p_localNormal);
              transformVec2(planePoint$1, xfB, this.p_localPoint);
              transformVec2(clipPoint, xfA, this.p_localPoints[j]);
              separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;
              copyVec2(point, clipPoint);
              negVec2(normal$2);
              break;
            }
          default:
            {
              return minSeparation;
            }
        }
        subVec2(rA, point, cA);
        subVec2(rB, point, cB);
        minSeparation = math_min$9(minSeparation, separation);
        var baumgarte = toi ? SettingsInternal.toiBaugarte : SettingsInternal.baumgarte;
        var linearSlop = SettingsInternal.linearSlop;
        var maxLinearCorrection = SettingsInternal.maxLinearCorrection;
        var C = clamp$1(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0);
        var rnA = crossVec2Vec2(rA, normal$2);
        var rnB = crossVec2Vec2(rB, normal$2);
        var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
        var impulse = K > 0 ? -C / K : 0;
        scaleVec2(P$1, impulse, normal$2);
        minusScaleVec2(cA, mA, P$1);
        aA -= iA * crossVec2Vec2(rA, P$1);
        plusScaleVec2(cB, mB, P$1);
        aB += iB * crossVec2Vec2(rB, P$1);
      }
      copyVec2(positionA.c, cA);
      positionA.a = aA;
      copyVec2(positionB.c, cB);
      positionB.a = aB;
      return minSeparation;
    };
    Contact2.prototype.initVelocityConstraint = function (step) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var velocityA = bodyA.c_velocity;
      var velocityB = bodyB.c_velocity;
      var positionA = bodyA.c_position;
      var positionB = bodyB.c_position;
      var radiusA = this.p_radiusA;
      var radiusB = this.p_radiusB;
      var manifold = this.m_manifold;
      var mA = this.v_invMassA;
      var mB = this.v_invMassB;
      var iA = this.v_invIA;
      var iB = this.v_invIB;
      var localCenterA = this.p_localCenterA;
      var localCenterB = this.p_localCenterB;
      copyVec2(cA, positionA.c);
      var aA = positionA.a;
      copyVec2(vA, velocityA.v);
      var wA = velocityA.w;
      copyVec2(cB, positionB.c);
      var aB = positionB.a;
      copyVec2(vB, velocityB.v);
      var wB = velocityB.w;
      getTransform(xfA, localCenterA, cA, aA);
      getTransform(xfB, localCenterB, cB, aB);
      worldManifold.recycle();
      manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);
      copyVec2(this.v_normal, worldManifold.normal);
      for (var j = 0; j < this.v_pointCount; ++j) {
        var vcp = this.v_points[j];
        var wmp = worldManifold.points[j];
        subVec2(vcp.rA, wmp, cA);
        subVec2(vcp.rB, wmp, cB);
        var rnA = crossVec2Vec2(vcp.rA, this.v_normal);
        var rnB = crossVec2Vec2(vcp.rB, this.v_normal);
        var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
        vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
        crossVec2Num(tangent$1, this.v_normal, 1);
        var rtA = crossVec2Vec2(vcp.rA, tangent$1);
        var rtB = crossVec2Vec2(vcp.rB, tangent$1);
        var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
        vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
        vcp.velocityBias = 0;
        var vRel = 0;
        vRel += dotVec2(this.v_normal, vB);
        vRel += dotVec2(this.v_normal, crossNumVec2(temp$2, wB, vcp.rB));
        vRel -= dotVec2(this.v_normal, vA);
        vRel -= dotVec2(this.v_normal, crossNumVec2(temp$2, wA, vcp.rA));
        if (vRel < -SettingsInternal.velocityThreshold) {
          vcp.velocityBias = -this.v_restitution * vRel;
        }
      }
      if (this.v_pointCount == 2 && step.blockSolve) {
        var vcp1 = this.v_points[0];
        var vcp2 = this.v_points[1];
        var rn1A = crossVec2Vec2(vcp1.rA, this.v_normal);
        var rn1B = crossVec2Vec2(vcp1.rB, this.v_normal);
        var rn2A = crossVec2Vec2(vcp2.rA, this.v_normal);
        var rn2B = crossVec2Vec2(vcp2.rB, this.v_normal);
        var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
        var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
        var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
        var k_maxConditionNumber = 1e3;
        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
          this.v_K.ex.setNum(k11, k12);
          this.v_K.ey.setNum(k12, k22);
          var a_1 = this.v_K.ex.x;
          var b_1 = this.v_K.ey.x;
          var c2 = this.v_K.ex.y;
          var d_1 = this.v_K.ey.y;
          var det = a_1 * d_1 - b_1 * c2;
          if (det !== 0) {
            det = 1 / det;
          }
          this.v_normalMass.ex.x = det * d_1;
          this.v_normalMass.ey.x = -det * b_1;
          this.v_normalMass.ex.y = -det * c2;
          this.v_normalMass.ey.y = det * a_1;
        } else {
          this.v_pointCount = 1;
        }
      }
      copyVec2(positionA.c, cA);
      positionA.a = aA;
      copyVec2(velocityA.v, vA);
      velocityA.w = wA;
      copyVec2(positionB.c, cB);
      positionB.a = aB;
      copyVec2(velocityB.v, vB);
      velocityB.w = wB;
    };
    Contact2.prototype.warmStartConstraint = function (step) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var velocityA = bodyA.c_velocity;
      var velocityB = bodyB.c_velocity;
      bodyA.c_position;
      bodyB.c_position;
      var mA = this.v_invMassA;
      var iA = this.v_invIA;
      var mB = this.v_invMassB;
      var iB = this.v_invIB;
      copyVec2(vA, velocityA.v);
      var wA = velocityA.w;
      copyVec2(vB, velocityB.v);
      var wB = velocityB.w;
      copyVec2(normal$2, this.v_normal);
      crossVec2Num(tangent$1, normal$2, 1);
      for (var j = 0; j < this.v_pointCount; ++j) {
        var vcp = this.v_points[j];
        combine2Vec2(P$1, vcp.normalImpulse, normal$2, vcp.tangentImpulse, tangent$1);
        wA -= iA * crossVec2Vec2(vcp.rA, P$1);
        minusScaleVec2(vA, mA, P$1);
        wB += iB * crossVec2Vec2(vcp.rB, P$1);
        plusScaleVec2(vB, mB, P$1);
      }
      copyVec2(velocityA.v, vA);
      velocityA.w = wA;
      copyVec2(velocityB.v, vB);
      velocityB.w = wB;
    };
    Contact2.prototype.storeConstraintImpulses = function (step) {
      var manifold = this.m_manifold;
      for (var j = 0; j < this.v_pointCount; ++j) {
        manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
        manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
      }
    };
    Contact2.prototype.solveVelocityConstraint = function (step) {
      var fixtureA = this.m_fixtureA;
      var fixtureB = this.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      var velocityA = bodyA.c_velocity;
      bodyA.c_position;
      var velocityB = bodyB.c_velocity;
      bodyB.c_position;
      var mA = this.v_invMassA;
      var iA = this.v_invIA;
      var mB = this.v_invMassB;
      var iB = this.v_invIB;
      copyVec2(vA, velocityA.v);
      var wA = velocityA.w;
      copyVec2(vB, velocityB.v);
      var wB = velocityB.w;
      copyVec2(normal$2, this.v_normal);
      crossVec2Num(tangent$1, normal$2, 1);
      var friction = this.v_friction;
      for (var j = 0; j < this.v_pointCount; ++j) {
        var vcp = this.v_points[j];
        zeroVec2(dv);
        plusVec2(dv, vB);
        plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));
        minusVec2(dv, vA);
        minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));
        var vt = dotVec2(dv, tangent$1) - this.v_tangentSpeed;
        var lambda = vcp.tangentMass * -vt;
        var maxFriction = friction * vcp.normalImpulse;
        var newImpulse = clamp$1(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
        lambda = newImpulse - vcp.tangentImpulse;
        vcp.tangentImpulse = newImpulse;
        scaleVec2(P$1, lambda, tangent$1);
        minusScaleVec2(vA, mA, P$1);
        wA -= iA * crossVec2Vec2(vcp.rA, P$1);
        plusScaleVec2(vB, mB, P$1);
        wB += iB * crossVec2Vec2(vcp.rB, P$1);
      }
      if (this.v_pointCount == 1 || step.blockSolve == false) {
        for (var i = 0; i < this.v_pointCount; ++i) {
          var vcp = this.v_points[i];
          zeroVec2(dv);
          plusVec2(dv, vB);
          plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));
          minusVec2(dv, vA);
          minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));
          var vn = dotVec2(dv, normal$2);
          var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
          var newImpulse = math_max$5(vcp.normalImpulse + lambda, 0);
          lambda = newImpulse - vcp.normalImpulse;
          vcp.normalImpulse = newImpulse;
          scaleVec2(P$1, lambda, normal$2);
          minusScaleVec2(vA, mA, P$1);
          wA -= iA * crossVec2Vec2(vcp.rA, P$1);
          plusScaleVec2(vB, mB, P$1);
          wB += iB * crossVec2Vec2(vcp.rB, P$1);
        }
      } else {
        var vcp1 = this.v_points[0];
        var vcp2 = this.v_points[1];
        setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);
        zeroVec2(dv1);
        plusVec2(dv1, vB);
        plusVec2(dv1, crossNumVec2(temp$2, wB, vcp1.rB));
        minusVec2(dv1, vA);
        minusVec2(dv1, crossNumVec2(temp$2, wA, vcp1.rA));
        zeroVec2(dv2);
        plusVec2(dv2, vB);
        plusVec2(dv2, crossNumVec2(temp$2, wB, vcp2.rB));
        minusVec2(dv2, vA);
        minusVec2(dv2, crossNumVec2(temp$2, wA, vcp2.rA));
        var vn1 = dotVec2(dv1, normal$2);
        var vn2 = dotVec2(dv2, normal$2);
        setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);
        b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;
        b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;
        while (true) {
          zeroVec2(x);
          x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);
          x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);
          if (x.x >= 0 && x.y >= 0) {
            subVec2(d, x, a);
            scaleVec2(P1, d.x, normal$2);
            scaleVec2(P2, d.y, normal$2);
            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);
            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);
            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
            vcp1.normalImpulse = x.x;
            vcp2.normalImpulse = x.y;
            break;
          }
          x.x = -vcp1.normalMass * b.x;
          x.y = 0;
          vn1 = 0;
          vn2 = this.v_K.ex.y * x.x + b.y;
          if (x.x >= 0 && vn2 >= 0) {
            subVec2(d, x, a);
            scaleVec2(P1, d.x, normal$2);
            scaleVec2(P2, d.y, normal$2);
            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);
            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);
            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
            vcp1.normalImpulse = x.x;
            vcp2.normalImpulse = x.y;
            break;
          }
          x.x = 0;
          x.y = -vcp2.normalMass * b.y;
          vn1 = this.v_K.ey.x * x.y + b.x;
          vn2 = 0;
          if (x.y >= 0 && vn1 >= 0) {
            subVec2(d, x, a);
            scaleVec2(P1, d.x, normal$2);
            scaleVec2(P2, d.y, normal$2);
            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);
            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);
            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
            vcp1.normalImpulse = x.x;
            vcp2.normalImpulse = x.y;
            break;
          }
          x.x = 0;
          x.y = 0;
          vn1 = b.x;
          vn2 = b.y;
          if (vn1 >= 0 && vn2 >= 0) {
            subVec2(d, x, a);
            scaleVec2(P1, d.x, normal$2);
            scaleVec2(P2, d.y, normal$2);
            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);
            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);
            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
            vcp1.normalImpulse = x.x;
            vcp2.normalImpulse = x.y;
            break;
          }
          break;
        }
      }
      copyVec2(velocityA.v, vA);
      velocityA.w = wA;
      copyVec2(velocityB.v, vB);
      velocityB.w = wB;
    };
    Contact2.addType = function (type1, type2, callback) {
      s_registers[type1] = s_registers[type1] || {};
      s_registers[type1][type2] = callback;
    };
    Contact2.create = function (fixtureA, indexA, fixtureB, indexB) {
      var typeA = fixtureA.m_shape.m_type;
      var typeB = fixtureB.m_shape.m_type;
      var contact = contactPool.allocate();
      var evaluateFcn;
      if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
        contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
      } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
        contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
      } else {
        return null;
      }
      fixtureA = contact.m_fixtureA;
      fixtureB = contact.m_fixtureB;
      indexA = contact.getChildIndexA();
      indexB = contact.getChildIndexB();
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      contact.m_nodeA.contact = contact;
      contact.m_nodeA.other = bodyB;
      contact.m_nodeA.prev = null;
      contact.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
        bodyA.m_contactList.prev = contact.m_nodeA;
      }
      bodyA.m_contactList = contact.m_nodeA;
      contact.m_nodeB.contact = contact;
      contact.m_nodeB.other = bodyA;
      contact.m_nodeB.prev = null;
      contact.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
        bodyB.m_contactList.prev = contact.m_nodeB;
      }
      bodyB.m_contactList = contact.m_nodeB;
      if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
        bodyA.setAwake(true);
        bodyB.setAwake(true);
      }
      return contact;
    };
    Contact2.destroy = function (contact, listener) {
      var fixtureA = contact.m_fixtureA;
      var fixtureB = contact.m_fixtureB;
      if (fixtureA === null || fixtureB === null) return;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      if (bodyA === null || bodyB === null) return;
      if (contact.isTouching()) {
        listener.endContact(contact);
      }
      if (contact.m_nodeA.prev) {
        contact.m_nodeA.prev.next = contact.m_nodeA.next;
      }
      if (contact.m_nodeA.next) {
        contact.m_nodeA.next.prev = contact.m_nodeA.prev;
      }
      if (contact.m_nodeA == bodyA.m_contactList) {
        bodyA.m_contactList = contact.m_nodeA.next;
      }
      if (contact.m_nodeB.prev) {
        contact.m_nodeB.prev.next = contact.m_nodeB.next;
      }
      if (contact.m_nodeB.next) {
        contact.m_nodeB.next.prev = contact.m_nodeB.prev;
      }
      if (contact.m_nodeB == bodyB.m_contactList) {
        bodyB.m_contactList = contact.m_nodeB.next;
      }
      if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {
        bodyA.setAwake(true);
        bodyB.setAwake(true);
      }
      contactPool.release(contact);
    };
    return Contact2;
  }();
  var DEFAULTS$c = {
    gravity: Vec2.zero(),
    allowSleep: true,
    warmStarting: true,
    continuousPhysics: true,
    subStepping: false,
    blockSolve: true,
    velocityIterations: 8,
    positionIterations: 3
  };
  var World = /** @class */
  function () {
    function World2(def) {
      if (!(this instanceof World2)) {
        return new World2(def);
      }
      this.s_step = new TimeStep();
      if (!def) {
        def = {};
      } else if (Vec2.isValid(def)) {
        def = {
          gravity: def
        };
      }
      def = options(def, DEFAULTS$c);
      this.m_solver = new Solver(this);
      this.m_broadPhase = new BroadPhase();
      this.m_contactList = null;
      this.m_contactCount = 0;
      this.m_bodyList = null;
      this.m_bodyCount = 0;
      this.m_jointList = null;
      this.m_jointCount = 0;
      this.m_stepComplete = true;
      this.m_allowSleep = def.allowSleep;
      this.m_gravity = Vec2.clone(def.gravity);
      this.m_clearForces = true;
      this.m_newFixture = false;
      this.m_locked = false;
      this.m_warmStarting = def.warmStarting;
      this.m_continuousPhysics = def.continuousPhysics;
      this.m_subStepping = def.subStepping;
      this.m_blockSolve = def.blockSolve;
      this.m_velocityIterations = def.velocityIterations;
      this.m_positionIterations = def.positionIterations;
      this.m_t = 0;
      this.m_step_callback = [];
    }
    World2.prototype._serialize = function () {
      var bodies = [];
      var joints = [];
      for (var b2 = this.getBodyList(); b2; b2 = b2.getNext()) {
        bodies.push(b2);
      }
      for (var j = this.getJointList(); j; j = j.getNext()) {
        if (typeof j._serialize === "function") {
          joints.push(j);
        }
      }
      return {
        gravity: this.m_gravity,
        bodies: bodies,
        joints: joints
      };
    };
    World2._deserialize = function (data, context, restore) {
      if (!data) {
        return new World2();
      }
      var world = new World2(data.gravity);
      if (data.bodies) {
        for (var i = data.bodies.length - 1; i >= 0; i -= 1) {
          world._addBody(restore(Body, data.bodies[i], world));
        }
      }
      if (data.joints) {
        for (var i = data.joints.length - 1; i >= 0; i--) {
          world.createJoint(restore(Joint, data.joints[i], world));
        }
      }
      return world;
    };
    World2.prototype.getBodyList = function () {
      return this.m_bodyList;
    };
    World2.prototype.getJointList = function () {
      return this.m_jointList;
    };
    World2.prototype.getContactList = function () {
      return this.m_contactList;
    };
    World2.prototype.getBodyCount = function () {
      return this.m_bodyCount;
    };
    World2.prototype.getJointCount = function () {
      return this.m_jointCount;
    };
    World2.prototype.getContactCount = function () {
      return this.m_contactCount;
    };
    World2.prototype.setGravity = function (gravity) {
      this.m_gravity.set(gravity);
    };
    World2.prototype.getGravity = function () {
      return this.m_gravity;
    };
    World2.prototype.isLocked = function () {
      return this.m_locked;
    };
    World2.prototype.setAllowSleeping = function (flag) {
      if (flag == this.m_allowSleep) {
        return;
      }
      this.m_allowSleep = flag;
      if (this.m_allowSleep == false) {
        for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {
          b2.setAwake(true);
        }
      }
    };
    World2.prototype.getAllowSleeping = function () {
      return this.m_allowSleep;
    };
    World2.prototype.setWarmStarting = function (flag) {
      this.m_warmStarting = flag;
    };
    World2.prototype.getWarmStarting = function () {
      return this.m_warmStarting;
    };
    World2.prototype.setContinuousPhysics = function (flag) {
      this.m_continuousPhysics = flag;
    };
    World2.prototype.getContinuousPhysics = function () {
      return this.m_continuousPhysics;
    };
    World2.prototype.setSubStepping = function (flag) {
      this.m_subStepping = flag;
    };
    World2.prototype.getSubStepping = function () {
      return this.m_subStepping;
    };
    World2.prototype.setAutoClearForces = function (flag) {
      this.m_clearForces = flag;
    };
    World2.prototype.getAutoClearForces = function () {
      return this.m_clearForces;
    };
    World2.prototype.clearForces = function () {
      for (var body = this.m_bodyList; body; body = body.getNext()) {
        body.m_force.setZero();
        body.m_torque = 0;
      }
    };
    World2.prototype.queryAABB = function (aabb, callback) {
      var broadPhase = this.m_broadPhase;
      this.m_broadPhase.query(aabb, function (proxyId) {
        var proxy = broadPhase.getUserData(proxyId);
        return callback(proxy.fixture);
      });
    };
    World2.prototype.rayCast = function (point1, point2, callback) {
      var broadPhase = this.m_broadPhase;
      this.m_broadPhase.rayCast({
        maxFraction: 1,
        p1: point1,
        p2: point2
      }, function (input2, proxyId) {
        var proxy = broadPhase.getUserData(proxyId);
        var fixture = proxy.fixture;
        var index = proxy.childIndex;
        var output2 = {};
        var hit = fixture.rayCast(output2, input2, index);
        if (hit) {
          var fraction = output2.fraction;
          var point3 = Vec2.add(Vec2.mulNumVec2(1 - fraction, input2.p1), Vec2.mulNumVec2(fraction, input2.p2));
          return callback(fixture, point3, output2.normal, fraction);
        }
        return input2.maxFraction;
      });
    };
    World2.prototype.getProxyCount = function () {
      return this.m_broadPhase.getProxyCount();
    };
    World2.prototype.getTreeHeight = function () {
      return this.m_broadPhase.getTreeHeight();
    };
    World2.prototype.getTreeBalance = function () {
      return this.m_broadPhase.getTreeBalance();
    };
    World2.prototype.getTreeQuality = function () {
      return this.m_broadPhase.getTreeQuality();
    };
    World2.prototype.shiftOrigin = function (newOrigin) {
      if (this.isLocked()) {
        return;
      }
      for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {
        b2.m_xf.p.sub(newOrigin);
        b2.m_sweep.c0.sub(newOrigin);
        b2.m_sweep.c.sub(newOrigin);
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
        j.shiftOrigin(newOrigin);
      }
      this.m_broadPhase.shiftOrigin(newOrigin);
    };
    World2.prototype._addBody = function (body) {
      if (this.isLocked()) {
        return;
      }
      body.m_prev = null;
      body.m_next = this.m_bodyList;
      if (this.m_bodyList) {
        this.m_bodyList.m_prev = body;
      }
      this.m_bodyList = body;
      ++this.m_bodyCount;
    };
    World2.prototype.createBody = function (arg1, arg2) {
      if (this.isLocked()) {
        return null;
      }
      var def = {};
      if (!arg1) ;else if (Vec2.isValid(arg1)) {
        def = {
          position: arg1,
          angle: arg2
        };
      } else if (_typeof(arg1) === "object") {
        def = arg1;
      }
      var body = new Body(this, def);
      this._addBody(body);
      return body;
    };
    World2.prototype.createDynamicBody = function (arg1, arg2) {
      var def = {};
      if (!arg1) ;else if (Vec2.isValid(arg1)) {
        def = {
          position: arg1,
          angle: arg2
        };
      } else if (_typeof(arg1) === "object") {
        def = arg1;
      }
      def.type = "dynamic";
      return this.createBody(def);
    };
    World2.prototype.createKinematicBody = function (arg1, arg2) {
      var def = {};
      if (!arg1) ;else if (Vec2.isValid(arg1)) {
        def = {
          position: arg1,
          angle: arg2
        };
      } else if (_typeof(arg1) === "object") {
        def = arg1;
      }
      def.type = "kinematic";
      return this.createBody(def);
    };
    World2.prototype.destroyBody = function (b2) {
      if (this.isLocked()) {
        return;
      }
      if (b2.m_destroyed) {
        return false;
      }
      var je = b2.m_jointList;
      while (je) {
        var je0 = je;
        je = je.next;
        this.publish("remove-joint", je0.joint);
        this.destroyJoint(je0.joint);
        b2.m_jointList = je;
      }
      b2.m_jointList = null;
      var ce = b2.m_contactList;
      while (ce) {
        var ce0 = ce;
        ce = ce.next;
        this.destroyContact(ce0.contact);
        b2.m_contactList = ce;
      }
      b2.m_contactList = null;
      var f = b2.m_fixtureList;
      while (f) {
        var f0 = f;
        f = f.m_next;
        this.publish("remove-fixture", f0);
        f0.destroyProxies(this.m_broadPhase);
        b2.m_fixtureList = f;
      }
      b2.m_fixtureList = null;
      if (b2.m_prev) {
        b2.m_prev.m_next = b2.m_next;
      }
      if (b2.m_next) {
        b2.m_next.m_prev = b2.m_prev;
      }
      if (b2 == this.m_bodyList) {
        this.m_bodyList = b2.m_next;
      }
      b2.m_destroyed = true;
      --this.m_bodyCount;
      this.publish("remove-body", b2);
      return true;
    };
    World2.prototype.createJoint = function (joint) {
      if (this.isLocked()) {
        return null;
      }
      joint.m_prev = null;
      joint.m_next = this.m_jointList;
      if (this.m_jointList) {
        this.m_jointList.m_prev = joint;
      }
      this.m_jointList = joint;
      ++this.m_jointCount;
      joint.m_edgeA.joint = joint;
      joint.m_edgeA.other = joint.m_bodyB;
      joint.m_edgeA.prev = null;
      joint.m_edgeA.next = joint.m_bodyA.m_jointList;
      if (joint.m_bodyA.m_jointList) joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
      joint.m_bodyA.m_jointList = joint.m_edgeA;
      joint.m_edgeB.joint = joint;
      joint.m_edgeB.other = joint.m_bodyA;
      joint.m_edgeB.prev = null;
      joint.m_edgeB.next = joint.m_bodyB.m_jointList;
      if (joint.m_bodyB.m_jointList) joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
      joint.m_bodyB.m_jointList = joint.m_edgeB;
      if (joint.m_collideConnected == false) {
        for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {
          if (edge.other == joint.m_bodyA) {
            edge.contact.flagForFiltering();
          }
        }
      }
      return joint;
    };
    World2.prototype.destroyJoint = function (joint) {
      if (this.isLocked()) {
        return;
      }
      if (joint.m_prev) {
        joint.m_prev.m_next = joint.m_next;
      }
      if (joint.m_next) {
        joint.m_next.m_prev = joint.m_prev;
      }
      if (joint == this.m_jointList) {
        this.m_jointList = joint.m_next;
      }
      var bodyA = joint.m_bodyA;
      var bodyB = joint.m_bodyB;
      bodyA.setAwake(true);
      bodyB.setAwake(true);
      if (joint.m_edgeA.prev) {
        joint.m_edgeA.prev.next = joint.m_edgeA.next;
      }
      if (joint.m_edgeA.next) {
        joint.m_edgeA.next.prev = joint.m_edgeA.prev;
      }
      if (joint.m_edgeA == bodyA.m_jointList) {
        bodyA.m_jointList = joint.m_edgeA.next;
      }
      joint.m_edgeA.prev = null;
      joint.m_edgeA.next = null;
      if (joint.m_edgeB.prev) {
        joint.m_edgeB.prev.next = joint.m_edgeB.next;
      }
      if (joint.m_edgeB.next) {
        joint.m_edgeB.next.prev = joint.m_edgeB.prev;
      }
      if (joint.m_edgeB == bodyB.m_jointList) {
        bodyB.m_jointList = joint.m_edgeB.next;
      }
      joint.m_edgeB.prev = null;
      joint.m_edgeB.next = null;
      --this.m_jointCount;
      if (joint.m_collideConnected == false) {
        var edge = bodyB.getContactList();
        while (edge) {
          if (edge.other == bodyA) {
            edge.contact.flagForFiltering();
          }
          edge = edge.next;
        }
      }
      this.publish("remove-joint", joint);
    };
    World2.prototype.step = function (timeStep, velocityIterations, positionIterations) {
      this.publish("pre-step", timeStep);
      if ((velocityIterations | 0) !== velocityIterations) {
        velocityIterations = 0;
      }
      velocityIterations = velocityIterations || this.m_velocityIterations;
      positionIterations = positionIterations || this.m_positionIterations;
      if (this.m_newFixture) {
        this.findNewContacts();
        this.m_newFixture = false;
      }
      this.m_locked = true;
      this.s_step.reset(timeStep);
      this.s_step.velocityIterations = velocityIterations;
      this.s_step.positionIterations = positionIterations;
      this.s_step.warmStarting = this.m_warmStarting;
      this.s_step.blockSolve = this.m_blockSolve;
      this.updateContacts();
      if (this.m_stepComplete && timeStep > 0) {
        this.m_solver.solveWorld(this.s_step);
        for (var b2 = this.m_bodyList; b2; b2 = b2.getNext()) {
          if (b2.m_islandFlag == false) {
            continue;
          }
          if (b2.isStatic()) {
            continue;
          }
          b2.synchronizeFixtures();
        }
        this.findNewContacts();
      }
      if (this.m_continuousPhysics && timeStep > 0) {
        this.m_solver.solveWorldTOI(this.s_step);
      }
      if (this.m_clearForces) {
        this.clearForces();
      }
      this.m_locked = false;
      var callback;
      while (callback = this.m_step_callback.shift()) {
        callback(this);
      }
      this.publish("post-step", timeStep);
    };
    World2.prototype.queueUpdate = function (callback) {
      if (!this.isLocked()) {
        callback(this);
      } else {
        this.m_step_callback.push(callback);
      }
    };
    World2.prototype.findNewContacts = function () {
      var _this = this;
      this.m_broadPhase.updatePairs(function (proxyA, proxyB) {
        return _this.createContact(proxyA, proxyB);
      });
    };
    World2.prototype.createContact = function (proxyA, proxyB) {
      var fixtureA = proxyA.fixture;
      var fixtureB = proxyB.fixture;
      var indexA = proxyA.childIndex;
      var indexB = proxyB.childIndex;
      var bodyA = fixtureA.getBody();
      var bodyB = fixtureB.getBody();
      if (bodyA == bodyB) {
        return;
      }
      var edge = bodyB.getContactList();
      while (edge) {
        if (edge.other == bodyA) {
          var fA = edge.contact.getFixtureA();
          var fB = edge.contact.getFixtureB();
          var iA = edge.contact.getChildIndexA();
          var iB = edge.contact.getChildIndexB();
          if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
            return;
          }
          if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
            return;
          }
        }
        edge = edge.next;
      }
      if (bodyB.shouldCollide(bodyA) == false) {
        return;
      }
      if (fixtureB.shouldCollide(fixtureA) == false) {
        return;
      }
      var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);
      if (contact == null) {
        return;
      }
      contact.m_prev = null;
      if (this.m_contactList != null) {
        contact.m_next = this.m_contactList;
        this.m_contactList.m_prev = contact;
      }
      this.m_contactList = contact;
      ++this.m_contactCount;
    };
    World2.prototype.updateContacts = function () {
      var c2;
      var next_c = this.m_contactList;
      while (c2 = next_c) {
        next_c = c2.getNext();
        var fixtureA = c2.getFixtureA();
        var fixtureB = c2.getFixtureB();
        var indexA = c2.getChildIndexA();
        var indexB = c2.getChildIndexB();
        var bodyA = fixtureA.getBody();
        var bodyB = fixtureB.getBody();
        if (c2.m_filterFlag) {
          if (bodyB.shouldCollide(bodyA) == false) {
            this.destroyContact(c2);
            continue;
          }
          if (fixtureB.shouldCollide(fixtureA) == false) {
            this.destroyContact(c2);
            continue;
          }
          c2.m_filterFlag = false;
        }
        var activeA = bodyA.isAwake() && !bodyA.isStatic();
        var activeB = bodyB.isAwake() && !bodyB.isStatic();
        if (activeA == false && activeB == false) {
          continue;
        }
        var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
        var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
        var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);
        if (overlap == false) {
          this.destroyContact(c2);
          continue;
        }
        c2.update(this);
      }
    };
    World2.prototype.destroyContact = function (contact) {
      if (contact.m_prev) {
        contact.m_prev.m_next = contact.m_next;
      }
      if (contact.m_next) {
        contact.m_next.m_prev = contact.m_prev;
      }
      if (contact == this.m_contactList) {
        this.m_contactList = contact.m_next;
      }
      Contact.destroy(contact, this);
      --this.m_contactCount;
    };
    World2.prototype.on = function (name, listener) {
      if (typeof name !== "string" || typeof listener !== "function") {
        return this;
      }
      if (!this._listeners) {
        this._listeners = {};
      }
      if (!this._listeners[name]) {
        this._listeners[name] = [];
      }
      this._listeners[name].push(listener);
      return this;
    };
    World2.prototype.off = function (name, listener) {
      if (typeof name !== "string" || typeof listener !== "function") {
        return this;
      }
      var listeners = this._listeners && this._listeners[name];
      if (!listeners || !listeners.length) {
        return this;
      }
      var index = listeners.indexOf(listener);
      if (index >= 0) {
        listeners.splice(index, 1);
      }
      return this;
    };
    World2.prototype.publish = function (name, arg1, arg2, arg3) {
      var listeners = this._listeners && this._listeners[name];
      if (!listeners || !listeners.length) {
        return 0;
      }
      for (var l = 0; l < listeners.length; l++) {
        listeners[l].call(this, arg1, arg2, arg3);
      }
      return listeners.length;
    };
    World2.prototype.beginContact = function (contact) {
      this.publish("begin-contact", contact);
    };
    World2.prototype.endContact = function (contact) {
      this.publish("end-contact", contact);
    };
    World2.prototype.preSolve = function (contact, oldManifold2) {
      this.publish("pre-solve", contact, oldManifold2);
    };
    World2.prototype.postSolve = function (contact, impulse) {
      this.publish("post-solve", contact, impulse);
    };
    return World2;
  }();
  var Vec3 = /** @class */
  function () {
    function Vec32(x2, y, z) {
      if (!(this instanceof Vec32)) {
        return new Vec32(x2, y, z);
      }
      if (typeof x2 === "undefined") {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      } else if (_typeof(x2) === "object") {
        this.x = x2.x;
        this.y = x2.y;
        this.z = x2.z;
      } else {
        this.x = x2;
        this.y = y;
        this.z = z;
      }
    }
    Vec32.prototype._serialize = function () {
      return {
        x: this.x,
        y: this.y,
        z: this.z
      };
    };
    Vec32._deserialize = function (data) {
      var obj = Object.create(Vec32.prototype);
      obj.x = data.x;
      obj.y = data.y;
      obj.z = data.z;
      return obj;
    };
    Vec32.neo = function (x2, y, z) {
      var obj = Object.create(Vec32.prototype);
      obj.x = x2;
      obj.y = y;
      obj.z = z;
      return obj;
    };
    Vec32.zero = function () {
      var obj = Object.create(Vec32.prototype);
      obj.x = 0;
      obj.y = 0;
      obj.z = 0;
      return obj;
    };
    Vec32.clone = function (v3) {
      return Vec32.neo(v3.x, v3.y, v3.z);
    };
    Vec32.prototype.toString = function () {
      return JSON.stringify(this);
    };
    Vec32.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Number.isFinite(obj.x) && Number.isFinite(obj.y) && Number.isFinite(obj.z);
    };
    Vec32.assert = function (o) {};
    Vec32.prototype.setZero = function () {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      return this;
    };
    Vec32.prototype.set = function (x2, y, z) {
      this.x = x2;
      this.y = y;
      this.z = z;
      return this;
    };
    Vec32.prototype.add = function (w) {
      this.x += w.x;
      this.y += w.y;
      this.z += w.z;
      return this;
    };
    Vec32.prototype.sub = function (w) {
      this.x -= w.x;
      this.y -= w.y;
      this.z -= w.z;
      return this;
    };
    Vec32.prototype.mul = function (m) {
      this.x *= m;
      this.y *= m;
      this.z *= m;
      return this;
    };
    Vec32.areEqual = function (v3, w) {
      return v3 === w || _typeof(v3) === "object" && v3 !== null && _typeof(w) === "object" && w !== null && v3.x === w.x && v3.y === w.y && v3.z === w.z;
    };
    Vec32.dot = function (v3, w) {
      return v3.x * w.x + v3.y * w.y + v3.z * w.z;
    };
    Vec32.cross = function (v3, w) {
      return new Vec32(v3.y * w.z - v3.z * w.y, v3.z * w.x - v3.x * w.z, v3.x * w.y - v3.y * w.x);
    };
    Vec32.add = function (v3, w) {
      return new Vec32(v3.x + w.x, v3.y + w.y, v3.z + w.z);
    };
    Vec32.sub = function (v3, w) {
      return new Vec32(v3.x - w.x, v3.y - w.y, v3.z - w.z);
    };
    Vec32.mul = function (v3, m) {
      return new Vec32(m * v3.x, m * v3.y, m * v3.z);
    };
    Vec32.prototype.neg = function () {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    };
    Vec32.neg = function (v3) {
      return new Vec32(-v3.x, -v3.y, -v3.z);
    };
    return Vec32;
  }();
  var v1$2 = vec2(0, 0);
  var v2$1 = vec2(0, 0);
  var EdgeShape = /** @class */
  function (_super) {
    __extends$1(EdgeShape2, _super);
    function EdgeShape2(v122, v22) {
      var _this = this;
      if (!(_this instanceof EdgeShape2)) {
        return new EdgeShape2(v122, v22);
      }
      _this = _super.call(this) || this;
      _this.m_type = EdgeShape2.TYPE;
      _this.m_radius = SettingsInternal.polygonRadius;
      _this.m_vertex1 = v122 ? Vec2.clone(v122) : Vec2.zero();
      _this.m_vertex2 = v22 ? Vec2.clone(v22) : Vec2.zero();
      _this.m_vertex0 = Vec2.zero();
      _this.m_vertex3 = Vec2.zero();
      _this.m_hasVertex0 = false;
      _this.m_hasVertex3 = false;
      return _this;
    }
    EdgeShape2.prototype._serialize = function () {
      return {
        type: this.m_type,
        vertex1: this.m_vertex1,
        vertex2: this.m_vertex2,
        vertex0: this.m_vertex0,
        vertex3: this.m_vertex3,
        hasVertex0: this.m_hasVertex0,
        hasVertex3: this.m_hasVertex3
      };
    };
    EdgeShape2._deserialize = function (data) {
      var shape = new EdgeShape2(data.vertex1, data.vertex2);
      if (shape.m_hasVertex0) {
        shape.setPrevVertex(data.vertex0);
      }
      if (shape.m_hasVertex3) {
        shape.setNextVertex(data.vertex3);
      }
      return shape;
    };
    EdgeShape2.prototype._reset = function () {};
    EdgeShape2.prototype.getRadius = function () {
      return this.m_radius;
    };
    EdgeShape2.prototype.getType = function () {
      return this.m_type;
    };
    EdgeShape2.prototype.setNext = function (v3) {
      return this.setNextVertex(v3);
    };
    EdgeShape2.prototype.setNextVertex = function (v3) {
      if (v3) {
        this.m_vertex3.setVec2(v3);
        this.m_hasVertex3 = true;
      } else {
        this.m_vertex3.setZero();
        this.m_hasVertex3 = false;
      }
      return this;
    };
    EdgeShape2.prototype.getNextVertex = function () {
      return this.m_vertex3;
    };
    EdgeShape2.prototype.setPrev = function (v3) {
      return this.setPrevVertex(v3);
    };
    EdgeShape2.prototype.setPrevVertex = function (v3) {
      if (v3) {
        this.m_vertex0.setVec2(v3);
        this.m_hasVertex0 = true;
      } else {
        this.m_vertex0.setZero();
        this.m_hasVertex0 = false;
      }
      return this;
    };
    EdgeShape2.prototype.getPrevVertex = function () {
      return this.m_vertex0;
    };
    EdgeShape2.prototype._set = function (v122, v22) {
      this.m_vertex1.setVec2(v122);
      this.m_vertex2.setVec2(v22);
      this.m_hasVertex0 = false;
      this.m_hasVertex3 = false;
      return this;
    };
    EdgeShape2.prototype._clone = function () {
      var clone = new EdgeShape2();
      clone.m_type = this.m_type;
      clone.m_radius = this.m_radius;
      clone.m_vertex1.setVec2(this.m_vertex1);
      clone.m_vertex2.setVec2(this.m_vertex2);
      clone.m_vertex0.setVec2(this.m_vertex0);
      clone.m_vertex3.setVec2(this.m_vertex3);
      clone.m_hasVertex0 = this.m_hasVertex0;
      clone.m_hasVertex3 = this.m_hasVertex3;
      return clone;
    };
    EdgeShape2.prototype.getChildCount = function () {
      return 1;
    };
    EdgeShape2.prototype.testPoint = function (xf2, p) {
      return false;
    };
    EdgeShape2.prototype.rayCast = function (output2, input2, xf2, childIndex) {
      var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));
      var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));
      var d2 = Vec2.sub(p2, p1);
      var v122 = this.m_vertex1;
      var v22 = this.m_vertex2;
      var e3 = Vec2.sub(v22, v122);
      var normal3 = Vec2.neo(e3.y, -e3.x);
      normal3.normalize();
      var numerator = Vec2.dot(normal3, Vec2.sub(v122, p1));
      var denominator = Vec2.dot(normal3, d2);
      if (denominator == 0) {
        return false;
      }
      var t = numerator / denominator;
      if (t < 0 || input2.maxFraction < t) {
        return false;
      }
      var q = Vec2.add(p1, Vec2.mulNumVec2(t, d2));
      var r = Vec2.sub(v22, v122);
      var rr = Vec2.dot(r, r);
      if (rr == 0) {
        return false;
      }
      var s2 = Vec2.dot(Vec2.sub(q, v122), r) / rr;
      if (s2 < 0 || 1 < s2) {
        return false;
      }
      output2.fraction = t;
      if (numerator > 0) {
        output2.normal = Rot.mulVec2(xf2.q, normal3).neg();
      } else {
        output2.normal = Rot.mulVec2(xf2.q, normal3);
      }
      return true;
    };
    EdgeShape2.prototype.computeAABB = function (aabb, xf2, childIndex) {
      transformVec2(v1$2, xf2, this.m_vertex1);
      transformVec2(v2$1, xf2, this.m_vertex2);
      AABB.combinePoints(aabb, v1$2, v2$1);
      AABB.extend(aabb, this.m_radius);
    };
    EdgeShape2.prototype.computeMass = function (massData, density) {
      massData.mass = 0;
      combine2Vec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);
      massData.I = 0;
    };
    EdgeShape2.prototype.computeDistanceProxy = function (proxy) {
      proxy.m_vertices[0] = this.m_vertex1;
      proxy.m_vertices[1] = this.m_vertex2;
      proxy.m_vertices.length = 2;
      proxy.m_count = 2;
      proxy.m_radius = this.m_radius;
    };
    EdgeShape2.TYPE = "edge";
    return EdgeShape2;
  }(Shape);
  var Edge = EdgeShape;
  var v1$1 = vec2(0, 0);
  var v2 = vec2(0, 0);
  var ChainShape = /** @class */
  function (_super) {
    __extends$1(ChainShape2, _super);
    function ChainShape2(vertices, loop) {
      var _this = this;
      if (!(_this instanceof ChainShape2)) {
        return new ChainShape2(vertices, loop);
      }
      _this = _super.call(this) || this;
      _this.m_type = ChainShape2.TYPE;
      _this.m_radius = SettingsInternal.polygonRadius;
      _this.m_vertices = [];
      _this.m_count = 0;
      _this.m_prevVertex = null;
      _this.m_nextVertex = null;
      _this.m_hasPrevVertex = false;
      _this.m_hasNextVertex = false;
      _this.m_isLoop = !!loop;
      if (vertices && vertices.length) {
        if (loop) {
          _this._createLoop(vertices);
        } else {
          _this._createChain(vertices);
        }
      }
      return _this;
    }
    ChainShape2.prototype._serialize = function () {
      var data = {
        type: this.m_type,
        vertices: this.m_isLoop ? this.m_vertices.slice(0, this.m_vertices.length - 1) : this.m_vertices,
        isLoop: this.m_isLoop,
        hasPrevVertex: this.m_hasPrevVertex,
        hasNextVertex: this.m_hasNextVertex,
        prevVertex: null,
        nextVertex: null
      };
      if (this.m_prevVertex) {
        data.prevVertex = this.m_prevVertex;
      }
      if (this.m_nextVertex) {
        data.nextVertex = this.m_nextVertex;
      }
      return data;
    };
    ChainShape2._deserialize = function (data, fixture, restore) {
      var vertices = [];
      if (data.vertices) {
        for (var i = 0; i < data.vertices.length; i++) {
          vertices.push(restore(Vec2, data.vertices[i]));
        }
      }
      var shape = new ChainShape2(vertices, data.isLoop);
      if (data.prevVertex) {
        shape.setPrevVertex(data.prevVertex);
      }
      if (data.nextVertex) {
        shape.setNextVertex(data.nextVertex);
      }
      return shape;
    };
    ChainShape2.prototype.getType = function () {
      return this.m_type;
    };
    ChainShape2.prototype.getRadius = function () {
      return this.m_radius;
    };
    ChainShape2.prototype._createLoop = function (vertices) {
      if (vertices.length < 3) {
        return;
      }
      for (var i = 1; i < vertices.length; ++i) {
        vertices[i - 1];
        vertices[i];
      }
      this.m_vertices = [];
      this.m_count = vertices.length + 1;
      for (var i = 0; i < vertices.length; ++i) {
        this.m_vertices[i] = Vec2.clone(vertices[i]);
      }
      this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);
      this.m_prevVertex = this.m_vertices[this.m_count - 2];
      this.m_nextVertex = this.m_vertices[1];
      this.m_hasPrevVertex = true;
      this.m_hasNextVertex = true;
      return this;
    };
    ChainShape2.prototype._createChain = function (vertices) {
      for (var i = 1; i < vertices.length; ++i) {
        vertices[i - 1];
        vertices[i];
      }
      this.m_vertices = [];
      this.m_count = vertices.length;
      for (var i = 0; i < vertices.length; ++i) {
        this.m_vertices[i] = Vec2.clone(vertices[i]);
      }
      this.m_prevVertex = null;
      this.m_nextVertex = null;
      this.m_hasPrevVertex = false;
      this.m_hasNextVertex = false;
      return this;
    };
    ChainShape2.prototype._reset = function () {
      if (this.m_isLoop) {
        this._createLoop(this.m_vertices.slice(0, this.m_vertices.length - 1));
      } else {
        this._createChain(this.m_vertices);
      }
    };
    ChainShape2.prototype.setPrevVertex = function (prevVertex) {
      this.m_prevVertex = prevVertex;
      this.m_hasPrevVertex = true;
    };
    ChainShape2.prototype.getPrevVertex = function () {
      return this.m_prevVertex;
    };
    ChainShape2.prototype.setNextVertex = function (nextVertex) {
      this.m_nextVertex = nextVertex;
      this.m_hasNextVertex = true;
    };
    ChainShape2.prototype.getNextVertex = function () {
      return this.m_nextVertex;
    };
    ChainShape2.prototype._clone = function () {
      var clone = new ChainShape2();
      clone._createChain(this.m_vertices);
      clone.m_type = this.m_type;
      clone.m_radius = this.m_radius;
      clone.m_prevVertex = this.m_prevVertex;
      clone.m_nextVertex = this.m_nextVertex;
      clone.m_hasPrevVertex = this.m_hasPrevVertex;
      clone.m_hasNextVertex = this.m_hasNextVertex;
      return clone;
    };
    ChainShape2.prototype.getChildCount = function () {
      return this.m_count - 1;
    };
    ChainShape2.prototype.getChildEdge = function (edge, childIndex) {
      edge.m_type = EdgeShape.TYPE;
      edge.m_radius = this.m_radius;
      edge.m_vertex1 = this.m_vertices[childIndex];
      edge.m_vertex2 = this.m_vertices[childIndex + 1];
      if (childIndex > 0) {
        edge.m_vertex0 = this.m_vertices[childIndex - 1];
        edge.m_hasVertex0 = true;
      } else {
        edge.m_vertex0 = this.m_prevVertex;
        edge.m_hasVertex0 = this.m_hasPrevVertex;
      }
      if (childIndex < this.m_count - 2) {
        edge.m_vertex3 = this.m_vertices[childIndex + 2];
        edge.m_hasVertex3 = true;
      } else {
        edge.m_vertex3 = this.m_nextVertex;
        edge.m_hasVertex3 = this.m_hasNextVertex;
      }
    };
    ChainShape2.prototype.getVertex = function (index) {
      if (index < this.m_count) {
        return this.m_vertices[index];
      } else {
        return this.m_vertices[0];
      }
    };
    ChainShape2.prototype.isLoop = function () {
      return this.m_isLoop;
    };
    ChainShape2.prototype.testPoint = function (xf2, p) {
      return false;
    };
    ChainShape2.prototype.rayCast = function (output2, input2, xf2, childIndex) {
      var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));
      return edgeShape.rayCast(output2, input2, xf2, 0);
    };
    ChainShape2.prototype.computeAABB = function (aabb, xf2, childIndex) {
      transformVec2(v1$1, xf2, this.getVertex(childIndex));
      transformVec2(v2, xf2, this.getVertex(childIndex + 1));
      AABB.combinePoints(aabb, v1$1, v2);
    };
    ChainShape2.prototype.computeMass = function (massData, density) {
      massData.mass = 0;
      zeroVec2(massData.center);
      massData.I = 0;
    };
    ChainShape2.prototype.computeDistanceProxy = function (proxy, childIndex) {
      proxy.m_vertices[0] = this.getVertex(childIndex);
      proxy.m_vertices[1] = this.getVertex(childIndex + 1);
      proxy.m_count = 2;
      proxy.m_radius = this.m_radius;
    };
    ChainShape2.TYPE = "chain";
    return ChainShape2;
  }(Shape);
  var Chain = ChainShape;
  var math_max$4 = Math.max;
  var math_min$8 = Math.min;
  var temp$1 = vec2(0, 0);
  var e$1 = vec2(0, 0);
  var e1$1 = vec2(0, 0);
  var e2$1 = vec2(0, 0);
  var center = vec2(0, 0);
  var s = vec2(0, 0);
  var PolygonShape = /** @class */
  function (_super) {
    __extends$1(PolygonShape2, _super);
    function PolygonShape2(vertices) {
      var _this = this;
      if (!(_this instanceof PolygonShape2)) {
        return new PolygonShape2(vertices);
      }
      _this = _super.call(this) || this;
      _this.m_type = PolygonShape2.TYPE;
      _this.m_radius = SettingsInternal.polygonRadius;
      _this.m_centroid = Vec2.zero();
      _this.m_vertices = [];
      _this.m_normals = [];
      _this.m_count = 0;
      if (vertices && vertices.length) {
        _this._set(vertices);
      }
      return _this;
    }
    PolygonShape2.prototype._serialize = function () {
      return {
        type: this.m_type,
        vertices: this.m_vertices
      };
    };
    PolygonShape2._deserialize = function (data, fixture, restore) {
      var vertices = [];
      if (data.vertices) {
        for (var i = 0; i < data.vertices.length; i++) {
          vertices.push(restore(Vec2, data.vertices[i]));
        }
      }
      var shape = new PolygonShape2(vertices);
      return shape;
    };
    PolygonShape2.prototype.getType = function () {
      return this.m_type;
    };
    PolygonShape2.prototype.getRadius = function () {
      return this.m_radius;
    };
    PolygonShape2.prototype._clone = function () {
      var clone = new PolygonShape2();
      clone.m_type = this.m_type;
      clone.m_radius = this.m_radius;
      clone.m_count = this.m_count;
      clone.m_centroid.setVec2(this.m_centroid);
      for (var i = 0; i < this.m_count; i++) {
        clone.m_vertices.push(this.m_vertices[i].clone());
      }
      for (var i = 0; i < this.m_normals.length; i++) {
        clone.m_normals.push(this.m_normals[i].clone());
      }
      return clone;
    };
    PolygonShape2.prototype.getChildCount = function () {
      return 1;
    };
    PolygonShape2.prototype._reset = function () {
      this._set(this.m_vertices);
    };
    PolygonShape2.prototype._set = function (vertices) {
      if (vertices.length < 3) {
        this._setAsBox(1, 1);
        return;
      }
      var n2 = math_min$8(vertices.length, SettingsInternal.maxPolygonVertices);
      var ps = [];
      for (var i = 0; i < n2; ++i) {
        var v3 = vertices[i];
        var unique = true;
        for (var j = 0; j < ps.length; ++j) {
          if (Vec2.distanceSquared(v3, ps[j]) < 0.25 * SettingsInternal.linearSlopSquared) {
            unique = false;
            break;
          }
        }
        if (unique) {
          ps.push(Vec2.clone(v3));
        }
      }
      n2 = ps.length;
      if (n2 < 3) {
        this._setAsBox(1, 1);
        return;
      }
      var i0 = 0;
      var x0 = ps[0].x;
      for (var i = 1; i < n2; ++i) {
        var x2 = ps[i].x;
        if (x2 > x0 || x2 === x0 && ps[i].y < ps[i0].y) {
          i0 = i;
          x0 = x2;
        }
      }
      var hull = [];
      var m = 0;
      var ih = i0;
      while (true) {
        hull[m] = ih;
        var ie2 = 0;
        for (var j = 1; j < n2; ++j) {
          if (ie2 === ih) {
            ie2 = j;
            continue;
          }
          var r = Vec2.sub(ps[ie2], ps[hull[m]]);
          var v3 = Vec2.sub(ps[j], ps[hull[m]]);
          var c2 = Vec2.crossVec2Vec2(r, v3);
          if (c2 < 0) {
            ie2 = j;
          }
          if (c2 === 0 && v3.lengthSquared() > r.lengthSquared()) {
            ie2 = j;
          }
        }
        ++m;
        ih = ie2;
        if (ie2 === i0) {
          break;
        }
      }
      if (m < 3) {
        this._setAsBox(1, 1);
        return;
      }
      this.m_count = m;
      this.m_vertices = [];
      for (var i = 0; i < m; ++i) {
        this.m_vertices[i] = ps[hull[i]];
      }
      for (var i = 0; i < m; ++i) {
        var i1 = i;
        var i2 = i + 1 < m ? i + 1 : 0;
        var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);
        this.m_normals[i] = Vec2.crossVec2Num(edge, 1);
        this.m_normals[i].normalize();
      }
      this.m_centroid = computeCentroid(this.m_vertices, m);
    };
    PolygonShape2.prototype._setAsBox = function (hx, hy, center2, angle) {
      this.m_vertices[0] = Vec2.neo(hx, -hy);
      this.m_vertices[1] = Vec2.neo(hx, hy);
      this.m_vertices[2] = Vec2.neo(-hx, hy);
      this.m_vertices[3] = Vec2.neo(-hx, -hy);
      this.m_normals[0] = Vec2.neo(1, 0);
      this.m_normals[1] = Vec2.neo(0, 1);
      this.m_normals[2] = Vec2.neo(-1, 0);
      this.m_normals[3] = Vec2.neo(0, -1);
      this.m_count = 4;
      if (center2 && Vec2.isValid(center2)) {
        angle = angle || 0;
        copyVec2(this.m_centroid, center2);
        var xf2 = Transform.identity();
        xf2.p.setVec2(center2);
        xf2.q.setAngle(angle);
        for (var i = 0; i < this.m_count; ++i) {
          this.m_vertices[i] = Transform.mulVec2(xf2, this.m_vertices[i]);
          this.m_normals[i] = Rot.mulVec2(xf2.q, this.m_normals[i]);
        }
      }
    };
    PolygonShape2.prototype.testPoint = function (xf2, p) {
      var pLocal = detransformVec2(temp$1, xf2, p);
      for (var i = 0; i < this.m_count; ++i) {
        var dot = dotVec2(this.m_normals[i], pLocal) - dotVec2(this.m_normals[i], this.m_vertices[i]);
        if (dot > 0) {
          return false;
        }
      }
      return true;
    };
    PolygonShape2.prototype.rayCast = function (output2, input2, xf2, childIndex) {
      var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));
      var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));
      var d2 = Vec2.sub(p2, p1);
      var lower = 0;
      var upper = input2.maxFraction;
      var index = -1;
      for (var i = 0; i < this.m_count; ++i) {
        var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));
        var denominator = Vec2.dot(this.m_normals[i], d2);
        if (denominator == 0) {
          if (numerator < 0) {
            return false;
          }
        } else {
          if (denominator < 0 && numerator < lower * denominator) {
            lower = numerator / denominator;
            index = i;
          } else if (denominator > 0 && numerator < upper * denominator) {
            upper = numerator / denominator;
          }
        }
        if (upper < lower) {
          return false;
        }
      }
      if (index >= 0) {
        output2.fraction = lower;
        output2.normal = Rot.mulVec2(xf2.q, this.m_normals[index]);
        return true;
      }
      return false;
    };
    PolygonShape2.prototype.computeAABB = function (aabb, xf2, childIndex) {
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      for (var i = 0; i < this.m_count; ++i) {
        var v3 = transformVec2(temp$1, xf2, this.m_vertices[i]);
        minX = math_min$8(minX, v3.x);
        maxX = math_max$4(maxX, v3.x);
        minY = math_min$8(minY, v3.y);
        maxY = math_max$4(maxY, v3.y);
      }
      setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);
      setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);
    };
    PolygonShape2.prototype.computeMass = function (massData, density) {
      zeroVec2(center);
      var area = 0;
      var I = 0;
      zeroVec2(s);
      for (var i = 0; i < this.m_count; ++i) {
        plusVec2(s, this.m_vertices[i]);
      }
      scaleVec2(s, 1 / this.m_count, s);
      var k_inv3 = 1 / 3;
      for (var i = 0; i < this.m_count; ++i) {
        subVec2(e1$1, this.m_vertices[i], s);
        if (i + 1 < this.m_count) {
          subVec2(e2$1, this.m_vertices[i + 1], s);
        } else {
          subVec2(e2$1, this.m_vertices[0], s);
        }
        var D = crossVec2Vec2(e1$1, e2$1);
        var triangleArea = 0.5 * D;
        area += triangleArea;
        combine2Vec2(temp$1, triangleArea * k_inv3, e1$1, triangleArea * k_inv3, e2$1);
        plusVec2(center, temp$1);
        var ex1 = e1$1.x;
        var ey1 = e1$1.y;
        var ex2 = e2$1.x;
        var ey2 = e2$1.y;
        var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
        var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
        I += 0.25 * k_inv3 * D * (intx2 + inty2);
      }
      massData.mass = density * area;
      scaleVec2(center, 1 / area, center);
      addVec2(massData.center, center, s);
      massData.I = density * I;
      massData.I += massData.mass * (dotVec2(massData.center, massData.center) - dotVec2(center, center));
    };
    PolygonShape2.prototype.validate = function () {
      for (var i = 0; i < this.m_count; ++i) {
        var i1 = i;
        var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
        var p = this.m_vertices[i1];
        subVec2(e$1, this.m_vertices[i2], p);
        for (var j = 0; j < this.m_count; ++j) {
          if (j == i1 || j == i2) {
            continue;
          }
          var c2 = crossVec2Vec2(e$1, subVec2(temp$1, this.m_vertices[j], p));
          if (c2 < 0) {
            return false;
          }
        }
      }
      return true;
    };
    PolygonShape2.prototype.computeDistanceProxy = function (proxy) {
      for (var i = 0; i < this.m_count; ++i) {
        proxy.m_vertices[i] = this.m_vertices[i];
      }
      proxy.m_vertices.length = this.m_count;
      proxy.m_count = this.m_count;
      proxy.m_radius = this.m_radius;
    };
    PolygonShape2.TYPE = "polygon";
    return PolygonShape2;
  }(Shape);
  function computeCentroid(vs, count) {
    var c2 = Vec2.zero();
    var area = 0;
    var pRef = Vec2.zero();
    var i;
    var inv3 = 1 / 3;
    for (var i = 0; i < count; ++i) {
      var p1 = pRef;
      var p2 = vs[i];
      var p3 = i + 1 < count ? vs[i + 1] : vs[0];
      var e1_1 = Vec2.sub(p2, p1);
      var e2_1 = Vec2.sub(p3, p1);
      var D = Vec2.crossVec2Vec2(e1_1, e2_1);
      var triangleArea = 0.5 * D;
      area += triangleArea;
      combine3Vec2(temp$1, 1, p1, 1, p2, 1, p3);
      plusScaleVec2(c2, triangleArea * inv3, temp$1);
    }
    c2.mul(1 / area);
    return c2;
  }
  var Polygon = PolygonShape;
  var math_sqrt$3 = Math.sqrt;
  var math_PI$6 = Math.PI;
  var temp = vec2(0, 0);
  var CircleShape = /** @class */
  function (_super) {
    __extends$1(CircleShape2, _super);
    function CircleShape2(a2, b2) {
      var _this = this;
      if (!(_this instanceof CircleShape2)) {
        return new CircleShape2(a2, b2);
      }
      _this = _super.call(this) || this;
      _this.m_type = CircleShape2.TYPE;
      _this.m_p = Vec2.zero();
      _this.m_radius = 1;
      if (_typeof(a2) === "object" && Vec2.isValid(a2)) {
        _this.m_p.setVec2(a2);
        if (typeof b2 === "number") {
          _this.m_radius = b2;
        }
      } else if (typeof a2 === "number") {
        _this.m_radius = a2;
      }
      return _this;
    }
    CircleShape2.prototype._serialize = function () {
      return {
        type: this.m_type,
        p: this.m_p,
        radius: this.m_radius
      };
    };
    CircleShape2._deserialize = function (data) {
      return new CircleShape2(data.p, data.radius);
    };
    CircleShape2.prototype._reset = function () {};
    CircleShape2.prototype.getType = function () {
      return this.m_type;
    };
    CircleShape2.prototype.getRadius = function () {
      return this.m_radius;
    };
    CircleShape2.prototype.getCenter = function () {
      return this.m_p;
    };
    CircleShape2.prototype._clone = function () {
      var clone = new CircleShape2();
      clone.m_type = this.m_type;
      clone.m_radius = this.m_radius;
      clone.m_p = this.m_p.clone();
      return clone;
    };
    CircleShape2.prototype.getChildCount = function () {
      return 1;
    };
    CircleShape2.prototype.testPoint = function (xf2, p) {
      var center2 = transformVec2(temp, xf2, this.m_p);
      return distSqrVec2(p, center2) <= this.m_radius * this.m_radius;
    };
    CircleShape2.prototype.rayCast = function (output2, input2, xf2, childIndex) {
      var position = Vec2.add(xf2.p, Rot.mulVec2(xf2.q, this.m_p));
      var s2 = Vec2.sub(input2.p1, position);
      var b2 = Vec2.dot(s2, s2) - this.m_radius * this.m_radius;
      var r = Vec2.sub(input2.p2, input2.p1);
      var c2 = Vec2.dot(s2, r);
      var rr = Vec2.dot(r, r);
      var sigma = c2 * c2 - rr * b2;
      if (sigma < 0 || rr < EPSILON) {
        return false;
      }
      var a2 = -(c2 + math_sqrt$3(sigma));
      if (0 <= a2 && a2 <= input2.maxFraction * rr) {
        a2 /= rr;
        output2.fraction = a2;
        output2.normal = Vec2.add(s2, Vec2.mulNumVec2(a2, r));
        output2.normal.normalize();
        return true;
      }
      return false;
    };
    CircleShape2.prototype.computeAABB = function (aabb, xf2, childIndex) {
      var p = transformVec2(temp, xf2, this.m_p);
      setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);
      setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);
    };
    CircleShape2.prototype.computeMass = function (massData, density) {
      massData.mass = density * math_PI$6 * this.m_radius * this.m_radius;
      copyVec2(massData.center, this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + lengthSqrVec2(this.m_p));
    };
    CircleShape2.prototype.computeDistanceProxy = function (proxy) {
      proxy.m_vertices[0] = this.m_p;
      proxy.m_vertices.length = 1;
      proxy.m_count = 1;
      proxy.m_radius = this.m_radius;
    };
    CircleShape2.TYPE = "circle";
    return CircleShape2;
  }(Shape);
  var Circle = CircleShape;
  var math_abs$6 = Math.abs;
  var math_PI$5 = Math.PI;
  var DEFAULTS$b = {
    frequencyHz: 0,
    dampingRatio: 0
  };
  var DistanceJoint = /** @class */
  function (_super) {
    __extends$1(DistanceJoint2, _super);
    function DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB) {
      var _this = this;
      if (!(_this instanceof DistanceJoint2)) {
        return new DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB);
      }
      if (bodyB && anchorA && "m_type" in anchorA && "x" in bodyB && "y" in bodyB) {
        var temp3 = bodyB;
        bodyB = anchorA;
        anchorA = temp3;
      }
      def = options(def, DEFAULTS$b);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = DistanceJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());
      _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());
      _this.m_length = Number.isFinite(def.length) ? def.length : Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));
      _this.m_frequencyHz = def.frequencyHz;
      _this.m_dampingRatio = def.dampingRatio;
      _this.m_impulse = 0;
      _this.m_gamma = 0;
      _this.m_bias = 0;
      return _this;
    }
    DistanceJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        frequencyHz: this.m_frequencyHz,
        dampingRatio: this.m_dampingRatio,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        length: this.m_length,
        impulse: this.m_impulse,
        gamma: this.m_gamma,
        bias: this.m_bias
      };
    };
    DistanceJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new DistanceJoint2(data);
      return joint;
    };
    DistanceJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (def.length > 0) {
        this.m_length = +def.length;
      } else if (def.length < 0) ;else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {
        this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));
      }
      if (Number.isFinite(def.frequencyHz)) {
        this.m_frequencyHz = def.frequencyHz;
      }
      if (Number.isFinite(def.dampingRatio)) {
        this.m_dampingRatio = def.dampingRatio;
      }
    };
    DistanceJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    DistanceJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    DistanceJoint2.prototype.setLength = function (length2) {
      this.m_length = length2;
    };
    DistanceJoint2.prototype.getLength = function () {
      return this.m_length;
    };
    DistanceJoint2.prototype.setFrequency = function (hz) {
      this.m_frequencyHz = hz;
    };
    DistanceJoint2.prototype.getFrequency = function () {
      return this.m_frequencyHz;
    };
    DistanceJoint2.prototype.setDampingRatio = function (ratio) {
      this.m_dampingRatio = ratio;
    };
    DistanceJoint2.prototype.getDampingRatio = function () {
      return this.m_dampingRatio;
    };
    DistanceJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    DistanceJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    DistanceJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);
    };
    DistanceJoint2.prototype.getReactionTorque = function (inv_dt) {
      return 0;
    };
    DistanceJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      this.m_u = Vec2.sub(Vec2.add(cB2, this.m_rB), Vec2.add(cA2, this.m_rA));
      var length2 = this.m_u.length();
      if (length2 > SettingsInternal.linearSlop) {
        this.m_u.mul(1 / length2);
      } else {
        this.m_u.setNum(0, 0);
      }
      var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);
      var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);
      var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
      this.m_mass = invMass != 0 ? 1 / invMass : 0;
      if (this.m_frequencyHz > 0) {
        var C = length2 - this.m_length;
        var omega = 2 * math_PI$5 * this.m_frequencyHz;
        var d2 = 2 * this.m_mass * this.m_dampingRatio * omega;
        var k = this.m_mass * omega * omega;
        var h = step.dt;
        this.m_gamma = h * (d2 + h * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
        this.m_bias = C * h * k * this.m_gamma;
        invMass += this.m_gamma;
        this.m_mass = invMass != 0 ? 1 / invMass : 0;
      } else {
        this.m_gamma = 0;
        this.m_bias = 0;
      }
      if (step.warmStarting) {
        this.m_impulse *= step.dtRatio;
        var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);
        vA2.subMul(this.m_invMassA, P3);
        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);
        vB2.addMul(this.m_invMassB, P3);
        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);
      } else {
        this.m_impulse = 0;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    DistanceJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));
      var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));
      var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);
      var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
      this.m_impulse += impulse;
      var P3 = Vec2.mulNumVec2(impulse, this.m_u);
      vA2.subMul(this.m_invMassA, P3);
      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);
      vB2.addMul(this.m_invMassB, P3);
      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    DistanceJoint2.prototype.solvePositionConstraints = function (step) {
      if (this.m_frequencyHz > 0) {
        return true;
      }
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
      var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
      var u = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));
      var length2 = u.normalize();
      var C = clamp$1(length2 - this.m_length, -SettingsInternal.maxLinearCorrection, SettingsInternal.maxLinearCorrection);
      var impulse = -this.m_mass * C;
      var P3 = Vec2.mulNumVec2(impulse, u);
      cA2.subMul(this.m_invMassA, P3);
      aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);
      cB2.addMul(this.m_invMassB, P3);
      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);
      this.m_bodyA.c_position.c.setVec2(cA2);
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c.setVec2(cB2);
      this.m_bodyB.c_position.a = aB;
      return math_abs$6(C) < SettingsInternal.linearSlop;
    };
    DistanceJoint2.TYPE = "distance-joint";
    return DistanceJoint2;
  }(Joint);
  var DEFAULTS$a = {
    maxForce: 0,
    maxTorque: 0
  };
  var FrictionJoint = /** @class */
  function (_super) {
    __extends$1(FrictionJoint2, _super);
    function FrictionJoint2(def, bodyA, bodyB, anchor) {
      var _this = this;
      if (!(_this instanceof FrictionJoint2)) {
        return new FrictionJoint2(def, bodyA, bodyB, anchor);
      }
      def = options(def, DEFAULTS$a);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = FrictionJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
      _this.m_linearImpulse = Vec2.zero();
      _this.m_angularImpulse = 0;
      _this.m_maxForce = def.maxForce;
      _this.m_maxTorque = def.maxTorque;
      return _this;
    }
    FrictionJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        maxForce: this.m_maxForce,
        maxTorque: this.m_maxTorque,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB
      };
    };
    FrictionJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new FrictionJoint2(data);
      return joint;
    };
    FrictionJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (Number.isFinite(def.maxForce)) {
        this.m_maxForce = def.maxForce;
      }
      if (Number.isFinite(def.maxTorque)) {
        this.m_maxTorque = def.maxTorque;
      }
    };
    FrictionJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    FrictionJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    FrictionJoint2.prototype.setMaxForce = function (force) {
      this.m_maxForce = force;
    };
    FrictionJoint2.prototype.getMaxForce = function () {
      return this.m_maxForce;
    };
    FrictionJoint2.prototype.setMaxTorque = function (torque) {
      this.m_maxTorque = torque;
    };
    FrictionJoint2.prototype.getMaxTorque = function () {
      return this.m_maxTorque;
    };
    FrictionJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    FrictionJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    FrictionJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);
    };
    FrictionJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_angularImpulse;
    };
    FrictionJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var K = new Mat22();
      K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
      K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
      K.ey.x = K.ex.y;
      K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
      this.m_linearMass = K.getInverse();
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0) {
        this.m_angularMass = 1 / this.m_angularMass;
      }
      if (step.warmStarting) {
        this.m_linearImpulse.mul(step.dtRatio);
        this.m_angularImpulse *= step.dtRatio;
        var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);
      } else {
        this.m_linearImpulse.setZero();
        this.m_angularImpulse = 0;
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    FrictionJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var h = step.dt;
      {
        var Cdot = wB - wA;
        var impulse = -this.m_angularMass * Cdot;
        var oldImpulse = this.m_angularImpulse;
        var maxImpulse = h * this.m_maxTorque;
        this.m_angularImpulse = clamp$1(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
        impulse = this.m_angularImpulse - oldImpulse;
        wA -= iA * impulse;
        wB += iB * impulse;
      }
      {
        var Cdot = Vec2.sub(Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA)));
        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
        var oldImpulse = this.m_linearImpulse;
        this.m_linearImpulse.add(impulse);
        var maxImpulse = h * this.m_maxForce;
        if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
          this.m_linearImpulse.normalize();
          this.m_linearImpulse.mul(maxImpulse);
        }
        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
        vA2.subMul(mA, impulse);
        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
        vB2.addMul(mB, impulse);
        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    FrictionJoint2.prototype.solvePositionConstraints = function (step) {
      return true;
    };
    FrictionJoint2.TYPE = "friction-joint";
    return FrictionJoint2;
  }(Joint);
  var Mat33 = /** @class */
  function () {
    function Mat332(a2, b2, c2) {
      if (_typeof(a2) === "object" && a2 !== null) {
        this.ex = Vec3.clone(a2);
        this.ey = Vec3.clone(b2);
        this.ez = Vec3.clone(c2);
      } else {
        this.ex = Vec3.zero();
        this.ey = Vec3.zero();
        this.ez = Vec3.zero();
      }
    }
    Mat332.prototype.toString = function () {
      return JSON.stringify(this);
    };
    Mat332.isValid = function (obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);
    };
    Mat332.assert = function (o) {};
    Mat332.prototype.setZero = function () {
      this.ex.setZero();
      this.ey.setZero();
      this.ez.setZero();
      return this;
    };
    Mat332.prototype.solve33 = function (v3) {
      var cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;
      var cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;
      var cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;
      var det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;
      if (det !== 0) {
        det = 1 / det;
      }
      var r = new Vec3();
      cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;
      cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;
      cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;
      r.x = det * (v3.x * cross_x + v3.y * cross_y + v3.z * cross_z);
      cross_x = v3.y * this.ez.z - v3.z * this.ez.y;
      cross_y = v3.z * this.ez.x - v3.x * this.ez.z;
      cross_z = v3.x * this.ez.y - v3.y * this.ez.x;
      r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);
      cross_x = this.ey.y * v3.z - this.ey.z * v3.y;
      cross_y = this.ey.z * v3.x - this.ey.x * v3.z;
      cross_z = this.ey.x * v3.y - this.ey.y * v3.x;
      r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);
      return r;
    };
    Mat332.prototype.solve22 = function (v3) {
      var a11 = this.ex.x;
      var a12 = this.ey.x;
      var a21 = this.ex.y;
      var a22 = this.ey.y;
      var det = a11 * a22 - a12 * a21;
      if (det !== 0) {
        det = 1 / det;
      }
      var r = Vec2.zero();
      r.x = det * (a22 * v3.x - a12 * v3.y);
      r.y = det * (a11 * v3.y - a21 * v3.x);
      return r;
    };
    Mat332.prototype.getInverse22 = function (M) {
      var a2 = this.ex.x;
      var b2 = this.ey.x;
      var c2 = this.ex.y;
      var d2 = this.ey.y;
      var det = a2 * d2 - b2 * c2;
      if (det !== 0) {
        det = 1 / det;
      }
      M.ex.x = det * d2;
      M.ey.x = -det * b2;
      M.ex.z = 0;
      M.ex.y = -det * c2;
      M.ey.y = det * a2;
      M.ey.z = 0;
      M.ez.x = 0;
      M.ez.y = 0;
      M.ez.z = 0;
    };
    Mat332.prototype.getSymInverse33 = function (M) {
      var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
      if (det !== 0) {
        det = 1 / det;
      }
      var a11 = this.ex.x;
      var a12 = this.ey.x;
      var a13 = this.ez.x;
      var a22 = this.ey.y;
      var a23 = this.ez.y;
      var a33 = this.ez.z;
      M.ex.x = det * (a22 * a33 - a23 * a23);
      M.ex.y = det * (a13 * a23 - a12 * a33);
      M.ex.z = det * (a12 * a23 - a13 * a22);
      M.ey.x = M.ex.y;
      M.ey.y = det * (a11 * a33 - a13 * a13);
      M.ey.z = det * (a13 * a12 - a11 * a23);
      M.ez.x = M.ex.z;
      M.ez.y = M.ey.z;
      M.ez.z = det * (a11 * a22 - a12 * a12);
    };
    Mat332.mul = function (a2, b2) {
      if (b2 && "z" in b2 && "y" in b2 && "x" in b2) {
        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;
        var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;
        var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;
        return new Vec3(x2, y, z);
      } else if (b2 && "y" in b2 && "x" in b2) {
        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;
        var y = a2.ex.y * b2.x + a2.ey.y * b2.y;
        return Vec2.neo(x2, y);
      }
    };
    Mat332.mulVec3 = function (a2, b2) {
      var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;
      var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;
      var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;
      return new Vec3(x2, y, z);
    };
    Mat332.mulVec2 = function (a2, b2) {
      var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;
      var y = a2.ex.y * b2.x + a2.ey.y * b2.y;
      return Vec2.neo(x2, y);
    };
    Mat332.add = function (a2, b2) {
      return new Mat332(Vec3.add(a2.ex, b2.ex), Vec3.add(a2.ey, b2.ey), Vec3.add(a2.ez, b2.ez));
    };
    return Mat332;
  }();
  var math_abs$5 = Math.abs;
  var LimitState$2;
  (function (LimitState2) {
    LimitState2[LimitState2["inactiveLimit"] = 0] = "inactiveLimit";
    LimitState2[LimitState2["atLowerLimit"] = 1] = "atLowerLimit";
    LimitState2[LimitState2["atUpperLimit"] = 2] = "atUpperLimit";
    LimitState2[LimitState2["equalLimits"] = 3] = "equalLimits";
  })(LimitState$2 || (LimitState$2 = {}));
  var DEFAULTS$9 = {
    lowerAngle: 0,
    upperAngle: 0,
    maxMotorTorque: 0,
    motorSpeed: 0,
    enableLimit: false,
    enableMotor: false
  };
  var RevoluteJoint = /** @class */
  function (_super) {
    __extends$1(RevoluteJoint2, _super);
    function RevoluteJoint2(def, bodyA, bodyB, anchor) {
      var _this = this;
      var _a2, _b, _c, _d, _e, _f;
      if (!(_this instanceof RevoluteJoint2)) {
        return new RevoluteJoint2(def, bodyA, bodyB, anchor);
      }
      def = def !== null && def !== void 0 ? def : {};
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_mass = new Mat33();
      _this.m_limitState = LimitState$2.inactiveLimit;
      _this.m_type = RevoluteJoint2.TYPE;
      if (Vec2.isValid(anchor)) {
        _this.m_localAnchorA = bodyA.getLocalPoint(anchor);
      } else if (Vec2.isValid(def.localAnchorA)) {
        _this.m_localAnchorA = Vec2.clone(def.localAnchorA);
      } else {
        _this.m_localAnchorA = Vec2.zero();
      }
      if (Vec2.isValid(anchor)) {
        _this.m_localAnchorB = bodyB.getLocalPoint(anchor);
      } else if (Vec2.isValid(def.localAnchorB)) {
        _this.m_localAnchorB = Vec2.clone(def.localAnchorB);
      } else {
        _this.m_localAnchorB = Vec2.zero();
      }
      if (Number.isFinite(def.referenceAngle)) {
        _this.m_referenceAngle = def.referenceAngle;
      } else {
        _this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();
      }
      _this.m_impulse = new Vec3();
      _this.m_motorImpulse = 0;
      _this.m_lowerAngle = (_a2 = def.lowerAngle) !== null && _a2 !== void 0 ? _a2 : DEFAULTS$9.lowerAngle;
      _this.m_upperAngle = (_b = def.upperAngle) !== null && _b !== void 0 ? _b : DEFAULTS$9.upperAngle;
      _this.m_maxMotorTorque = (_c = def.maxMotorTorque) !== null && _c !== void 0 ? _c : DEFAULTS$9.maxMotorTorque;
      _this.m_motorSpeed = (_d = def.motorSpeed) !== null && _d !== void 0 ? _d : DEFAULTS$9.motorSpeed;
      _this.m_enableLimit = (_e = def.enableLimit) !== null && _e !== void 0 ? _e : DEFAULTS$9.enableLimit;
      _this.m_enableMotor = (_f = def.enableMotor) !== null && _f !== void 0 ? _f : DEFAULTS$9.enableMotor;
      return _this;
    }
    RevoluteJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        lowerAngle: this.m_lowerAngle,
        upperAngle: this.m_upperAngle,
        maxMotorTorque: this.m_maxMotorTorque,
        motorSpeed: this.m_motorSpeed,
        enableLimit: this.m_enableLimit,
        enableMotor: this.m_enableMotor,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        referenceAngle: this.m_referenceAngle
      };
    };
    RevoluteJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new RevoluteJoint2(data);
      return joint;
    };
    RevoluteJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (Number.isFinite(def.referenceAngle)) {
        this.m_referenceAngle = def.referenceAngle;
      }
      if (def.enableLimit !== void 0) {
        this.m_enableLimit = def.enableLimit;
      }
      if (Number.isFinite(def.lowerAngle)) {
        this.m_lowerAngle = def.lowerAngle;
      }
      if (Number.isFinite(def.upperAngle)) {
        this.m_upperAngle = def.upperAngle;
      }
      if (Number.isFinite(def.maxMotorTorque)) {
        this.m_maxMotorTorque = def.maxMotorTorque;
      }
      if (Number.isFinite(def.motorSpeed)) {
        this.m_motorSpeed = def.motorSpeed;
      }
      if (def.enableMotor !== void 0) {
        this.m_enableMotor = def.enableMotor;
      }
    };
    RevoluteJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    RevoluteJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    RevoluteJoint2.prototype.getReferenceAngle = function () {
      return this.m_referenceAngle;
    };
    RevoluteJoint2.prototype.getJointAngle = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    };
    RevoluteJoint2.prototype.getJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      return bB.m_angularVelocity - bA.m_angularVelocity;
    };
    RevoluteJoint2.prototype.isMotorEnabled = function () {
      return this.m_enableMotor;
    };
    RevoluteJoint2.prototype.enableMotor = function (flag) {
      if (flag == this.m_enableMotor) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_enableMotor = flag;
    };
    RevoluteJoint2.prototype.getMotorTorque = function (inv_dt) {
      return inv_dt * this.m_motorImpulse;
    };
    RevoluteJoint2.prototype.setMotorSpeed = function (speed) {
      if (speed == this.m_motorSpeed) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_motorSpeed = speed;
    };
    RevoluteJoint2.prototype.getMotorSpeed = function () {
      return this.m_motorSpeed;
    };
    RevoluteJoint2.prototype.setMaxMotorTorque = function (torque) {
      if (torque == this.m_maxMotorTorque) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_maxMotorTorque = torque;
    };
    RevoluteJoint2.prototype.getMaxMotorTorque = function () {
      return this.m_maxMotorTorque;
    };
    RevoluteJoint2.prototype.isLimitEnabled = function () {
      return this.m_enableLimit;
    };
    RevoluteJoint2.prototype.enableLimit = function (flag) {
      if (flag != this.m_enableLimit) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_enableLimit = flag;
        this.m_impulse.z = 0;
      }
    };
    RevoluteJoint2.prototype.getLowerLimit = function () {
      return this.m_lowerAngle;
    };
    RevoluteJoint2.prototype.getUpperLimit = function () {
      return this.m_upperAngle;
    };
    RevoluteJoint2.prototype.setLimits = function (lower, upper) {
      if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_impulse.z = 0;
        this.m_lowerAngle = lower;
        this.m_upperAngle = upper;
      }
    };
    RevoluteJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    RevoluteJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    RevoluteJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
    };
    RevoluteJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_impulse.z;
    };
    RevoluteJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var fixedRotation = iA + iB === 0;
      this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
      this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
      this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
      this.m_mass.ex.y = this.m_mass.ey.x;
      this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
      this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
      this.m_mass.ex.z = this.m_mass.ez.x;
      this.m_mass.ey.z = this.m_mass.ez.y;
      this.m_mass.ez.z = iA + iB;
      this.m_motorMass = iA + iB;
      if (this.m_motorMass > 0) {
        this.m_motorMass = 1 / this.m_motorMass;
      }
      if (this.m_enableMotor == false || fixedRotation) {
        this.m_motorImpulse = 0;
      }
      if (this.m_enableLimit && fixedRotation == false) {
        var jointAngle = aB - aA - this.m_referenceAngle;
        if (math_abs$5(this.m_upperAngle - this.m_lowerAngle) < 2 * SettingsInternal.angularSlop) {
          this.m_limitState = LimitState$2.equalLimits;
        } else if (jointAngle <= this.m_lowerAngle) {
          if (this.m_limitState != LimitState$2.atLowerLimit) {
            this.m_impulse.z = 0;
          }
          this.m_limitState = LimitState$2.atLowerLimit;
        } else if (jointAngle >= this.m_upperAngle) {
          if (this.m_limitState != LimitState$2.atUpperLimit) {
            this.m_impulse.z = 0;
          }
          this.m_limitState = LimitState$2.atUpperLimit;
        } else {
          this.m_limitState = LimitState$2.inactiveLimit;
          this.m_impulse.z = 0;
        }
      } else {
        this.m_limitState = LimitState$2.inactiveLimit;
      }
      if (step.warmStarting) {
        this.m_impulse.mul(step.dtRatio);
        this.m_motorImpulse *= step.dtRatio;
        var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_motorImpulse + this.m_impulse.z);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_motorImpulse + this.m_impulse.z);
      } else {
        this.m_impulse.setZero();
        this.m_motorImpulse = 0;
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    RevoluteJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var fixedRotation = iA + iB === 0;
      if (this.m_enableMotor && this.m_limitState != LimitState$2.equalLimits && fixedRotation == false) {
        var Cdot = wB - wA - this.m_motorSpeed;
        var impulse = -this.m_motorMass * Cdot;
        var oldImpulse = this.m_motorImpulse;
        var maxImpulse = step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = clamp$1(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
        impulse = this.m_motorImpulse - oldImpulse;
        wA -= iA * impulse;
        wB += iB * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {
        var Cdot1 = Vec2.zero();
        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));
        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));
        var Cdot2 = wB - wA;
        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
        var impulse = Vec3.neg(this.m_mass.solve33(Cdot));
        if (this.m_limitState == LimitState$2.equalLimits) {
          this.m_impulse.add(impulse);
        } else if (this.m_limitState == LimitState$2.atLowerLimit) {
          var newImpulse = this.m_impulse.z + impulse.z;
          if (newImpulse < 0) {
            var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
            var reduced = this.m_mass.solve22(rhs);
            impulse.x = reduced.x;
            impulse.y = reduced.y;
            impulse.z = -this.m_impulse.z;
            this.m_impulse.x += reduced.x;
            this.m_impulse.y += reduced.y;
            this.m_impulse.z = 0;
          } else {
            this.m_impulse.add(impulse);
          }
        } else if (this.m_limitState == LimitState$2.atUpperLimit) {
          var newImpulse = this.m_impulse.z + impulse.z;
          if (newImpulse > 0) {
            var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
            var reduced = this.m_mass.solve22(rhs);
            impulse.x = reduced.x;
            impulse.y = reduced.y;
            impulse.z = -this.m_impulse.z;
            this.m_impulse.x += reduced.x;
            this.m_impulse.y += reduced.y;
            this.m_impulse.z = 0;
          } else {
            this.m_impulse.add(impulse);
          }
        }
        var P3 = Vec2.neo(impulse.x, impulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);
      } else {
        var Cdot = Vec2.zero();
        Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));
        Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));
        var impulse = this.m_mass.solve22(Vec2.neg(Cdot));
        this.m_impulse.x += impulse.x;
        this.m_impulse.y += impulse.y;
        vA2.subMul(mA, impulse);
        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
        vB2.addMul(mB, impulse);
        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    RevoluteJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var angularError = 0;
      var positionError = 0;
      var fixedRotation = this.m_invIA + this.m_invIB == 0;
      if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {
        var angle = aB - aA - this.m_referenceAngle;
        var limitImpulse = 0;
        if (this.m_limitState == LimitState$2.equalLimits) {
          var C = clamp$1(angle - this.m_lowerAngle, -SettingsInternal.maxAngularCorrection, SettingsInternal.maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C;
          angularError = math_abs$5(C);
        } else if (this.m_limitState == LimitState$2.atLowerLimit) {
          var C = angle - this.m_lowerAngle;
          angularError = -C;
          C = clamp$1(C + SettingsInternal.angularSlop, -SettingsInternal.maxAngularCorrection, 0);
          limitImpulse = -this.m_motorMass * C;
        } else if (this.m_limitState == LimitState$2.atUpperLimit) {
          var C = angle - this.m_upperAngle;
          angularError = C;
          C = clamp$1(C - SettingsInternal.angularSlop, 0, SettingsInternal.maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C;
        }
        aA -= this.m_invIA * limitImpulse;
        aB += this.m_invIB * limitImpulse;
      }
      {
        qA.setAngle(aA);
        qB.setAngle(aB);
        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
        var C = Vec2.zero();
        C.addCombine(1, cB2, 1, rB2);
        C.subCombine(1, cA2, 1, rA2);
        positionError = C.length();
        var mA = this.m_invMassA;
        var mB = this.m_invMassB;
        var iA = this.m_invIA;
        var iB = this.m_invIB;
        var K = new Mat22();
        K.ex.x = mA + mB + iA * rA2.y * rA2.y + iB * rB2.y * rB2.y;
        K.ex.y = -iA * rA2.x * rA2.y - iB * rB2.x * rB2.y;
        K.ey.x = K.ex.y;
        K.ey.y = mA + mB + iA * rA2.x * rA2.x + iB * rB2.x * rB2.x;
        var impulse = Vec2.neg(K.solve(C));
        cA2.subMul(mA, impulse);
        aA -= iA * Vec2.crossVec2Vec2(rA2, impulse);
        cB2.addMul(mB, impulse);
        aB += iB * Vec2.crossVec2Vec2(rB2, impulse);
      }
      this.m_bodyA.c_position.c.setVec2(cA2);
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c.setVec2(cB2);
      this.m_bodyB.c_position.a = aB;
      return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;
    };
    RevoluteJoint2.TYPE = "revolute-joint";
    return RevoluteJoint2;
  }(Joint);
  var math_abs$4 = Math.abs;
  var math_max$3 = Math.max;
  var math_min$7 = Math.min;
  var LimitState$1;
  (function (LimitState2) {
    LimitState2[LimitState2["inactiveLimit"] = 0] = "inactiveLimit";
    LimitState2[LimitState2["atLowerLimit"] = 1] = "atLowerLimit";
    LimitState2[LimitState2["atUpperLimit"] = 2] = "atUpperLimit";
    LimitState2[LimitState2["equalLimits"] = 3] = "equalLimits";
  })(LimitState$1 || (LimitState$1 = {}));
  var DEFAULTS$8 = {
    enableLimit: false,
    lowerTranslation: 0,
    upperTranslation: 0,
    enableMotor: false,
    maxMotorForce: 0,
    motorSpeed: 0
  };
  var PrismaticJoint = /** @class */
  function (_super) {
    __extends$1(PrismaticJoint2, _super);
    function PrismaticJoint2(def, bodyA, bodyB, anchor, axis) {
      var _this = this;
      if (!(_this instanceof PrismaticJoint2)) {
        return new PrismaticJoint2(def, bodyA, bodyB, anchor, axis);
      }
      def = options(def, DEFAULTS$8);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = PrismaticJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
      _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1, 0));
      _this.m_localXAxisA.normalize();
      _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);
      _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
      _this.m_impulse = new Vec3();
      _this.m_motorMass = 0;
      _this.m_motorImpulse = 0;
      _this.m_lowerTranslation = def.lowerTranslation;
      _this.m_upperTranslation = def.upperTranslation;
      _this.m_maxMotorForce = def.maxMotorForce;
      _this.m_motorSpeed = def.motorSpeed;
      _this.m_enableLimit = def.enableLimit;
      _this.m_enableMotor = def.enableMotor;
      _this.m_limitState = LimitState$1.inactiveLimit;
      _this.m_axis = Vec2.zero();
      _this.m_perp = Vec2.zero();
      _this.m_K = new Mat33();
      return _this;
    }
    PrismaticJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        lowerTranslation: this.m_lowerTranslation,
        upperTranslation: this.m_upperTranslation,
        maxMotorForce: this.m_maxMotorForce,
        motorSpeed: this.m_motorSpeed,
        enableLimit: this.m_enableLimit,
        enableMotor: this.m_enableMotor,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        localAxisA: this.m_localXAxisA,
        referenceAngle: this.m_referenceAngle
      };
    };
    PrismaticJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      data.localAxisA = Vec2.clone(data.localAxisA);
      var joint = new PrismaticJoint2(data);
      return joint;
    };
    PrismaticJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (def.localAxisA) {
        this.m_localXAxisA.setVec2(def.localAxisA);
        this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));
      }
      if (Number.isFinite(def.referenceAngle)) {
        this.m_referenceAngle = def.referenceAngle;
      }
      if (typeof def.enableLimit !== "undefined") {
        this.m_enableLimit = !!def.enableLimit;
      }
      if (Number.isFinite(def.lowerTranslation)) {
        this.m_lowerTranslation = def.lowerTranslation;
      }
      if (Number.isFinite(def.upperTranslation)) {
        this.m_upperTranslation = def.upperTranslation;
      }
      if (typeof def.enableMotor !== "undefined") {
        this.m_enableMotor = !!def.enableMotor;
      }
      if (Number.isFinite(def.maxMotorForce)) {
        this.m_maxMotorForce = def.maxMotorForce;
      }
      if (Number.isFinite(def.motorSpeed)) {
        this.m_motorSpeed = def.motorSpeed;
      }
    };
    PrismaticJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    PrismaticJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    PrismaticJoint2.prototype.getLocalAxisA = function () {
      return this.m_localXAxisA;
    };
    PrismaticJoint2.prototype.getReferenceAngle = function () {
      return this.m_referenceAngle;
    };
    PrismaticJoint2.prototype.getJointTranslation = function () {
      var pA2 = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
      var pB2 = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
      var d2 = Vec2.sub(pB2, pA2);
      var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);
      var translation2 = Vec2.dot(d2, axis);
      return translation2;
    };
    PrismaticJoint2.prototype.getJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var rA2 = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));
      var rB2 = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));
      var p1 = Vec2.add(bA.m_sweep.c, rA2);
      var p2 = Vec2.add(bB.m_sweep.c, rB2);
      var d2 = Vec2.sub(p2, p1);
      var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);
      var vA2 = bA.m_linearVelocity;
      var vB2 = bB.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var wB = bB.m_angularVelocity;
      var speed = Vec2.dot(d2, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB2, wB, rB2), Vec2.addCrossNumVec2(vA2, wA, rA2)));
      return speed;
    };
    PrismaticJoint2.prototype.isLimitEnabled = function () {
      return this.m_enableLimit;
    };
    PrismaticJoint2.prototype.enableLimit = function (flag) {
      if (flag != this.m_enableLimit) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_enableLimit = flag;
        this.m_impulse.z = 0;
      }
    };
    PrismaticJoint2.prototype.getLowerLimit = function () {
      return this.m_lowerTranslation;
    };
    PrismaticJoint2.prototype.getUpperLimit = function () {
      return this.m_upperTranslation;
    };
    PrismaticJoint2.prototype.setLimits = function (lower, upper) {
      if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
        this.m_impulse.z = 0;
      }
    };
    PrismaticJoint2.prototype.isMotorEnabled = function () {
      return this.m_enableMotor;
    };
    PrismaticJoint2.prototype.enableMotor = function (flag) {
      if (flag == this.m_enableMotor) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_enableMotor = flag;
    };
    PrismaticJoint2.prototype.setMotorSpeed = function (speed) {
      if (speed == this.m_motorSpeed) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_motorSpeed = speed;
    };
    PrismaticJoint2.prototype.setMaxMotorForce = function (force) {
      if (force == this.m_maxMotorForce) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_maxMotorForce = force;
    };
    PrismaticJoint2.prototype.getMaxMotorForce = function () {
      return this.m_maxMotorForce;
    };
    PrismaticJoint2.prototype.getMotorSpeed = function () {
      return this.m_motorSpeed;
    };
    PrismaticJoint2.prototype.getMotorForce = function (inv_dt) {
      return inv_dt * this.m_motorImpulse;
    };
    PrismaticJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    PrismaticJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    PrismaticJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);
    };
    PrismaticJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_impulse.y;
    };
    PrismaticJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var d2 = Vec2.zero();
      d2.addCombine(1, cB2, 1, rB2);
      d2.subCombine(1, cA2, 1, rA2);
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      {
        this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);
        this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_axis);
        this.m_a2 = Vec2.crossVec2Vec2(rB2, this.m_axis);
        this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
        if (this.m_motorMass > 0) {
          this.m_motorMass = 1 / this.m_motorMass;
        }
      }
      {
        this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);
        this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_perp);
        this.m_s2 = Vec2.crossVec2Vec2(rB2, this.m_perp);
        Vec2.crossVec2Vec2(rA2, this.m_perp);
        var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
        var k12 = iA * this.m_s1 + iB * this.m_s2;
        var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
        var k22 = iA + iB;
        if (k22 == 0) {
          k22 = 1;
        }
        var k23 = iA * this.m_a1 + iB * this.m_a2;
        var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
        this.m_K.ex.set(k11, k12, k13);
        this.m_K.ey.set(k12, k22, k23);
        this.m_K.ez.set(k13, k23, k33);
      }
      if (this.m_enableLimit) {
        var jointTranslation = Vec2.dot(this.m_axis, d2);
        if (math_abs$4(this.m_upperTranslation - this.m_lowerTranslation) < 2 * SettingsInternal.linearSlop) {
          this.m_limitState = LimitState$1.equalLimits;
        } else if (jointTranslation <= this.m_lowerTranslation) {
          if (this.m_limitState != LimitState$1.atLowerLimit) {
            this.m_limitState = LimitState$1.atLowerLimit;
            this.m_impulse.z = 0;
          }
        } else if (jointTranslation >= this.m_upperTranslation) {
          if (this.m_limitState != LimitState$1.atUpperLimit) {
            this.m_limitState = LimitState$1.atUpperLimit;
            this.m_impulse.z = 0;
          }
        } else {
          this.m_limitState = LimitState$1.inactiveLimit;
          this.m_impulse.z = 0;
        }
      } else {
        this.m_limitState = LimitState$1.inactiveLimit;
        this.m_impulse.z = 0;
      }
      if (this.m_enableMotor == false) {
        this.m_motorImpulse = 0;
      }
      if (step.warmStarting) {
        this.m_impulse.mul(step.dtRatio);
        this.m_motorImpulse *= step.dtRatio;
        var P3 = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);
        var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
        var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      } else {
        this.m_impulse.setZero();
        this.m_motorImpulse = 0;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    PrismaticJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      if (this.m_enableMotor && this.m_limitState != LimitState$1.equalLimits) {
        var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB2, vA2)) + this.m_a2 * wB - this.m_a1 * wA;
        var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
        var oldImpulse = this.m_motorImpulse;
        var maxImpulse = step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = clamp$1(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
        impulse = this.m_motorImpulse - oldImpulse;
        var P3 = Vec2.mulNumVec2(impulse, this.m_axis);
        var LA = impulse * this.m_a1;
        var LB = impulse * this.m_a2;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      }
      var Cdot1 = Vec2.zero();
      Cdot1.x += Vec2.dot(this.m_perp, vB2) + this.m_s2 * wB;
      Cdot1.x -= Vec2.dot(this.m_perp, vA2) + this.m_s1 * wA;
      Cdot1.y = wB - wA;
      if (this.m_enableLimit && this.m_limitState != LimitState$1.inactiveLimit) {
        var Cdot2 = 0;
        Cdot2 += Vec2.dot(this.m_axis, vB2) + this.m_a2 * wB;
        Cdot2 -= Vec2.dot(this.m_axis, vA2) + this.m_a1 * wA;
        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
        var f1 = Vec3.clone(this.m_impulse);
        var df = this.m_K.solve33(Vec3.neg(Cdot));
        this.m_impulse.add(df);
        if (this.m_limitState == LimitState$1.atLowerLimit) {
          this.m_impulse.z = math_max$3(this.m_impulse.z, 0);
        } else if (this.m_limitState == LimitState$1.atUpperLimit) {
          this.m_impulse.z = math_min$7(this.m_impulse.z, 0);
        }
        var b2 = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));
        var f2r = Vec2.add(this.m_K.solve22(b2), Vec2.neo(f1.x, f1.y));
        this.m_impulse.x = f2r.x;
        this.m_impulse.y = f2r.y;
        df = Vec3.sub(this.m_impulse, f1);
        var P3 = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);
        var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
        var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      } else {
        var df = this.m_K.solve22(Vec2.neg(Cdot1));
        this.m_impulse.x += df.x;
        this.m_impulse.y += df.y;
        var P3 = Vec2.mulNumVec2(df.x, this.m_perp);
        var LA = df.x * this.m_s1 + df.y;
        var LB = df.x * this.m_s2 + df.y;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    PrismaticJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var d2 = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));
      var axis = Rot.mulVec2(qA, this.m_localXAxisA);
      var a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), axis);
      var a2 = Vec2.crossVec2Vec2(rB2, axis);
      var perp2 = Rot.mulVec2(qA, this.m_localYAxisA);
      var s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), perp2);
      var s2 = Vec2.crossVec2Vec2(rB2, perp2);
      var impulse = new Vec3();
      var C1 = Vec2.zero();
      C1.x = Vec2.dot(perp2, d2);
      C1.y = aB - aA - this.m_referenceAngle;
      var linearError = math_abs$4(C1.x);
      var angularError = math_abs$4(C1.y);
      var linearSlop = SettingsInternal.linearSlop;
      var maxLinearCorrection = SettingsInternal.maxLinearCorrection;
      var active = false;
      var C2 = 0;
      if (this.m_enableLimit) {
        var translation2 = Vec2.dot(axis, d2);
        if (math_abs$4(this.m_upperTranslation - this.m_lowerTranslation) < 2 * linearSlop) {
          C2 = clamp$1(translation2, -maxLinearCorrection, maxLinearCorrection);
          linearError = math_max$3(linearError, math_abs$4(translation2));
          active = true;
        } else if (translation2 <= this.m_lowerTranslation) {
          C2 = clamp$1(translation2 - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0);
          linearError = Math.max(linearError, this.m_lowerTranslation - translation2);
          active = true;
        } else if (translation2 >= this.m_upperTranslation) {
          C2 = clamp$1(translation2 - this.m_upperTranslation - linearSlop, 0, maxLinearCorrection);
          linearError = Math.max(linearError, translation2 - this.m_upperTranslation);
          active = true;
        }
      }
      if (active) {
        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
        var k12 = iA * s1 + iB * s2;
        var k13 = iA * s1 * a1 + iB * s2 * a2;
        var k22 = iA + iB;
        if (k22 == 0) {
          k22 = 1;
        }
        var k23 = iA * a1 + iB * a2;
        var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
        var K = new Mat33();
        K.ex.set(k11, k12, k13);
        K.ey.set(k12, k22, k23);
        K.ez.set(k13, k23, k33);
        var C = new Vec3();
        C.x = C1.x;
        C.y = C1.y;
        C.z = C2;
        impulse = K.solve33(Vec3.neg(C));
      } else {
        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
        var k12 = iA * s1 + iB * s2;
        var k22 = iA + iB;
        if (k22 == 0) {
          k22 = 1;
        }
        var K = new Mat22();
        K.ex.setNum(k11, k12);
        K.ey.setNum(k12, k22);
        var impulse1 = K.solve(Vec2.neg(C1));
        impulse.x = impulse1.x;
        impulse.y = impulse1.y;
        impulse.z = 0;
      }
      var P3 = Vec2.combine(impulse.x, perp2, impulse.z, axis);
      var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
      var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
      cA2.subMul(mA, P3);
      aA -= iA * LA;
      cB2.addMul(mB, P3);
      aB += iB * LB;
      this.m_bodyA.c_position.c = cA2;
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c = cB2;
      this.m_bodyB.c_position.a = aB;
      return linearError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;
    };
    PrismaticJoint2.TYPE = "prismatic-joint";
    return PrismaticJoint2;
  }(Joint);
  var DEFAULTS$7 = {
    ratio: 1
  };
  var GearJoint = /** @class */
  function (_super) {
    __extends$1(GearJoint2, _super);
    function GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio) {
      var _this = this;
      if (!(_this instanceof GearJoint2)) {
        return new GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio);
      }
      def = options(def, DEFAULTS$7);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = GearJoint2.TYPE;
      _this.m_joint1 = joint1 ? joint1 : def.joint1;
      _this.m_joint2 = joint2 ? joint2 : def.joint2;
      _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;
      _this.m_type1 = _this.m_joint1.getType();
      _this.m_type2 = _this.m_joint2.getType();
      var coordinateA;
      var coordinateB;
      _this.m_bodyC = _this.m_joint1.getBodyA();
      _this.m_bodyA = _this.m_joint1.getBodyB();
      var xfA2 = _this.m_bodyA.m_xf;
      var aA = _this.m_bodyA.m_sweep.a;
      var xfC = _this.m_bodyC.m_xf;
      var aC = _this.m_bodyC.m_sweep.a;
      if (_this.m_type1 === RevoluteJoint.TYPE) {
        var revolute = _this.m_joint1;
        _this.m_localAnchorC = revolute.m_localAnchorA;
        _this.m_localAnchorA = revolute.m_localAnchorB;
        _this.m_referenceAngleA = revolute.m_referenceAngle;
        _this.m_localAxisC = Vec2.zero();
        coordinateA = aA - aC - _this.m_referenceAngleA;
      } else {
        var prismatic = _this.m_joint1;
        _this.m_localAnchorC = prismatic.m_localAnchorA;
        _this.m_localAnchorA = prismatic.m_localAnchorB;
        _this.m_referenceAngleA = prismatic.m_referenceAngle;
        _this.m_localAxisC = prismatic.m_localXAxisA;
        var pC = _this.m_localAnchorC;
        var pA2 = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA2.q, _this.m_localAnchorA), Vec2.sub(xfA2.p, xfC.p)));
        coordinateA = Vec2.dot(pA2, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);
      }
      _this.m_bodyD = _this.m_joint2.getBodyA();
      _this.m_bodyB = _this.m_joint2.getBodyB();
      var xfB2 = _this.m_bodyB.m_xf;
      var aB = _this.m_bodyB.m_sweep.a;
      var xfD = _this.m_bodyD.m_xf;
      var aD = _this.m_bodyD.m_sweep.a;
      if (_this.m_type2 === RevoluteJoint.TYPE) {
        var revolute = _this.m_joint2;
        _this.m_localAnchorD = revolute.m_localAnchorA;
        _this.m_localAnchorB = revolute.m_localAnchorB;
        _this.m_referenceAngleB = revolute.m_referenceAngle;
        _this.m_localAxisD = Vec2.zero();
        coordinateB = aB - aD - _this.m_referenceAngleB;
      } else {
        var prismatic = _this.m_joint2;
        _this.m_localAnchorD = prismatic.m_localAnchorA;
        _this.m_localAnchorB = prismatic.m_localAnchorB;
        _this.m_referenceAngleB = prismatic.m_referenceAngle;
        _this.m_localAxisD = prismatic.m_localXAxisA;
        var pD = _this.m_localAnchorD;
        var pB2 = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB2.q, _this.m_localAnchorB), Vec2.sub(xfB2.p, xfD.p)));
        coordinateB = Vec2.dot(pB2, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);
      }
      _this.m_constant = coordinateA + _this.m_ratio * coordinateB;
      _this.m_impulse = 0;
      return _this;
    }
    GearJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        joint1: this.m_joint1,
        joint2: this.m_joint2,
        ratio: this.m_ratio
        // _constant: this.m_constant,
      };
    };
    GearJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      data.joint1 = restore(Joint, data.joint1, world);
      data.joint2 = restore(Joint, data.joint2, world);
      var joint = new GearJoint2(data);
      return joint;
    };
    GearJoint2.prototype._reset = function (def) {
      if (Number.isFinite(def.ratio)) {
        this.m_ratio = def.ratio;
      }
    };
    GearJoint2.prototype.getJoint1 = function () {
      return this.m_joint1;
    };
    GearJoint2.prototype.getJoint2 = function () {
      return this.m_joint2;
    };
    GearJoint2.prototype.setRatio = function (ratio) {
      this.m_ratio = ratio;
    };
    GearJoint2.prototype.getRatio = function () {
      return this.m_ratio;
    };
    GearJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    GearJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    GearJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);
    };
    GearJoint2.prototype.getReactionTorque = function (inv_dt) {
      var L = this.m_impulse * this.m_JwA;
      return inv_dt * L;
    };
    GearJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_lcA = this.m_bodyA.m_sweep.localCenter;
      this.m_lcB = this.m_bodyB.m_sweep.localCenter;
      this.m_lcC = this.m_bodyC.m_sweep.localCenter;
      this.m_lcD = this.m_bodyD.m_sweep.localCenter;
      this.m_mA = this.m_bodyA.m_invMass;
      this.m_mB = this.m_bodyB.m_invMass;
      this.m_mC = this.m_bodyC.m_invMass;
      this.m_mD = this.m_bodyD.m_invMass;
      this.m_iA = this.m_bodyA.m_invI;
      this.m_iB = this.m_bodyB.m_invI;
      this.m_iC = this.m_bodyC.m_invI;
      this.m_iD = this.m_bodyD.m_invI;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var aC = this.m_bodyC.c_position.a;
      var vC = this.m_bodyC.c_velocity.v;
      var wC = this.m_bodyC.c_velocity.w;
      var aD = this.m_bodyD.c_position.a;
      var vD = this.m_bodyD.c_velocity.v;
      var wD = this.m_bodyD.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var qC = Rot.neo(aC);
      var qD = Rot.neo(aD);
      this.m_mass = 0;
      if (this.m_type1 == RevoluteJoint.TYPE) {
        this.m_JvAC = Vec2.zero();
        this.m_JwA = 1;
        this.m_JwC = 1;
        this.m_mass += this.m_iA + this.m_iC;
      } else {
        var u = Rot.mulVec2(qC, this.m_localAxisC);
        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
        this.m_JvAC = u;
        this.m_JwC = Vec2.crossVec2Vec2(rC, u);
        this.m_JwA = Vec2.crossVec2Vec2(rA2, u);
        this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
      }
      if (this.m_type2 == RevoluteJoint.TYPE) {
        this.m_JvBD = Vec2.zero();
        this.m_JwB = this.m_ratio;
        this.m_JwD = this.m_ratio;
        this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
      } else {
        var u = Rot.mulVec2(qD, this.m_localAxisD);
        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
        this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);
        this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);
        this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);
        this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
      }
      this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
      if (step.warmStarting) {
        vA2.addMul(this.m_mA * this.m_impulse, this.m_JvAC);
        wA += this.m_iA * this.m_impulse * this.m_JwA;
        vB2.addMul(this.m_mB * this.m_impulse, this.m_JvBD);
        wB += this.m_iB * this.m_impulse * this.m_JwB;
        vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);
        wC -= this.m_iC * this.m_impulse * this.m_JwC;
        vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);
        wD -= this.m_iD * this.m_impulse * this.m_JwD;
      } else {
        this.m_impulse = 0;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
      this.m_bodyC.c_velocity.v.setVec2(vC);
      this.m_bodyC.c_velocity.w = wC;
      this.m_bodyD.c_velocity.v.setVec2(vD);
      this.m_bodyD.c_velocity.w = wD;
    };
    GearJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var vC = this.m_bodyC.c_velocity.v;
      var wC = this.m_bodyC.c_velocity.w;
      var vD = this.m_bodyD.c_velocity.v;
      var wD = this.m_bodyD.c_velocity.w;
      var Cdot = Vec2.dot(this.m_JvAC, vA2) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB2) - Vec2.dot(this.m_JvBD, vD);
      Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
      var impulse = -this.m_mass * Cdot;
      this.m_impulse += impulse;
      vA2.addMul(this.m_mA * impulse, this.m_JvAC);
      wA += this.m_iA * impulse * this.m_JwA;
      vB2.addMul(this.m_mB * impulse, this.m_JvBD);
      wB += this.m_iB * impulse * this.m_JwB;
      vC.subMul(this.m_mC * impulse, this.m_JvAC);
      wC -= this.m_iC * impulse * this.m_JwC;
      vD.subMul(this.m_mD * impulse, this.m_JvBD);
      wD -= this.m_iD * impulse * this.m_JwD;
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
      this.m_bodyC.c_velocity.v.setVec2(vC);
      this.m_bodyC.c_velocity.w = wC;
      this.m_bodyD.c_velocity.v.setVec2(vD);
      this.m_bodyD.c_velocity.w = wD;
    };
    GearJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var cC = this.m_bodyC.c_position.c;
      var aC = this.m_bodyC.c_position.a;
      var cD = this.m_bodyD.c_position.c;
      var aD = this.m_bodyD.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var qC = Rot.neo(aC);
      var qD = Rot.neo(aD);
      var linearError = 0;
      var coordinateA;
      var coordinateB;
      var JvAC;
      var JvBD;
      var JwA;
      var JwB;
      var JwC;
      var JwD;
      var mass = 0;
      if (this.m_type1 == RevoluteJoint.TYPE) {
        JvAC = Vec2.zero();
        JwA = 1;
        JwC = 1;
        mass += this.m_iA + this.m_iC;
        coordinateA = aA - aC - this.m_referenceAngleA;
      } else {
        var u = Rot.mulVec2(qC, this.m_localAxisC);
        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
        JvAC = u;
        JwC = Vec2.crossVec2Vec2(rC, u);
        JwA = Vec2.crossVec2Vec2(rA2, u);
        mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
        var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);
        var pA2 = Rot.mulTVec2(qC, Vec2.add(rA2, Vec2.sub(cA2, cC)));
        coordinateA = Vec2.dot(Vec2.sub(pA2, pC), this.m_localAxisC);
      }
      if (this.m_type2 == RevoluteJoint.TYPE) {
        JvBD = Vec2.zero();
        JwB = this.m_ratio;
        JwD = this.m_ratio;
        mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
        coordinateB = aB - aD - this.m_referenceAngleB;
      } else {
        var u = Rot.mulVec2(qD, this.m_localAxisD);
        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
        JvBD = Vec2.mulNumVec2(this.m_ratio, u);
        JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);
        JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);
        mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
        var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);
        var pB2 = Rot.mulTVec2(qD, Vec2.add(rB2, Vec2.sub(cB2, cD)));
        coordinateB = Vec2.dot(pB2, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
      }
      var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
      var impulse = 0;
      if (mass > 0) {
        impulse = -C / mass;
      }
      cA2.addMul(this.m_mA * impulse, JvAC);
      aA += this.m_iA * impulse * JwA;
      cB2.addMul(this.m_mB * impulse, JvBD);
      aB += this.m_iB * impulse * JwB;
      cC.subMul(this.m_mC * impulse, JvAC);
      aC -= this.m_iC * impulse * JwC;
      cD.subMul(this.m_mD * impulse, JvBD);
      aD -= this.m_iD * impulse * JwD;
      this.m_bodyA.c_position.c.setVec2(cA2);
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c.setVec2(cB2);
      this.m_bodyB.c_position.a = aB;
      this.m_bodyC.c_position.c.setVec2(cC);
      this.m_bodyC.c_position.a = aC;
      this.m_bodyD.c_position.c.setVec2(cD);
      this.m_bodyD.c_position.a = aD;
      return linearError < SettingsInternal.linearSlop;
    };
    GearJoint2.TYPE = "gear-joint";
    return GearJoint2;
  }(Joint);
  var DEFAULTS$6 = {
    maxForce: 1,
    maxTorque: 1,
    correctionFactor: 0.3
  };
  var MotorJoint = /** @class */
  function (_super) {
    __extends$1(MotorJoint2, _super);
    function MotorJoint2(def, bodyA, bodyB) {
      var _this = this;
      if (!(_this instanceof MotorJoint2)) {
        return new MotorJoint2(def, bodyA, bodyB);
      }
      def = options(def, DEFAULTS$6);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = MotorJoint2.TYPE;
      _this.m_linearOffset = Vec2.isValid(def.linearOffset) ? Vec2.clone(def.linearOffset) : bodyA.getLocalPoint(bodyB.getPosition());
      _this.m_angularOffset = Number.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();
      _this.m_linearImpulse = Vec2.zero();
      _this.m_angularImpulse = 0;
      _this.m_maxForce = def.maxForce;
      _this.m_maxTorque = def.maxTorque;
      _this.m_correctionFactor = def.correctionFactor;
      return _this;
    }
    MotorJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        maxForce: this.m_maxForce,
        maxTorque: this.m_maxTorque,
        correctionFactor: this.m_correctionFactor,
        linearOffset: this.m_linearOffset,
        angularOffset: this.m_angularOffset
      };
    };
    MotorJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new MotorJoint2(data);
      return joint;
    };
    MotorJoint2.prototype._reset = function (def) {
      if (Number.isFinite(def.angularOffset)) {
        this.m_angularOffset = def.angularOffset;
      }
      if (Number.isFinite(def.maxForce)) {
        this.m_maxForce = def.maxForce;
      }
      if (Number.isFinite(def.maxTorque)) {
        this.m_maxTorque = def.maxTorque;
      }
      if (Number.isFinite(def.correctionFactor)) {
        this.m_correctionFactor = def.correctionFactor;
      }
      if (Vec2.isValid(def.linearOffset)) {
        this.m_linearOffset.set(def.linearOffset);
      }
    };
    MotorJoint2.prototype.setMaxForce = function (force) {
      this.m_maxForce = force;
    };
    MotorJoint2.prototype.getMaxForce = function () {
      return this.m_maxForce;
    };
    MotorJoint2.prototype.setMaxTorque = function (torque) {
      this.m_maxTorque = torque;
    };
    MotorJoint2.prototype.getMaxTorque = function () {
      return this.m_maxTorque;
    };
    MotorJoint2.prototype.setCorrectionFactor = function (factor) {
      this.m_correctionFactor = factor;
    };
    MotorJoint2.prototype.getCorrectionFactor = function () {
      return this.m_correctionFactor;
    };
    MotorJoint2.prototype.setLinearOffset = function (linearOffset) {
      if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_linearOffset.set(linearOffset);
      }
    };
    MotorJoint2.prototype.getLinearOffset = function () {
      return this.m_linearOffset;
    };
    MotorJoint2.prototype.setAngularOffset = function (angularOffset) {
      if (angularOffset != this.m_angularOffset) {
        this.m_bodyA.setAwake(true);
        this.m_bodyB.setAwake(true);
        this.m_angularOffset = angularOffset;
      }
    };
    MotorJoint2.prototype.getAngularOffset = function () {
      return this.m_angularOffset;
    };
    MotorJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getPosition();
    };
    MotorJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getPosition();
    };
    MotorJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);
    };
    MotorJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_angularImpulse;
    };
    MotorJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var K = new Mat22();
      K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
      K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
      K.ey.x = K.ex.y;
      K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
      this.m_linearMass = K.getInverse();
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0) {
        this.m_angularMass = 1 / this.m_angularMass;
      }
      this.m_linearError = Vec2.zero();
      this.m_linearError.addCombine(1, cB2, 1, this.m_rB);
      this.m_linearError.subCombine(1, cA2, 1, this.m_rA);
      this.m_angularError = aB - aA - this.m_angularOffset;
      if (step.warmStarting) {
        this.m_linearImpulse.mul(step.dtRatio);
        this.m_angularImpulse *= step.dtRatio;
        var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);
      } else {
        this.m_linearImpulse.setZero();
        this.m_angularImpulse = 0;
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    MotorJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var h = step.dt;
      var inv_h = step.inv_dt;
      {
        var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
        var impulse = -this.m_angularMass * Cdot;
        var oldImpulse = this.m_angularImpulse;
        var maxImpulse = h * this.m_maxTorque;
        this.m_angularImpulse = clamp$1(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
        impulse = this.m_angularImpulse - oldImpulse;
        wA -= iA * impulse;
        wB += iB * impulse;
      }
      {
        var Cdot = Vec2.zero();
        Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));
        Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));
        Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);
        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
        var oldImpulse = Vec2.clone(this.m_linearImpulse);
        this.m_linearImpulse.add(impulse);
        var maxImpulse = h * this.m_maxForce;
        this.m_linearImpulse.clamp(maxImpulse);
        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
        vA2.subMul(mA, impulse);
        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
        vB2.addMul(mB, impulse);
        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    MotorJoint2.prototype.solvePositionConstraints = function (step) {
      return true;
    };
    MotorJoint2.TYPE = "motor-joint";
    return MotorJoint2;
  }(Joint);
  var math_PI$4 = Math.PI;
  var DEFAULTS$5 = {
    maxForce: 0,
    frequencyHz: 5,
    dampingRatio: 0.7
  };
  var MouseJoint = /** @class */
  function (_super) {
    __extends$1(MouseJoint2, _super);
    function MouseJoint2(def, bodyA, bodyB, target) {
      var _this = this;
      if (!(_this instanceof MouseJoint2)) {
        return new MouseJoint2(def, bodyA, bodyB, target);
      }
      def = options(def, DEFAULTS$5);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = MouseJoint2.TYPE;
      if (Vec2.isValid(target)) {
        _this.m_targetA = Vec2.clone(target);
      } else if (Vec2.isValid(def.target)) {
        _this.m_targetA = Vec2.clone(def.target);
      } else {
        _this.m_targetA = Vec2.zero();
      }
      _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);
      _this.m_maxForce = def.maxForce;
      _this.m_impulse = Vec2.zero();
      _this.m_frequencyHz = def.frequencyHz;
      _this.m_dampingRatio = def.dampingRatio;
      _this.m_beta = 0;
      _this.m_gamma = 0;
      _this.m_rB = Vec2.zero();
      _this.m_localCenterB = Vec2.zero();
      _this.m_invMassB = 0;
      _this.m_invIB = 0;
      _this.m_mass = new Mat22();
      _this.m_C = Vec2.zero();
      return _this;
    }
    MouseJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        target: this.m_targetA,
        maxForce: this.m_maxForce,
        frequencyHz: this.m_frequencyHz,
        dampingRatio: this.m_dampingRatio,
        _localAnchorB: this.m_localAnchorB
      };
    };
    MouseJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      data.target = Vec2.clone(data.target);
      var joint = new MouseJoint2(data);
      if (data._localAnchorB) {
        joint.m_localAnchorB = data._localAnchorB;
      }
      return joint;
    };
    MouseJoint2.prototype._reset = function (def) {
      if (Number.isFinite(def.maxForce)) {
        this.m_maxForce = def.maxForce;
      }
      if (Number.isFinite(def.frequencyHz)) {
        this.m_frequencyHz = def.frequencyHz;
      }
      if (Number.isFinite(def.dampingRatio)) {
        this.m_dampingRatio = def.dampingRatio;
      }
    };
    MouseJoint2.prototype.setTarget = function (target) {
      if (Vec2.areEqual(target, this.m_targetA)) return;
      this.m_bodyB.setAwake(true);
      this.m_targetA.set(target);
    };
    MouseJoint2.prototype.getTarget = function () {
      return this.m_targetA;
    };
    MouseJoint2.prototype.setMaxForce = function (force) {
      this.m_maxForce = force;
    };
    MouseJoint2.prototype.getMaxForce = function () {
      return this.m_maxForce;
    };
    MouseJoint2.prototype.setFrequency = function (hz) {
      this.m_frequencyHz = hz;
    };
    MouseJoint2.prototype.getFrequency = function () {
      return this.m_frequencyHz;
    };
    MouseJoint2.prototype.setDampingRatio = function (ratio) {
      this.m_dampingRatio = ratio;
    };
    MouseJoint2.prototype.getDampingRatio = function () {
      return this.m_dampingRatio;
    };
    MouseJoint2.prototype.getAnchorA = function () {
      return Vec2.clone(this.m_targetA);
    };
    MouseJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    MouseJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(inv_dt, this.m_impulse);
    };
    MouseJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * 0;
    };
    MouseJoint2.prototype.shiftOrigin = function (newOrigin) {
      this.m_targetA.sub(newOrigin);
    };
    MouseJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIB = this.m_bodyB.m_invI;
      var position = this.m_bodyB.c_position;
      var velocity = this.m_bodyB.c_velocity;
      var cB2 = position.c;
      var aB = position.a;
      var vB2 = velocity.v;
      var wB = velocity.w;
      var qB = Rot.neo(aB);
      var mass = this.m_bodyB.getMass();
      var omega = 2 * math_PI$4 * this.m_frequencyHz;
      var d2 = 2 * mass * this.m_dampingRatio * omega;
      var k = mass * (omega * omega);
      var h = step.dt;
      this.m_gamma = h * (d2 + h * k);
      if (this.m_gamma != 0) {
        this.m_gamma = 1 / this.m_gamma;
      }
      this.m_beta = h * k * this.m_gamma;
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var K = new Mat22();
      K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
      K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
      K.ey.x = K.ex.y;
      K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
      this.m_mass = K.getInverse();
      this.m_C.setVec2(cB2);
      this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);
      this.m_C.mul(this.m_beta);
      wB *= 0.98;
      if (step.warmStarting) {
        this.m_impulse.mul(step.dtRatio);
        vB2.addMul(this.m_invMassB, this.m_impulse);
        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);
      } else {
        this.m_impulse.setZero();
      }
      velocity.v.setVec2(vB2);
      velocity.w = wB;
    };
    MouseJoint2.prototype.solveVelocityConstraints = function (step) {
      var velocity = this.m_bodyB.c_velocity;
      var vB2 = Vec2.clone(velocity.v);
      var wB = velocity.w;
      var Cdot = Vec2.crossNumVec2(wB, this.m_rB);
      Cdot.add(vB2);
      Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);
      Cdot.neg();
      var impulse = Mat22.mulVec2(this.m_mass, Cdot);
      var oldImpulse = Vec2.clone(this.m_impulse);
      this.m_impulse.add(impulse);
      var maxImpulse = step.dt * this.m_maxForce;
      this.m_impulse.clamp(maxImpulse);
      impulse = Vec2.sub(this.m_impulse, oldImpulse);
      vB2.addMul(this.m_invMassB, impulse);
      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);
      velocity.v.setVec2(vB2);
      velocity.w = wB;
    };
    MouseJoint2.prototype.solvePositionConstraints = function (step) {
      return true;
    };
    MouseJoint2.TYPE = "mouse-joint";
    return MouseJoint2;
  }(Joint);
  var math_abs$3 = Math.abs;
  var DEFAULTS$4 = {
    collideConnected: true
  };
  var PulleyJoint = /** @class */
  function (_super) {
    __extends$1(PulleyJoint2, _super);
    function PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
      var _this = this;
      if (!(_this instanceof PulleyJoint2)) {
        return new PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
      }
      def = options(def, DEFAULTS$4);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = PulleyJoint2.TYPE;
      _this.m_groundAnchorA = Vec2.clone(groundA ? groundA : def.groundAnchorA || Vec2.neo(-1, 1));
      _this.m_groundAnchorB = Vec2.clone(groundB ? groundB : def.groundAnchorB || Vec2.neo(1, 1));
      _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1, 0));
      _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1, 0));
      _this.m_lengthA = Number.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);
      _this.m_lengthB = Number.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);
      _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;
      _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;
      _this.m_impulse = 0;
      return _this;
    }
    PulleyJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        groundAnchorA: this.m_groundAnchorA,
        groundAnchorB: this.m_groundAnchorB,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        lengthA: this.m_lengthA,
        lengthB: this.m_lengthB,
        ratio: this.m_ratio
      };
    };
    PulleyJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new PulleyJoint2(data);
      return joint;
    };
    PulleyJoint2.prototype._reset = function (def) {
      if (Vec2.isValid(def.groundAnchorA)) {
        this.m_groundAnchorA.set(def.groundAnchorA);
      }
      if (Vec2.isValid(def.groundAnchorB)) {
        this.m_groundAnchorB.set(def.groundAnchorB);
      }
      if (Vec2.isValid(def.localAnchorA)) {
        this.m_localAnchorA.set(def.localAnchorA);
      } else if (Vec2.isValid(def.anchorA)) {
        this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
      }
      if (Vec2.isValid(def.localAnchorB)) {
        this.m_localAnchorB.set(def.localAnchorB);
      } else if (Vec2.isValid(def.anchorB)) {
        this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
      }
      if (Number.isFinite(def.lengthA)) {
        this.m_lengthA = def.lengthA;
      }
      if (Number.isFinite(def.lengthB)) {
        this.m_lengthB = def.lengthB;
      }
      if (Number.isFinite(def.ratio)) {
        this.m_ratio = def.ratio;
      }
    };
    PulleyJoint2.prototype.getGroundAnchorA = function () {
      return this.m_groundAnchorA;
    };
    PulleyJoint2.prototype.getGroundAnchorB = function () {
      return this.m_groundAnchorB;
    };
    PulleyJoint2.prototype.getLengthA = function () {
      return this.m_lengthA;
    };
    PulleyJoint2.prototype.getLengthB = function () {
      return this.m_lengthB;
    };
    PulleyJoint2.prototype.getRatio = function () {
      return this.m_ratio;
    };
    PulleyJoint2.prototype.getCurrentLengthA = function () {
      var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
      var s2 = this.m_groundAnchorA;
      return Vec2.distance(p, s2);
    };
    PulleyJoint2.prototype.getCurrentLengthB = function () {
      var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
      var s2 = this.m_groundAnchorB;
      return Vec2.distance(p, s2);
    };
    PulleyJoint2.prototype.shiftOrigin = function (newOrigin) {
      this.m_groundAnchorA.sub(newOrigin);
      this.m_groundAnchorB.sub(newOrigin);
    };
    PulleyJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    PulleyJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    PulleyJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);
    };
    PulleyJoint2.prototype.getReactionTorque = function (inv_dt) {
      return 0;
    };
    PulleyJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      this.m_uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);
      this.m_uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);
      var lengthA = this.m_uA.length();
      var lengthB = this.m_uB.length();
      if (lengthA > 10 * SettingsInternal.linearSlop) {
        this.m_uA.mul(1 / lengthA);
      } else {
        this.m_uA.setZero();
      }
      if (lengthB > 10 * SettingsInternal.linearSlop) {
        this.m_uB.mul(1 / lengthB);
      } else {
        this.m_uB.setZero();
      }
      var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA);
      var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB);
      var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
      var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
      this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
      if (this.m_mass > 0) {
        this.m_mass = 1 / this.m_mass;
      }
      if (step.warmStarting) {
        this.m_impulse *= step.dtRatio;
        var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);
        var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);
        vA2.addMul(this.m_invMassA, PA);
        wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);
        vB2.addMul(this.m_invMassB, PB);
        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);
      } else {
        this.m_impulse = 0;
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    PulleyJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));
      var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));
      var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);
      var impulse = -this.m_mass * Cdot;
      this.m_impulse += impulse;
      var PA = Vec2.mulNumVec2(-impulse, this.m_uA);
      var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB);
      vA2.addMul(this.m_invMassA, PA);
      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);
      vB2.addMul(this.m_invMassB, PB);
      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    PulleyJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);
      var uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);
      var lengthA = uA.length();
      var lengthB = uB.length();
      if (lengthA > 10 * SettingsInternal.linearSlop) {
        uA.mul(1 / lengthA);
      } else {
        uA.setZero();
      }
      if (lengthB > 10 * SettingsInternal.linearSlop) {
        uB.mul(1 / lengthB);
      } else {
        uB.setZero();
      }
      var ruA = Vec2.crossVec2Vec2(rA2, uA);
      var ruB = Vec2.crossVec2Vec2(rB2, uB);
      var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
      var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
      var mass = mA + this.m_ratio * this.m_ratio * mB;
      if (mass > 0) {
        mass = 1 / mass;
      }
      var C = this.m_constant - lengthA - this.m_ratio * lengthB;
      var linearError = math_abs$3(C);
      var impulse = -mass * C;
      var PA = Vec2.mulNumVec2(-impulse, uA);
      var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB);
      cA2.addMul(this.m_invMassA, PA);
      aA += this.m_invIA * Vec2.crossVec2Vec2(rA2, PA);
      cB2.addMul(this.m_invMassB, PB);
      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, PB);
      this.m_bodyA.c_position.c = cA2;
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c = cB2;
      this.m_bodyB.c_position.a = aB;
      return linearError < SettingsInternal.linearSlop;
    };
    PulleyJoint2.TYPE = "pulley-joint";
    return PulleyJoint2;
  }(Joint);
  var math_min$6 = Math.min;
  var LimitState;
  (function (LimitState2) {
    LimitState2[LimitState2["inactiveLimit"] = 0] = "inactiveLimit";
    LimitState2[LimitState2["atLowerLimit"] = 1] = "atLowerLimit";
    LimitState2[LimitState2["atUpperLimit"] = 2] = "atUpperLimit";
    LimitState2[LimitState2["equalLimits"] = 3] = "equalLimits";
  })(LimitState || (LimitState = {}));
  var DEFAULTS$3 = {
    maxLength: 0
  };
  var RopeJoint = /** @class */
  function (_super) {
    __extends$1(RopeJoint2, _super);
    function RopeJoint2(def, bodyA, bodyB, anchor) {
      var _this = this;
      if (!(_this instanceof RopeJoint2)) {
        return new RopeJoint2(def, bodyA, bodyB, anchor);
      }
      def = options(def, DEFAULTS$3);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = RopeJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1, 0));
      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1, 0));
      _this.m_maxLength = def.maxLength;
      _this.m_mass = 0;
      _this.m_impulse = 0;
      _this.m_length = 0;
      _this.m_state = LimitState.inactiveLimit;
      return _this;
    }
    RopeJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        maxLength: this.m_maxLength
      };
    };
    RopeJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new RopeJoint2(data);
      return joint;
    };
    RopeJoint2.prototype._reset = function (def) {
      if (Number.isFinite(def.maxLength)) {
        this.m_maxLength = def.maxLength;
      }
    };
    RopeJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    RopeJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    RopeJoint2.prototype.setMaxLength = function (length2) {
      this.m_maxLength = length2;
    };
    RopeJoint2.prototype.getMaxLength = function () {
      return this.m_maxLength;
    };
    RopeJoint2.prototype.getLimitState = function () {
      return this.m_state;
    };
    RopeJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    RopeJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    RopeJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);
    };
    RopeJoint2.prototype.getReactionTorque = function (inv_dt) {
      return 0;
    };
    RopeJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
      this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
      this.m_u = Vec2.zero();
      this.m_u.addCombine(1, cB2, 1, this.m_rB);
      this.m_u.subCombine(1, cA2, 1, this.m_rA);
      this.m_length = this.m_u.length();
      var C = this.m_length - this.m_maxLength;
      if (C > 0) {
        this.m_state = LimitState.atUpperLimit;
      } else {
        this.m_state = LimitState.inactiveLimit;
      }
      if (this.m_length > SettingsInternal.linearSlop) {
        this.m_u.mul(1 / this.m_length);
      } else {
        this.m_u.setZero();
        this.m_mass = 0;
        this.m_impulse = 0;
        return;
      }
      var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u);
      var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u);
      var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
      this.m_mass = invMass != 0 ? 1 / invMass : 0;
      if (step.warmStarting) {
        this.m_impulse *= step.dtRatio;
        var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);
        vA2.subMul(this.m_invMassA, P3);
        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);
        vB2.addMul(this.m_invMassB, P3);
        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);
      } else {
        this.m_impulse = 0;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    RopeJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var vpA = Vec2.addCrossNumVec2(vA2, wA, this.m_rA);
      var vpB = Vec2.addCrossNumVec2(vB2, wB, this.m_rB);
      var C = this.m_length - this.m_maxLength;
      var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));
      if (C < 0) {
        Cdot += step.inv_dt * C;
      }
      var impulse = -this.m_mass * Cdot;
      var oldImpulse = this.m_impulse;
      this.m_impulse = math_min$6(0, this.m_impulse + impulse);
      impulse = this.m_impulse - oldImpulse;
      var P3 = Vec2.mulNumVec2(impulse, this.m_u);
      vA2.subMul(this.m_invMassA, P3);
      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);
      vB2.addMul(this.m_invMassB, P3);
      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    RopeJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
      var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
      var u = Vec2.zero();
      u.addCombine(1, cB2, 1, rB2);
      u.subCombine(1, cA2, 1, rA2);
      var length2 = u.normalize();
      var C = length2 - this.m_maxLength;
      C = clamp$1(C, 0, SettingsInternal.maxLinearCorrection);
      var impulse = -this.m_mass * C;
      var P3 = Vec2.mulNumVec2(impulse, u);
      cA2.subMul(this.m_invMassA, P3);
      aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);
      cB2.addMul(this.m_invMassB, P3);
      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);
      this.m_bodyA.c_position.c.setVec2(cA2);
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c.setVec2(cB2);
      this.m_bodyB.c_position.a = aB;
      return length2 - this.m_maxLength < SettingsInternal.linearSlop;
    };
    RopeJoint2.TYPE = "rope-joint";
    return RopeJoint2;
  }(Joint);
  var math_abs$2 = Math.abs;
  var math_PI$3 = Math.PI;
  var DEFAULTS$2 = {
    frequencyHz: 0,
    dampingRatio: 0
  };
  var WeldJoint = /** @class */
  function (_super) {
    __extends$1(WeldJoint2, _super);
    function WeldJoint2(def, bodyA, bodyB, anchor) {
      var _this = this;
      if (!(_this instanceof WeldJoint2)) {
        return new WeldJoint2(def, bodyA, bodyB, anchor);
      }
      def = options(def, DEFAULTS$2);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_type = WeldJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
      _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
      _this.m_frequencyHz = def.frequencyHz;
      _this.m_dampingRatio = def.dampingRatio;
      _this.m_impulse = new Vec3();
      _this.m_bias = 0;
      _this.m_gamma = 0;
      _this.m_mass = new Mat33();
      return _this;
    }
    WeldJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        frequencyHz: this.m_frequencyHz,
        dampingRatio: this.m_dampingRatio,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        referenceAngle: this.m_referenceAngle
      };
    };
    WeldJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new WeldJoint2(data);
      return joint;
    };
    WeldJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (Number.isFinite(def.frequencyHz)) {
        this.m_frequencyHz = def.frequencyHz;
      }
      if (Number.isFinite(def.dampingRatio)) {
        this.m_dampingRatio = def.dampingRatio;
      }
    };
    WeldJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    WeldJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    WeldJoint2.prototype.getReferenceAngle = function () {
      return this.m_referenceAngle;
    };
    WeldJoint2.prototype.setFrequency = function (hz) {
      this.m_frequencyHz = hz;
    };
    WeldJoint2.prototype.getFrequency = function () {
      return this.m_frequencyHz;
    };
    WeldJoint2.prototype.setDampingRatio = function (ratio) {
      this.m_dampingRatio = ratio;
    };
    WeldJoint2.prototype.getDampingRatio = function () {
      return this.m_dampingRatio;
    };
    WeldJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    WeldJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    WeldJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
    };
    WeldJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_impulse.z;
    };
    WeldJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var K = new Mat33();
      K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
      K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
      K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
      K.ex.y = K.ey.x;
      K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
      K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
      K.ex.z = K.ez.x;
      K.ey.z = K.ez.y;
      K.ez.z = iA + iB;
      if (this.m_frequencyHz > 0) {
        K.getInverse22(this.m_mass);
        var invM = iA + iB;
        var m = invM > 0 ? 1 / invM : 0;
        var C = aB - aA - this.m_referenceAngle;
        var omega = 2 * math_PI$3 * this.m_frequencyHz;
        var d2 = 2 * m * this.m_dampingRatio * omega;
        var k = m * omega * omega;
        var h = step.dt;
        this.m_gamma = h * (d2 + h * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
        this.m_bias = C * h * k * this.m_gamma;
        invM += this.m_gamma;
        this.m_mass.ez.z = invM != 0 ? 1 / invM : 0;
      } else if (K.ez.z == 0) {
        K.getInverse22(this.m_mass);
        this.m_gamma = 0;
        this.m_bias = 0;
      } else {
        K.getSymInverse33(this.m_mass);
        this.m_gamma = 0;
        this.m_bias = 0;
      }
      if (step.warmStarting) {
        this.m_impulse.mul(step.dtRatio);
        var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_impulse.z);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_impulse.z);
      } else {
        this.m_impulse.setZero();
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    WeldJoint2.prototype.solveVelocityConstraints = function (step) {
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      if (this.m_frequencyHz > 0) {
        var Cdot2 = wB - wA;
        var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += impulse2;
        wA -= iA * impulse2;
        wB += iB * impulse2;
        var Cdot1 = Vec2.zero();
        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));
        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));
        var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));
        this.m_impulse.x += impulse1.x;
        this.m_impulse.y += impulse1.y;
        var P3 = Vec2.clone(impulse1);
        vA2.subMul(mA, P3);
        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P3);
        vB2.addMul(mB, P3);
        wB += iB * Vec2.crossVec2Vec2(this.m_rB, P3);
      } else {
        var Cdot1 = Vec2.zero();
        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));
        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));
        var Cdot2 = wB - wA;
        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
        var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));
        this.m_impulse.add(impulse);
        var P3 = Vec2.neo(impulse.x, impulse.y);
        vA2.subMul(mA, P3);
        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);
        vB2.addMul(mB, P3);
        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);
      }
      this.m_bodyA.c_velocity.v = vA2;
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v = vB2;
      this.m_bodyB.c_velocity.w = wB;
    };
    WeldJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var positionError;
      var angularError;
      var K = new Mat33();
      K.ex.x = mA + mB + rA2.y * rA2.y * iA + rB2.y * rB2.y * iB;
      K.ey.x = -rA2.y * rA2.x * iA - rB2.y * rB2.x * iB;
      K.ez.x = -rA2.y * iA - rB2.y * iB;
      K.ex.y = K.ey.x;
      K.ey.y = mA + mB + rA2.x * rA2.x * iA + rB2.x * rB2.x * iB;
      K.ez.y = rA2.x * iA + rB2.x * iB;
      K.ex.z = K.ez.x;
      K.ey.z = K.ez.y;
      K.ez.z = iA + iB;
      if (this.m_frequencyHz > 0) {
        var C1 = Vec2.zero();
        C1.addCombine(1, cB2, 1, rB2);
        C1.subCombine(1, cA2, 1, rA2);
        positionError = C1.length();
        angularError = 0;
        var P3 = Vec2.neg(K.solve22(C1));
        cA2.subMul(mA, P3);
        aA -= iA * Vec2.crossVec2Vec2(rA2, P3);
        cB2.addMul(mB, P3);
        aB += iB * Vec2.crossVec2Vec2(rB2, P3);
      } else {
        var C1 = Vec2.zero();
        C1.addCombine(1, cB2, 1, rB2);
        C1.subCombine(1, cA2, 1, rA2);
        var C2 = aB - aA - this.m_referenceAngle;
        positionError = C1.length();
        angularError = math_abs$2(C2);
        var C = new Vec3(C1.x, C1.y, C2);
        var impulse = new Vec3();
        if (K.ez.z > 0) {
          impulse = Vec3.neg(K.solve33(C));
        } else {
          var impulse2 = Vec2.neg(K.solve22(C1));
          impulse.set(impulse2.x, impulse2.y, 0);
        }
        var P3 = Vec2.neo(impulse.x, impulse.y);
        cA2.subMul(mA, P3);
        aA -= iA * (Vec2.crossVec2Vec2(rA2, P3) + impulse.z);
        cB2.addMul(mB, P3);
        aB += iB * (Vec2.crossVec2Vec2(rB2, P3) + impulse.z);
      }
      this.m_bodyA.c_position.c = cA2;
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c = cB2;
      this.m_bodyB.c_position.a = aB;
      return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;
    };
    WeldJoint2.TYPE = "weld-joint";
    return WeldJoint2;
  }(Joint);
  var math_abs$1 = Math.abs;
  var math_PI$2 = Math.PI;
  var DEFAULTS$1 = {
    enableMotor: false,
    maxMotorTorque: 0,
    motorSpeed: 0,
    frequencyHz: 2,
    dampingRatio: 0.7
  };
  var WheelJoint = /** @class */
  function (_super) {
    __extends$1(WheelJoint2, _super);
    function WheelJoint2(def, bodyA, bodyB, anchor, axis) {
      var _this = this;
      if (!(_this instanceof WheelJoint2)) {
        return new WheelJoint2(def, bodyA, bodyB, anchor, axis);
      }
      def = options(def, DEFAULTS$1);
      _this = _super.call(this, def, bodyA, bodyB) || this;
      bodyA = _this.m_bodyA;
      bodyB = _this.m_bodyB;
      _this.m_ax = Vec2.zero();
      _this.m_ay = Vec2.zero();
      _this.m_type = WheelJoint2.TYPE;
      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
      if (Vec2.isValid(axis)) {
        _this.m_localXAxisA = bodyA.getLocalVector(axis);
      } else if (Vec2.isValid(def.localAxisA)) {
        _this.m_localXAxisA = Vec2.clone(def.localAxisA);
      } else if (Vec2.isValid(def.localAxis)) {
        _this.m_localXAxisA = Vec2.clone(def.localAxis);
      } else {
        _this.m_localXAxisA = Vec2.neo(1, 0);
      }
      _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);
      _this.m_mass = 0;
      _this.m_impulse = 0;
      _this.m_motorMass = 0;
      _this.m_motorImpulse = 0;
      _this.m_springMass = 0;
      _this.m_springImpulse = 0;
      _this.m_maxMotorTorque = def.maxMotorTorque;
      _this.m_motorSpeed = def.motorSpeed;
      _this.m_enableMotor = def.enableMotor;
      _this.m_frequencyHz = def.frequencyHz;
      _this.m_dampingRatio = def.dampingRatio;
      _this.m_bias = 0;
      _this.m_gamma = 0;
      return _this;
    }
    WheelJoint2.prototype._serialize = function () {
      return {
        type: this.m_type,
        bodyA: this.m_bodyA,
        bodyB: this.m_bodyB,
        collideConnected: this.m_collideConnected,
        enableMotor: this.m_enableMotor,
        maxMotorTorque: this.m_maxMotorTorque,
        motorSpeed: this.m_motorSpeed,
        frequencyHz: this.m_frequencyHz,
        dampingRatio: this.m_dampingRatio,
        localAnchorA: this.m_localAnchorA,
        localAnchorB: this.m_localAnchorB,
        localAxisA: this.m_localXAxisA
      };
    };
    WheelJoint2._deserialize = function (data, world, restore) {
      data = _assign$({}, data);
      data.bodyA = restore(Body, data.bodyA, world);
      data.bodyB = restore(Body, data.bodyB, world);
      var joint = new WheelJoint2(data);
      return joint;
    };
    WheelJoint2.prototype._reset = function (def) {
      if (def.anchorA) {
        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
      } else if (def.localAnchorA) {
        this.m_localAnchorA.setVec2(def.localAnchorA);
      }
      if (def.anchorB) {
        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
      } else if (def.localAnchorB) {
        this.m_localAnchorB.setVec2(def.localAnchorB);
      }
      if (def.localAxisA) {
        this.m_localXAxisA.setVec2(def.localAxisA);
        this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));
      }
      if (def.enableMotor !== void 0) {
        this.m_enableMotor = def.enableMotor;
      }
      if (Number.isFinite(def.maxMotorTorque)) {
        this.m_maxMotorTorque = def.maxMotorTorque;
      }
      if (Number.isFinite(def.motorSpeed)) {
        this.m_motorSpeed = def.motorSpeed;
      }
      if (Number.isFinite(def.frequencyHz)) {
        this.m_frequencyHz = def.frequencyHz;
      }
      if (Number.isFinite(def.dampingRatio)) {
        this.m_dampingRatio = def.dampingRatio;
      }
    };
    WheelJoint2.prototype.getLocalAnchorA = function () {
      return this.m_localAnchorA;
    };
    WheelJoint2.prototype.getLocalAnchorB = function () {
      return this.m_localAnchorB;
    };
    WheelJoint2.prototype.getLocalAxisA = function () {
      return this.m_localXAxisA;
    };
    WheelJoint2.prototype.getJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var pA2 = bA.getWorldPoint(this.m_localAnchorA);
      var pB2 = bB.getWorldPoint(this.m_localAnchorB);
      var d2 = Vec2.sub(pB2, pA2);
      var axis = bA.getWorldVector(this.m_localXAxisA);
      var translation2 = Vec2.dot(d2, axis);
      return translation2;
    };
    WheelJoint2.prototype.getJointSpeed = function () {
      var wA = this.m_bodyA.m_angularVelocity;
      var wB = this.m_bodyB.m_angularVelocity;
      return wB - wA;
    };
    WheelJoint2.prototype.isMotorEnabled = function () {
      return this.m_enableMotor;
    };
    WheelJoint2.prototype.enableMotor = function (flag) {
      if (flag == this.m_enableMotor) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_enableMotor = flag;
    };
    WheelJoint2.prototype.setMotorSpeed = function (speed) {
      if (speed == this.m_motorSpeed) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_motorSpeed = speed;
    };
    WheelJoint2.prototype.getMotorSpeed = function () {
      return this.m_motorSpeed;
    };
    WheelJoint2.prototype.setMaxMotorTorque = function (torque) {
      if (torque == this.m_maxMotorTorque) return;
      this.m_bodyA.setAwake(true);
      this.m_bodyB.setAwake(true);
      this.m_maxMotorTorque = torque;
    };
    WheelJoint2.prototype.getMaxMotorTorque = function () {
      return this.m_maxMotorTorque;
    };
    WheelJoint2.prototype.getMotorTorque = function (inv_dt) {
      return inv_dt * this.m_motorImpulse;
    };
    WheelJoint2.prototype.setSpringFrequencyHz = function (hz) {
      this.m_frequencyHz = hz;
    };
    WheelJoint2.prototype.getSpringFrequencyHz = function () {
      return this.m_frequencyHz;
    };
    WheelJoint2.prototype.setSpringDampingRatio = function (ratio) {
      this.m_dampingRatio = ratio;
    };
    WheelJoint2.prototype.getSpringDampingRatio = function () {
      return this.m_dampingRatio;
    };
    WheelJoint2.prototype.getAnchorA = function () {
      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
    };
    WheelJoint2.prototype.getAnchorB = function () {
      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
    };
    WheelJoint2.prototype.getReactionForce = function (inv_dt) {
      return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);
    };
    WheelJoint2.prototype.getReactionTorque = function (inv_dt) {
      return inv_dt * this.m_motorImpulse;
    };
    WheelJoint2.prototype.initVelocityConstraints = function (step) {
      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
      this.m_invMassA = this.m_bodyA.m_invMass;
      this.m_invMassB = this.m_bodyB.m_invMass;
      this.m_invIA = this.m_bodyA.m_invI;
      this.m_invIB = this.m_bodyB.m_invI;
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var d2 = Vec2.zero();
      d2.addCombine(1, cB2, 1, rB2);
      d2.subCombine(1, cA2, 1, rA2);
      {
        this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);
        this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ay);
        this.m_sBy = Vec2.crossVec2Vec2(rB2, this.m_ay);
        this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
        if (this.m_mass > 0) {
          this.m_mass = 1 / this.m_mass;
        }
      }
      this.m_springMass = 0;
      this.m_bias = 0;
      this.m_gamma = 0;
      if (this.m_frequencyHz > 0) {
        this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);
        this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ax);
        this.m_sBx = Vec2.crossVec2Vec2(rB2, this.m_ax);
        var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
        if (invMass > 0) {
          this.m_springMass = 1 / invMass;
          var C = Vec2.dot(d2, this.m_ax);
          var omega = 2 * math_PI$2 * this.m_frequencyHz;
          var damp = 2 * this.m_springMass * this.m_dampingRatio * omega;
          var k = this.m_springMass * omega * omega;
          var h = step.dt;
          this.m_gamma = h * (damp + h * k);
          if (this.m_gamma > 0) {
            this.m_gamma = 1 / this.m_gamma;
          }
          this.m_bias = C * h * k * this.m_gamma;
          this.m_springMass = invMass + this.m_gamma;
          if (this.m_springMass > 0) {
            this.m_springMass = 1 / this.m_springMass;
          }
        }
      } else {
        this.m_springImpulse = 0;
      }
      if (this.m_enableMotor) {
        this.m_motorMass = iA + iB;
        if (this.m_motorMass > 0) {
          this.m_motorMass = 1 / this.m_motorMass;
        }
      } else {
        this.m_motorMass = 0;
        this.m_motorImpulse = 0;
      }
      if (step.warmStarting) {
        this.m_impulse *= step.dtRatio;
        this.m_springImpulse *= step.dtRatio;
        this.m_motorImpulse *= step.dtRatio;
        var P3 = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
        var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
        var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
        vA2.subMul(this.m_invMassA, P3);
        wA -= this.m_invIA * LA;
        vB2.addMul(this.m_invMassB, P3);
        wB += this.m_invIB * LB;
      } else {
        this.m_impulse = 0;
        this.m_springImpulse = 0;
        this.m_motorImpulse = 0;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    WheelJoint2.prototype.solveVelocityConstraints = function (step) {
      var mA = this.m_invMassA;
      var mB = this.m_invMassB;
      var iA = this.m_invIA;
      var iB = this.m_invIB;
      var vA2 = this.m_bodyA.c_velocity.v;
      var wA = this.m_bodyA.c_velocity.w;
      var vB2 = this.m_bodyB.c_velocity.v;
      var wB = this.m_bodyB.c_velocity.w;
      {
        var Cdot = Vec2.dot(this.m_ax, vB2) - Vec2.dot(this.m_ax, vA2) + this.m_sBx * wB - this.m_sAx * wA;
        var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
        this.m_springImpulse += impulse;
        var P3 = Vec2.mulNumVec2(impulse, this.m_ax);
        var LA = impulse * this.m_sAx;
        var LB = impulse * this.m_sBx;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      }
      {
        var Cdot = wB - wA - this.m_motorSpeed;
        var impulse = -this.m_motorMass * Cdot;
        var oldImpulse = this.m_motorImpulse;
        var maxImpulse = step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = clamp$1(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
        impulse = this.m_motorImpulse - oldImpulse;
        wA -= iA * impulse;
        wB += iB * impulse;
      }
      {
        var Cdot = Vec2.dot(this.m_ay, vB2) - Vec2.dot(this.m_ay, vA2) + this.m_sBy * wB - this.m_sAy * wA;
        var impulse = -this.m_mass * Cdot;
        this.m_impulse += impulse;
        var P3 = Vec2.mulNumVec2(impulse, this.m_ay);
        var LA = impulse * this.m_sAy;
        var LB = impulse * this.m_sBy;
        vA2.subMul(mA, P3);
        wA -= iA * LA;
        vB2.addMul(mB, P3);
        wB += iB * LB;
      }
      this.m_bodyA.c_velocity.v.setVec2(vA2);
      this.m_bodyA.c_velocity.w = wA;
      this.m_bodyB.c_velocity.v.setVec2(vB2);
      this.m_bodyB.c_velocity.w = wB;
    };
    WheelJoint2.prototype.solvePositionConstraints = function (step) {
      var cA2 = this.m_bodyA.c_position.c;
      var aA = this.m_bodyA.c_position.a;
      var cB2 = this.m_bodyB.c_position.c;
      var aB = this.m_bodyB.c_position.a;
      var qA = Rot.neo(aA);
      var qB = Rot.neo(aB);
      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
      var d2 = Vec2.zero();
      d2.addCombine(1, cB2, 1, rB2);
      d2.subCombine(1, cA2, 1, rA2);
      var ay = Rot.mulVec2(qA, this.m_localYAxisA);
      var sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), ay);
      var sBy = Vec2.crossVec2Vec2(rB2, ay);
      var C = Vec2.dot(d2, ay);
      var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
      var impulse = k != 0 ? -C / k : 0;
      var P3 = Vec2.mulNumVec2(impulse, ay);
      var LA = impulse * sAy;
      var LB = impulse * sBy;
      cA2.subMul(this.m_invMassA, P3);
      aA -= this.m_invIA * LA;
      cB2.addMul(this.m_invMassB, P3);
      aB += this.m_invIB * LB;
      this.m_bodyA.c_position.c.setVec2(cA2);
      this.m_bodyA.c_position.a = aA;
      this.m_bodyB.c_position.c.setVec2(cB2);
      this.m_bodyB.c_position.a = aB;
      return math_abs$1(C) <= SettingsInternal.linearSlop;
    };
    WheelJoint2.TYPE = "wheel-joint";
    return WheelJoint2;
  }(Joint);
  var _a;
  var SID = 0;
  var SERIALIZE_REF_TYPES = {
    "World": World,
    "Body": Body,
    "Joint": Joint,
    "Fixture": Fixture,
    "Shape": Shape
  };
  var DESERIALIZE_BY_REF_TYPE = {
    "Vec2": Vec2,
    "Vec3": Vec3,
    "World": World,
    "Body": Body,
    "Joint": Joint,
    "Fixture": Fixture,
    "Shape": Shape
  };
  var DESERIALIZE_BY_TYPE_FIELD = (_a = {}, _a[Body.STATIC] = Body, _a[Body.DYNAMIC] = Body, _a[Body.KINEMATIC] = Body, _a[ChainShape.TYPE] = ChainShape,
  // [BoxShape.TYPE]: BoxShape,
  _a[PolygonShape.TYPE] = PolygonShape, _a[EdgeShape.TYPE] = EdgeShape, _a[CircleShape.TYPE] = CircleShape, _a[DistanceJoint.TYPE] = DistanceJoint, _a[FrictionJoint.TYPE] = FrictionJoint, _a[GearJoint.TYPE] = GearJoint, _a[MotorJoint.TYPE] = MotorJoint, _a[MouseJoint.TYPE] = MouseJoint, _a[PrismaticJoint.TYPE] = PrismaticJoint, _a[PulleyJoint.TYPE] = PulleyJoint, _a[RevoluteJoint.TYPE] = RevoluteJoint, _a[RopeJoint.TYPE] = RopeJoint, _a[WeldJoint.TYPE] = WeldJoint, _a[WheelJoint.TYPE] = WheelJoint, _a);
  var DEFAULT_OPTIONS = {
    rootClass: World,
    preSerialize: function preSerialize(obj) {
      return obj;
    },
    postSerialize: function postSerialize(data, obj) {
      return data;
    },
    preDeserialize: function preDeserialize(data) {
      return data;
    },
    postDeserialize: function postDeserialize(obj, data) {
      return obj;
    }
  };
  var Serializer = /** @class */
  /* @__PURE__ */function () {
    function Serializer2(options2) {
      var _this = this;
      this.toJson = function (root) {
        var preSerialize = _this.options.preSerialize;
        var postSerialize = _this.options.postSerialize;
        var json = [];
        var refQueue = [root];
        var refMemoById = {};
        function addToRefQueue(value, typeName) {
          value.__sid = value.__sid || ++SID;
          if (!refMemoById[value.__sid]) {
            refQueue.push(value);
            var index = json.length + refQueue.length;
            var ref = {
              refIndex: index,
              refType: typeName
            };
            refMemoById[value.__sid] = ref;
          }
          return refMemoById[value.__sid];
        }
        function serializeWithHooks(obj2) {
          obj2 = preSerialize(obj2);
          var data = obj2._serialize();
          data = postSerialize(data, obj2);
          return data;
        }
        function traverse(value, noRefType) {
          if (noRefType === void 0) {
            noRefType = false;
          }
          if (_typeof(value) !== "object" || value === null) {
            return value;
          }
          if (typeof value._serialize === "function") {
            if (!noRefType) {
              for (var typeName in SERIALIZE_REF_TYPES) {
                if (value instanceof SERIALIZE_REF_TYPES[typeName]) {
                  return addToRefQueue(value, typeName);
                }
              }
            }
            value = serializeWithHooks(value);
          }
          if (Array.isArray(value)) {
            var newValue = [];
            for (var key = 0; key < value.length; key++) {
              newValue[key] = traverse(value[key]);
            }
            value = newValue;
          } else {
            var newValue = {};
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                newValue[key] = traverse(value[key]);
              }
            }
            value = newValue;
          }
          return value;
        }
        while (refQueue.length) {
          var obj = refQueue.shift();
          var str = traverse(obj, true);
          json.push(str);
        }
        return json;
      };
      this.fromJson = function (json) {
        var preDeserialize = _this.options.preDeserialize;
        var postDeserialize = _this.options.postDeserialize;
        var rootClass = _this.options.rootClass;
        var deserializedRefMemoByIndex = {};
        function deserializeWithHooks(classHint, data, context) {
          if (!classHint || !classHint._deserialize) {
            classHint = DESERIALIZE_BY_TYPE_FIELD[data.type];
          }
          var deserializer = classHint && classHint._deserialize;
          if (!deserializer) {
            return;
          }
          data = preDeserialize(data);
          var classDeserializeFn = classHint._deserialize;
          var obj = classDeserializeFn(data, context, deserializeChild);
          obj = postDeserialize(obj, data);
          return obj;
        }
        function deserializeChild(classHint, dataOrRef, context) {
          var isRefObject = dataOrRef.refIndex && dataOrRef.refType;
          if (!isRefObject) {
            return deserializeWithHooks(classHint, dataOrRef, context);
          }
          var ref = dataOrRef;
          if (DESERIALIZE_BY_REF_TYPE[ref.refType]) {
            classHint = DESERIALIZE_BY_REF_TYPE[ref.refType];
          }
          var refIndex = ref.refIndex;
          if (!deserializedRefMemoByIndex[refIndex]) {
            var data = json[refIndex];
            var obj = deserializeWithHooks(classHint, data, context);
            deserializedRefMemoByIndex[refIndex] = obj;
          }
          return deserializedRefMemoByIndex[refIndex];
        }
        var root = deserializeWithHooks(rootClass, json[0], null);
        return root;
      };
      this.options = _assign$(_assign$({}, DEFAULT_OPTIONS), options2);
    }
    return Serializer2;
  }();
  var worldSerializer = new Serializer({
    rootClass: World
  });
  Serializer.fromJson = worldSerializer.fromJson;
  Serializer.toJson = worldSerializer.toJson;
  var Testbed = /** @class */
  function () {
    function Testbed2() {
      this.width = 80;
      this.height = 60;
      this.x = 0;
      this.y = -10;
      this.scaleY = -1;
      this.hz = 60;
      this.speed = 1;
      this.background = "#222222";
      this.activeKeys = {};
      this.step = function (dt, t) {
        return;
      };
      this.keydown = function (keyCode, label) {
        return;
      };
      this.keyup = function (keyCode, label) {
        return;
      };
    }
    Testbed2.mount = function (options2) {
      throw new Error("Not implemented");
    };
    Testbed2.start = function (world) {
      var testbed2 = Testbed2.mount();
      testbed2.start(world);
      return testbed2;
    };
    Testbed2.prototype.color = function (r, g, b2) {
      r = r * 256 | 0;
      g = g * 256 | 0;
      b2 = b2 * 256 | 0;
      return "rgb(" + r + ", " + g + ", " + b2 + ")";
    };
    return Testbed2;
  }();
  function testbed(a2, b2) {
    var callback;
    var options2;
    if (typeof a2 === "function") {
      callback = a2;
      options2 = b2;
    } else if (typeof b2 === "function") {
      callback = b2;
      options2 = a2;
    } else {
      options2 = a2 !== null && a2 !== void 0 ? a2 : b2;
    }
    var testbed2 = Testbed.mount(options2);
    if (callback) {
      var world = callback(testbed2) || testbed2.world;
      testbed2.start(world);
    } else {
      return testbed2;
    }
  }
  var BoxShape = /** @class */
  function (_super) {
    __extends$1(BoxShape2, _super);
    function BoxShape2(halfWidth, halfHeight, center2, angle) {
      var _this = this;
      if (!(_this instanceof BoxShape2)) {
        return new BoxShape2(halfWidth, halfHeight, center2, angle);
      }
      _this = _super.call(this) || this;
      _this._setAsBox(halfWidth, halfHeight, center2, angle);
      return _this;
    }
    BoxShape2.TYPE = "polygon";
    return BoxShape2;
  }(PolygonShape);
  var Box = BoxShape;
  Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);
  function CircleCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {
    CollideCircles(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);
  }
  var pA = vec2(0, 0);
  var pB = vec2(0, 0);
  var CollideCircles = function CollideCircles(manifold, circleA, xfA2, circleB, xfB2) {
    manifold.pointCount = 0;
    transformVec2(pA, xfA2, circleA.m_p);
    transformVec2(pB, xfB2, circleB.m_p);
    var distSqr = distSqrVec2(pB, pA);
    var rA2 = circleA.m_radius;
    var rB2 = circleB.m_radius;
    var radius = rA2 + rB2;
    if (distSqr > radius * radius) {
      return;
    }
    manifold.type = exports2.ManifoldType.e_circles;
    copyVec2(manifold.localPoint, circleA.m_p);
    zeroVec2(manifold.localNormal);
    manifold.pointCount = 1;
    copyVec2(manifold.points[0].localPoint, circleB.m_p);
    manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
  };
  Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);
  Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);
  function EdgeCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {
    var shapeA = fixtureA.getShape();
    var shapeB = fixtureB.getShape();
    CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);
  }
  function ChainCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {
    var chain = fixtureA.getShape();
    var edge = new EdgeShape();
    chain.getChildEdge(edge, indexA);
    var shapeA = edge;
    var shapeB = fixtureB.getShape();
    CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);
  }
  var e = vec2(0, 0);
  var e1 = vec2(0, 0);
  var e2 = vec2(0, 0);
  var Q = vec2(0, 0);
  var P = vec2(0, 0);
  var n$2 = vec2(0, 0);
  var CollideEdgeCircle = function CollideEdgeCircle(manifold, edgeA, xfA2, circleB, xfB2) {
    manifold.pointCount = 0;
    retransformVec2(Q, xfB2, xfA2, circleB.m_p);
    var A = edgeA.m_vertex1;
    var B = edgeA.m_vertex2;
    subVec2(e, B, A);
    var u = dotVec2(e, B) - dotVec2(e, Q);
    var v3 = dotVec2(e, Q) - dotVec2(e, A);
    var radius = edgeA.m_radius + circleB.m_radius;
    if (v3 <= 0) {
      copyVec2(P, A);
      var dd_1 = distSqrVec2(Q, A);
      if (dd_1 > radius * radius) {
        return;
      }
      if (edgeA.m_hasVertex0) {
        var A1 = edgeA.m_vertex0;
        var B1 = A;
        subVec2(e1, B1, A1);
        var u1 = dotVec2(e1, B1) - dotVec2(e1, Q);
        if (u1 > 0) {
          return;
        }
      }
      manifold.type = exports2.ManifoldType.e_circles;
      zeroVec2(manifold.localNormal);
      copyVec2(manifold.localPoint, P);
      manifold.pointCount = 1;
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
      return;
    }
    if (u <= 0) {
      copyVec2(P, B);
      var dd_2 = distSqrVec2(Q, P);
      if (dd_2 > radius * radius) {
        return;
      }
      if (edgeA.m_hasVertex3) {
        var B2 = edgeA.m_vertex3;
        var A2 = B;
        subVec2(e2, B2, A2);
        var v22 = dotVec2(e2, Q) - dotVec2(e2, A2);
        if (v22 > 0) {
          return;
        }
      }
      manifold.type = exports2.ManifoldType.e_circles;
      zeroVec2(manifold.localNormal);
      copyVec2(manifold.localPoint, P);
      manifold.pointCount = 1;
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(1, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
      return;
    }
    var den = lengthSqrVec2(e);
    combine2Vec2(P, u / den, A, v3 / den, B);
    var dd = distSqrVec2(Q, P);
    if (dd > radius * radius) {
      return;
    }
    crossNumVec2(n$2, 1, e);
    if (dotVec2(n$2, Q) - dotVec2(n$2, A) < 0) {
      negVec2(n$2);
    }
    normalizeVec2(n$2);
    manifold.type = exports2.ManifoldType.e_faceA;
    copyVec2(manifold.localNormal, n$2);
    copyVec2(manifold.localPoint, A);
    manifold.pointCount = 1;
    copyVec2(manifold.points[0].localPoint, circleB.m_p);
    manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_face, 0, exports2.ContactFeatureType.e_vertex);
  };
  var incidentEdge = [new ClipVertex(), new ClipVertex()];
  var clipPoints1$1 = [new ClipVertex(), new ClipVertex()];
  var clipPoints2$1 = [new ClipVertex(), new ClipVertex()];
  var clipSegmentToLineNormal = vec2(0, 0);
  var v1 = vec2(0, 0);
  var n$1 = vec2(0, 0);
  var xf$1 = transform(0, 0, 0);
  var v11 = vec2(0, 0);
  var v12 = vec2(0, 0);
  var localTangent = vec2(0, 0);
  var localNormal = vec2(0, 0);
  var planePoint = vec2(0, 0);
  var tangent = vec2(0, 0);
  var normal$1 = vec2(0, 0);
  var normal1$1 = vec2(0, 0);
  Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);
  function PolygonContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {
    CollidePolygons(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);
  }
  function findMaxSeparation(poly1, xf1, poly2, xf2, output2) {
    var count1 = poly1.m_count;
    var count2 = poly2.m_count;
    var n1s = poly1.m_normals;
    var v1s = poly1.m_vertices;
    var v2s = poly2.m_vertices;
    detransformTransform(xf$1, xf2, xf1);
    var bestIndex = 0;
    var maxSeparation2 = -Infinity;
    for (var i = 0; i < count1; ++i) {
      rotVec2(n$1, xf$1.q, n1s[i]);
      transformVec2(v1, xf$1, v1s[i]);
      var si = Infinity;
      for (var j = 0; j < count2; ++j) {
        var sij = dotVec2(n$1, v2s[j]) - dotVec2(n$1, v1);
        if (sij < si) {
          si = sij;
        }
      }
      if (si > maxSeparation2) {
        maxSeparation2 = si;
        bestIndex = i;
      }
    }
    output2.maxSeparation = maxSeparation2;
    output2.bestIndex = bestIndex;
  }
  function findIncidentEdge(clipVertex, poly1, xf1, edge12, poly2, xf2) {
    var normals1 = poly1.m_normals;
    var count2 = poly2.m_count;
    var vertices2 = poly2.m_vertices;
    var normals2 = poly2.m_normals;
    rerotVec2(normal1$1, xf2.q, xf1.q, normals1[edge12]);
    var index = 0;
    var minDot = Infinity;
    for (var i = 0; i < count2; ++i) {
      var dot = dotVec2(normal1$1, normals2[i]);
      if (dot < minDot) {
        minDot = dot;
        index = i;
      }
    }
    var i1 = index;
    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
    transformVec2(clipVertex[0].v, xf2, vertices2[i1]);
    clipVertex[0].id.setFeatures(edge12, exports2.ContactFeatureType.e_face, i1, exports2.ContactFeatureType.e_vertex);
    transformVec2(clipVertex[1].v, xf2, vertices2[i2]);
    clipVertex[1].id.setFeatures(edge12, exports2.ContactFeatureType.e_face, i2, exports2.ContactFeatureType.e_vertex);
  }
  var maxSeparation = {
    maxSeparation: 0,
    bestIndex: 0
  };
  var CollidePolygons = function CollidePolygons(manifold, polyA, xfA2, polyB, xfB2) {
    manifold.pointCount = 0;
    var totalRadius = polyA.m_radius + polyB.m_radius;
    findMaxSeparation(polyA, xfA2, polyB, xfB2, maxSeparation);
    var edgeA = maxSeparation.bestIndex;
    var separationA = maxSeparation.maxSeparation;
    if (separationA > totalRadius) return;
    findMaxSeparation(polyB, xfB2, polyA, xfA2, maxSeparation);
    var edgeB = maxSeparation.bestIndex;
    var separationB = maxSeparation.maxSeparation;
    if (separationB > totalRadius) return;
    var poly1;
    var poly2;
    var xf1;
    var xf2;
    var edge12;
    var flip;
    var k_tol = 0.1 * SettingsInternal.linearSlop;
    if (separationB > separationA + k_tol) {
      poly1 = polyB;
      poly2 = polyA;
      xf1 = xfB2;
      xf2 = xfA2;
      edge12 = edgeB;
      manifold.type = exports2.ManifoldType.e_faceB;
      flip = true;
    } else {
      poly1 = polyA;
      poly2 = polyB;
      xf1 = xfA2;
      xf2 = xfB2;
      edge12 = edgeA;
      manifold.type = exports2.ManifoldType.e_faceA;
      flip = false;
    }
    incidentEdge[0].recycle();
    incidentEdge[1].recycle();
    findIncidentEdge(incidentEdge, poly1, xf1, edge12, poly2, xf2);
    var count1 = poly1.m_count;
    var vertices1 = poly1.m_vertices;
    var iv1 = edge12;
    var iv2 = edge12 + 1 < count1 ? edge12 + 1 : 0;
    copyVec2(v11, vertices1[iv1]);
    copyVec2(v12, vertices1[iv2]);
    subVec2(localTangent, v12, v11);
    normalizeVec2(localTangent);
    crossVec2Num(localNormal, localTangent, 1);
    combine2Vec2(planePoint, 0.5, v11, 0.5, v12);
    rotVec2(tangent, xf1.q, localTangent);
    crossVec2Num(normal$1, tangent, 1);
    transformVec2(v11, xf1, v11);
    transformVec2(v12, xf1, v12);
    var frontOffset = dotVec2(normal$1, v11);
    var sideOffset1 = -dotVec2(tangent, v11) + totalRadius;
    var sideOffset2 = dotVec2(tangent, v12) + totalRadius;
    clipPoints1$1[0].recycle();
    clipPoints1$1[1].recycle();
    clipPoints2$1[0].recycle();
    clipPoints2$1[1].recycle();
    setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);
    var np1 = clipSegmentToLine(clipPoints1$1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);
    if (np1 < 2) {
      return;
    }
    setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);
    var np2 = clipSegmentToLine(clipPoints2$1, clipPoints1$1, clipSegmentToLineNormal, sideOffset2, iv2);
    if (np2 < 2) {
      return;
    }
    copyVec2(manifold.localNormal, localNormal);
    copyVec2(manifold.localPoint, planePoint);
    var pointCount = 0;
    for (var i = 0; i < clipPoints2$1.length; ++i) {
      var separation = dotVec2(normal$1, clipPoints2$1[i].v) - frontOffset;
      if (separation <= totalRadius) {
        var cp = manifold.points[pointCount];
        detransformVec2(cp.localPoint, xf2, clipPoints2$1[i].v);
        cp.id.set(clipPoints2$1[i].id);
        if (flip) {
          cp.id.swapFeatures();
        }
        ++pointCount;
      }
    }
    manifold.pointCount = pointCount;
  };
  Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);
  function PolygonCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {
    CollidePolygonCircle(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);
  }
  var cLocal = vec2(0, 0);
  var faceCenter = vec2(0, 0);
  var CollidePolygonCircle = function CollidePolygonCircle(manifold, polygonA, xfA2, circleB, xfB2) {
    manifold.pointCount = 0;
    retransformVec2(cLocal, xfB2, xfA2, circleB.m_p);
    var normalIndex = 0;
    var separation = -Infinity;
    var radius = polygonA.m_radius + circleB.m_radius;
    var vertexCount = polygonA.m_count;
    var vertices = polygonA.m_vertices;
    var normals = polygonA.m_normals;
    for (var i = 0; i < vertexCount; ++i) {
      var s2 = dotVec2(normals[i], cLocal) - dotVec2(normals[i], vertices[i]);
      if (s2 > radius) {
        return;
      }
      if (s2 > separation) {
        separation = s2;
        normalIndex = i;
      }
    }
    var vertIndex1 = normalIndex;
    var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
    var v13 = vertices[vertIndex1];
    var v22 = vertices[vertIndex2];
    if (separation < EPSILON) {
      manifold.pointCount = 1;
      manifold.type = exports2.ManifoldType.e_faceA;
      copyVec2(manifold.localNormal, normals[normalIndex]);
      combine2Vec2(manifold.localPoint, 0.5, v13, 0.5, v22);
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
      return;
    }
    var u1 = dotVec2(cLocal, v22) - dotVec2(cLocal, v13) - dotVec2(v13, v22) + dotVec2(v13, v13);
    var u2 = dotVec2(cLocal, v13) - dotVec2(cLocal, v22) - dotVec2(v22, v13) + dotVec2(v22, v22);
    if (u1 <= 0) {
      if (distSqrVec2(cLocal, v13) > radius * radius) {
        return;
      }
      manifold.pointCount = 1;
      manifold.type = exports2.ManifoldType.e_faceA;
      subVec2(manifold.localNormal, cLocal, v13);
      normalizeVec2(manifold.localNormal);
      copyVec2(manifold.localPoint, v13);
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
    } else if (u2 <= 0) {
      if (distSqrVec2(cLocal, v22) > radius * radius) {
        return;
      }
      manifold.pointCount = 1;
      manifold.type = exports2.ManifoldType.e_faceA;
      subVec2(manifold.localNormal, cLocal, v22);
      normalizeVec2(manifold.localNormal);
      copyVec2(manifold.localPoint, v22);
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
    } else {
      combine2Vec2(faceCenter, 0.5, v13, 0.5, v22);
      var separation_1 = dotVec2(cLocal, normals[vertIndex1]) - dotVec2(faceCenter, normals[vertIndex1]);
      if (separation_1 > radius) {
        return;
      }
      manifold.pointCount = 1;
      manifold.type = exports2.ManifoldType.e_faceA;
      copyVec2(manifold.localNormal, normals[vertIndex1]);
      copyVec2(manifold.localPoint, faceCenter);
      copyVec2(manifold.points[0].localPoint, circleB.m_p);
      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);
    }
  };
  var math_min$5 = Math.min;
  Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);
  Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);
  function EdgePolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {
    CollideEdgePolygon(manifold, fA.getShape(), xfA2, fB.getShape(), xfB2);
  }
  var edge_reuse = new EdgeShape();
  function ChainPolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {
    var chain = fA.getShape();
    chain.getChildEdge(edge_reuse, indexA);
    CollideEdgePolygon(manifold, edge_reuse, xfA2, fB.getShape(), xfB2);
  }
  var EPAxisType;
  (function (EPAxisType2) {
    EPAxisType2[EPAxisType2["e_unknown"] = -1] = "e_unknown";
    EPAxisType2[EPAxisType2["e_edgeA"] = 1] = "e_edgeA";
    EPAxisType2[EPAxisType2["e_edgeB"] = 2] = "e_edgeB";
  })(EPAxisType || (EPAxisType = {}));
  var VertexType;
  (function (VertexType2) {
    VertexType2[VertexType2["e_isolated"] = 0] = "e_isolated";
    VertexType2[VertexType2["e_concave"] = 1] = "e_concave";
    VertexType2[VertexType2["e_convex"] = 2] = "e_convex";
  })(VertexType || (VertexType = {}));
  var EPAxis = /** @class */
  /* @__PURE__ */function () {
    function EPAxis2() {}
    return EPAxis2;
  }();
  var TempPolygon = /** @class */
  /* @__PURE__ */function () {
    function TempPolygon2() {
      this.vertices = [];
      this.normals = [];
      this.count = 0;
      for (var i = 0; i < SettingsInternal.maxPolygonVertices; i++) {
        this.vertices.push(vec2(0, 0));
        this.normals.push(vec2(0, 0));
      }
    }
    return TempPolygon2;
  }();
  var ReferenceFace = /** @class */
  function () {
    function ReferenceFace2() {
      this.v1 = vec2(0, 0);
      this.v2 = vec2(0, 0);
      this.normal = vec2(0, 0);
      this.sideNormal1 = vec2(0, 0);
      this.sideNormal2 = vec2(0, 0);
    }
    ReferenceFace2.prototype.recycle = function () {
      zeroVec2(this.v1);
      zeroVec2(this.v2);
      zeroVec2(this.normal);
      zeroVec2(this.sideNormal1);
      zeroVec2(this.sideNormal2);
    };
    return ReferenceFace2;
  }();
  var clipPoints1 = [new ClipVertex(), new ClipVertex()];
  var clipPoints2 = [new ClipVertex(), new ClipVertex()];
  var ie = [new ClipVertex(), new ClipVertex()];
  var edgeAxis = new EPAxis();
  var polygonAxis = new EPAxis();
  var polygonBA = new TempPolygon();
  var rf = new ReferenceFace();
  var centroidB = vec2(0, 0);
  var edge0 = vec2(0, 0);
  var edge1 = vec2(0, 0);
  var edge2 = vec2(0, 0);
  var xf = transform(0, 0, 0);
  var normal = vec2(0, 0);
  var normal0 = vec2(0, 0);
  var normal1 = vec2(0, 0);
  var normal2 = vec2(0, 0);
  var lowerLimit = vec2(0, 0);
  var upperLimit = vec2(0, 0);
  var perp = vec2(0, 0);
  var n = vec2(0, 0);
  var CollideEdgePolygon = function CollideEdgePolygon(manifold, edgeA, xfA2, polygonB, xfB2) {
    detransformTransform(xf, xfA2, xfB2);
    transformVec2(centroidB, xf, polygonB.m_centroid);
    var v0 = edgeA.m_vertex0;
    var v13 = edgeA.m_vertex1;
    var v22 = edgeA.m_vertex2;
    var v3 = edgeA.m_vertex3;
    var hasVertex0 = edgeA.m_hasVertex0;
    var hasVertex3 = edgeA.m_hasVertex3;
    subVec2(edge1, v22, v13);
    normalizeVec2(edge1);
    setVec2(normal1, edge1.y, -edge1.x);
    var offset1 = dotVec2(normal1, centroidB) - dotVec2(normal1, v13);
    var offset0 = 0;
    var offset2 = 0;
    var convex1 = false;
    var convex2 = false;
    zeroVec2(normal0);
    zeroVec2(normal2);
    if (hasVertex0) {
      subVec2(edge0, v13, v0);
      normalizeVec2(edge0);
      setVec2(normal0, edge0.y, -edge0.x);
      convex1 = crossVec2Vec2(edge0, edge1) >= 0;
      offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);
    }
    if (hasVertex3) {
      subVec2(edge2, v3, v22);
      normalizeVec2(edge2);
      setVec2(normal2, edge2.y, -edge2.x);
      convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0;
      offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v22);
    }
    var front;
    zeroVec2(normal);
    zeroVec2(lowerLimit);
    zeroVec2(upperLimit);
    if (hasVertex0 && hasVertex3) {
      if (convex1 && convex2) {
        front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal0);
          copyVec2(upperLimit, normal2);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal1);
          scaleVec2(upperLimit, -1, normal1);
        }
      } else if (convex1) {
        front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal0);
          copyVec2(upperLimit, normal1);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal2);
          scaleVec2(upperLimit, -1, normal1);
        }
      } else if (convex2) {
        front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal1);
          copyVec2(upperLimit, normal2);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal1);
          scaleVec2(upperLimit, -1, normal0);
        }
      } else {
        front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal1);
          copyVec2(upperLimit, normal1);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal2);
          scaleVec2(upperLimit, -1, normal0);
        }
      }
    } else if (hasVertex0) {
      if (convex1) {
        front = offset0 >= 0 || offset1 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal0);
          scaleVec2(upperLimit, -1, normal1);
        } else {
          scaleVec2(normal, -1, normal1);
          copyVec2(lowerLimit, normal1);
          scaleVec2(upperLimit, -1, normal1);
        }
      } else {
        front = offset0 >= 0 && offset1 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          copyVec2(lowerLimit, normal1);
          scaleVec2(upperLimit, -1, normal1);
        } else {
          scaleVec2(normal, -1, normal1);
          copyVec2(lowerLimit, normal1);
          scaleVec2(upperLimit, -1, normal0);
        }
      }
    } else if (hasVertex3) {
      if (convex2) {
        front = offset1 >= 0 || offset2 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          scaleVec2(lowerLimit, -1, normal1);
          copyVec2(upperLimit, normal2);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal1);
          copyVec2(upperLimit, normal1);
        }
      } else {
        front = offset1 >= 0 && offset2 >= 0;
        if (front) {
          copyVec2(normal, normal1);
          scaleVec2(lowerLimit, -1, normal1);
          copyVec2(upperLimit, normal1);
        } else {
          scaleVec2(normal, -1, normal1);
          scaleVec2(lowerLimit, -1, normal2);
          copyVec2(upperLimit, normal1);
        }
      }
    } else {
      front = offset1 >= 0;
      if (front) {
        copyVec2(normal, normal1);
        scaleVec2(lowerLimit, -1, normal1);
        scaleVec2(upperLimit, -1, normal1);
      } else {
        scaleVec2(normal, -1, normal1);
        copyVec2(lowerLimit, normal1);
        copyVec2(upperLimit, normal1);
      }
    }
    polygonBA.count = polygonB.m_count;
    for (var i = 0; i < polygonB.m_count; ++i) {
      transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);
      rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);
    }
    var radius = polygonB.m_radius + edgeA.m_radius;
    manifold.pointCount = 0;
    {
      edgeAxis.type = EPAxisType.e_edgeA;
      edgeAxis.index = front ? 0 : 1;
      edgeAxis.separation = Infinity;
      for (var i = 0; i < polygonBA.count; ++i) {
        var v4 = polygonBA.vertices[i];
        var s2 = dotVec2(normal, v4) - dotVec2(normal, v13);
        if (s2 < edgeAxis.separation) {
          edgeAxis.separation = s2;
        }
      }
    }
    if (edgeAxis.type == EPAxisType.e_unknown) {
      return;
    }
    if (edgeAxis.separation > radius) {
      return;
    }
    {
      polygonAxis.type = EPAxisType.e_unknown;
      polygonAxis.index = -1;
      polygonAxis.separation = -Infinity;
      setVec2(perp, -normal.y, normal.x);
      for (var i = 0; i < polygonBA.count; ++i) {
        scaleVec2(n, -1, polygonBA.normals[i]);
        var s1 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v13);
        var s22 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v22);
        var s2 = math_min$5(s1, s22);
        if (s2 > radius) {
          polygonAxis.type = EPAxisType.e_edgeB;
          polygonAxis.index = i;
          polygonAxis.separation = s2;
          break;
        }
        if (dotVec2(n, perp) >= 0) {
          if (dotVec2(n, normal) - dotVec2(upperLimit, normal) < -SettingsInternal.angularSlop) {
            continue;
          }
        } else {
          if (dotVec2(n, normal) - dotVec2(lowerLimit, normal) < -SettingsInternal.angularSlop) {
            continue;
          }
        }
        if (s2 > polygonAxis.separation) {
          polygonAxis.type = EPAxisType.e_edgeB;
          polygonAxis.index = i;
          polygonAxis.separation = s2;
        }
      }
    }
    if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {
      return;
    }
    var k_relativeTol = 0.98;
    var k_absoluteTol = 1e-3;
    var primaryAxis;
    if (polygonAxis.type == EPAxisType.e_unknown) {
      primaryAxis = edgeAxis;
    } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
      primaryAxis = polygonAxis;
    } else {
      primaryAxis = edgeAxis;
    }
    ie[0].recycle();
    ie[1].recycle();
    if (primaryAxis.type == EPAxisType.e_edgeA) {
      manifold.type = exports2.ManifoldType.e_faceA;
      var bestIndex = 0;
      var bestValue = dotVec2(normal, polygonBA.normals[0]);
      for (var i = 1; i < polygonBA.count; ++i) {
        var value = dotVec2(normal, polygonBA.normals[i]);
        if (value < bestValue) {
          bestValue = value;
          bestIndex = i;
        }
      }
      var i1 = bestIndex;
      var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;
      copyVec2(ie[0].v, polygonBA.vertices[i1]);
      ie[0].id.setFeatures(0, exports2.ContactFeatureType.e_face, i1, exports2.ContactFeatureType.e_vertex);
      copyVec2(ie[1].v, polygonBA.vertices[i2]);
      ie[1].id.setFeatures(0, exports2.ContactFeatureType.e_face, i2, exports2.ContactFeatureType.e_vertex);
      if (front) {
        rf.i1 = 0;
        rf.i2 = 1;
        copyVec2(rf.v1, v13);
        copyVec2(rf.v2, v22);
        copyVec2(rf.normal, normal1);
      } else {
        rf.i1 = 1;
        rf.i2 = 0;
        copyVec2(rf.v1, v22);
        copyVec2(rf.v2, v13);
        scaleVec2(rf.normal, -1, normal1);
      }
    } else {
      manifold.type = exports2.ManifoldType.e_faceB;
      copyVec2(ie[0].v, v13);
      ie[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, primaryAxis.index, exports2.ContactFeatureType.e_face);
      copyVec2(ie[1].v, v22);
      ie[1].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, primaryAxis.index, exports2.ContactFeatureType.e_face);
      rf.i1 = primaryAxis.index;
      rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
      copyVec2(rf.v1, polygonBA.vertices[rf.i1]);
      copyVec2(rf.v2, polygonBA.vertices[rf.i2]);
      copyVec2(rf.normal, polygonBA.normals[rf.i1]);
    }
    setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);
    setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);
    rf.sideOffset1 = dotVec2(rf.sideNormal1, rf.v1);
    rf.sideOffset2 = dotVec2(rf.sideNormal2, rf.v2);
    clipPoints1[0].recycle();
    clipPoints1[1].recycle();
    clipPoints2[0].recycle();
    clipPoints2[1].recycle();
    var np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
    if (np1 < SettingsInternal.maxManifoldPoints) {
      return;
    }
    var np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
    if (np2 < SettingsInternal.maxManifoldPoints) {
      return;
    }
    if (primaryAxis.type == EPAxisType.e_edgeA) {
      copyVec2(manifold.localNormal, rf.normal);
      copyVec2(manifold.localPoint, rf.v1);
    } else {
      copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);
      copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);
    }
    var pointCount = 0;
    for (var i = 0; i < SettingsInternal.maxManifoldPoints; ++i) {
      var separation = dotVec2(rf.normal, clipPoints2[i].v) - dotVec2(rf.normal, rf.v1);
      if (separation <= radius) {
        var cp = manifold.points[pointCount];
        if (primaryAxis.type == EPAxisType.e_edgeA) {
          detransformVec2(cp.localPoint, xf, clipPoints2[i].v);
          cp.id.set(clipPoints2[i].id);
        } else {
          copyVec2(cp.localPoint, clipPoints2[i].v);
          cp.id.set(clipPoints2[i].id);
          cp.id.swapFeatures();
        }
        ++pointCount;
      }
    }
    manifold.pointCount = pointCount;
  };
  var internal = {
    CollidePolygons: CollidePolygons,
    Settings: Settings,
    Sweep: Sweep,
    Manifold: Manifold,
    Distance: Distance,
    TimeOfImpact: TimeOfImpact,
    DynamicTree: DynamicTree,
    stats: stats$1
  };
  var DataDriver = /** @class */
  function () {
    function DataDriver2(key, listener) {
      this._refMap = {};
      this._map = {};
      this._xmap = {};
      this._data = [];
      this._entered = [];
      this._exited = [];
      this._key = key;
      this._listener = listener;
    }
    DataDriver2.prototype.update = function (data) {
      if (!Array.isArray(data)) throw "Invalid data: " + data;
      this._entered.length = 0;
      this._exited.length = 0;
      this._data.length = data.length;
      for (var i = 0; i < data.length; i++) {
        if (_typeof(data[i]) !== "object" || data[i] === null) continue;
        var d2 = data[i];
        var id = this._key(d2);
        if (!this._map[id]) {
          this._entered.push(d2);
        } else {
          delete this._map[id];
        }
        this._data[i] = d2;
        this._xmap[id] = d2;
      }
      for (var id in this._map) {
        this._exited.push(this._map[id]);
        delete this._map[id];
      }
      var temp3 = this._map;
      this._map = this._xmap;
      this._xmap = temp3;
      for (var i = 0; i < this._exited.length; i++) {
        var d2 = this._exited[i];
        var key = this._key(d2);
        var ref = this._refMap[key];
        this._listener.exit(d2, ref);
        delete this._refMap[key];
      }
      for (var i = 0; i < this._entered.length; i++) {
        var d2 = this._entered[i];
        var key = this._key(d2);
        var ref = this._listener.enter(d2);
        if (ref) {
          this._refMap[key] = ref;
        }
      }
      for (var i = 0; i < this._data.length; i++) {
        if (_typeof(data[i]) !== "object" || data[i] === null) continue;
        var d2 = this._data[i];
        var key = this._key(d2);
        var ref = this._refMap[key];
        this._listener.update(d2, ref);
      }
      this._entered.length = 0;
      this._exited.length = 0;
      this._data.length = 0;
    };
    DataDriver2.prototype.ref = function (d2) {
      return this._refMap[this._key(d2)];
    };
    return DataDriver2;
  }();
  /**
   * Stage.js 1.0.0-alpha.12
   *
   * @copyright Copyright (c) Ali Shakiba
   * @license The MIT License (MIT)
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var math_random = Math.random;
  var math_sqrt$2 = Math.sqrt;
  function random(min, max) {
    if (typeof min === "undefined") {
      max = 1;
      min = 0;
    } else if (typeof max === "undefined") {
      max = min;
      min = 0;
    }
    return min == max ? min : math_random() * (max - min) + min;
  }
  function wrap(num, min, max) {
    if (typeof min === "undefined") {
      max = 1;
      min = 0;
    } else if (typeof max === "undefined") {
      max = min;
      min = 0;
    }
    if (max > min) {
      num = (num - min) % (max - min);
      return num + (num < 0 ? max : min);
    } else {
      num = (num - max) % (min - max);
      return num + (num <= 0 ? min : max);
    }
  }
  function clamp(num, min, max) {
    if (num < min) {
      return min;
    } else if (num > max) {
      return max;
    } else {
      return num;
    }
  }
  function length(x2, y) {
    return math_sqrt$2(x2 * x2 + y * y);
  }
  var math = Object.create(Math);
  math.random = random;
  math.wrap = wrap;
  math.clamp = clamp;
  math.length = length;
  math.rotate = wrap;
  math.limit = clamp;
  var Matrix = /** @class */
  function () {
    function Matrix2(a2, b2, c2, d2, e3, f) {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.e = 0;
      this.f = 0;
      if (_typeof(a2) === "object") {
        this.reset(a2);
      } else {
        this.reset(a2, b2, c2, d2, e3, f);
      }
    }
    Matrix2.prototype.toString = function () {
      return "[" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.e + ", " + this.f + "]";
    };
    Matrix2.prototype.clone = function () {
      return new Matrix2(this.a, this.b, this.c, this.d, this.e, this.f);
    };
    Matrix2.prototype.reset = function (a2, b2, c2, d2, e3, f) {
      this._dirty = true;
      if (_typeof(a2) === "object") {
        this.a = a2.a;
        this.d = a2.d;
        this.b = a2.b;
        this.c = a2.c;
        this.e = a2.e;
        this.f = a2.f;
      } else {
        this.a = typeof a2 === "number" ? a2 : 1;
        this.b = typeof b2 === "number" ? b2 : 0;
        this.c = typeof c2 === "number" ? c2 : 0;
        this.d = typeof d2 === "number" ? d2 : 1;
        this.e = typeof e3 === "number" ? e3 : 0;
        this.f = typeof f === "number" ? f : 0;
      }
      return this;
    };
    Matrix2.prototype.identity = function () {
      this._dirty = true;
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.e = 0;
      this.f = 0;
      return this;
    };
    Matrix2.prototype.rotate = function (angle) {
      if (!angle) {
        return this;
      }
      this._dirty = true;
      var u = angle ? Math.cos(angle) : 1;
      var v3 = angle ? Math.sin(angle) : 0;
      var a2 = u * this.a - v3 * this.b;
      var b2 = u * this.b + v3 * this.a;
      var c2 = u * this.c - v3 * this.d;
      var d2 = u * this.d + v3 * this.c;
      var e3 = u * this.e - v3 * this.f;
      var f = u * this.f + v3 * this.e;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.e = e3;
      this.f = f;
      return this;
    };
    Matrix2.prototype.translate = function (x2, y) {
      if (!x2 && !y) {
        return this;
      }
      this._dirty = true;
      this.e += x2;
      this.f += y;
      return this;
    };
    Matrix2.prototype.scale = function (x2, y) {
      if (!(x2 - 1) && !(y - 1)) {
        return this;
      }
      this._dirty = true;
      this.a *= x2;
      this.b *= y;
      this.c *= x2;
      this.d *= y;
      this.e *= x2;
      this.f *= y;
      return this;
    };
    Matrix2.prototype.skew = function (x2, y) {
      if (!x2 && !y) {
        return this;
      }
      this._dirty = true;
      var a2 = this.a + this.b * x2;
      var b2 = this.b + this.a * y;
      var c2 = this.c + this.d * x2;
      var d2 = this.d + this.c * y;
      var e3 = this.e + this.f * x2;
      var f = this.f + this.e * y;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.e = e3;
      this.f = f;
      return this;
    };
    Matrix2.prototype.concat = function (m) {
      this._dirty = true;
      var a2 = this.a * m.a + this.b * m.c;
      var b2 = this.b * m.d + this.a * m.b;
      var c2 = this.c * m.a + this.d * m.c;
      var d2 = this.d * m.d + this.c * m.b;
      var e3 = this.e * m.a + m.e + this.f * m.c;
      var f = this.f * m.d + m.f + this.e * m.b;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.e = e3;
      this.f = f;
      return this;
    };
    Matrix2.prototype.inverse = function () {
      if (this._dirty) {
        this._dirty = false;
        if (!this.inverted) {
          this.inverted = new Matrix2();
        }
        var z = this.a * this.d - this.b * this.c;
        this.inverted.a = this.d / z;
        this.inverted.b = -this.b / z;
        this.inverted.c = -this.c / z;
        this.inverted.d = this.a / z;
        this.inverted.e = (this.c * this.f - this.e * this.d) / z;
        this.inverted.f = (this.e * this.b - this.a * this.f) / z;
      }
      return this.inverted;
    };
    Matrix2.prototype.map = function (p, q) {
      q = q || {
        x: 0,
        y: 0
      };
      q.x = this.a * p.x + this.c * p.y + this.e;
      q.y = this.b * p.x + this.d * p.y + this.f;
      return q;
    };
    Matrix2.prototype.mapX = function (x2, y) {
      if (_typeof(x2) === "object") {
        y = x2.y;
        x2 = x2.x;
      }
      return this.a * x2 + this.c * y + this.e;
    };
    Matrix2.prototype.mapY = function (x2, y) {
      if (_typeof(x2) === "object") {
        y = x2.y;
        x2 = x2.x;
      }
      return this.b * x2 + this.d * y + this.f;
    };
    return Matrix2;
  }();
  /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d22, b22) {
      d22.__proto__ = b22;
    } || function (d22, b22) {
      for (var p in b22) if (b22.hasOwnProperty(p)) d22[p] = b22[p];
    };
    return _extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var _assign = function __assign() {
    _assign = Object.assign || function __assign2(t) {
      for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
        s2 = arguments[i];
        for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t[p] = s2[p];
      }
      return t;
    };
    return _assign.apply(this, arguments);
  };
  function __awaiter(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function (resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n2) {
      return function (v3) {
        return step([n2, v3]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e3) {
        op = [6, e3];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  var objectToString = Object.prototype.toString;
  function isFn(value) {
    var str = objectToString.call(value);
    return str === "[object Function]" || str === "[object GeneratorFunction]" || str === "[object AsyncFunction]";
  }
  function isHash(value) {
    return objectToString.call(value) === "[object Object]" && value.constructor === Object;
  }
  var stats = {
    create: 0,
    tick: 0,
    node: 0,
    draw: 0,
    fps: 0
  };
  var uid = function uid() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2);
  };
  var Texture = /** @class */
  function () {
    function Texture2() {
      this.uid = "texture:" + uid();
      this.sx = 0;
      this.sy = 0;
      this.dx = 0;
      this.dy = 0;
    }
    Texture2.prototype.setSourceCoordinate = function (x2, y) {
      this.sx = x2;
      this.sy = y;
    };
    Texture2.prototype.setSourceDimension = function (w, h) {
      this.sw = w;
      this.sh = h;
    };
    Texture2.prototype.setDestinationCoordinate = function (x2, y) {
      this.dx = x2;
      this.dy = y;
    };
    Texture2.prototype.setDestinationDimension = function (w, h) {
      this.dw = w;
      this.dh = h;
    };
    Texture2.prototype.draw = function (context, x1, y1, w1, h1, x2, y2, w2, h2) {
      var sx, sy, sw, sh;
      var dx, dy, dw, dh;
      if (arguments.length > 5) {
        sx = this.sx + x1;
        sy = this.sy + y1;
        sw = w1 !== null && w1 !== void 0 ? w1 : this.sw;
        sh = h1 !== null && h1 !== void 0 ? h1 : this.sh;
        dx = this.dx + x2;
        dy = this.dy + y2;
        dw = w2 !== null && w2 !== void 0 ? w2 : this.dw;
        dh = h2 !== null && h2 !== void 0 ? h2 : this.dh;
      } else if (arguments.length > 1) {
        sx = this.sx;
        sy = this.sy;
        sw = this.sw;
        sh = this.sh;
        dx = this.dx + x1;
        dy = this.dy + y1;
        dw = w1 !== null && w1 !== void 0 ? w1 : this.dw;
        dh = h1 !== null && h1 !== void 0 ? h1 : this.dh;
      } else {
        sx = this.sx;
        sy = this.sy;
        sw = this.sw;
        sh = this.sh;
        dx = this.dx;
        dy = this.dy;
        dw = this.dw;
        dh = this.dh;
      }
      this.drawWithNormalizedArgs(context, sx, sy, sw, sh, dx, dy, dw, dh);
    };
    return Texture2;
  }();
  var ImageTexture = /** @class */
  function (_super) {
    __extends(ImageTexture2, _super);
    function ImageTexture2(source, pixelRatio) {
      var _this = _super.call(this) || this;
      _this._pixelRatio = 1;
      _this.padding = 0;
      if (_typeof(source) === "object") {
        _this.setSourceImage(source, pixelRatio);
      }
      return _this;
    }
    ImageTexture2.prototype.setSourceImage = function (image2, pixelRatio) {
      if (pixelRatio === void 0) {
        pixelRatio = 1;
      }
      this._source = image2;
      this._pixelRatio = pixelRatio;
    };
    ImageTexture2.prototype.setPadding = function (padding) {
      this.padding = padding;
    };
    ImageTexture2.prototype.getWidth = function () {
      return this._source.width / this._pixelRatio + (this.padding + this.padding);
    };
    ImageTexture2.prototype.getHeight = function () {
      return this._source.height / this._pixelRatio + (this.padding + this.padding);
    };
    ImageTexture2.prototype.prerender = function (context) {
      return false;
    };
    ImageTexture2.prototype.drawWithNormalizedArgs = function (context, sx, sy, sw, sh, dx, dy, dw, dh) {
      var image2 = this._source;
      if (image2 === null || _typeof(image2) !== "object") {
        return;
      }
      sw = sw !== null && sw !== void 0 ? sw : this._source.width / this._pixelRatio;
      sh = sh !== null && sh !== void 0 ? sh : this._source.height / this._pixelRatio;
      dw = dw !== null && dw !== void 0 ? dw : sw;
      dh = dh !== null && dh !== void 0 ? dh : sh;
      dx += this.padding;
      dy += this.padding;
      var ix = sx * this._pixelRatio;
      var iy = sy * this._pixelRatio;
      var iw = sw * this._pixelRatio;
      var ih = sh * this._pixelRatio;
      try {
        stats.draw++;
        context.drawImage(image2, ix, iy, iw, ih, dx, dy, dw, dh);
      } catch (ex) {
        if (!this._draw_failed) {
          console.log("Unable to draw: ", image2);
          console.log(ex);
          this._draw_failed = true;
        }
      }
    };
    return ImageTexture2;
  }(Texture);
  var PipeTexture = /** @class */
  function (_super) {
    __extends(PipeTexture2, _super);
    function PipeTexture2(source) {
      var _this = _super.call(this) || this;
      _this._source = source;
      return _this;
    }
    PipeTexture2.prototype.setSourceTexture = function (texture2) {
      this._source = texture2;
    };
    PipeTexture2.prototype.getWidth = function () {
      var _a2, _b;
      return (_b = (_a2 = this.dw) !== null && _a2 !== void 0 ? _a2 : this.sw) !== null && _b !== void 0 ? _b : this._source.getWidth();
    };
    PipeTexture2.prototype.getHeight = function () {
      var _a2, _b;
      return (_b = (_a2 = this.dh) !== null && _a2 !== void 0 ? _a2 : this.sh) !== null && _b !== void 0 ? _b : this._source.getHeight();
    };
    PipeTexture2.prototype.prerender = function (context) {
      return this._source.prerender(context);
    };
    PipeTexture2.prototype.drawWithNormalizedArgs = function (context, sx, sy, sw, sh, dx, dy, dw, dh) {
      var texture2 = this._source;
      if (texture2 === null || _typeof(texture2) !== "object") {
        return;
      }
      texture2.draw(context, sx, sy, sw, sh, dx, dy, dw, dh);
    };
    return PipeTexture2;
  }(Texture);
  /** @class */
  (function (_super) {
    __extends(Atlas2, _super);
    function Atlas2(def) {
      if (def === void 0) {
        def = {};
      }
      var _this = _super.call(this) || this;
      _this.pipeSpriteTexture = function (def2) {
        var map = _this._map;
        var ppu = _this._ppu;
        var trim = _this._trim;
        if (!def2) {
          return void 0;
        }
        def2 = Object.assign({}, def2);
        if (isFn(map)) {
          def2 = map(def2);
        }
        if (ppu != 1) {
          def2.x *= ppu;
          def2.y *= ppu;
          def2.width *= ppu;
          def2.height *= ppu;
          def2.top *= ppu;
          def2.bottom *= ppu;
          def2.left *= ppu;
          def2.right *= ppu;
        }
        if (trim != 0) {
          def2.x += trim;
          def2.y += trim;
          def2.width -= 2 * trim;
          def2.height -= 2 * trim;
          def2.top -= trim;
          def2.bottom -= trim;
          def2.left -= trim;
          def2.right -= trim;
        }
        var texture2 = new PipeTexture(_this);
        texture2.top = def2.top;
        texture2.bottom = def2.bottom;
        texture2.left = def2.left;
        texture2.right = def2.right;
        texture2.setSourceCoordinate(def2.x, def2.y);
        texture2.setSourceDimension(def2.width, def2.height);
        return texture2;
      };
      _this.findSpriteDefinition = function (query) {
        var textures = _this._textures;
        if (textures) {
          if (isFn(textures)) {
            return textures(query);
          } else if (isHash(textures)) {
            return textures[query];
          }
        }
      };
      _this.select = function (query) {
        if (!query) {
          return new TextureSelection(new PipeTexture(_this));
        }
        var textureDefinition = _this.findSpriteDefinition(query);
        if (textureDefinition) {
          return new TextureSelection(textureDefinition, _this);
        }
      };
      _this.name = def.name;
      _this._ppu = def.ppu || def.ratio || 1;
      _this._trim = def.trim || 0;
      _this._map = def.map || def.filter;
      _this._textures = def.textures;
      if (_typeof(def.image) === "object" && isHash(def.image)) {
        _this._imageSrc = def.image.src || def.image.url;
        if (typeof def.image.ratio === "number") {
          _this._pixelRatio = def.image.ratio;
        }
      } else {
        if (typeof def.imagePath === "string") {
          _this._imageSrc = def.imagePath;
        } else if (typeof def.image === "string") {
          _this._imageSrc = def.image;
        }
        if (typeof def.imageRatio === "number") {
          _this._pixelRatio = def.imageRatio;
        }
      }
      deprecatedWarning(def);
      return _this;
    }
    Atlas2.prototype.load = function () {
      return __awaiter(this, void 0, void 0, function () {
        var image2;
        return __generator(this, function (_a2) {
          switch (_a2.label) {
            case 0:
              if (!this._imageSrc) return [3, 2];
              return [4, asyncLoadImage(this._imageSrc)];
            case 1:
              image2 = _a2.sent();
              this.setSourceImage(image2, this._pixelRatio);
              _a2.label = 2;
            case 2:
              return [2
              /*return*/];
          }
        });
      });
    };
    return Atlas2;
  })(ImageTexture);
  function asyncLoadImage(src) {
    console.debug && console.debug("Loading image: " + src);
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.onload = function () {
        console.debug && console.debug("Image loaded: " + src);
        resolve(img);
      };
      img.onerror = function (error) {
        console.error("Loading failed: " + src);
        reject(error);
      };
      img.src = src;
    });
  }
  function deprecatedWarning(def) {
    if ("filter" in def) console.warn("'filter' field of atlas definition is deprecated");
    if ("cutouts" in def) console.warn("'cutouts' field of atlas definition is deprecated");
    if ("sprites" in def) console.warn("'sprites' field of atlas definition is deprecated");
    if ("factory" in def) console.warn("'factory' field of atlas definition is deprecated");
    if ("ratio" in def) console.warn("'ratio' field of atlas definition is deprecated");
    if ("imagePath" in def) console.warn("'imagePath' field of atlas definition is deprecated");
    if ("imageRatio" in def) console.warn("'imageRatio' field of atlas definition is deprecated");
    if (_typeof(def.image) === "object" && "url" in def.image) console.warn("'image.url' field of atlas definition is deprecated");
  }
  function isAtlasSpriteDefinition(selection) {
    return _typeof(selection) === "object" && isHash(selection) && "number" === typeof selection.width && "number" === typeof selection.height;
  }
  var TextureSelection = /** @class */
  function () {
    function TextureSelection2(selection, atlas2) {
      this.selection = selection;
      this.atlas = atlas2;
    }
    TextureSelection2.prototype.resolve = function (selection, subquery) {
      if (!selection) {
        return NO_TEXTURE;
      } else if (Array.isArray(selection)) {
        return this.resolve(selection[0]);
      } else if (selection instanceof Texture) {
        return selection;
      } else if (isAtlasSpriteDefinition(selection)) {
        if (!this.atlas) {
          return NO_TEXTURE;
        }
        return this.atlas.pipeSpriteTexture(selection);
      } else if (_typeof(selection) === "object" && isHash(selection) && typeof subquery !== "undefined") {
        return this.resolve(selection[subquery]);
      } else if (typeof selection === "function" && isFn(selection)) {
        return this.resolve(selection(subquery));
      } else if (typeof selection === "string") {
        if (!this.atlas) {
          return NO_TEXTURE;
        }
        return this.resolve(this.atlas.findSpriteDefinition(selection));
      }
    };
    TextureSelection2.prototype.one = function (subquery) {
      return this.resolve(this.selection, subquery);
    };
    TextureSelection2.prototype.array = function (arr) {
      var array = Array.isArray(arr) ? arr : [];
      if (Array.isArray(this.selection)) {
        for (var i = 0; i < this.selection.length; i++) {
          array[i] = this.resolve(this.selection[i]);
        }
      } else {
        array[0] = this.resolve(this.selection);
      }
      return array;
    };
    return TextureSelection2;
  }();
  var NO_TEXTURE = new (/** @class */
  function (_super) {
    __extends(class_1, _super);
    function class_1() {
      var _this = _super.call(this) || this;
      _this.setSourceDimension(0, 0);
      return _this;
    }
    class_1.prototype.getWidth = function () {
      return 0;
    };
    class_1.prototype.getHeight = function () {
      return 0;
    };
    class_1.prototype.prerender = function (context) {
      return false;
    };
    class_1.prototype.drawWithNormalizedArgs = function (context, sx, sy, sw, sh, dx, dy, dw, dh) {};
    class_1.prototype.setSourceCoordinate = function (x2, y) {};
    class_1.prototype.setSourceDimension = function (w, h) {};
    class_1.prototype.setDestinationCoordinate = function (x2, y) {};
    class_1.prototype.setDestinationDimension = function (w, h) {};
    class_1.prototype.draw = function () {};
    return class_1;
  }(Texture))();
  var NO_SELECTION = new TextureSelection(NO_TEXTURE);
  var ATLAS_MEMO_BY_NAME = {};
  var ATLAS_ARRAY = [];
  function texture(query) {
    if ("string" !== typeof query) {
      return new TextureSelection(query);
    }
    var result = null;
    var colonIndex = query.indexOf(":");
    if (colonIndex > 0 && query.length > colonIndex + 1) {
      var atlas_1 = ATLAS_MEMO_BY_NAME[query.slice(0, colonIndex)];
      result = atlas_1 && atlas_1.select(query.slice(colonIndex + 1));
    }
    if (!result) {
      var atlas_2 = ATLAS_MEMO_BY_NAME[query];
      result = atlas_2 && atlas_2.select();
    }
    if (!result) {
      for (var i = 0; i < ATLAS_ARRAY.length; i++) {
        result = ATLAS_ARRAY[i].select(query);
        if (result) {
          break;
        }
      }
    }
    if (!result) {
      console.error("Texture not found: " + query);
      result = NO_SELECTION;
    }
    return result;
  }
  var ResizableTexture = /** @class */
  function (_super) {
    __extends(ResizableTexture2, _super);
    function ResizableTexture2(source, mode) {
      var _this = _super.call(this) || this;
      _this._source = source;
      _this._resizeMode = mode;
      return _this;
    }
    ResizableTexture2.prototype.getWidth = function () {
      var _a2;
      return (_a2 = this.dw) !== null && _a2 !== void 0 ? _a2 : this._source.getWidth();
    };
    ResizableTexture2.prototype.getHeight = function () {
      var _a2;
      return (_a2 = this.dh) !== null && _a2 !== void 0 ? _a2 : this._source.getHeight();
    };
    ResizableTexture2.prototype.prerender = function (context) {
      return false;
    };
    ResizableTexture2.prototype.drawWithNormalizedArgs = function (context, sx, sy, sw, sh, dx, dy, dw, dh) {
      var texture2 = this._source;
      if (texture2 === null || _typeof(texture2) !== "object") {
        return;
      }
      var outWidth = dw;
      var outHeight = dh;
      var left = Number.isFinite(texture2.left) ? texture2.left : 0;
      var right = Number.isFinite(texture2.right) ? texture2.right : 0;
      var top = Number.isFinite(texture2.top) ? texture2.top : 0;
      var bottom = Number.isFinite(texture2.bottom) ? texture2.bottom : 0;
      var width = texture2.getWidth() - left - right;
      var height = texture2.getHeight() - top - bottom;
      if (!this._innerSize) {
        outWidth = Math.max(outWidth - left - right, 0);
        outHeight = Math.max(outHeight - top - bottom, 0);
      }
      if (top > 0 && left > 0) {
        texture2.draw(context, 0, 0, left, top, 0, 0, left, top);
      }
      if (bottom > 0 && left > 0) {
        texture2.draw(context, 0, height + top, left, bottom, 0, outHeight + top, left, bottom);
      }
      if (top > 0 && right > 0) {
        texture2.draw(context, width + left, 0, right, top, outWidth + left, 0, right, top);
      }
      if (bottom > 0 && right > 0) {
        texture2.draw(context, width + left, height + top, right, bottom, outWidth + left, outHeight + top, right, bottom);
      }
      if (this._resizeMode === "stretch") {
        if (top > 0) {
          texture2.draw(context, left, 0, width, top, left, 0, outWidth, top);
        }
        if (bottom > 0) {
          texture2.draw(context, left, height + top, width, bottom, left, outHeight + top, outWidth, bottom);
        }
        if (left > 0) {
          texture2.draw(context, 0, top, left, height, 0, top, left, outHeight);
        }
        if (right > 0) {
          texture2.draw(context, width + left, top, right, height, outWidth + left, top, right, outHeight);
        }
        texture2.draw(context, left, top, width, height, left, top, outWidth, outHeight);
      } else if (this._resizeMode === "tile") {
        var l = left;
        var r = outWidth;
        var w = void 0;
        while (r > 0) {
          w = Math.min(width, r);
          r -= width;
          var t = top;
          var b2 = outHeight;
          var h = void 0;
          while (b2 > 0) {
            h = Math.min(height, b2);
            b2 -= height;
            texture2.draw(context, left, top, w, h, l, t, w, h);
            if (r <= 0) {
              if (left) {
                texture2.draw(context, 0, top, left, h, 0, t, left, h);
              }
              if (right) {
                texture2.draw(context, width + left, top, right, h, l + w, t, right, h);
              }
            }
            t += h;
          }
          if (top) {
            texture2.draw(context, left, 0, w, top, l, 0, w, top);
          }
          if (bottom) {
            texture2.draw(context, left, height + top, w, bottom, l, t, w, bottom);
          }
          l += w;
        }
      }
    };
    return ResizableTexture2;
  }(Texture);
  function getDevicePixelRatio() {
    return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
  }
  function isValidFitMode(value) {
    return value && (value === "cover" || value === "contain" || value === "fill" || value === "in" || value === "in-pad" || value === "out" || value === "out-crop");
  }
  var iid$1 = 0;
  var Pin = /** @class */
  function () {
    function Pin2(owner) {
      this.uid = "pin:" + uid();
      this._directionX = 1;
      this._directionY = 1;
      this._owner = owner;
      this._parent = null;
      this._relativeMatrix = new Matrix();
      this._absoluteMatrix = new Matrix();
      this.reset();
    }
    Pin2.prototype.reset = function () {
      this._textureAlpha = 1;
      this._alpha = 1;
      this._width = 0;
      this._height = 0;
      this._scaleX = 1;
      this._scaleY = 1;
      this._skewX = 0;
      this._skewY = 0;
      this._rotation = 0;
      this._pivoted = false;
      this._pivotX = 0;
      this._pivotY = 0;
      this._handled = false;
      this._handleX = 0;
      this._handleY = 0;
      this._aligned = false;
      this._alignX = 0;
      this._alignY = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._boxX = 0;
      this._boxY = 0;
      this._boxWidth = this._width;
      this._boxHeight = this._height;
      this._ts_translate = ++iid$1;
      this._ts_transform = ++iid$1;
      this._ts_matrix = ++iid$1;
    };
    Pin2.prototype._update = function () {
      this._parent = this._owner._parent && this._owner._parent._pin;
      if (this._handled && this._mo_handle != this._ts_transform) {
        this._mo_handle = this._ts_transform;
        this._ts_translate = ++iid$1;
      }
      if (this._aligned && this._parent && this._mo_align != this._parent._ts_transform) {
        this._mo_align = this._parent._ts_transform;
        this._ts_translate = ++iid$1;
      }
      return this;
    };
    Pin2.prototype.toString = function () {
      return this._owner + " (" + (this._parent ? this._parent._owner : null) + ")";
    };
    Pin2.prototype.absoluteMatrix = function () {
      this._update();
      var ts = Math.max(this._ts_transform, this._ts_translate, this._parent ? this._parent._ts_matrix : 0);
      if (this._mo_abs == ts) {
        return this._absoluteMatrix;
      }
      this._mo_abs = ts;
      var abs = this._absoluteMatrix;
      abs.reset(this.relativeMatrix());
      this._parent && abs.concat(this._parent._absoluteMatrix);
      this._ts_matrix = ++iid$1;
      return abs;
    };
    Pin2.prototype.relativeMatrix = function () {
      this._update();
      var ts = Math.max(this._ts_transform, this._ts_translate, this._parent ? this._parent._ts_transform : 0);
      if (this._mo_rel == ts) {
        return this._relativeMatrix;
      }
      this._mo_rel = ts;
      var rel = this._relativeMatrix;
      rel.identity();
      if (this._pivoted) {
        rel.translate(-this._pivotX * this._width, -this._pivotY * this._height);
      }
      rel.scale(this._scaleX * this._directionX, this._scaleY * this._directionY);
      rel.skew(this._skewX, this._skewY);
      rel.rotate(this._rotation);
      if (this._pivoted) {
        rel.translate(this._pivotX * this._width, this._pivotY * this._height);
      }
      if (this._pivoted) {
        this._boxX = 0;
        this._boxY = 0;
        this._boxWidth = this._width;
        this._boxHeight = this._height;
      } else {
        var p = void 0;
        var q = void 0;
        if (rel.a > 0 && rel.c > 0 || rel.a < 0 && rel.c < 0) {
          p = 0;
          q = rel.a * this._width + rel.c * this._height;
        } else {
          p = rel.a * this._width;
          q = rel.c * this._height;
        }
        if (p > q) {
          this._boxX = q;
          this._boxWidth = p - q;
        } else {
          this._boxX = p;
          this._boxWidth = q - p;
        }
        if (rel.b > 0 && rel.d > 0 || rel.b < 0 && rel.d < 0) {
          p = 0;
          q = rel.b * this._width + rel.d * this._height;
        } else {
          p = rel.b * this._width;
          q = rel.d * this._height;
        }
        if (p > q) {
          this._boxY = q;
          this._boxHeight = p - q;
        } else {
          this._boxY = p;
          this._boxHeight = q - p;
        }
      }
      this._x = this._offsetX;
      this._y = this._offsetY;
      this._x -= this._boxX + this._handleX * this._boxWidth * this._directionX;
      this._y -= this._boxY + this._handleY * this._boxHeight * this._directionY;
      if (this._aligned && this._parent) {
        this._parent.relativeMatrix();
        this._x += this._alignX * this._parent._width;
        this._y += this._alignY * this._parent._height;
      }
      rel.translate(this._x, this._y);
      return this._relativeMatrix;
    };
    Pin2.prototype.get = function (key) {
      if (typeof getters[key] === "function") {
        return getters[key](this);
      }
    };
    Pin2.prototype.set = function (a2, b2) {
      if (typeof a2 === "string") {
        if (typeof setters[a2] === "function" && typeof b2 !== "undefined") {
          setters[a2](this, b2);
        }
      } else if (_typeof(a2) === "object") {
        for (b2 in a2) {
          if (typeof setters[b2] === "function" && typeof a2[b2] !== "undefined") {
            setters[b2](this, a2[b2], a2);
          }
        }
      }
      if (this._owner) {
        this._owner._ts_pin = ++iid$1;
        this._owner.touch();
      }
      return this;
    };
    Pin2.prototype.fit = function (width, height, mode) {
      this._ts_transform = ++iid$1;
      if (mode === "contain") {
        mode = "in-pad";
      }
      if (mode === "cover") {
        mode = "out-crop";
      }
      if (typeof width === "number") {
        this._scaleX = width / this._unscaled_width;
        this._width = this._unscaled_width;
      }
      if (typeof height === "number") {
        this._scaleY = height / this._unscaled_height;
        this._height = this._unscaled_height;
      }
      if (typeof width === "number" && typeof height === "number" && typeof mode === "string") {
        if (mode === "fill") ;else if (mode === "out" || mode === "out-crop") {
          this._scaleX = this._scaleY = Math.max(this._scaleX, this._scaleY);
        } else if (mode === "in" || mode === "in-pad") {
          this._scaleX = this._scaleY = Math.min(this._scaleX, this._scaleY);
        }
        if (mode === "out-crop" || mode === "in-pad") {
          this._width = width / this._scaleX;
          this._height = height / this._scaleY;
        }
      }
    };
    return Pin2;
  }();
  var getters = {
    alpha: function alpha(pin) {
      return pin._alpha;
    },
    textureAlpha: function textureAlpha(pin) {
      return pin._textureAlpha;
    },
    width: function width(pin) {
      return pin._width;
    },
    height: function height(pin) {
      return pin._height;
    },
    boxWidth: function boxWidth(pin) {
      return pin._boxWidth;
    },
    boxHeight: function boxHeight(pin) {
      return pin._boxHeight;
    },
    // scale : function(pin: Pin) {
    // },
    scaleX: function scaleX(pin) {
      return pin._scaleX;
    },
    scaleY: function scaleY(pin) {
      return pin._scaleY;
    },
    // skew : function(pin: Pin) {
    // },
    skewX: function skewX(pin) {
      return pin._skewX;
    },
    skewY: function skewY(pin) {
      return pin._skewY;
    },
    rotation: function rotation(pin) {
      return pin._rotation;
    },
    // pivot : function(pin: Pin) {
    // },
    pivotX: function pivotX(pin) {
      return pin._pivotX;
    },
    pivotY: function pivotY(pin) {
      return pin._pivotY;
    },
    // offset : function(pin: Pin) {
    // },
    offsetX: function offsetX(pin) {
      return pin._offsetX;
    },
    offsetY: function offsetY(pin) {
      return pin._offsetY;
    },
    // align : function(pin: Pin) {
    // },
    alignX: function alignX(pin) {
      return pin._alignX;
    },
    alignY: function alignY(pin) {
      return pin._alignY;
    },
    // handle : function(pin: Pin) {
    // },
    handleX: function handleX(pin) {
      return pin._handleX;
    },
    handleY: function handleY(pin) {
      return pin._handleY;
    }
  };
  var setters = {
    alpha: function alpha(pin, value) {
      pin._alpha = value;
    },
    textureAlpha: function textureAlpha(pin, value) {
      pin._textureAlpha = value;
    },
    width: function width(pin, value) {
      pin._unscaled_width = value;
      pin._width = value;
      pin._ts_transform = ++iid$1;
    },
    height: function height(pin, value) {
      pin._unscaled_height = value;
      pin._height = value;
      pin._ts_transform = ++iid$1;
    },
    scale: function scale(pin, value) {
      pin._scaleX = value;
      pin._scaleY = value;
      pin._ts_transform = ++iid$1;
    },
    scaleX: function scaleX(pin, value) {
      pin._scaleX = value;
      pin._ts_transform = ++iid$1;
    },
    scaleY: function scaleY(pin, value) {
      pin._scaleY = value;
      pin._ts_transform = ++iid$1;
    },
    skew: function skew(pin, value) {
      pin._skewX = value;
      pin._skewY = value;
      pin._ts_transform = ++iid$1;
    },
    skewX: function skewX(pin, value) {
      pin._skewX = value;
      pin._ts_transform = ++iid$1;
    },
    skewY: function skewY(pin, value) {
      pin._skewY = value;
      pin._ts_transform = ++iid$1;
    },
    rotation: function rotation(pin, value) {
      pin._rotation = value;
      pin._ts_transform = ++iid$1;
    },
    pivot: function pivot(pin, value) {
      pin._pivotX = value;
      pin._pivotY = value;
      pin._pivoted = true;
      pin._ts_transform = ++iid$1;
    },
    pivotX: function pivotX(pin, value) {
      pin._pivotX = value;
      pin._pivoted = true;
      pin._ts_transform = ++iid$1;
    },
    pivotY: function pivotY(pin, value) {
      pin._pivotY = value;
      pin._pivoted = true;
      pin._ts_transform = ++iid$1;
    },
    offset: function offset(pin, value) {
      pin._offsetX = value;
      pin._offsetY = value;
      pin._ts_translate = ++iid$1;
    },
    offsetX: function offsetX(pin, value) {
      pin._offsetX = value;
      pin._ts_translate = ++iid$1;
    },
    offsetY: function offsetY(pin, value) {
      pin._offsetY = value;
      pin._ts_translate = ++iid$1;
    },
    align: function align(pin, value) {
      this.alignX(pin, value);
      this.alignY(pin, value);
    },
    alignX: function alignX(pin, value) {
      pin._alignX = value;
      pin._aligned = true;
      pin._ts_translate = ++iid$1;
      this.handleX(pin, value);
    },
    alignY: function alignY(pin, value) {
      pin._alignY = value;
      pin._aligned = true;
      pin._ts_translate = ++iid$1;
      this.handleY(pin, value);
    },
    handle: function handle(pin, value) {
      this.handleX(pin, value);
      this.handleY(pin, value);
    },
    handleX: function handleX(pin, value) {
      pin._handleX = value;
      pin._handled = true;
      pin._ts_translate = ++iid$1;
    },
    handleY: function handleY(pin, value) {
      pin._handleY = value;
      pin._handled = true;
      pin._ts_translate = ++iid$1;
    },
    resizeMode: function resizeMode(pin, value, all) {
      if (all) {
        if (value == "in") {
          value = "in-pad";
        } else if (value == "out") {
          value = "out-crop";
        }
        pin.fit(all.resizeWidth, all.resizeHeight, value);
      }
    },
    resizeWidth: function resizeWidth(pin, value, all) {
      if (!all || !all.resizeMode) {
        pin.fit(value, null);
      }
    },
    resizeHeight: function resizeHeight(pin, value, all) {
      if (!all || !all.resizeMode) {
        pin.fit(null, value);
      }
    },
    scaleMode: function scaleMode(pin, value, all) {
      if (all) {
        pin.fit(all.scaleWidth, all.scaleHeight, value);
      }
    },
    scaleWidth: function scaleWidth(pin, value, all) {
      if (!all || !all.scaleMode) {
        pin.fit(value, null);
      }
    },
    scaleHeight: function scaleHeight(pin, value, all) {
      if (!all || !all.scaleMode) {
        pin.fit(null, value);
      }
    },
    matrix: function matrix(pin, value) {
      this.scaleX(pin, value.a);
      this.skewX(pin, value.c / value.d);
      this.skewY(pin, value.b / value.a);
      this.scaleY(pin, value.d);
      this.offsetX(pin, value.e);
      this.offsetY(pin, value.f);
      this.rotation(pin, 0);
    }
  };
  function IDENTITY(x2) {
    return x2;
  }
  var LOOKUP_CACHE = {};
  var MODE_BY_NAME = {};
  var EASE_BY_NAME = {};
  var Easing = /** @class */
  function () {
    function Easing2() {}
    Easing2.get = function (token, fallback) {
      fallback = fallback || IDENTITY;
      if (typeof token === "function") {
        return token;
      }
      if (typeof token !== "string") {
        return fallback;
      }
      var easeFn = LOOKUP_CACHE[token];
      if (easeFn) {
        return easeFn;
      }
      var tokens = /^(\w+)(-(in|out|in-out|out-in))?(\((.*)\))?$/i.exec(token);
      if (!tokens || !tokens.length) {
        return fallback;
      }
      var easeName = tokens[1];
      var easing = EASE_BY_NAME[easeName];
      var modeName = tokens[3];
      var modeFn = MODE_BY_NAME[modeName];
      var params = tokens[5];
      if (!easing) {
        easeFn = fallback;
      } else if ("fn" in easing && typeof easing.fn === "function") {
        easeFn = easing.fn;
      } else if ("fc" in easing && typeof easing.fc === "function") {
        var args = params ? params.replace(/\s+/, "").split(",") : void 0;
        easeFn = easing.fc.apply(easing.fc, args);
      } else {
        easeFn = fallback;
      }
      if (modeFn) {
        easeFn = modeFn(easeFn);
      }
      LOOKUP_CACHE[token] = easeFn;
      return easeFn;
    };
    return Easing2;
  }();
  function addMode(name, fn) {
    MODE_BY_NAME[name] = fn;
  }
  function addEaseFn(data) {
    var names = data.name.split(/\s+/);
    for (var i = 0; i < names.length; i++) {
      var key = names[i];
      if (key) {
        EASE_BY_NAME[key] = data;
      }
    }
  }
  addMode("in", function (f) {
    return f;
  });
  addMode("out", function (f) {
    return function (t) {
      return 1 - f(1 - t);
    };
  });
  addMode("in-out", function (f) {
    return function (t) {
      return t < 0.5 ? f(2 * t) / 2 : 1 - f(2 * (1 - t)) / 2;
    };
  });
  addMode("out-in", function (f) {
    return function (t) {
      return t < 0.5 ? 1 - f(2 * (1 - t)) / 2 : f(2 * t) / 2;
    };
  });
  addEaseFn({
    name: "linear",
    fn: function fn(t) {
      return t;
    }
  });
  addEaseFn({
    name: "quad",
    fn: function fn(t) {
      return t * t;
    }
  });
  addEaseFn({
    name: "cubic",
    fn: function fn(t) {
      return t * t * t;
    }
  });
  addEaseFn({
    name: "quart",
    fn: function fn(t) {
      return t * t * t * t;
    }
  });
  addEaseFn({
    name: "quint",
    fn: function fn(t) {
      return t * t * t * t * t;
    }
  });
  addEaseFn({
    name: "sin sine",
    fn: function fn(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    }
  });
  addEaseFn({
    name: "exp expo",
    fn: function fn(t) {
      return t == 0 ? 0 : Math.pow(2, 10 * (t - 1));
    }
  });
  addEaseFn({
    name: "circle circ",
    fn: function fn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }
  });
  addEaseFn({
    name: "bounce",
    fn: function fn(t) {
      return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
  });
  addEaseFn({
    name: "poly",
    fc: function fc(e3) {
      return function (t) {
        return Math.pow(t, e3);
      };
    }
  });
  addEaseFn({
    name: "elastic",
    fc: function fc(a2, p) {
      p = p || 0.45;
      a2 = a2 || 1;
      var s2 = p / (2 * Math.PI) * Math.asin(1 / a2);
      return function (t) {
        return 1 + a2 * Math.pow(2, -10 * t) * Math.sin((t - s2) * (2 * Math.PI) / p);
      };
    }
  });
  addEaseFn({
    name: "back",
    fc: function fc(s2) {
      s2 = typeof s2 !== "undefined" ? s2 : 1.70158;
      return function (t) {
        return t * t * ((s2 + 1) * t - s2);
      };
    }
  });
  var Transition = /** @class */
  function () {
    function Transition2(owner, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.uid = "transition:" + uid();
      this._ending = [];
      this._end = {};
      this._duration = options2.duration || 400;
      this._delay = options2.delay || 0;
      this._owner = owner;
      this._time = 0;
    }
    Transition2.prototype.tick = function (node, elapsed, now2, last) {
      this._time += elapsed;
      if (this._time < this._delay) {
        return;
      }
      var time = this._time - this._delay;
      if (!this._start) {
        this._start = {};
        for (var key in this._end) {
          this._start[key] = this._owner.pin(key);
        }
      }
      var p = Math.min(time / this._duration, 1);
      var ended = p >= 1;
      if (typeof this._easing == "function") {
        p = this._easing(p);
      }
      var q = 1 - p;
      for (var key in this._end) {
        this._owner.pin(key, this._start[key] * q + this._end[key] * p);
      }
      return ended;
    };
    Transition2.prototype.finish = function () {
      var _this = this;
      this._ending.forEach(function (callback) {
        try {
          callback.call(_this._owner);
        } catch (e3) {
          console.error(e3);
        }
      });
      return this._next;
    };
    Transition2.prototype.tween = function (a2, b2) {
      var options2;
      if (_typeof(a2) === "object" && a2 !== null) {
        options2 = a2;
      } else {
        options2 = {};
        if (typeof a2 === "number") {
          options2.duration = a2;
          if (typeof b2 === "number") {
            options2.delay = b2;
          }
        }
      }
      return this._next = new Transition2(this._owner, options2);
    };
    Transition2.prototype.duration = function (duration) {
      this._duration = duration;
      return this;
    };
    Transition2.prototype.delay = function (delay) {
      this._delay = delay;
      return this;
    };
    Transition2.prototype.ease = function (easing) {
      this._easing = Easing.get(easing);
      return this;
    };
    Transition2.prototype.done = function (fn) {
      this._ending.push(fn);
      return this;
    };
    Transition2.prototype.hide = function () {
      this._ending.push(function () {
        this.hide();
      });
      this._hide = true;
      return this;
    };
    Transition2.prototype.remove = function () {
      this._ending.push(function () {
        this.remove();
      });
      this._remove = true;
      return this;
    };
    Transition2.prototype.pin = function (a2, b2) {
      if (_typeof(a2) === "object") {
        for (var attr in a2) {
          pinning(this._owner, this._end, attr, a2[attr]);
        }
      } else if (typeof b2 !== "undefined") {
        pinning(this._owner, this._end, a2, b2);
      }
      return this;
    };
    Transition2.prototype.then = function (fn) {
      this.done(fn);
      return this;
    };
    Transition2.prototype.clear = function (forward) {
      return this;
    };
    Transition2.prototype.size = function (w, h) {
      this.pin("width", w);
      this.pin("height", h);
      return this;
    };
    Transition2.prototype.width = function (w) {
      if (typeof w === "undefined") {
        return this.pin("width");
      }
      this.pin("width", w);
      return this;
    };
    Transition2.prototype.height = function (h) {
      if (typeof h === "undefined") {
        return this.pin("height");
      }
      this.pin("height", h);
      return this;
    };
    Transition2.prototype.offset = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      }
      this.pin("offsetX", a2);
      this.pin("offsetY", b2);
      return this;
    };
    Transition2.prototype.rotate = function (a2) {
      this.pin("rotation", a2);
      return this;
    };
    Transition2.prototype.skew = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      } else if (typeof b2 === "undefined") {
        b2 = a2;
      }
      this.pin("skewX", a2);
      this.pin("skewY", b2);
      return this;
    };
    Transition2.prototype.scale = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      } else if (typeof b2 === "undefined") {
        b2 = a2;
      }
      this.pin("scaleX", a2);
      this.pin("scaleY", b2);
      return this;
    };
    Transition2.prototype.alpha = function (a2, ta) {
      this.pin("alpha", a2);
      if (typeof ta !== "undefined") {
        this.pin("textureAlpha", ta);
      }
      return this;
    };
    return Transition2;
  }();
  function pinning(node, map, key, value) {
    if (typeof node.pin(key) === "number") {
      map[key] = value;
    } else if (typeof node.pin(key + "X") === "number" && typeof node.pin(key + "Y") === "number") {
      map[key + "X"] = value;
      map[key + "Y"] = value;
    }
  }
  var iid = 0;
  stats.create = 0;
  function assertType(obj) {
    if (obj && obj instanceof Node) {
      return obj;
    }
    throw "Invalid node: " + obj;
  }
  var Node = /** @class */
  function () {
    function Node2() {
      var _this = this;
      this.uid = "node:" + uid();
      this._label = "";
      this._parent = null;
      this._next = null;
      this._prev = null;
      this._first = null;
      this._last = null;
      this._visible = true;
      this._alpha = 1;
      this._padding = 0;
      this._spacing = 0;
      this._pin = new Pin(this);
      this._listeners = {};
      this._attrs = {};
      this._flags = {};
      this._transitions = [];
      this._tickBefore = [];
      this._tickAfter = [];
      this.MAX_ELAPSE = Infinity;
      this.renderedBefore = false;
      this._transitionTickInitied = false;
      this._transitionTickLastTime = 0;
      this._transitionTick = function (elapsed, now2, last) {
        if (!_this._transitions.length) {
          return false;
        }
        var ignore = _this._transitionTickLastTime !== last;
        _this._transitionTickLastTime = now2;
        if (ignore) {
          return true;
        }
        var head = _this._transitions[0];
        var ended = head.tick(_this, elapsed, now2, last);
        if (ended) {
          if (head === _this._transitions[0]) {
            _this._transitions.shift();
          }
          var next = head.finish();
          if (next) {
            _this._transitions.unshift(next);
          }
        }
        return true;
      };
      stats.create++;
      if (this instanceof Node2) {
        this.label(this.constructor.name);
      }
    }
    Node2.prototype.matrix = function (relative) {
      if (relative === void 0) {
        relative = false;
      }
      if (relative === true) {
        return this._pin.relativeMatrix();
      }
      return this._pin.absoluteMatrix();
    };
    Node2.prototype.getPixelRatio = function () {
      var _a2;
      var m = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2.matrix();
      var pixelRatio = !m ? 1 : Math.max(Math.abs(m.a), Math.abs(m.b)) / getDevicePixelRatio();
      return pixelRatio;
    };
    Node2.prototype.getDevicePixelRatio = function () {
      var _a2;
      var parentMatrix = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2.matrix();
      var pixelRatio = !parentMatrix ? 1 : Math.max(Math.abs(parentMatrix.a), Math.abs(parentMatrix.b));
      return pixelRatio;
    };
    Node2.prototype.getLogicalPixelRatio = function () {
      return this.getDevicePixelRatio() / getDevicePixelRatio();
    };
    Node2.prototype.pin = function (a2, b2) {
      if (_typeof(a2) === "object") {
        this._pin.set(a2);
        return this;
      } else if (typeof a2 === "string") {
        if (typeof b2 === "undefined") {
          return this._pin.get(a2);
        } else {
          this._pin.set(a2, b2);
          return this;
        }
      } else if (typeof a2 === "undefined") {
        return this._pin;
      }
    };
    Node2.prototype.fit = function (a2, b2, c2) {
      if (_typeof(a2) === "object") {
        c2 = b2;
        b2 = a2.y;
        a2 = a2.x;
      }
      this._pin.fit(a2, b2, c2);
      return this;
    };
    Node2.prototype.scaleTo = function (a2, b2, c2) {
      return this.fit(a2, b2, c2);
    };
    Node2.prototype.toString = function () {
      return "[" + this._label + "]";
    };
    Node2.prototype.id = function (label) {
      if (typeof label === "undefined") {
        return this._label;
      }
      this._label = label;
      return this;
    };
    Node2.prototype.label = function (label) {
      if (typeof label === "undefined") {
        return this._label;
      }
      this._label = label;
      return this;
    };
    Node2.prototype.attr = function (name, value) {
      if (typeof value === "undefined") {
        return this._attrs !== null ? this._attrs[name] : void 0;
      }
      (this._attrs !== null ? this._attrs : this._attrs = {})[name] = value;
      return this;
    };
    Node2.prototype.visible = function (visible) {
      if (typeof visible === "undefined") {
        return this._visible;
      }
      this._visible = visible;
      this._parent && (this._parent._ts_children = ++iid);
      this._ts_pin = ++iid;
      this.touch();
      return this;
    };
    Node2.prototype.hide = function () {
      this.visible(false);
      return this;
    };
    Node2.prototype.show = function () {
      this.visible(true);
      return this;
    };
    Node2.prototype.parent = function () {
      return this._parent;
    };
    Node2.prototype.next = function (visible) {
      var next = this._next;
      while (next && visible && !next._visible) {
        next = next._next;
      }
      return next;
    };
    Node2.prototype.prev = function (visible) {
      var prev = this._prev;
      while (prev && visible && !prev._visible) {
        prev = prev._prev;
      }
      return prev;
    };
    Node2.prototype.first = function (visible) {
      var next = this._first;
      while (next && visible && !next._visible) {
        next = next._next;
      }
      return next;
    };
    Node2.prototype.last = function (visible) {
      var prev = this._last;
      while (prev && visible && !prev._visible) {
        prev = prev._prev;
      }
      return prev;
    };
    Node2.prototype.visit = function (visitor, payload) {
      var reverse = visitor.reverse;
      var visible = visitor.visible;
      if (visitor.start && visitor.start(this, payload)) {
        return;
      }
      var child;
      var next = reverse ? this.last(visible) : this.first(visible);
      while (child = next) {
        next = reverse ? child.prev(visible) : child.next(visible);
        if (child.visit(visitor, payload)) {
          return true;
        }
      }
      return visitor.end && visitor.end(this, payload);
    };
    Node2.prototype.append = function (child, more) {
      if (Array.isArray(child)) {
        for (var i = 0; i < child.length; i++) {
          Node2.append(this, child[i]);
        }
      } else if (typeof more !== "undefined") {
        for (var i = 0; i < arguments.length; i++) {
          Node2.append(this, arguments[i]);
        }
      } else if (typeof child !== "undefined") Node2.append(this, child);
      return this;
    };
    Node2.prototype.prepend = function (child, more) {
      if (Array.isArray(child)) {
        for (var i = child.length - 1; i >= 0; i--) {
          Node2.prepend(this, child[i]);
        }
      } else if (typeof more !== "undefined") {
        for (var i = arguments.length - 1; i >= 0; i--) {
          Node2.prepend(this, arguments[i]);
        }
      } else if (typeof child !== "undefined") Node2.prepend(this, child);
      return this;
    };
    Node2.prototype.appendTo = function (parent) {
      Node2.append(parent, this);
      return this;
    };
    Node2.prototype.prependTo = function (parent) {
      Node2.prepend(parent, this);
      return this;
    };
    Node2.prototype.insertNext = function (sibling, more) {
      if (Array.isArray(sibling)) {
        for (var i = 0; i < sibling.length; i++) {
          Node2.insertAfter(sibling[i], this);
        }
      } else if (typeof more !== "undefined") {
        for (var i = 0; i < arguments.length; i++) {
          Node2.insertAfter(arguments[i], this);
        }
      } else if (typeof sibling !== "undefined") {
        Node2.insertAfter(sibling, this);
      }
      return this;
    };
    Node2.prototype.insertPrev = function (sibling, more) {
      if (Array.isArray(sibling)) {
        for (var i = sibling.length - 1; i >= 0; i--) {
          Node2.insertBefore(sibling[i], this);
        }
      } else if (typeof more !== "undefined") {
        for (var i = arguments.length - 1; i >= 0; i--) {
          Node2.insertBefore(arguments[i], this);
        }
      } else if (typeof sibling !== "undefined") {
        Node2.insertBefore(sibling, this);
      }
      return this;
    };
    Node2.prototype.insertAfter = function (prev) {
      Node2.insertAfter(this, prev);
      return this;
    };
    Node2.prototype.insertBefore = function (next) {
      Node2.insertBefore(this, next);
      return this;
    };
    Node2.append = function (parent, child) {
      assertType(child);
      assertType(parent);
      child.remove();
      if (parent._last) {
        parent._last._next = child;
        child._prev = parent._last;
      }
      child._parent = parent;
      parent._last = child;
      if (!parent._first) {
        parent._first = child;
      }
      child._parent._flag(child, true);
      child._ts_parent = ++iid;
      parent._ts_children = ++iid;
      parent.touch();
    };
    Node2.prepend = function (parent, child) {
      assertType(child);
      assertType(parent);
      child.remove();
      if (parent._first) {
        parent._first._prev = child;
        child._next = parent._first;
      }
      child._parent = parent;
      parent._first = child;
      if (!parent._last) {
        parent._last = child;
      }
      child._parent._flag(child, true);
      child._ts_parent = ++iid;
      parent._ts_children = ++iid;
      parent.touch();
    };
    Node2.insertBefore = function (self2, next) {
      assertType(self2);
      assertType(next);
      self2.remove();
      var parent = next._parent;
      var prev = next._prev;
      if (!parent) {
        return;
      }
      next._prev = self2;
      prev && (prev._next = self2) || parent && (parent._first = self2);
      self2._parent = parent;
      self2._prev = prev;
      self2._next = next;
      self2._parent._flag(self2, true);
      self2._ts_parent = ++iid;
      self2.touch();
    };
    Node2.insertAfter = function (self2, prev) {
      assertType(self2);
      assertType(prev);
      self2.remove();
      var parent = prev._parent;
      var next = prev._next;
      if (!parent) {
        return;
      }
      prev._next = self2;
      next && (next._prev = self2) || parent && (parent._last = self2);
      self2._parent = parent;
      self2._prev = prev;
      self2._next = next;
      self2._parent._flag(self2, true);
      self2._ts_parent = ++iid;
      self2.touch();
    };
    Node2.prototype.remove = function (child, more) {
      if (typeof child !== "undefined") {
        if (Array.isArray(child)) {
          for (var i = 0; i < child.length; i++) {
            assertType(child[i]).remove();
          }
        } else if (typeof more !== "undefined") {
          for (var i = 0; i < arguments.length; i++) {
            assertType(arguments[i]).remove();
          }
        } else {
          assertType(child).remove();
        }
        return this;
      }
      if (this._prev) {
        this._prev._next = this._next;
      }
      if (this._next) {
        this._next._prev = this._prev;
      }
      if (this._parent) {
        if (this._parent._first === this) {
          this._parent._first = this._next;
        }
        if (this._parent._last === this) {
          this._parent._last = this._prev;
        }
        this._parent._flag(this, false);
        this._parent._ts_children = ++iid;
        this._parent.touch();
      }
      this._prev = this._next = this._parent = null;
      this._ts_parent = ++iid;
      return this;
    };
    Node2.prototype.empty = function () {
      var child = null;
      var next = this._first;
      while (child = next) {
        next = child._next;
        child._prev = child._next = child._parent = null;
        this._flag(child, false);
      }
      this._first = this._last = null;
      this._ts_children = ++iid;
      this.touch();
      return this;
    };
    Node2.prototype.touch = function () {
      this._ts_touch = ++iid;
      this._parent && this._parent.touch();
      return this;
    };
    Node2.prototype._flag = function (key, value) {
      if (typeof value === "undefined") {
        return this._flags !== null && this._flags[key] || 0;
      }
      if (typeof key === "string") {
        if (value) {
          this._flags = this._flags || {};
          if (!this._flags[key] && this._parent) {
            this._parent._flag(key, true);
          }
          this._flags[key] = (this._flags[key] || 0) + 1;
        } else if (this._flags && this._flags[key] > 0) {
          if (this._flags[key] == 1 && this._parent) {
            this._parent._flag(key, false);
          }
          this._flags[key] = this._flags[key] - 1;
        }
      }
      if (_typeof(key) === "object") {
        if (key._flags) {
          for (var type in key._flags) {
            if (key._flags[type] > 0) {
              this._flag(type, value);
            }
          }
        }
      }
      return this;
    };
    Node2.prototype.hitTest = function (hit) {
      var width = this._pin._width;
      var height = this._pin._height;
      return hit.x >= 0 && hit.x <= width && hit.y >= 0 && hit.y <= height;
    };
    Node2.prototype.prerender = function () {
      if (!this._visible) {
        return;
      }
      this.prerenderTexture();
      var child;
      var next = this._first;
      while (child = next) {
        next = child._next;
        child.prerender();
      }
    };
    Node2.prototype.prerenderTexture = function () {};
    Node2.prototype.render = function (context) {
      if (!this._visible) {
        return;
      }
      stats.node++;
      var m = this.matrix();
      context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
      this._alpha = this._pin._alpha * (this._parent ? this._parent._alpha : 1);
      var alpha = this._pin._textureAlpha * this._alpha;
      if (context.globalAlpha != alpha) {
        context.globalAlpha = alpha;
      }
      if (!this.renderedBefore) {
        this.prerenderTexture();
      }
      this.renderedBefore = true;
      this.renderTexture(context);
      if (context.globalAlpha != this._alpha) {
        context.globalAlpha = this._alpha;
      }
      var child;
      var next = this._first;
      while (child = next) {
        next = child._next;
        child.render(context);
      }
    };
    Node2.prototype.renderTexture = function (context) {};
    Node2.prototype._tick = function (elapsed, now2, last) {
      if (!this._visible) {
        return;
      }
      if (elapsed > this.MAX_ELAPSE) {
        elapsed = this.MAX_ELAPSE;
      }
      var ticked = false;
      if (this._tickBefore !== null) {
        for (var i = 0; i < this._tickBefore.length; i++) {
          stats.tick++;
          var tickFn = this._tickBefore[i];
          ticked = tickFn.call(this, elapsed, now2, last) === true || ticked;
        }
      }
      var child;
      var next = this._first;
      while (child = next) {
        next = child._next;
        if (child._flag("_tick")) {
          ticked = child._tick(elapsed, now2, last) === true ? true : ticked;
        }
      }
      if (this._tickAfter !== null) {
        for (var i = 0; i < this._tickAfter.length; i++) {
          stats.tick++;
          var tickFn = this._tickAfter[i];
          ticked = tickFn.call(this, elapsed, now2, last) === true || ticked;
        }
      }
      return ticked;
    };
    Node2.prototype.tick = function (callback, before) {
      var _a2, _b;
      if (before === void 0) {
        before = false;
      }
      if (typeof callback !== "function") {
        return;
      }
      if (before) {
        if (this._tickBefore === null) {
          this._tickBefore = [];
        }
        this._tickBefore.push(callback);
      } else {
        if (this._tickAfter === null) {
          this._tickAfter = [];
        }
        this._tickAfter.push(callback);
      }
      var hasTickListener = ((_a2 = this._tickAfter) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 || ((_b = this._tickBefore) === null || _b === void 0 ? void 0 : _b.length) > 0;
      this._flag("_tick", hasTickListener);
    };
    Node2.prototype.untick = function (callback) {
      if (typeof callback !== "function") {
        return;
      }
      var i;
      if (this._tickBefore !== null && (i = this._tickBefore.indexOf(callback)) >= 0) {
        this._tickBefore.splice(i, 1);
      }
      if (this._tickAfter !== null && (i = this._tickAfter.indexOf(callback)) >= 0) {
        this._tickAfter.splice(i, 1);
      }
    };
    Node2.prototype.timeout = function (callback, time) {
      this.setTimeout(callback, time);
    };
    Node2.prototype.setTimeout = function (callback, time) {
      function timer(t) {
        if ((time -= t) < 0) {
          this.untick(timer);
          callback.call(this);
        } else {
          return true;
        }
      }
      this.tick(timer);
      return timer;
    };
    Node2.prototype.clearTimeout = function (timer) {
      this.untick(timer);
    };
    Node2.prototype.on = function (type, listener) {
      if (!type || !type.length || typeof listener !== "function") {
        return this;
      }
      if (typeof type !== "string" && typeof type.join === "function") {
        for (var i = 0; i < type.length; i++) {
          this.on(type[i], listener);
        }
      } else if (typeof type === "string" && type.indexOf(" ") > -1) {
        type = type.match(/\S+/g);
        for (var i = 0; i < type.length; i++) {
          this._on(type[i], listener);
        }
      } else if (typeof type === "string") {
        this._on(type, listener);
      } else ;
      return this;
    };
    Node2.prototype._on = function (type, listener) {
      if (typeof type !== "string" && typeof listener !== "function") {
        return;
      }
      this._listeners[type] = this._listeners[type] || [];
      this._listeners[type].push(listener);
      this._flag(type, true);
    };
    Node2.prototype.off = function (type, listener) {
      if (!type || !type.length || typeof listener !== "function") {
        return this;
      }
      if (typeof type !== "string" && typeof type.join === "function") {
        for (var i = 0; i < type.length; i++) {
          this.off(type[i], listener);
        }
      } else if (typeof type === "string" && type.indexOf(" ") > -1) {
        type = type.match(/\S+/g);
        for (var i = 0; i < type.length; i++) {
          this._off(type[i], listener);
        }
      } else if (typeof type === "string") {
        this._off(type, listener);
      } else ;
      return this;
    };
    Node2.prototype._off = function (type, listener) {
      if (typeof type !== "string" && typeof listener !== "function") {
        return;
      }
      var listeners = this._listeners[type];
      if (!listeners || !listeners.length) {
        return;
      }
      var index = listeners.indexOf(listener);
      if (index >= 0) {
        listeners.splice(index, 1);
        this._flag(type, false);
      }
    };
    Node2.prototype.listeners = function (type) {
      return this._listeners[type];
    };
    Node2.prototype.publish = function (name, args) {
      var listeners = this.listeners(name);
      if (!listeners || !listeners.length) {
        return 0;
      }
      for (var l = 0; l < listeners.length; l++) {
        listeners[l].apply(this, args);
      }
      return listeners.length;
    };
    Node2.prototype.trigger = function (name, args) {
      this.publish(name, args);
      return this;
    };
    Node2.prototype.size = function (w, h) {
      this.pin("width", w);
      this.pin("height", h);
      return this;
    };
    Node2.prototype.width = function (w) {
      if (typeof w === "undefined") {
        return this.pin("width");
      }
      this.pin("width", w);
      return this;
    };
    Node2.prototype.height = function (h) {
      if (typeof h === "undefined") {
        return this.pin("height");
      }
      this.pin("height", h);
      return this;
    };
    Node2.prototype.offset = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      }
      this.pin("offsetX", a2);
      this.pin("offsetY", b2);
      return this;
    };
    Node2.prototype.rotate = function (a2) {
      this.pin("rotation", a2);
      return this;
    };
    Node2.prototype.skew = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      } else if (typeof b2 === "undefined") b2 = a2;
      this.pin("skewX", a2);
      this.pin("skewY", b2);
      return this;
    };
    Node2.prototype.scale = function (a2, b2) {
      if (_typeof(a2) === "object") {
        b2 = a2.y;
        a2 = a2.x;
      } else if (typeof b2 === "undefined") b2 = a2;
      this.pin("scaleX", a2);
      this.pin("scaleY", b2);
      return this;
    };
    Node2.prototype.alpha = function (a2, ta) {
      this.pin("alpha", a2);
      if (typeof ta !== "undefined") {
        this.pin("textureAlpha", ta);
      }
      return this;
    };
    Node2.prototype.tween = function (a2, b2, c2) {
      var options2;
      if (_typeof(a2) === "object" && a2 !== null) {
        options2 = a2;
      } else {
        options2 = {};
        if (typeof a2 === "number") {
          options2.duration = a2;
          if (typeof b2 === "number") {
            options2.delay = b2;
            if (typeof c2 === "boolean") {
              options2.append = c2;
            }
          } else if (typeof b2 === "boolean") {
            options2.append = b2;
          }
        } else if (typeof a2 === "boolean") {
          options2.append = a2;
        }
      }
      if (!this._transitionTickInitied) {
        this.tick(this._transitionTick, true);
        this._transitionTickInitied = true;
      }
      this.touch();
      if (!options2.append) {
        this._transitions.length = 0;
      }
      var transition = new Transition(this, options2);
      this._transitions.push(transition);
      return transition;
    };
    Node2.prototype.row = function (align) {
      this.align("row", align);
      return this;
    };
    Node2.prototype.column = function (align) {
      this.align("column", align);
      return this;
    };
    Node2.prototype.align = function (type, align) {
      var _this = this;
      this._padding = this._padding;
      this._spacing = this._spacing;
      this._layoutTicker && this.untick(this._layoutTicker);
      this.tick(this._layoutTicker = function () {
        if (_this._mo_seq == _this._ts_touch) {
          return;
        }
        _this._mo_seq = _this._ts_touch;
        var alignChildren = _this._mo_seqAlign != _this._ts_children;
        _this._mo_seqAlign = _this._ts_children;
        var width = 0;
        var height = 0;
        var child;
        var next = _this.first(true);
        var first = true;
        while (child = next) {
          next = child.next(true);
          child.matrix(true);
          var w = child.pin("boxWidth");
          var h = child.pin("boxHeight");
          if (type == "column") {
            !first && (height += _this._spacing);
            child.pin("offsetY") != height && child.pin("offsetY", height);
            width = Math.max(width, w);
            height = height + h;
            alignChildren && child.pin("alignX", align);
          } else if (type == "row") {
            !first && (width += _this._spacing);
            child.pin("offsetX") != width && child.pin("offsetX", width);
            width = width + w;
            height = Math.max(height, h);
            alignChildren && child.pin("alignY", align);
          }
          first = false;
        }
        width += 2 * _this._padding;
        height += 2 * _this._padding;
        _this.pin("width") != width && _this.pin("width", width);
        _this.pin("height") != height && _this.pin("height", height);
      });
      return this;
    };
    Node2.prototype.box = function () {
      return this.minimize();
    };
    Node2.prototype.layer = function () {
      return this.maximize();
    };
    Node2.prototype.minimize = function () {
      var _this = this;
      this._padding = this._padding;
      this._layoutTicker && this.untick(this._layoutTicker);
      this.tick(this._layoutTicker = function () {
        if (_this._mo_box == _this._ts_touch) {
          return;
        }
        _this._mo_box = _this._ts_touch;
        var width = 0;
        var height = 0;
        var child;
        var next = _this.first(true);
        while (child = next) {
          next = child.next(true);
          child.matrix(true);
          var w = child.pin("boxWidth");
          var h = child.pin("boxHeight");
          width = Math.max(width, w);
          height = Math.max(height, h);
        }
        width += 2 * _this._padding;
        height += 2 * _this._padding;
        _this.pin("width") != width && _this.pin("width", width);
        _this.pin("height") != height && _this.pin("height", height);
      });
      return this;
    };
    Node2.prototype.maximize = function () {
      var _this = this;
      this._layoutTicker && this.untick(this._layoutTicker);
      this.tick(this._layoutTicker = function () {
        var parent = _this.parent();
        if (parent) {
          var width = parent.pin("width");
          if (_this.pin("width") != width) {
            _this.pin("width", width);
          }
          var height = parent.pin("height");
          if (_this.pin("height") != height) {
            _this.pin("height", height);
          }
        }
      }, true);
      return this;
    };
    Node2.prototype.padding = function (pad) {
      this._padding = pad;
      return this;
    };
    Node2.prototype.spacing = function (space) {
      this._spacing = space;
      return this;
    };
    return Node2;
  }();
  function sprite(frame) {
    var sprite2 = new Sprite();
    frame && sprite2.texture(frame);
    return sprite2;
  }
  var Sprite = /** @class */
  function (_super) {
    __extends(Sprite2, _super);
    function Sprite2() {
      var _this = _super.call(this) || this;
      _this._texture = null;
      _this._image = null;
      _this._tiled = false;
      _this._stretched = false;
      _this.prerenderContext = {};
      _this.label("Sprite");
      return _this;
    }
    Sprite2.prototype.texture = function (frame) {
      this._image = texture(frame).one();
      if (this._image) {
        this.pin("width", this._image.getWidth());
        this.pin("height", this._image.getHeight());
        if (this._tiled) {
          this._texture = new ResizableTexture(this._image, "tile");
        } else if (this._stretched) {
          this._texture = new ResizableTexture(this._image, "stretch");
        } else {
          this._texture = new PipeTexture(this._image);
        }
      } else {
        this.pin("width", 0);
        this.pin("height", 0);
        this._texture = null;
      }
      return this;
    };
    Sprite2.prototype.image = function (frame) {
      return this.texture(frame);
    };
    Sprite2.prototype.tile = function (inner) {
      this._tiled = true;
      var texture2 = new ResizableTexture(this._image, "tile");
      this._texture = texture2;
      return this;
    };
    Sprite2.prototype.stretch = function (inner) {
      this._stretched = true;
      var texture2 = new ResizableTexture(this._image, "stretch");
      this._texture = texture2;
      return this;
    };
    Sprite2.prototype.prerenderTexture = function () {
      if (!this._image) return;
      var pixelRatio = this.getDevicePixelRatio();
      this.prerenderContext.pixelRatio = pixelRatio;
      var updated = this._image.prerender(this.prerenderContext);
      if (updated === true) {
        var w = this._image.getWidth();
        var h = this._image.getHeight();
        this.size(w, h);
      }
    };
    Sprite2.prototype.renderTexture = function (context) {
      if (!this._texture) return;
      if (this._texture["_resizeMode"]) {
        this._texture.dw = this.pin("width");
        this._texture.dh = this.pin("height");
      }
      this._texture.draw(context);
    };
    return Sprite2;
  }(Node);
  var CanvasTexture = /** @class */
  function (_super) {
    __extends(CanvasTexture2, _super);
    function CanvasTexture2() {
      var _this = _super.call(this, document.createElement("canvas")) || this;
      _this._lastPixelRatio = 0;
      return _this;
    }
    CanvasTexture2.prototype.setSize = function (destWidth, destHeight, pixelRatio) {
      if (pixelRatio === void 0) {
        pixelRatio = 1;
      }
      this._source.width = destWidth * pixelRatio;
      this._source.height = destHeight * pixelRatio;
      this._pixelRatio = pixelRatio;
    };
    CanvasTexture2.prototype.getContext = function (type, attributes) {
      if (type === void 0) {
        type = "2d";
      }
      return this._source.getContext(type, attributes);
    };
    CanvasTexture2.prototype.getDevicePixelRatio = function () {
      return this._lastPixelRatio;
    };
    CanvasTexture2.prototype.getOptimalPixelRatio = function () {
      return this.getDevicePixelRatio();
    };
    CanvasTexture2.prototype.setMemoizer = function (memoizer) {
      this._memoizer = memoizer;
    };
    CanvasTexture2.prototype.setDrawer = function (drawer) {
      this._drawer = drawer;
    };
    CanvasTexture2.prototype.prerender = function (context) {
      var newPixelRatio = context.pixelRatio;
      var lastPixelRatio = this._lastPixelRatio;
      var pixelRationChange = lastPixelRatio / newPixelRatio;
      var pixelRatioChanged = lastPixelRatio === 0 || pixelRationChange > 1.25 || pixelRationChange < 0.8;
      if (pixelRatioChanged) {
        this._lastPixelRatio = newPixelRatio;
      }
      var newMemoKey = this._memoizer ? this._memoizer.call(this) : null;
      var memoKeyChanged = this._lastMemoKey !== newMemoKey;
      if (pixelRatioChanged || memoKeyChanged) {
        this._lastMemoKey = newMemoKey;
        this._lastPixelRatio = newPixelRatio;
        if (typeof this._drawer === "function") {
          this._drawer.call(this);
        }
        return true;
      }
    };
    CanvasTexture2.prototype.size = function (width, height, pixelRatio) {
      this.setSize(width, height, pixelRatio);
      return this;
    };
    CanvasTexture2.prototype.context = function (type, attributes) {
      if (type === void 0) {
        type = "2d";
      }
      return this.getContext(type, attributes);
    };
    CanvasTexture2.prototype.canvas = function (legacyTextureDrawer) {
      if (typeof legacyTextureDrawer === "function") {
        legacyTextureDrawer.call(this, this.getContext());
      } else if (typeof legacyTextureDrawer === "undefined") {
        if (typeof this._drawer === "function") {
          this._drawer.call(this);
        }
      }
      return this;
    };
    return CanvasTexture2;
  }(ImageTexture);
  function canvas(type, attributes, legacyTextureDrawer) {
    if (typeof type === "function") {
      var texture_1 = new CanvasTexture();
      legacyTextureDrawer = type;
      texture_1.setDrawer(function () {
        legacyTextureDrawer.call(texture_1, texture_1.getContext());
      });
      return texture_1;
    } else if (typeof attributes === "function") {
      var texture_2 = new CanvasTexture();
      legacyTextureDrawer = attributes;
      texture_2.setDrawer(function () {
        legacyTextureDrawer.call(texture_2, texture_2.getContext(type));
      });
      return texture_2;
    } else if (typeof legacyTextureDrawer === "function") {
      var texture_3 = new CanvasTexture();
      texture_3.setDrawer(function () {
        legacyTextureDrawer.call(texture_3, texture_3.getContext(type, attributes));
      });
      return texture_3;
    } else {
      var texture2 = new CanvasTexture();
      return texture2;
    }
  }
  var POINTER_DOWN = "touchstart mousedown";
  var POINTER_MOVE = "touchmove mousemove";
  var POINTER_UP = "touchend mouseup";
  var POINTER_CANCEL = "touchcancel mousecancel";
  var EventPoint = /** @class */
  function () {
    function EventPoint2() {}
    EventPoint2.prototype.clone = function (obj) {
      if (obj) {
        obj.x = this.x;
        obj.y = this.y;
      } else {
        obj = {
          x: this.x,
          y: this.y
        };
      }
      return obj;
    };
    EventPoint2.prototype.toString = function () {
      return (this.x | 0) + "x" + (this.y | 0);
    };
    return EventPoint2;
  }();
  var PointerSyntheticEvent = /** @class */
  function () {
    function PointerSyntheticEvent2() {
      this.abs = new EventPoint();
    }
    PointerSyntheticEvent2.prototype.clone = function (obj) {
      if (obj) {
        obj.x = this.x;
        obj.y = this.y;
      } else {
        obj = {
          x: this.x,
          y: this.y
        };
      }
      return obj;
    };
    PointerSyntheticEvent2.prototype.toString = function () {
      return this.type + ": " + (this.x | 0) + "x" + (this.y | 0);
    };
    return PointerSyntheticEvent2;
  }();
  var VisitPayload = /** @class */
  function () {
    function VisitPayload2() {
      this.type = "";
      this.x = 0;
      this.y = 0;
      this.timeStamp = -1;
      this.event = null;
      this.root = null;
      this.collected = null;
    }
    VisitPayload2.prototype.toString = function () {
      return this.type + ": " + (this.x | 0) + "x" + (this.y | 0);
    };
    return VisitPayload2;
  }();
  var syntheticEvent = new PointerSyntheticEvent();
  var PAYLOAD = new VisitPayload();
  var Pointer = /** @class */
  function () {
    function Pointer2() {
      var _this = this;
      this.ratio = 1;
      this.clickList = [];
      this.cancelList = [];
      this.handleStart = function (event) {
        Pointer2.DEBUG && console.debug && console.debug("pointer-start", event.type);
        event.preventDefault();
        _this.localPoint(event);
        _this.dispatchEvent(event.type, event);
        _this.findTargets("click", _this.clickList);
        _this.findTargets("mousecancel", _this.cancelList);
      };
      this.handleMove = function (event) {
        event.preventDefault();
        _this.localPoint(event);
        _this.dispatchEvent(event.type, event);
      };
      this.handleEnd = function (event) {
        var _a2;
        event.preventDefault();
        Pointer2.DEBUG && console.debug && console.debug("pointer-end", event.type);
        _this.dispatchEvent(event.type, event);
        if (_this.clickList.length) {
          Pointer2.DEBUG && console.debug && console.debug("pointer-click: ", event.type, (_a2 = _this.clickList) === null || _a2 === void 0 ? void 0 : _a2.length);
          _this.dispatchEvent("click", event, _this.clickList);
        }
        _this.cancelList.length = 0;
      };
      this.handleCancel = function (event) {
        var _a2;
        if (_this.cancelList.length) {
          Pointer2.DEBUG && console.debug && console.debug("pointer-cancel", event.type, (_a2 = _this.clickList) === null || _a2 === void 0 ? void 0 : _a2.length);
          _this.dispatchEvent("mousecancel", event, _this.cancelList);
        }
        _this.clickList.length = 0;
      };
      this.visitStart = function (node, payload) {
        return !node._flag(payload.type);
      };
      this.visitEnd = function (node, payload) {
        syntheticEvent.raw = payload.event;
        syntheticEvent.type = payload.type;
        syntheticEvent.timeStamp = payload.timeStamp;
        syntheticEvent.abs.x = payload.x;
        syntheticEvent.abs.y = payload.y;
        var listeners = node.listeners(payload.type);
        if (!listeners) {
          return;
        }
        node.matrix().inverse().map(payload, syntheticEvent);
        var isEventTarget = node === payload.root || node.attr("spy") || node.hitTest(syntheticEvent);
        if (!isEventTarget) {
          return;
        }
        if (payload.collected) {
          payload.collected.push(node);
        }
        if (payload.event) {
          var stop_1 = false;
          for (var l = 0; l < listeners.length; l++) {
            stop_1 = listeners[l].call(node, syntheticEvent) ? true : stop_1;
          }
          return stop_1;
        }
      };
    }
    Pointer2.prototype.mount = function (stage, elem) {
      var _this = this;
      this.stage = stage;
      this.elem = elem;
      this.ratio = stage.viewport().ratio || 1;
      stage.on("viewport", function (viewport) {
        var _a2;
        _this.ratio = (_a2 = viewport.ratio) !== null && _a2 !== void 0 ? _a2 : _this.ratio;
      });
      elem.addEventListener("touchstart", this.handleStart);
      elem.addEventListener("touchend", this.handleEnd);
      elem.addEventListener("touchmove", this.handleMove);
      elem.addEventListener("touchcancel", this.handleCancel);
      elem.addEventListener("mousedown", this.handleStart);
      elem.addEventListener("mouseup", this.handleEnd);
      elem.addEventListener("mousemove", this.handleMove);
      document.addEventListener("mouseup", this.handleCancel);
      window.addEventListener("blur", this.handleCancel);
      return this;
    };
    Pointer2.prototype.unmount = function () {
      var elem = this.elem;
      elem.removeEventListener("touchstart", this.handleStart);
      elem.removeEventListener("touchend", this.handleEnd);
      elem.removeEventListener("touchmove", this.handleMove);
      elem.removeEventListener("touchcancel", this.handleCancel);
      elem.removeEventListener("mousedown", this.handleStart);
      elem.removeEventListener("mouseup", this.handleEnd);
      elem.removeEventListener("mousemove", this.handleMove);
      document.removeEventListener("mouseup", this.handleCancel);
      window.removeEventListener("blur", this.handleCancel);
      return this;
    };
    Pointer2.prototype.localPoint = function (event) {
      var _a2;
      var elem = this.elem;
      var x2;
      var y;
      if ((_a2 = event.touches) === null || _a2 === void 0 ? void 0 : _a2.length) {
        x2 = event.touches[0].clientX;
        y = event.touches[0].clientY;
      } else {
        x2 = event.clientX;
        y = event.clientY;
      }
      var rect = elem.getBoundingClientRect();
      x2 -= rect.left;
      y -= rect.top;
      x2 -= elem.clientLeft | 0;
      y -= elem.clientTop | 0;
      PAYLOAD.x = x2 * this.ratio;
      PAYLOAD.y = y * this.ratio;
    };
    Pointer2.prototype.findTargets = function (type, result) {
      var payload = PAYLOAD;
      payload.type = type;
      payload.root = this.stage;
      payload.event = null;
      payload.collected = result;
      payload.collected.length = 0;
      this.stage.visit({
        reverse: true,
        visible: true,
        start: this.visitStart,
        end: this.visitEnd
      }, payload);
    };
    Pointer2.prototype.dispatchEvent = function (type, event, targets) {
      var payload = PAYLOAD;
      payload.type = type;
      payload.root = this.stage;
      payload.event = event;
      payload.timeStamp = Date.now();
      payload.collected = null;
      if (type !== "mousemove" && type !== "touchmove") {
        Pointer2.DEBUG && console.debug && console.debug("pointer:dispatchEvent", payload, targets === null || targets === void 0 ? void 0 : targets.length);
      }
      if (targets) {
        while (targets.length) {
          var node = targets.shift();
          if (this.visitEnd(node, payload)) {
            break;
          }
        }
        targets.length = 0;
      } else {
        this.stage.visit({
          reverse: true,
          visible: true,
          start: this.visitStart,
          end: this.visitEnd
        }, payload);
      }
    };
    Pointer2.DEBUG = false;
    return Pointer2;
  }();
  function mount(configs) {
    if (configs === void 0) {
      configs = {};
    }
    var root = new Root();
    root.mount(configs);
    root.pointer = new Pointer().mount(root, root.dom);
    return root;
  }
  var Root = /** @class */
  function (_super) {
    __extends(Root2, _super);
    function Root2() {
      var _this = _super.call(this) || this;
      _this.canvas = null;
      _this.dom = null;
      _this.context = null;
      _this.pixelWidth = -1;
      _this.pixelHeight = -1;
      _this.pixelRatio = 1;
      _this.drawingWidth = 0;
      _this.drawingHeight = 0;
      _this.mounted = false;
      _this.paused = false;
      _this.sleep = false;
      _this.mount = function (configs) {
        if (configs === void 0) {
          configs = {};
        }
        if (typeof configs.canvas === "string") {
          _this.canvas = document.getElementById(configs.canvas);
          if (!_this.canvas) {
            console.error("Canvas element not found: ", configs.canvas);
          }
        } else if (configs.canvas instanceof HTMLCanvasElement) {
          _this.canvas = configs.canvas;
        } else if (configs.canvas) {
          console.error("Unknown value for canvas:", configs.canvas);
        }
        if (!_this.canvas) {
          _this.canvas = document.getElementById("cutjs") || document.getElementById("stage");
        }
        if (!_this.canvas) {
          console.debug && console.debug("Creating canvas element...");
          _this.canvas = document.createElement("canvas");
          Object.assign(_this.canvas.style, {
            position: "absolute",
            display: "block",
            top: "0",
            left: "0",
            bottom: "0",
            right: "0",
            width: "100%",
            height: "100%"
          });
          var body = document.body;
          body.insertBefore(_this.canvas, body.firstChild);
        }
        _this.dom = _this.canvas;
        _this.context = _this.canvas.getContext("2d");
        _this.devicePixelRatio = window.devicePixelRatio || 1;
        _this.backingStoreRatio = _this.context["webkitBackingStorePixelRatio"] || _this.context["mozBackingStorePixelRatio"] || _this.context["msBackingStorePixelRatio"] || _this.context["oBackingStorePixelRatio"] || _this.context["backingStorePixelRatio"] || 1;
        _this.pixelRatio = _this.devicePixelRatio / _this.backingStoreRatio;
        _this.mounted = true;
        _this.requestFrame();
      };
      _this.frameRequested = false;
      _this.requestFrame = function () {
        if (!_this.frameRequested) {
          _this.frameRequested = true;
          requestAnimationFrame(_this.onFrame);
        }
      };
      _this._lastFrameTime = 0;
      _this._mo_touch = null;
      _this.onFrame = function (now2) {
        _this.frameRequested = false;
        if (!_this.mounted || !_this.canvas || !_this.context) {
          return;
        }
        _this.requestFrame();
        var newPixelWidth = _this.canvas.clientWidth;
        var newPixelHeight = _this.canvas.clientHeight;
        if (_this.pixelWidth !== newPixelWidth || _this.pixelHeight !== newPixelHeight) {
          _this.pixelWidth = newPixelWidth;
          _this.pixelHeight = newPixelHeight;
          _this.drawingWidth = newPixelWidth * _this.pixelRatio;
          _this.drawingHeight = newPixelHeight * _this.pixelRatio;
          if (_this.canvas.width !== _this.drawingWidth || _this.canvas.height !== _this.drawingHeight) {
            _this.canvas.width = _this.drawingWidth;
            _this.canvas.height = _this.drawingHeight;
            console.debug && console.debug("Resize: [" + _this.drawingWidth + ", " + _this.drawingHeight + "] = " + _this.pixelRatio + " x [" + _this.pixelWidth + ", " + _this.pixelHeight + "]");
            _this.viewport({
              width: _this.drawingWidth,
              height: _this.drawingHeight,
              ratio: _this.pixelRatio
            });
          }
        }
        var last = _this._lastFrameTime || now2;
        var elapsed = now2 - last;
        if (!_this.mounted || _this.paused || _this.sleep) {
          return;
        }
        _this._lastFrameTime = now2;
        _this.prerender();
        var tickRequest = _this._tick(elapsed, now2, last);
        if (_this._mo_touch != _this._ts_touch) {
          _this._mo_touch = _this._ts_touch;
          _this.sleep = false;
          if (_this.drawingWidth > 0 && _this.drawingHeight > 0) {
            _this.context.setTransform(1, 0, 0, 1, 0, 0);
            _this.context.clearRect(0, 0, _this.drawingWidth, _this.drawingHeight);
            if (_this.debugDrawAxis > 0) {
              _this.renderDebug(_this.context);
            }
            _this.render(_this.context);
          }
        } else if (tickRequest) {
          _this.sleep = false;
        } else {
          _this.sleep = true;
        }
        stats.fps = elapsed ? 1e3 / elapsed : 0;
      };
      _this.debugDrawAxis = 0;
      _this.label("Root");
      return _this;
    }
    Root2.prototype.renderDebug = function (context) {
      var size = typeof this.debugDrawAxis === "number" ? this.debugDrawAxis : 10;
      var m = this.matrix();
      context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
      var lineWidth = 3 / m.a;
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(0, 0.8 * size);
      context.lineTo(-0.2 * size, 0.8 * size);
      context.lineTo(0, size);
      context.lineTo(0.2 * size, 0.8 * size);
      context.lineTo(0, 0.8 * size);
      context.strokeStyle = "rgba(93, 173, 226)";
      context.lineJoin = "round";
      context.lineCap = "round";
      context.lineWidth = lineWidth;
      context.stroke();
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(0.8 * size, 0);
      context.lineTo(0.8 * size, -0.2 * size);
      context.lineTo(size, 0);
      context.lineTo(0.8 * size, 0.2 * size);
      context.lineTo(0.8 * size, 0);
      context.strokeStyle = "rgba(236, 112, 99)";
      context.lineJoin = "round";
      context.lineCap = "round";
      context.lineWidth = lineWidth;
      context.stroke();
    };
    Root2.prototype.resume = function () {
      if (this.sleep || this.paused) {
        this.requestFrame();
      }
      this.paused = false;
      this.sleep = false;
      this.publish("resume");
      return this;
    };
    Root2.prototype.pause = function () {
      if (!this.paused) {
        this.publish("pause");
      }
      this.paused = true;
      return this;
    };
    Root2.prototype.touch = function () {
      if (this.sleep || this.paused) {
        this.requestFrame();
      }
      this.sleep = false;
      return _super.prototype.touch.call(this);
    };
    Root2.prototype.unmount = function () {
      var _a2;
      this.mounted = false;
      (_a2 = this.pointer) === null || _a2 === void 0 ? void 0 : _a2.unmount();
      return this;
    };
    Root2.prototype.background = function (color) {
      if (this.dom) {
        this.dom.style.backgroundColor = color;
      }
      return this;
    };
    Root2.prototype.viewport = function (width, height, ratio) {
      if (typeof width === "undefined") {
        return Object.assign({}, this._viewport);
      }
      if (_typeof(width) === "object") {
        var options2 = width;
        width = options2.width;
        height = options2.height;
        ratio = options2.ratio;
      }
      if (typeof width === "number" && typeof height === "number") {
        this._viewport = {
          width: width,
          height: height,
          ratio: typeof ratio === "number" ? ratio : 1
        };
        this.viewbox();
        var data_1 = Object.assign({}, this._viewport);
        this.visit({
          start: function start(node) {
            if (!node._flag("viewport")) {
              return true;
            }
            node.publish("viewport", [data_1]);
          }
        });
      }
      return this;
    };
    Root2.prototype.viewbox = function (width, height, mode) {
      if (typeof width === "number" && typeof height === "number") {
        this._viewbox = {
          width: width,
          height: height,
          mode: mode
        };
      } else if (_typeof(width) === "object" && width !== null) {
        this._viewbox = _assign({}, width);
      }
      this.rescale();
      return this;
    };
    Root2.prototype.camera = function (matrix) {
      this._camera = matrix;
      this.rescale();
      return this;
    };
    Root2.prototype.rescale = function () {
      var viewbox = this._viewbox;
      var viewport = this._viewport;
      var camera = this._camera;
      if (viewport && viewbox) {
        var viewportWidth = viewport.width;
        var viewportHeight = viewport.height;
        var viewboxMode = isValidFitMode(viewbox.mode) ? viewbox.mode : "in-pad";
        var viewboxWidth = viewbox.width;
        var viewboxHeight = viewbox.height;
        this.pin({
          width: viewboxWidth,
          height: viewboxHeight
        });
        this.fit(viewportWidth, viewportHeight, viewboxMode);
        var viewboxX = viewbox.x || 0;
        var viewboxY = viewbox.y || 0;
        var cameraZoomX = (camera === null || camera === void 0 ? void 0 : camera.a) || 1;
        var cameraZoomY = (camera === null || camera === void 0 ? void 0 : camera.d) || 1;
        var cameraX = (camera === null || camera === void 0 ? void 0 : camera.e) || 0;
        var cameraY = (camera === null || camera === void 0 ? void 0 : camera.f) || 0;
        var scaleX = this.pin("scaleX");
        var scaleY = this.pin("scaleY");
        this.pin("scaleX", scaleX * cameraZoomX);
        this.pin("scaleY", scaleY * cameraZoomY);
        this.pin("offsetX", cameraX - viewboxX * scaleX * cameraZoomX);
        this.pin("offsetY", cameraY - viewboxY * scaleY * cameraZoomY);
      } else if (viewport) {
        this.pin({
          width: viewport.width,
          height: viewport.height
        });
      }
      return this;
    };
    Root2.prototype.flipX = function (x2) {
      this._pin._directionX = x2 ? -1 : 1;
      return this;
    };
    Root2.prototype.flipY = function (y) {
      this._pin._directionY = y ? -1 : 1;
      return this;
    };
    return Root2;
  }(Node);
  var FPS = 15;
  /** @class */
  (function (_super) {
    __extends(Anim2, _super);
    function Anim2() {
      var _this = _super.call(this) || this;
      _this._texture = null;
      _this._frames = [];
      _this._time = -1;
      _this._repeat = 0;
      _this._index = 0;
      _this._animTickLastTime = 0;
      _this._animTick = function (t, now2, last) {
        if (_this._time < 0 || _this._frames.length <= 1) {
          return;
        }
        var ignore = _this._animTickLastTime != last;
        _this._animTickLastTime = now2;
        if (ignore) {
          return true;
        }
        _this._time += t;
        if (_this._time < _this._ft) {
          return true;
        }
        var n2 = _this._time / _this._ft | 0;
        _this._time -= n2 * _this._ft;
        _this.moveFrame(n2);
        if (_this._repeat > 0 && (_this._repeat -= n2) <= 0) {
          _this.stop();
          _this._callback && _this._callback();
          return false;
        }
        return true;
      };
      _this.label("Anim");
      _this._fps = FPS;
      _this._ft = 1e3 / _this._fps;
      _this.tick(_this._animTick, false);
      return _this;
    }
    Anim2.prototype.renderTexture = function (context) {
      if (!this._texture) return;
      this._texture.draw(context);
    };
    Anim2.prototype.fps = function (fps) {
      if (typeof fps === "undefined") {
        return this._fps;
      }
      this._fps = fps > 0 ? fps : FPS;
      this._ft = 1e3 / this._fps;
      return this;
    };
    Anim2.prototype.setFrames = function (frames) {
      return this.frames(frames);
    };
    Anim2.prototype.frames = function (frames) {
      this._index = 0;
      this._frames = texture(frames).array();
      this.touch();
      return this;
    };
    Anim2.prototype.length = function () {
      return this._frames ? this._frames.length : 0;
    };
    Anim2.prototype.gotoFrame = function (frame, resize) {
      if (resize === void 0) {
        resize = false;
      }
      this._index = math.wrap(frame, this._frames.length) | 0;
      resize = resize || !this._texture;
      this._texture = this._frames[this._index];
      if (resize) {
        this.pin("width", this._texture.getWidth());
        this.pin("height", this._texture.getHeight());
      }
      this.touch();
      return this;
    };
    Anim2.prototype.moveFrame = function (move) {
      return this.gotoFrame(this._index + move);
    };
    Anim2.prototype.repeat = function (repeat, callback) {
      this._repeat = repeat * this._frames.length - 1;
      this._callback = callback;
      this.play();
      return this;
    };
    Anim2.prototype.play = function (frame) {
      if (typeof frame !== "undefined") {
        this.gotoFrame(frame);
        this._time = 0;
      } else if (this._time < 0) {
        this._time = 0;
      }
      this.touch();
      return this;
    };
    Anim2.prototype.stop = function (frame) {
      this._time = -1;
      if (typeof frame !== "undefined") {
        this.gotoFrame(frame);
      }
      return this;
    };
    return Anim2;
  })(Node);
  /** @class */
  (function (_super) {
    __extends(Monotype2, _super);
    function Monotype2() {
      var _this = _super.call(this) || this;
      _this._textures = [];
      _this.label("Monotype");
      return _this;
    }
    Monotype2.prototype.renderTexture = function (context) {
      if (!this._textures || !this._textures.length) return;
      for (var i = 0, n2 = this._textures.length; i < n2; i++) {
        this._textures[i].draw(context);
      }
    };
    Monotype2.prototype.setFont = function (frames) {
      return this.frames(frames);
    };
    Monotype2.prototype.frames = function (frames) {
      this._textures = [];
      if (typeof frames == "string") {
        var selection_1 = texture(frames);
        this._font = function (value) {
          return selection_1.one(value);
        };
      } else if (_typeof(frames) === "object") {
        this._font = function (value) {
          return frames[value];
        };
      } else if (typeof frames === "function") {
        this._font = frames;
      }
      return this;
    };
    Monotype2.prototype.setValue = function (value) {
      return this.value(value);
    };
    Monotype2.prototype.value = function (value) {
      if (typeof value === "undefined") {
        return this._value;
      }
      if (this._value === value) {
        return this;
      }
      this._value = value;
      if (value === null) {
        value = "";
      } else if (typeof value !== "string" && !Array.isArray(value)) {
        value = value.toString();
      }
      this._spacing = this._spacing || 0;
      var width = 0;
      var height = 0;
      for (var i = 0; i < value.length; i++) {
        var v3 = value[i];
        var texture_1 = this._textures[i] = this._font(typeof v3 === "string" ? v3 : v3 + "");
        width += i > 0 ? this._spacing : 0;
        texture_1.setDestinationCoordinate(width, 0);
        width = width + texture_1.getWidth();
        height = Math.max(height, texture_1.getHeight());
      }
      this.pin("width", width);
      this.pin("height", height);
      this._textures.length = value.length;
      return this;
    };
    return Monotype2;
  })(Node);
  var SHAPE_DEFAULTS = {
    stroke: "rgba(255,255,255,0.9)",
    fill: "rgba(255,255,255,0.1)",
    lineWidth: 3
  };
  var JOINT_DEFAULTS = {
    stroke: "rgba(255,255,255,0.9)",
    fill: null,
    lineWidth: 3
  };
  function getStyle(obj) {
    if (_typeof(obj["render"]) === "object" && ("stroke" in obj["render"] || "fill" in obj["render"])) {
      return obj["render"];
    } else if (_typeof(obj["style"]) === "object") {
      return obj["style"];
    }
  }
  var ComputedShapeStyle = /** @class */
  function () {
    function ComputedShapeStyle2(body, fixture, global) {
      this.body = body;
      this.fixture = fixture;
      this.global = global;
    }
    Object.defineProperty(ComputedShapeStyle2.prototype, "stroke", {
      get: function get() {
        var _a2;
        var shapeStyle = getStyle(this.fixture.getShape());
        var fixtureStyle = getStyle(this.fixture);
        var bodyStyle = getStyle(this.body);
        var stroke = SHAPE_DEFAULTS.stroke;
        if (shapeStyle === null || shapeStyle === void 0 ? void 0 : shapeStyle.stroke) {
          stroke = shapeStyle.stroke;
        } else if (fixtureStyle === null || fixtureStyle === void 0 ? void 0 : fixtureStyle.stroke) {
          stroke = fixtureStyle.stroke;
        } else if (bodyStyle === null || bodyStyle === void 0 ? void 0 : bodyStyle.stroke) {
          stroke = bodyStyle.stroke;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.stroke) {
          stroke = this.global.stroke;
        } else if (this.body.isDynamic()) {
          stroke = "rgba(255,255,255,0.9)";
        } else if (this.body.isKinematic()) {
          stroke = "rgba(255,255,255,0.8)";
        } else if (this.body.isStatic()) {
          stroke = "rgba(255,255,255,0.7)";
        }
        return stroke;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ComputedShapeStyle2.prototype, "fill", {
      get: function get() {
        var _a2;
        var shapeStyle = getStyle(this.fixture.getShape());
        var fixtureStyle = getStyle(this.fixture);
        var bodyStyle = getStyle(this.body);
        var fill = SHAPE_DEFAULTS.fill;
        if (shapeStyle === null || shapeStyle === void 0 ? void 0 : shapeStyle.fill) {
          fill = shapeStyle.fill;
        } else if (fixtureStyle === null || fixtureStyle === void 0 ? void 0 : fixtureStyle.fill) {
          fill = fixtureStyle.fill;
        } else if (bodyStyle === null || bodyStyle === void 0 ? void 0 : bodyStyle.fill) {
          fill = bodyStyle.fill;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.fill) {
          fill = this.global.fill;
        }
        return fill;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ComputedShapeStyle2.prototype, "lineWidth", {
      get: function get() {
        var _a2;
        var shapeStyle = getStyle(this.fixture.getShape());
        var fixtureStyle = getStyle(this.fixture);
        var bodyStyle = getStyle(this.body);
        var lineWidth = SHAPE_DEFAULTS.lineWidth;
        if (shapeStyle === null || shapeStyle === void 0 ? void 0 : shapeStyle.lineWidth) {
          lineWidth = shapeStyle.lineWidth;
        } else if (fixtureStyle === null || fixtureStyle === void 0 ? void 0 : fixtureStyle.lineWidth) {
          lineWidth = fixtureStyle.lineWidth;
        } else if (bodyStyle === null || bodyStyle === void 0 ? void 0 : bodyStyle.lineWidth) {
          lineWidth = bodyStyle.lineWidth;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.lineWidth) {
          lineWidth = this.global.lineWidth;
        }
        return lineWidth;
      },
      enumerable: false,
      configurable: true
    });
    return ComputedShapeStyle2;
  }();
  var ComputedJointStyle = /** @class */
  function () {
    function ComputedJointStyle2(joint, global) {
      this.joint = joint;
      this.global = global;
    }
    Object.defineProperty(ComputedJointStyle2.prototype, "stroke", {
      get: function get() {
        var _a2;
        var jointStyle = getStyle(this.joint);
        var stroke = JOINT_DEFAULTS.stroke;
        if (jointStyle === null || jointStyle === void 0 ? void 0 : jointStyle.stroke) {
          stroke = jointStyle.stroke;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.stroke) {
          stroke = this.global.stroke;
        }
        return stroke;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ComputedJointStyle2.prototype, "fill", {
      get: function get() {
        var _a2;
        var jointStyle = getStyle(this.joint);
        var fill = JOINT_DEFAULTS.fill;
        if (jointStyle === null || jointStyle === void 0 ? void 0 : jointStyle.fill) {
          fill = jointStyle.fill;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.fill) {
          fill = this.global.fill;
        }
        return fill;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ComputedJointStyle2.prototype, "lineWidth", {
      get: function get() {
        var _a2;
        var jointStyle = getStyle(this.joint);
        var lineWidth = JOINT_DEFAULTS.lineWidth;
        if (jointStyle === null || jointStyle === void 0 ? void 0 : jointStyle.lineWidth) {
          lineWidth = jointStyle.lineWidth;
        } else if ((_a2 = this.global) === null || _a2 === void 0 ? void 0 : _a2.lineWidth) {
          lineWidth = this.global.lineWidth;
        }
        return lineWidth;
      },
      enumerable: false,
      configurable: true
    });
    return ComputedJointStyle2;
  }();
  var Memo = /** @class */
  function () {
    function Memo2() {
      this.memory = [];
    }
    Memo2.init = function () {
      return new Memo2();
    };
    Memo2.prototype.update = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var equal = this.memory.length === args.length;
      for (var i = 0; i < args.length; i++) {
        equal = equal && this.memory[i] === args[i];
        this.memory[i] = args[i];
      }
      this.memory.length = args.length;
      return !equal;
    };
    Memo2.prototype.clear = function () {
      this.memory.length = 0;
    };
    return Memo2;
  }();
  var math_max$2 = Math.max;
  var math_min$4 = Math.min;
  var ChainShapeComponent = /** @class */
  function (_super) {
    __extends$1(ChainShapeComponent2, _super);
    function ChainShapeComponent2(shape, style) {
      var _this = _super.call(this) || this;
      _this.textureOffset = {
        x: 0,
        y: 0,
        a: 0
      };
      _this.__memo = Memo.init();
      _this.handleTick = function () {
        var x2 = _this.textureOffset.x;
        var y = _this.textureOffset.y;
        var a2 = _this.textureOffset.a;
        if (!_this.__memo.update(x2, y, a2)) {
          return true;
        }
        _this.offset(x2, y);
        _this.rotate(a2);
      };
      _this.style = style;
      _this.shape = shape;
      var textureOffset = _this.textureOffset;
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var key = "";
        var vertices = shape.m_vertices;
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          key += v3.x + "," + v3.y + ";";
        }
        key += shape.isLoop() + ";";
        key += style.lineWidth + ";";
        key += style.stroke + ";";
        key += style.fill + ";";
        return key;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        var vertices = shape.m_vertices;
        if (!vertices.length) {
          return;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          minX = math_min$4(minX, v3.x);
          maxX = math_max$2(maxX, v3.x);
          minY = math_min$4(minY, v3.y);
          maxY = math_max$2(maxY, v3.y);
        }
        textureOffset.x = minX;
        textureOffset.y = minY;
        this.setSize(maxX - minX + lw, maxY - minY + lw, ratio);
        this.setPadding(-lw / 2);
        ctx.scale(ratio, ratio);
        ctx.beginPath();
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          var x2 = v3.x - minX + lw / 2;
          var y = v3.y - minY + lw / 2;
          if (i == 0) ctx.moveTo(x2, y);else ctx.lineTo(x2, y);
        }
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.stroke();
      });
      _this.texture(texture2);
      _this.tick(_this.handleTick);
      return _this;
    }
    return ChainShapeComponent2;
  }(Sprite);
  var math_PI$1 = Math.PI;
  var CircleShapeComponent = /** @class */
  function (_super) {
    __extends$1(CircleShapeComponent2, _super);
    function CircleShapeComponent2(shape, style) {
      var _this = _super.call(this) || this;
      _this.textureOffset = {
        x: 0,
        y: 0,
        a: 0
      };
      _this.__memo = Memo.init();
      _this.handleTick = function () {
        var x2 = _this.textureOffset.x;
        var y = _this.textureOffset.y;
        var a2 = _this.textureOffset.a;
        if (!_this.__memo.update(x2, y, a2)) {
          return true;
        }
        _this.offset(x2, y);
        _this.rotate(a2);
      };
      _this.style = style;
      _this.shape = shape;
      var textureOffset = _this.textureOffset;
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var key = "";
        var v3 = shape.getCenter();
        key += v3.x + "," + v3.y + ";";
        key += shape.getRadius() + ";";
        key += style.lineWidth + ";";
        key += style.stroke + ";";
        key += style.fill + ";";
        return key;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        var fill = style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        var r = shape.m_radius;
        textureOffset.x = shape.m_p.x - r;
        textureOffset.y = shape.m_p.y - r;
        this.setSize(r * 2 + lw, r * 2 + lw, ratio);
        this.setPadding(-lw / 2);
        ctx.scale(ratio, ratio);
        ctx.arc(r + lw / 2, r + lw / 2, r, 0, 2 * math_PI$1);
        if (fill) {
          ctx.fillStyle = fill;
          ctx.fill();
        }
        ctx.lineTo(r + lw / 2, r + lw / 2);
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.stroke();
      });
      _this.texture(texture2);
      _this.tick(_this.handleTick);
      return _this;
    }
    return CircleShapeComponent2;
  }(Sprite);
  var math_atan2$1 = Math.atan2;
  var math_sqrt$1 = Math.sqrt;
  var math_min$3 = Math.min;
  var EdgeShapeComponent = /** @class */
  function (_super) {
    __extends$1(EdgeShapeComponent2, _super);
    function EdgeShapeComponent2(shape, style) {
      var _this = _super.call(this) || this;
      _this.textureOffset = {
        x: 0,
        y: 0,
        a: 0
      };
      _this.__memo = Memo.init();
      _this.handleTick = function () {
        var x2 = _this.textureOffset.x;
        var y = _this.textureOffset.y;
        var a2 = _this.textureOffset.a;
        if (!_this.__memo.update(x2, y, a2)) {
          return true;
        }
        _this.offset(x2, y);
        _this.rotate(a2);
      };
      _this.style = style;
      _this.shape = shape;
      var textureOffset = _this.textureOffset;
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var key = "";
        var v13 = shape.m_vertex1;
        var v22 = shape.m_vertex2;
        key += (v13 === null || v13 === void 0 ? void 0 : v13.x) + "," + (v13 === null || v13 === void 0 ? void 0 : v13.y) + ";";
        key += (v22 === null || v22 === void 0 ? void 0 : v22.x) + "," + (v22 === null || v22 === void 0 ? void 0 : v22.y) + ";";
        key += style.lineWidth + ";";
        key += style.stroke + ";";
        key += style.fill + ";";
        return key;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        var v13 = shape.m_vertex1;
        var v22 = shape.m_vertex2;
        var dx = v22.x - v13.x;
        var dy = v22.y - v13.y;
        var length2 = math_sqrt$1(dx * dx + dy * dy);
        this.setSize(length2 + lw, lw, ratio);
        this.setPadding(-lw / 2);
        var minX = math_min$3(v13.x, v22.x);
        var minY = math_min$3(v13.y, v22.y);
        textureOffset.x = minX;
        textureOffset.y = minY;
        textureOffset.a = math_atan2$1(dy, dx);
        ctx.scale(ratio, ratio);
        ctx.beginPath();
        ctx.moveTo(lw / 2, lw / 2);
        ctx.lineTo(lw / 2 + length2, lw / 2);
        ctx.lineCap = "round";
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.stroke();
      });
      _this.texture(texture2);
      _this.tick(_this.handleTick);
      return _this;
    }
    return EdgeShapeComponent2;
  }(Sprite);
  var math_max$1 = Math.max;
  var math_min$2 = Math.min;
  var PolygonShapeComponent = /** @class */
  function (_super) {
    __extends$1(PolygonShapeComponent2, _super);
    function PolygonShapeComponent2(shape, style) {
      var _this = _super.call(this) || this;
      _this.textureOffset = {
        x: 0,
        y: 0,
        a: 0
      };
      _this.__memo = Memo.init();
      _this.handleTick = function () {
        var x2 = _this.textureOffset.x;
        var y = _this.textureOffset.y;
        var a2 = _this.textureOffset.a;
        if (!_this.__memo.update(x2, y, a2)) {
          return true;
        }
        _this.offset(x2, y);
        _this.rotate(a2);
      };
      _this.style = style;
      _this.shape = shape;
      var textureOffset = _this.textureOffset;
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var key = "";
        var vertices = shape.m_vertices;
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          key += v3.x + "," + v3.y + ";";
        }
        key += style.lineWidth + ";";
        key += style.stroke + ";";
        key += style.fill + ";";
        return key;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        var fill = style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        var vertices = shape.m_vertices;
        if (!vertices.length) {
          return;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          minX = math_min$2(minX, v3.x);
          maxX = math_max$1(maxX, v3.x);
          minY = math_min$2(minY, v3.y);
          maxY = math_max$1(maxY, v3.y);
        }
        textureOffset.x = minX;
        textureOffset.y = minY;
        this.setSize(maxX - minX + lw, maxY - minY + lw, ratio);
        this.setPadding(-lw / 2);
        ctx.scale(ratio, ratio);
        ctx.beginPath();
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          var x2 = v3.x - minX + lw / 2;
          var y = v3.y - minY + lw / 2;
          if (i == 0) ctx.moveTo(x2, y);else ctx.lineTo(x2, y);
        }
        if (vertices.length > 2) {
          if (fill) {
            ctx.fillStyle = fill;
            ctx.fill();
          }
          ctx.closePath();
        }
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.stroke();
      });
      _this.texture(texture2);
      _this.tick(_this.handleTick);
      return _this;
    }
    return PolygonShapeComponent2;
  }(Sprite);
  var math_atan2 = Math.atan2;
  var math_sqrt = Math.sqrt;
  var math_min$1 = Math.min;
  var JointComponent = /** @class */
  function (_super) {
    __extends$1(JointComponent2, _super);
    function JointComponent2(joint, style) {
      var _this = _super.call(this) || this;
      _this.memo = Memo.init();
      _this.style = style;
      _this.joint = joint;
      var offsetX = 0;
      var offsetY = 0;
      var offsetA = 0;
      var offsetMemo = Memo.init();
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var v13 = joint.getAnchorA();
        var v22 = joint.getAnchorB();
        var token = v13.x + "." + v13.y + "." + v22.x + "." + v22.y;
        return token;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        var v13 = joint.getAnchorA();
        var v22 = joint.getAnchorB();
        var dx = v22.x - v13.x;
        var dy = v22.y - v13.y;
        var length2 = math_sqrt(dx * dx + dy * dy);
        this.setSize(length2 + lw, lw, ratio);
        this.setPadding(-lw / 2);
        var minX = math_min$1(v13.x, v22.x);
        var minY = math_min$1(v13.y, v22.y);
        offsetX = minX;
        offsetY = minY;
        offsetA = math_atan2(dy, dx);
        ctx.scale(ratio, ratio);
        ctx.beginPath();
        ctx.moveTo(lw / 2, lw / 2);
        ctx.lineTo(lw / 2 + length2, lw / 2);
        ctx.lineCap = "round";
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.stroke();
      });
      var sprite$1 = sprite(texture2);
      sprite$1.tick(function () {
        if (offsetMemo.update(offsetX, offsetY, offsetA)) {
          sprite$1.offset(offsetX, offsetY);
          sprite$1.rotate(offsetA);
        }
      });
      _this.append(sprite$1);
      return _this;
    }
    return JointComponent2;
  }(Node);
  var math_max = Math.max;
  var math_min = Math.min;
  var PulleyJointComponent = /** @class */
  function (_super) {
    __extends$1(PulleyJointComponent2, _super);
    function PulleyJointComponent2(joint, style) {
      var _this = _super.call(this) || this;
      _this.memo = Memo.init();
      _this.style = style;
      _this.joint = joint;
      var vertices = [];
      var offsetX = 0;
      var offsetY = 0;
      var offsetMemo = Memo.init();
      var texture2 = canvas();
      texture2.setMemoizer(function () {
        var v13 = joint.getAnchorA();
        var v22 = joint.getGroundAnchorA();
        var v3 = joint.getGroundAnchorB();
        var v4 = joint.getAnchorB();
        var token = v13.x + "." + v13.y + "." + v22.x + "." + v22.y + "." + v3.x + "." + v3.y + "." + v4.x + "." + v4.y;
        return token;
      });
      texture2.setDrawer(function () {
        var lineWidth = style.lineWidth;
        var stroke = style.stroke;
        style.fill;
        var ctx = this.getContext();
        var ratio = this.getDevicePixelRatio();
        var lw = lineWidth / ratio;
        vertices[0] = joint.getAnchorA();
        vertices[1] = joint.getGroundAnchorA();
        vertices[2] = joint.getGroundAnchorB();
        vertices[3] = joint.getAnchorB();
        if (!vertices.length) {
          return;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          minX = math_min(minX, v3.x);
          maxX = math_max(maxX, v3.x);
          minY = math_min(minY, v3.y);
          maxY = math_max(maxY, v3.y);
        }
        var width = maxX - minX;
        var height = maxY - minY;
        offsetX = minX;
        offsetY = minY;
        this.setSize(width + lw, height + lw, ratio);
        this.setPadding(-lw / 2);
        ctx.scale(ratio, ratio);
        ctx.beginPath();
        for (var i = 0; i < vertices.length; ++i) {
          var v3 = vertices[i];
          var x2 = v3.x - minX + lw / 2;
          var y = v3.y - minY + lw / 2;
          if (i == 0) ctx.moveTo(x2, y);else ctx.lineTo(x2, y);
        }
        ctx.lineCap = "round";
        ctx.lineWidth = lw;
        ctx.strokeStyle = stroke !== null && stroke !== void 0 ? stroke : "";
        ctx.stroke();
      });
      var sprite$1 = sprite(texture2);
      sprite$1.tick(function () {
        if (offsetMemo.update(offsetX, offsetY)) {
          sprite$1.offset(offsetX, offsetY);
        }
      });
      _this.append(sprite$1);
      return _this;
    }
    return PulleyJointComponent2;
  }(Node);
  var BodyComponent = /** @class */
  function (_super) {
    __extends$1(BodyComponent2, _super);
    function BodyComponent2(body) {
      var _this = _super.call(this) || this;
      _this.__memo = Memo.init();
      _this.handleTick = function () {
        if (!_this.body) {
          return;
        }
        var p = _this.body.getPosition();
        var x2 = p.x;
        var y = p.y;
        var a2 = _this.body.getAngle();
        if (!_this.__memo.update(x2, y, a2)) {
          return true;
        }
        _this.offset(x2, y);
        _this.rotate(a2);
      };
      _this.body = body;
      _this.tick(_this.handleTick, false);
      return _this;
    }
    return BodyComponent2;
  }(Sprite);
  var math_abs = Math.abs;
  var HIT_RADIUS_PIXEL = 10;
  var DEFAULTS = {
    speed: 1,
    hz: 60
  };
  var WorldComponent = /** @class */
  function (_super) {
    __extends$1(WorldComponent2, _super);
    function WorldComponent2(context, emit) {
      var _this = _super.call(this) || this;
      _this.bodies = /* @__PURE__ */new WeakMap();
      _this.shapes = /* @__PURE__ */new WeakMap();
      _this.joints = /* @__PURE__ */new WeakMap();
      _this.getHitRadius = function () {
        var pixelPerUnit = _this.getLogicalPixelRatio();
        var hitRadius = HIT_RADIUS_PIXEL / pixelPerUnit;
        return hitRadius;
      };
      _this.timeBuffer = 0;
      _this.stepErrored = false;
      _this.handleTick = function (dt) {
        var _a2, _b;
        if (!_this.world) return false;
        if (_this.stepErrored) return false;
        if (_this.context.paused) return false;
        var speed = (_a2 = _this.context.speed) !== null && _a2 !== void 0 ? _a2 : DEFAULTS.speed;
        var hz = (_b = _this.context.hz) !== null && _b !== void 0 ? _b : DEFAULTS.hz;
        if (math_abs(hz) < 1) {
          hz = 1 / hz;
        }
        var timeStep = 1 / hz;
        try {
          dt = dt * 1e-3 * speed;
          _this.timeBuffer += dt;
          while (_this.timeBuffer > timeStep) {
            _this.world.step(timeStep);
            _this.timeBuffer -= timeStep;
          }
          _this.renderWorld();
          return true;
        } catch (error) {
          _this.stepErrored = true;
          console.error(error);
          return false;
        }
      };
      _this.setWorld = function (world) {
        if (_this.world === world) {
          return;
        }
        if (_this.world) {
          _this.world.off("remove-body", _this.removeBody);
          _this.world.off("remove-fixture", _this.removeShape);
          _this.world.off("remove-joint", _this.removeJoint);
        }
        _this.world = world;
        if (_this.world) {
          _this.world.on("remove-body", _this.removeBody);
          _this.world.on("remove-fixture", _this.removeShape);
          _this.world.on("remove-joint", _this.removeJoint);
        }
        _this.empty();
        _this.bodies = /* @__PURE__ */new WeakMap();
        _this.shapes = /* @__PURE__ */new WeakMap();
        _this.joints = /* @__PURE__ */new WeakMap();
        _this.renderWorld();
      };
      _this.removeShape = function (obj) {
        var _a2;
        (_a2 = _this.shapes.get(obj)) === null || _a2 === void 0 ? void 0 : _a2.remove();
        _this.shapes.delete(obj);
      };
      _this.removeBody = function (obj) {
        var _a2;
        (_a2 = _this.bodies.get(obj)) === null || _a2 === void 0 ? void 0 : _a2.remove();
        _this.bodies.delete(obj);
      };
      _this.removeJoint = function (obj) {
        var _a2;
        (_a2 = _this.joints.get(obj)) === null || _a2 === void 0 ? void 0 : _a2.remove();
        _this.joints.delete(obj);
      };
      _this.rerenderWorld = function () {
        _this.renderWorld(true);
      };
      _this.renderWorld = function (clearCache) {
        if (clearCache === void 0) {
          clearCache = false;
        }
        if (clearCache === true) {
          _this.empty();
          _this.shapes = /* @__PURE__ */new WeakMap();
          _this.bodies = /* @__PURE__ */new WeakMap();
          _this.joints = /* @__PURE__ */new WeakMap();
        }
        if (!_this.world) return;
        var world = _this.world;
        for (var b2 = world.getBodyList(); b2; b2 = b2.getNext()) {
          _this.renderBody(b2);
        }
        for (var j = world.getJointList(); j; j = j.getNext()) {
          _this.renderJoint(j);
        }
      };
      _this.pointerStart = {
        x: 0,
        y: 0
      };
      _this.pointerLast = {
        x: 0,
        y: 0
      };
      _this.pointerDragged = false;
      _this.pointerDown = false;
      _this.handlePointerDown = function (point2) {
        var _a2;
        if (!_this.world) return;
        var fixture = _this.findFixture(point2);
        (_a2 = _this.emit) === null || _a2 === void 0 ? void 0 : _a2.call(_this, "world-pointer-down", {
          point: point2,
          fixture: fixture,
          background: !fixture
        });
        _this.pointerStart.x = point2.x;
        _this.pointerStart.y = point2.y;
        _this.pointerLast.x = point2.x;
        _this.pointerLast.y = point2.y;
        _this.pointerDown = true;
        _this.pointerDragged = false;
      };
      _this.handlePointerMove = function (point2) {
        var _a2, _b, _c;
        if (!_this.world) return;
        (_a2 = _this.emit) === null || _a2 === void 0 ? void 0 : _a2.call(_this, "world-pointer-move", {
          point: point2
        });
        if (!_this.pointerDown) return;
        var move = {
          x: point2.x - _this.pointerStart.x,
          y: point2.y - _this.pointerStart.y
        };
        var delta = {
          x: point2.x - _this.pointerLast.x,
          y: point2.y - _this.pointerLast.y
        };
        if (_this.pointerDragged) {
          _this.pointerLast.x = point2.x;
          _this.pointerLast.y = point2.y;
          (_b = _this.emit) === null || _b === void 0 ? void 0 : _b.call(_this, "world-drag-move", {
            point: point2,
            delta: delta,
            move: move
          });
        } else if (move.x !== 0 || move.y !== 0) {
          _this.pointerDragged = true;
          var fixture = _this.findFixture(point2);
          (_c = _this.emit) === null || _c === void 0 ? void 0 : _c.call(_this, "world-drag-start", {
            point: point2,
            fixture: fixture,
            background: !fixture
          });
        }
      };
      _this.handlePointerUp = function (point2) {
        var _a2, _b, _c;
        if (!_this.world) return;
        (_a2 = _this.emit) === null || _a2 === void 0 ? void 0 : _a2.call(_this, "world-pointer-up", {
          point: point2
        });
        if (!_this.pointerDown) return;
        _this.pointerDown = false;
        ({
          x: point2.x - _this.pointerStart.x,
          y: point2.y - _this.pointerStart.y
        });
        ({
          x: point2.x - _this.pointerLast.x,
          y: point2.y - _this.pointerLast.y
        });
        _this.pointerLast.x = point2.x;
        _this.pointerLast.y = point2.y;
        if (_this.pointerDragged) {
          (_b = _this.emit) === null || _b === void 0 ? void 0 : _b.call(_this, "world-drag-end", {
            point: point2
          });
          return;
        }
        var fixture = _this.findFixture(point2);
        (_c = _this.emit) === null || _c === void 0 ? void 0 : _c.call(_this, "world-click", {
          point: point2,
          fixture: fixture,
          background: !fixture
        });
      };
      _this.handlePointerCancel = function () {
        var _a2, _b;
        if (!_this.world) return;
        (_a2 = _this.emit) === null || _a2 === void 0 ? void 0 : _a2.call(_this, "world-pointer-cancel");
        if (!_this.pointerDown) return;
        _this.pointerDown = false;
        if (_this.pointerDragged) {
          (_b = _this.emit) === null || _b === void 0 ? void 0 : _b.call(_this, "world-drag-cancel");
        }
      };
      _this.findFixture = function (point2, filter) {
        var radius = _this.getHitRadius();
        var fixture = findFixture(_this.world, point2, radius, filter);
        return fixture;
      };
      _this.context = context;
      _this.emit = emit;
      _this.attr("spy", true);
      _this.on(POINTER_DOWN, _this.handlePointerDown);
      _this.on(POINTER_MOVE, _this.handlePointerMove);
      _this.on(POINTER_UP, _this.handlePointerUp);
      _this.on(POINTER_CANCEL, _this.handlePointerCancel);
      _this.tick(_this.handleTick, true);
      return _this;
    }
    WorldComponent2.prototype.renderBody = function (body) {
      var bodyComponent = this.bodies.get(body);
      if (!bodyComponent) {
        bodyComponent = new BodyComponent(body);
        bodyComponent.appendTo(this);
        this.bodies.set(body, bodyComponent);
      }
      for (var fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
        this.renderFixture(bodyComponent, body, fixture);
      }
    };
    WorldComponent2.prototype.renderFixture = function (bodyComponent, body, fixture) {
      var shapeComponent = this.shapes.get(fixture);
      if (shapeComponent) {
        return;
      }
      var type = fixture.getType();
      var shape = fixture.getShape();
      var style = new ComputedShapeStyle(body, fixture, this.context);
      if (type == "circle") {
        shapeComponent = new CircleShapeComponent(shape, style);
      } else if (type == "edge") {
        shapeComponent = new EdgeShapeComponent(shape, style);
      } else if (type == "polygon") {
        shapeComponent = new PolygonShapeComponent(shape, style);
      } else if (type == "chain") {
        shapeComponent = new ChainShapeComponent(shape, style);
      } else {
        return;
      }
      shapeComponent.appendTo(bodyComponent);
      this.shapes.set(fixture, shapeComponent);
    };
    WorldComponent2.prototype.renderJoint = function (joint) {
      var component = this.joints.get(joint);
      if (component) {
        return;
      }
      var type = joint.getType();
      var style = new ComputedJointStyle(joint, this.context);
      if (type == PulleyJoint.TYPE) {
        component = new PulleyJointComponent(joint, style);
      } else {
        component = new JointComponent(joint, style);
      }
      component.appendTo(this);
      this.joints.set(joint, component);
    };
    return WorldComponent2;
  }(Node);
  function findFixture(world, point2, radius, filter) {
    var bestFixture;
    var bestDistance = radius;
    var aabb = new AABB(point2, point2).extend(radius);
    var distanceInput2 = new DistanceInput();
    distanceInput2.useRadii = true;
    distanceInput2.proxyB.set(new CircleShape(1e-5), 0);
    distanceInput2.transformB.set(new Transform(point2));
    world.queryAABB(aabb, function (fixture) {
      if (filter && !filter(fixture)) {
        return true;
      }
      if (fixture.testPoint(point2)) {
        bestFixture = fixture;
        bestDistance = 0;
        return true;
      }
      for (var childIndex = fixture.getShape().getChildCount(); childIndex >= 0; childIndex--) {
        distanceInput2.proxyA.set(fixture.getShape(), childIndex);
        distanceInput2.transformA.set(fixture.getBody().getTransform());
        var cache2 = new SimplexCache();
        var output2 = new DistanceOutput();
        Distance(output2, cache2, distanceInput2);
        var distance = Vec2.distance(output2.pointA, output2.pointB);
        if (distance < bestDistance) {
          bestFixture = fixture;
          bestDistance = distance;
        }
      }
      return bestDistance == 0 ? false : true;
    });
    return bestFixture;
  }
  var math_PI = Math.PI;
  var mounted = null;
  Testbed.mount = function () {
    if (mounted) {
      return mounted;
    }
    mounted = new StageTestbed();
    var playButton = document.getElementById("testbed-play");
    var statusElement = document.getElementById("testbed-status");
    var infoElement = document.getElementById("testbed-info");
    if (playButton) {
      playButton.addEventListener("click", function () {
        if (mounted.isPaused()) {
          mounted.resume();
        } else {
          mounted.pause();
        }
      });
      mounted._pause = function () {
        playButton.classList.add("pause");
        playButton.classList.remove("play");
      };
      mounted._resume = function () {
        playButton.classList.add("play");
        playButton.classList.remove("pause");
      };
    } else {
      console.log("Please create a button with id='testbed-play'");
    }
    var lastStatus = "";
    if (statusElement) {
      statusElement.innerText = lastStatus;
    }
    mounted._status = function (text) {
      if (lastStatus === text) {
        return;
      }
      lastStatus = text;
      if (statusElement) {
        statusElement.innerText = text;
      }
    };
    var lastInfo = "";
    if (infoElement) {
      infoElement.innerText = lastInfo;
    }
    mounted._info = function (text) {
      if (lastInfo === text) {
        return;
      }
      lastInfo = text;
      if (infoElement) {
        infoElement.innerText = text;
      }
    };
    return mounted;
  };
  var StageTestbed = /** @class */
  function (_super) {
    __extends$1(StageTestbed2, _super);
    function StageTestbed2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.paused = false;
      _this.lastDrawHash = "";
      _this.newDrawHash = "";
      _this.buffer = [];
      _this.statusText = "";
      _this.statusMap = {};
      _this.drawSegment = _this.drawEdge;
      return _this;
    }
    StageTestbed2.prototype.start = function (world) {
      var _this = this;
      var stage = this.stage = mount();
      var canvas2 = this.canvas = stage.dom;
      var testbed2 = this;
      this.canvas = canvas2;
      stage.on(POINTER_DOWN, function () {
        var _a2;
        window.focus();
        (_a2 = document.activeElement) === null || _a2 === void 0 ? void 0 : _a2.blur();
        canvas2.focus();
      });
      stage.MAX_ELAPSE = 1e3 / 30;
      stage.flipY(true);
      stage.on("resume", function () {
        _this.paused = false;
        _this._resume();
      });
      stage.on("pause", function () {
        _this.paused = true;
        _this._pause();
      });
      var drawingTexture = new CanvasTexture();
      drawingTexture.draw = function (ctx) {
        var pixelRatio = drawingTexture.getDevicePixelRatio();
        ctx.save();
        ctx.transform(1, 0, 0, 1, -_this.x, -_this.y);
        ctx.lineWidth = 3 / pixelRatio;
        ctx.lineCap = "round";
        for (var drawing = _this.buffer.shift(); drawing; drawing = _this.buffer.shift()) {
          drawing(ctx, pixelRatio);
        }
        ctx.restore();
      };
      var drawingElement = sprite(drawingTexture);
      stage.append(drawingElement);
      stage.tick(function () {
        _this.buffer.length = 0;
      }, true);
      stage.background(this.background);
      stage.viewbox(this.width, this.height);
      stage.pin("alignX", -0.5);
      stage.pin("alignY", -0.5);
      var mouseGround = world.createBody();
      var mouseJoint = null;
      var targetBody = null;
      var mouseMove = {
        x: 0,
        y: 0
      };
      var pointerStart = function pointerStart(event) {
        var point2 = event.point;
        if (targetBody) {
          return;
        }
        var fixture = worldNode.findFixture(point2);
        if (!fixture) {
          return;
        }
        var body = fixture.getBody();
        if (_this.mouseForce) {
          targetBody = body;
        } else if (_this.mouseForce === 0) ;else {
          mouseJoint = new MouseJoint({
            maxForce: 1e3
          }, mouseGround, body, {
            x: point2.x,
            y: point2.y
          });
          world.createJoint(mouseJoint);
        }
      };
      var pointerMove = function pointerMove(event) {
        var point2 = event.point;
        if (mouseJoint) {
          mouseJoint.setTarget(point2);
        }
        mouseMove.x = point2.x;
        mouseMove.y = point2.y;
      };
      var pointerEnd = function pointerEnd(event) {
        var point2 = event.point;
        if (mouseJoint) {
          world.destroyJoint(mouseJoint);
          mouseJoint = null;
        }
        if (targetBody && _this.mouseForce) {
          var target = targetBody.getPosition();
          var force = {
            x: (point2.x - target.x) * _this.mouseForce,
            y: (point2.y - target.y) * _this.mouseForce
          };
          targetBody.applyForceToCenter(force, true);
          targetBody = null;
        }
      };
      var pointerCancel = function pointerCancel() {
        if (mouseJoint) {
          world.destroyJoint(mouseJoint);
          mouseJoint = null;
        }
        if (targetBody) {
          targetBody = null;
        }
      };
      var worldNode = new WorldComponent(this, function (name, event) {
        if (name === "world-drag-start") {
          pointerStart(event);
        } else if (name === "world-drag-move") {
          pointerMove(event);
        } else if (name === "world-drag-end") {
          pointerEnd(event);
        } else if (name === "world-pointer-cancel") {
          pointerCancel();
        }
      });
      worldNode.setWorld(world);
      stage.prepend(worldNode);
      var lastX = 0;
      var lastY = 0;
      stage.tick(function (dt, t) {
        if (lastX !== _this.x || lastY !== _this.y) {
          worldNode.offset(_this.x, _this.y);
          lastX = _this.x;
          lastY = _this.y;
        }
      });
      worldNode.tick(function (dt, t) {
        _this.step(dt, t);
        if (targetBody) {
          _this.drawSegment(targetBody.getPosition(), mouseMove, "rgba(255,255,255,0.2)");
        }
        if (_this.lastDrawHash !== _this.newDrawHash) {
          _this.lastDrawHash = _this.newDrawHash;
          stage.touch();
        }
        _this.newDrawHash = "";
        return true;
      });
      var activeKeys = testbed2.activeKeys;
      var downKeys = {};
      function updateActiveKeys(keyCode, down) {
        var char = String.fromCharCode(keyCode);
        if (/\w/.test(char)) {
          activeKeys[char] = down;
        }
        activeKeys.right = downKeys[39] || activeKeys["D"];
        activeKeys.left = downKeys[37] || activeKeys["A"];
        activeKeys.up = downKeys[38] || activeKeys["W"];
        activeKeys.down = downKeys[40] || activeKeys["S"];
        activeKeys.fire = downKeys[32] || downKeys[13];
      }
      window.addEventListener("keydown", function (e3) {
        var _a2;
        var keyCode = e3.keyCode;
        downKeys[keyCode] = true;
        updateActiveKeys(keyCode, true);
        (_a2 = testbed2.keydown) === null || _a2 === void 0 ? void 0 : _a2.call(testbed2, keyCode, String.fromCharCode(keyCode));
      });
      window.addEventListener("keyup", function (e3) {
        var _a2;
        var keyCode = e3.keyCode;
        downKeys[keyCode] = false;
        updateActiveKeys(keyCode, false);
        (_a2 = testbed2.keyup) === null || _a2 === void 0 ? void 0 : _a2.call(testbed2, keyCode, String.fromCharCode(keyCode));
      });
      this.resume();
    };
    StageTestbed2.prototype.focus = function () {
      document.activeElement && document.activeElement.blur();
      this.canvas.focus();
    };
    StageTestbed2.prototype._pause = function () {};
    StageTestbed2.prototype._resume = function () {};
    StageTestbed2.prototype.status = function (a2, b2) {
      if (typeof b2 !== "undefined") {
        var key_1 = a2;
        var value_1 = b2;
        if (typeof value_1 !== "function" && _typeof(value_1) !== "object") {
          this.statusMap[key_1] = value_1;
        }
      } else if (a2 && _typeof(a2) === "object") {
        for (var key_2 in a2) {
          var value_2 = a2[key_2];
          if (typeof value_2 !== "function" && _typeof(value_2) !== "object") {
            this.statusMap[key_2] = value_2;
          }
        }
      } else if (typeof a2 === "string") {
        this.statusText = a2;
      }
      var newline = "\n";
      var text = this.statusText || "";
      for (var key in this.statusMap) {
        var value = this.statusMap[key];
        if (typeof value === "function") continue;
        text += (text && newline) + key + ": " + value;
      }
      this._status(text);
    };
    StageTestbed2.prototype.info = function (text) {
      this._info(text);
    };
    StageTestbed2.prototype._status = function (string) {};
    StageTestbed2.prototype._info = function (text) {};
    StageTestbed2.prototype.isPaused = function () {
      return this.paused;
    };
    StageTestbed2.prototype.togglePause = function () {
      if (this.paused) {
        this.resume();
      } else {
        this.pause();
      }
    };
    StageTestbed2.prototype.pause = function () {
      this.stage.pause();
    };
    StageTestbed2.prototype.resume = function () {
      this.stage.resume();
      this.focus();
    };
    StageTestbed2.prototype.drawPoint = function (p, r, color) {
      this.buffer.push(function (ctx, ratio) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5 / ratio, 0, 2 * math_PI);
        ctx.strokeStyle = color;
        ctx.stroke();
      });
      this.newDrawHash += "point" + p.x + "," + p.y + "," + r + "," + color;
    };
    StageTestbed2.prototype.drawCircle = function (p, r, color) {
      this.buffer.push(function (ctx) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, 2 * math_PI);
        ctx.strokeStyle = color;
        ctx.stroke();
      });
      this.newDrawHash += "circle" + p.x + "," + p.y + "," + r + "," + color;
    };
    StageTestbed2.prototype.drawEdge = function (a2, b2, color) {
      this.buffer.push(function (ctx) {
        ctx.beginPath();
        ctx.moveTo(a2.x, a2.y);
        ctx.lineTo(b2.x, b2.y);
        ctx.strokeStyle = color;
        ctx.stroke();
      });
      this.newDrawHash += "segment" + a2.x + "," + a2.y + "," + b2.x + "," + b2.y + "," + color;
    };
    StageTestbed2.prototype.drawPolygon = function (points, color) {
      if (!points || !points.length) {
        return;
      }
      this.buffer.push(function (ctx) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (var i2 = 1; i2 < points.length; i2++) {
          ctx.lineTo(points[i2].x, points[i2].y);
        }
        ctx.strokeStyle = color;
        ctx.closePath();
        ctx.stroke();
      });
      this.newDrawHash += "segment";
      for (var i = 1; i < points.length; i++) {
        this.newDrawHash += points[i].x + "," + points[i].y + ",";
      }
      this.newDrawHash += color;
    };
    StageTestbed2.prototype.drawAABB = function (aabb, color) {
      this.buffer.push(function (ctx) {
        ctx.beginPath();
        ctx.moveTo(aabb.lowerBound.x, aabb.lowerBound.y);
        ctx.lineTo(aabb.upperBound.x, aabb.lowerBound.y);
        ctx.lineTo(aabb.upperBound.x, aabb.upperBound.y);
        ctx.lineTo(aabb.lowerBound.x, aabb.upperBound.y);
        ctx.strokeStyle = color;
        ctx.closePath();
        ctx.stroke();
      });
      this.newDrawHash += "aabb";
      this.newDrawHash += aabb.lowerBound.x + "," + aabb.lowerBound.y + ",";
      this.newDrawHash += aabb.upperBound.x + "," + aabb.upperBound.y + ",";
      this.newDrawHash += color;
    };
    StageTestbed2.prototype.findOne = function (query) {
      throw new Error("Not implemented");
    };
    StageTestbed2.prototype.findAll = function (query) {
      throw new Error("Not implemented");
    };
    return StageTestbed2;
  }(Testbed);
  var planck = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({
    __proto__: null,
    AABB: AABB,
    Body: Body,
    Box: Box,
    BoxShape: BoxShape,
    BroadPhase: BroadPhase,
    Chain: Chain,
    ChainShape: ChainShape,
    Circle: Circle,
    CircleShape: CircleShape,
    ClipVertex: ClipVertex,
    CollideCircles: CollideCircles,
    CollideEdgeCircle: CollideEdgeCircle,
    CollideEdgePolygon: CollideEdgePolygon,
    CollidePolygonCircle: CollidePolygonCircle,
    CollidePolygons: CollidePolygons,
    Contact: Contact,
    ContactEdge: ContactEdge,
    get ContactFeatureType() {
      return exports2.ContactFeatureType;
    },
    ContactID: ContactID,
    ContactImpulse: ContactImpulse,
    DataDriver: DataDriver,
    Distance: Distance,
    DistanceInput: DistanceInput,
    DistanceJoint: DistanceJoint,
    DistanceOutput: DistanceOutput,
    DistanceProxy: DistanceProxy,
    DynamicTree: DynamicTree,
    Edge: Edge,
    EdgeShape: EdgeShape,
    Fixture: Fixture,
    FixtureProxy: FixtureProxy,
    FrictionJoint: FrictionJoint,
    GearJoint: GearJoint,
    Joint: Joint,
    JointEdge: JointEdge,
    Manifold: Manifold,
    ManifoldPoint: ManifoldPoint,
    get ManifoldType() {
      return exports2.ManifoldType;
    },
    Mat22: Mat22,
    Mat33: Mat33,
    Math: math$1,
    MotorJoint: MotorJoint,
    MouseJoint: MouseJoint,
    get PointState() {
      return exports2.PointState;
    },
    Polygon: Polygon,
    PolygonShape: PolygonShape,
    PrismaticJoint: PrismaticJoint,
    PulleyJoint: PulleyJoint,
    RevoluteJoint: RevoluteJoint,
    RopeJoint: RopeJoint,
    Rot: Rot,
    Serializer: Serializer,
    Settings: Settings,
    SettingsInternal: SettingsInternal,
    Shape: Shape,
    ShapeCast: ShapeCast,
    ShapeCastInput: ShapeCastInput,
    ShapeCastOutput: ShapeCastOutput,
    SimplexCache: SimplexCache,
    Solver: Solver,
    StageTestbed: StageTestbed,
    Sweep: Sweep,
    TOIInput: TOIInput,
    TOIOutput: TOIOutput,
    get TOIOutputState() {
      return exports2.TOIOutputState;
    },
    Testbed: Testbed,
    TimeOfImpact: TimeOfImpact,
    TimeStep: TimeStep,
    Transform: Transform,
    TreeNode: TreeNode,
    Vec2: Vec2,
    Vec3: Vec3,
    VelocityConstraintPoint: VelocityConstraintPoint,
    WeldJoint: WeldJoint,
    WheelJoint: WheelJoint,
    World: World,
    WorldManifold: WorldManifold,
    clipSegmentToLine: clipSegmentToLine,
    getPointStates: getPointStates,
    internal: internal,
    mixFriction: mixFriction,
    mixRestitution: mixRestitution,
    stats: stats$1,
    testOverlap: testOverlap,
    testbed: testbed
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  exports2.AABB = AABB;
  exports2.Body = Body;
  exports2.Box = Box;
  exports2.BoxShape = BoxShape;
  exports2.BroadPhase = BroadPhase;
  exports2.Chain = Chain;
  exports2.ChainShape = ChainShape;
  exports2.Circle = Circle;
  exports2.CircleShape = CircleShape;
  exports2.ClipVertex = ClipVertex;
  exports2.CollideCircles = CollideCircles;
  exports2.CollideEdgeCircle = CollideEdgeCircle;
  exports2.CollideEdgePolygon = CollideEdgePolygon;
  exports2.CollidePolygonCircle = CollidePolygonCircle;
  exports2.CollidePolygons = CollidePolygons;
  exports2.Contact = Contact;
  exports2.ContactEdge = ContactEdge;
  exports2.ContactID = ContactID;
  exports2.ContactImpulse = ContactImpulse;
  exports2.DataDriver = DataDriver;
  exports2.Distance = Distance;
  exports2.DistanceInput = DistanceInput;
  exports2.DistanceJoint = DistanceJoint;
  exports2.DistanceOutput = DistanceOutput;
  exports2.DistanceProxy = DistanceProxy;
  exports2.DynamicTree = DynamicTree;
  exports2.Edge = Edge;
  exports2.EdgeShape = EdgeShape;
  exports2.Fixture = Fixture;
  exports2.FixtureProxy = FixtureProxy;
  exports2.FrictionJoint = FrictionJoint;
  exports2.GearJoint = GearJoint;
  exports2.Joint = Joint;
  exports2.JointEdge = JointEdge;
  exports2.Manifold = Manifold;
  exports2.ManifoldPoint = ManifoldPoint;
  exports2.Mat22 = Mat22;
  exports2.Mat33 = Mat33;
  exports2.Math = math$1;
  exports2.MotorJoint = MotorJoint;
  exports2.MouseJoint = MouseJoint;
  exports2.Polygon = Polygon;
  exports2.PolygonShape = PolygonShape;
  exports2.PrismaticJoint = PrismaticJoint;
  exports2.PulleyJoint = PulleyJoint;
  exports2.RevoluteJoint = RevoluteJoint;
  exports2.RopeJoint = RopeJoint;
  exports2.Rot = Rot;
  exports2.Serializer = Serializer;
  exports2.Settings = Settings;
  exports2.SettingsInternal = SettingsInternal;
  exports2.Shape = Shape;
  exports2.ShapeCast = ShapeCast;
  exports2.ShapeCastInput = ShapeCastInput;
  exports2.ShapeCastOutput = ShapeCastOutput;
  exports2.SimplexCache = SimplexCache;
  exports2.Solver = Solver;
  exports2.StageTestbed = StageTestbed;
  exports2.Sweep = Sweep;
  exports2.TOIInput = TOIInput;
  exports2.TOIOutput = TOIOutput;
  exports2.Testbed = Testbed;
  exports2.TimeOfImpact = TimeOfImpact;
  exports2.TimeStep = TimeStep;
  exports2.Transform = Transform;
  exports2.TreeNode = TreeNode;
  exports2.Vec2 = Vec2;
  exports2.Vec3 = Vec3;
  exports2.VelocityConstraintPoint = VelocityConstraintPoint;
  exports2.WeldJoint = WeldJoint;
  exports2.WheelJoint = WheelJoint;
  exports2.World = World;
  exports2.WorldManifold = WorldManifold;
  exports2.clipSegmentToLine = clipSegmentToLine;
  exports2.default = planck;
  exports2.getPointStates = getPointStates;
  exports2.internal = internal;
  exports2.mixFriction = mixFriction;
  exports2.mixRestitution = mixRestitution;
  exports2.stats = stats$1;
  exports2.testOverlap = testOverlap;
  exports2.testbed = testbed;
  Object.defineProperties(exports2, _defineProperty({
    __esModule: {
      value: true
    }
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
},{}],"GamePhysics.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createScene = void 0;
var _planckWithTestbed = require("planck/dist/planck-with-testbed");
var _lodash = require("lodash");
// wheel spring settings
var HZ = 2.4;
var ZETA = 0.5;
var SPEED = 80.0;
var groundFD = {
  density: 0.0,
  friction: 0.6
};
var lastTerrainPosition = {
  x: 20,
  y: 0
};

// When an object was created 2 laps ago, we can destroy it
var destroyOnLap = [];

// number of times we make new ground
var lap = 0;
var segmentsPerLap = 100;
var dx = 5.0;
var destroyBodies = function destroyBodies(world, bodies) {
  // destroy all bodies in array
  console.log('destroying bodies');
  bodies.forEach(function (body) {
    destroyBody(world, body);
  });

  // remove first element of array
  destroyOnLap.shift();
};
var destroyBody = function destroyBody(world, body) {
  if (world && body) {
    world.destroyBody(body);
  }
};
var createLap = function createLap(world, ground) {
  var objectsToDestroy = generateGround(world, ground);
  destroyOnLap.push(objectsToDestroy);
  if (destroyOnLap.length > 2) {
    destroyBodies(world, destroyOnLap[0]);
  }
  lap += 1;
};
var generateGround = function generateGround(world, ground) {
  var toDestroy = [];
  var x = lastTerrainPosition.x,
    y1 = lastTerrainPosition.y;
  for (var i = 0; i < segmentsPerLap; ++i) {
    var y2 = (0, _lodash.random)(-3.0, 2.0);
    ground.createFixture(new _planckWithTestbed.Edge((0, _planckWithTestbed.Vec2)(x, y1), (0, _planckWithTestbed.Vec2)(x + dx, y2)), groundFD);
    y1 = y2;
    x += dx;

    // 1 in 5 chance of generating a circle
    var randomObstacle = (0, _lodash.random)(0, 10);
    if (randomObstacle <= 1) {
      var randomRadus = (0, _lodash.random)(0.3, 1.3);
      var circle = generateCircle(world, randomRadus, 1.0, x + 2.5, Math.max(y1, y2) + randomRadus);
      toDestroy.push(circle);
    } else if (randomObstacle == 2) {
      var randomSize = (0, _lodash.random)(0.3, 1);
      var box = generateBox(world, randomSize, randomSize, randomSize, x + 2.5, Math.max(y1, y2) + 3);
      toDestroy.push(box);
    }
    if (i === 99) {
      lastTerrainPosition.x = x;
      lastTerrainPosition.y = y2;
    }
  }
  return toDestroy;
};
var generateCircle = function generateCircle(world, radius, density, x, y) {
  var body = world.createDynamicBody((0, _planckWithTestbed.Vec2)(x, y));
  var fd = {
    density: density,
    friction: 0.1
  };
  body.createFixture(new _planckWithTestbed.Circle(radius), fd);
  return body;
};
var generateBox = function generateBox(world, width, height, density, x, y) {
  var body = world.createDynamicBody((0, _planckWithTestbed.Vec2)(x, y));
  var fd = {
    density: density,
    friction: 0.1
  };
  body.createFixture(new _planckWithTestbed.Box(width, height), fd);
  return body;
};
var createScene = exports.createScene = function createScene() {
  var world = new _planckWithTestbed.World({
    gravity: new _planckWithTestbed.Vec2(0.0, -10.0)
  });
  var testbed = _planckWithTestbed.Testbed.mount();
  testbed.x = 0;
  testbed.y = 0;
  testbed.ratio = 40;
  // Viewbox size
  testbed.width = 30;
  testbed.height = 20;

  /*
    Ground
  */

  var ground = world.createBody();
  ground.createFixture(new _planckWithTestbed.Edge((0, _planckWithTestbed.Vec2)(-20.0, 0.0), (0, _planckWithTestbed.Vec2)(20.0, 0.0)), groundFD);
  createLap(world, ground);

  /*
    Truck
  */

  // Truck body
  var car = world.createDynamicBody((0, _planckWithTestbed.Vec2)(0.05, 2));
  var carBodyF = car.createFixture(new _planckWithTestbed.Box(1.5, .5), 1.0);
  car.createFixture((0, _planckWithTestbed.Box)(0.8, 0.5, (0, _planckWithTestbed.Vec2)(-1.4, 0.35), -.5), .5);
  car.createFixture((0, _planckWithTestbed.Box)(0.3, 0.3, (0, _planckWithTestbed.Vec2)(1.2, 2)), 1.0);
  car.createFixture((0, _planckWithTestbed.Box)(.5, .7, (0, _planckWithTestbed.Vec2)(2.1, .3)), .5);

  // Add wheels
  var wheelFD = {
    density: 1.0,
    friction: 0.9
  };
  var wheelBack = world.createDynamicBody((0, _planckWithTestbed.Vec2)(-1.75, 0.5));
  var wheelBackF = wheelBack.createFixture(new _planckWithTestbed.Circle(0.6), wheelFD);
  var wheelMiddle = world.createDynamicBody((0, _planckWithTestbed.Vec2)(0, 0.5));
  var wheelMiddleF = wheelMiddle.createFixture(new _planckWithTestbed.Circle(0.6), wheelFD);
  var wheelFront = world.createDynamicBody((0, _planckWithTestbed.Vec2)(1.75, 0.5));
  var wheelFrontF = wheelFront.createFixture(new _planckWithTestbed.Circle(0.6), wheelFD);

  // Add shocks
  var springBack = world.createJoint(new _planckWithTestbed.WheelJoint({
    motorSpeed: 0.0,
    maxMotorTorque: 20.0,
    enableMotor: true,
    frequencyHz: HZ,
    dampingRatio: ZETA
  }, car, wheelBack, wheelBack.getPosition(), (0, _planckWithTestbed.Vec2)(0.0, 1.0)));
  var springMiddle = world.createJoint(new _planckWithTestbed.WheelJoint({
    motorSpeed: 0.0,
    maxMotorTorque: 20.0,
    enableMotor: false,
    frequencyHz: HZ,
    dampingRatio: ZETA
  }, car, wheelMiddle, wheelMiddle.getPosition(), (0, _planckWithTestbed.Vec2)(0.0, 1.0)));
  var springFront = world.createJoint(new _planckWithTestbed.WheelJoint({
    motorSpeed: 0.0,
    maxMotorTorque: 20.0,
    enableMotor: false,
    frequencyHz: HZ,
    dampingRatio: ZETA
  }, car, wheelFront, wheelFront.getPosition(), (0, _planckWithTestbed.Vec2)(0.0, 1.0)));
  var carBodies = {
    back: wheelBack,
    middle: wheelMiddle,
    front: wheelFront,
    body: car,
    springBack: springBack,
    springMiddle: springMiddle
  };

  /*
    Controls
  */

  testbed.step = function () {
    if (!springBack || !springFront || !springMiddle) return;
    if (testbed.activeKeys.left) {
      // Apply torque for left turn (counter-clockwise)
      car.applyTorque(100, true);
    } else if (testbed.activeKeys.right) {
      // Apply torque for right turn (clockwise)
      car.applyTorque(-100, true);
    }
    if (testbed.activeKeys.up && testbed.activeKeys.down) {
      springBack.setMotorSpeed(0);
      springBack.enableMotor(false);
      springMiddle.setMotorSpeed(0);
      springMiddle.enableMotor(false);
      springFront.setMotorSpeed(0);
      springFront.enableMotor(false);
    } else if (testbed.activeKeys.up) {
      var speed = -SPEED;
      springBack.setMotorSpeed(speed);
      springBack.enableMotor(true);
      springMiddle.setMotorSpeed(speed);
      springMiddle.enableMotor(true);
      springFront.setMotorSpeed(speed);
      springFront.enableMotor(true);
    } else if (testbed.activeKeys.down) {
      var _speed = +SPEED;
      springBack.setMotorSpeed(_speed);
      springBack.enableMotor(true);
      springMiddle.setMotorSpeed(_speed);
      springMiddle.enableMotor(true);
      springFront.setMotorSpeed(_speed);
      springFront.enableMotor(true);
    } else {
      springBack.setMotorSpeed(0);
      springBack.enableMotor(false);
      springMiddle.setMotorSpeed(0);
      springMiddle.enableMotor(false);
      springFront.setMotorSpeed(0);
      springFront.enableMotor(false);
    }
    var cp = car.getPosition();
    testbed.x = -cp.x - 10;
    testbed.y = -cp.y - 3;
    if (cp.x > lap * dx * segmentsPerLap - 10) {
      createLap(world, ground);
    }
  };
  return {
    world: world,
    testbed: testbed,
    carBodies: carBodies
  };
};
},{"planck/dist/planck-with-testbed":"node_modules/planck/dist/planck-with-testbed.js","lodash":"node_modules/lodash/lodash.js"}],"index.js":[function(require,module,exports) {
"use strict";

var _lodash = require("lodash");
var _canvas_single = require("./canvas_single");
var _GamePhysics = require("./GamePhysics");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var el = document.getElementById("rive-canvas");
var _createScene = (0, _GamePhysics.createScene)(),
  testbed = _createScene.testbed,
  world = _createScene.world,
  carBodies = _createScene.carBodies;
testbed.start(world);
var modelValues = {};
var setTransforms = function setTransforms(body, modelInstance, bodyX, bodyY) {
  var postion = body.getPosition();
  modelInstance.x.value = postion.x * 100 - bodyX;
  modelInstance.y.value = postion.y * -100 - bodyY;
  modelInstance.r.value = -body.getAngle();
};
function main() {
  return _main.apply(this, arguments);
}
function _main() {
  _main = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var r;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          r = new _canvas_single.Rive({
            src: 'race_car.riv',
            autoplay: true,
            canvas: el,
            autoBind: true,
            layout: new _canvas_single.Layout({
              fit: _canvas_single.Fit.Contain,
              alignment: _canvas_single.Alignment.Center
            }),
            stateMachines: 'State Machine 1',
            onLoad: function onLoad() {
              var instance = r.viewModelInstance;
              console.log(r);
              modelValues = instance.properties.reduce(function (acc, property) {
                var propName = property.name;
                var propType = property.type;
                if (propType === "viewModel") {
                  return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, propName, {
                    x: instance.viewModel(propName).number('x'),
                    y: instance.viewModel(propName).number('y'),
                    r: instance.viewModel(propName).number('r')
                  }));
                }
              }, {});
              r.resizeDrawingSurfaceToCanvas();
            },
            onAdvance: function onAdvance() {
              var bodyPosition = carBodies.body.getPosition();
              var offsetX = r.artboardWidth / 5;
              var offsetY = r.artboardHeight / 3;
              var bodyX = bodyPosition.x * 100 - offsetX;
              var bodyY = bodyPosition.y * -100 - offsetY;
              modelValues.body.x.value = offsetX;
              modelValues.body.y.value = offsetY;
              modelValues.body.r.value = -carBodies.body.getAngle();
              setTransforms(carBodies.front, modelValues['wheel 3'], bodyX, bodyY);
              setTransforms(carBodies.middle, modelValues['wheel 2'], bodyX, bodyY);
              setTransforms(carBodies.back, modelValues['wheel 1'], bodyX, bodyY);
            }
          });
          window.addEventListener("resize", function () {
            r.resizeDrawingSurfaceToCanvas();
          }, false);
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _main.apply(this, arguments);
}
main();
},{"lodash":"node_modules/lodash/lodash.js","./canvas_single":"canvas_single/rive.js","./GamePhysics":"GamePhysics.js"}],"../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "61131" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/db-mars-rover.e31bb0bc.js.map